/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a3, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a3, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a3, prop, b2[prop]);
    }
  return a3;
};
var __spreadProps = (a3, b2) => __defProps(a3, __getOwnPropDescs(b2));
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i4 = decorators.length - 1, decorator; i4 >= 0; i4--)
    if (decorator = decorators[i4])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e7) {
        reject(e7);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e7) {
        reject(e7);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/buffers/index.js
var require_buffers = __commonJS({
  "node_modules/buffers/index.js"(exports, module2) {
    module2.exports = Buffers;
    function Buffers(bufs) {
      if (!(this instanceof Buffers))
        return new Buffers(bufs);
      this.buffers = bufs || [];
      this.length = this.buffers.reduce(function(size, buf) {
        return size + buf.length;
      }, 0);
    }
    Buffers.prototype.push = function() {
      for (var i4 = 0; i4 < arguments.length; i4++) {
        if (!Buffer.isBuffer(arguments[i4])) {
          throw new TypeError("Tried to push a non-buffer");
        }
      }
      for (var i4 = 0; i4 < arguments.length; i4++) {
        var buf = arguments[i4];
        this.buffers.push(buf);
        this.length += buf.length;
      }
      return this.length;
    };
    Buffers.prototype.unshift = function() {
      for (var i4 = 0; i4 < arguments.length; i4++) {
        if (!Buffer.isBuffer(arguments[i4])) {
          throw new TypeError("Tried to unshift a non-buffer");
        }
      }
      for (var i4 = 0; i4 < arguments.length; i4++) {
        var buf = arguments[i4];
        this.buffers.unshift(buf);
        this.length += buf.length;
      }
      return this.length;
    };
    Buffers.prototype.copy = function(dst, dStart, start, end) {
      return this.slice(start, end).copy(dst, dStart, 0, end - start);
    };
    Buffers.prototype.splice = function(i4, howMany) {
      var buffers = this.buffers;
      var index = i4 >= 0 ? i4 : this.length - i4;
      var reps = [].slice.call(arguments, 2);
      if (howMany === void 0) {
        howMany = this.length - index;
      } else if (howMany > this.length - index) {
        howMany = this.length - index;
      }
      for (var i4 = 0; i4 < reps.length; i4++) {
        this.length += reps[i4].length;
      }
      var removed = new Buffers();
      var bytes = 0;
      var startBytes = 0;
      for (var ii = 0; ii < buffers.length && startBytes + buffers[ii].length < index; ii++) {
        startBytes += buffers[ii].length;
      }
      if (index - startBytes > 0) {
        var start = index - startBytes;
        if (start + howMany < buffers[ii].length) {
          removed.push(buffers[ii].slice(start, start + howMany));
          var orig = buffers[ii];
          var buf0 = new Buffer(start);
          for (var i4 = 0; i4 < start; i4++) {
            buf0[i4] = orig[i4];
          }
          var buf1 = new Buffer(orig.length - start - howMany);
          for (var i4 = start + howMany; i4 < orig.length; i4++) {
            buf1[i4 - howMany - start] = orig[i4];
          }
          if (reps.length > 0) {
            var reps_ = reps.slice();
            reps_.unshift(buf0);
            reps_.push(buf1);
            buffers.splice.apply(buffers, [ii, 1].concat(reps_));
            ii += reps_.length;
            reps = [];
          } else {
            buffers.splice(ii, 1, buf0, buf1);
            ii += 2;
          }
        } else {
          removed.push(buffers[ii].slice(start));
          buffers[ii] = buffers[ii].slice(0, start);
          ii++;
        }
      }
      if (reps.length > 0) {
        buffers.splice.apply(buffers, [ii, 0].concat(reps));
        ii += reps.length;
      }
      while (removed.length < howMany) {
        var buf = buffers[ii];
        var len = buf.length;
        var take = Math.min(len, howMany - removed.length);
        if (take === len) {
          removed.push(buf);
          buffers.splice(ii, 1);
        } else {
          removed.push(buf.slice(0, take));
          buffers[ii] = buffers[ii].slice(take);
        }
      }
      this.length -= removed.length;
      return removed;
    };
    Buffers.prototype.slice = function(i4, j) {
      var buffers = this.buffers;
      if (j === void 0)
        j = this.length;
      if (i4 === void 0)
        i4 = 0;
      if (j > this.length)
        j = this.length;
      var startBytes = 0;
      for (var si = 0; si < buffers.length && startBytes + buffers[si].length <= i4; si++) {
        startBytes += buffers[si].length;
      }
      var target = new Buffer(j - i4);
      var ti = 0;
      for (var ii = si; ti < j - i4 && ii < buffers.length; ii++) {
        var len = buffers[ii].length;
        var start = ti === 0 ? i4 - startBytes : 0;
        var end = ti + len >= j - i4 ? Math.min(start + (j - i4) - ti, len) : len;
        buffers[ii].copy(target, ti, start, end);
        ti += end - start;
      }
      return target;
    };
    Buffers.prototype.pos = function(i4) {
      if (i4 < 0 || i4 >= this.length)
        throw new Error("oob");
      var l5 = i4, bi = 0, bu = null;
      for (; ; ) {
        bu = this.buffers[bi];
        if (l5 < bu.length) {
          return { buf: bi, offset: l5 };
        } else {
          l5 -= bu.length;
        }
        bi++;
      }
    };
    Buffers.prototype.get = function get(i4) {
      var pos = this.pos(i4);
      return this.buffers[pos.buf].get(pos.offset);
    };
    Buffers.prototype.set = function set2(i4, b2) {
      var pos = this.pos(i4);
      return this.buffers[pos.buf].set(pos.offset, b2);
    };
    Buffers.prototype.indexOf = function(needle, offset) {
      if (typeof needle === "string") {
        needle = new Buffer(needle);
      } else if (needle instanceof Buffer) {
      } else {
        throw new Error("Invalid type for a search string");
      }
      if (!needle.length) {
        return 0;
      }
      if (!this.length) {
        return -1;
      }
      var i4 = 0, j = 0, match = 0, mstart, pos = 0;
      if (offset) {
        var p2 = this.pos(offset);
        i4 = p2.buf;
        j = p2.offset;
        pos = offset;
      }
      for (; ; ) {
        while (j >= this.buffers[i4].length) {
          j = 0;
          i4++;
          if (i4 >= this.buffers.length) {
            return -1;
          }
        }
        var char = this.buffers[i4][j];
        if (char == needle[match]) {
          if (match == 0) {
            mstart = {
              i: i4,
              j,
              pos
            };
          }
          match++;
          if (match == needle.length) {
            return mstart.pos;
          }
        } else if (match != 0) {
          i4 = mstart.i;
          j = mstart.j;
          pos = mstart.pos;
          match = 0;
        }
        j++;
        pos++;
      }
    };
    Buffers.prototype.toBuffer = function() {
      return this.slice();
    };
    Buffers.prototype.toString = function(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
  }
});

// node_modules/node-osascript/lib/osa-parser.js
var require_osa_parser = __commonJS({
  "node_modules/node-osascript/lib/osa-parser.js"(exports, module2) {
    "use strict";
    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }
    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }
    peg$subclass(peg$SyntaxError, Error);
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        "class": function(expectation) {
          var escapedParts = "", i4;
          for (i4 = 0; i4 < expectation.parts.length; i4++) {
            escapedParts += expectation.parts[i4] instanceof Array ? classEscape(expectation.parts[i4][0]) + "-" + classEscape(expectation.parts[i4][1]) : classEscape(expectation.parts[i4]);
          }
          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function(expectation) {
          return "any character";
        },
        end: function(expectation) {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s5) {
        return s5.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s5) {
        return s5.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = new Array(expected2.length), i4, j;
        for (i4 = 0; i4 < expected2.length; i4++) {
          descriptions[i4] = describeExpectation(expected2[i4]);
        }
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i4 = 1, j = 1; i4 < descriptions.length; i4++) {
            if (descriptions[i4 - 1] !== descriptions[i4]) {
              descriptions[j] = descriptions[i4];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {}, peg$startRuleFunctions = { osascript: peg$parseosascript }, peg$startRuleFunction = peg$parseosascript, peg$c0 = function(value) {
        return value;
      }, peg$c1 = "{", peg$c2 = peg$literalExpectation("{", false), peg$c3 = "}", peg$c4 = peg$literalExpectation("}", false), peg$c5 = ":", peg$c6 = peg$literalExpectation(":", false), peg$c7 = ",", peg$c8 = peg$literalExpectation(",", false), peg$c9 = peg$otherExpectation("whitespace"), peg$c10 = /^[ \t\n\r]/, peg$c11 = peg$classExpectation([" ", "	", "\n", "\r"], false, false), peg$c12 = "false", peg$c13 = peg$literalExpectation("false", false), peg$c14 = function() {
        return false;
      }, peg$c15 = "true", peg$c16 = peg$literalExpectation("true", false), peg$c17 = function() {
        return true;
      }, peg$c18 = peg$anyExpectation(), peg$c19 = function(chars) {
        return chars.length > 0 ? chars.join("") : null;
      }, peg$c20 = function(first, m2) {
        return m2;
      }, peg$c21 = function(first, rest) {
        var result = {}, i4;
        result[first.name] = first.value;
        for (i4 = 0; i4 < rest.length; i4++) {
          result[rest[i4].name] = rest[i4].value;
        }
        return result;
      }, peg$c22 = function(members) {
        return members !== null ? members : {};
      }, peg$c23 = function(name, value) {
        return { name, value };
      }, peg$c24 = /^[ a-z0-9\-]/i, peg$c25 = peg$classExpectation([" ", ["a", "z"], ["0", "9"], "-"], false, true), peg$c26 = function(chars) {
        return chars.join("").trim();
      }, peg$c27 = function(first, v2) {
        return v2;
      }, peg$c28 = function(first, rest) {
        return [first].concat(rest);
      }, peg$c29 = function(values) {
        return values !== null ? values : [];
      }, peg$c30 = peg$otherExpectation("number"), peg$c31 = function() {
        return parseFloat(text());
      }, peg$c32 = ".", peg$c33 = peg$literalExpectation(".", false), peg$c34 = /^[1-9]/, peg$c35 = peg$classExpectation([["1", "9"]], false, false), peg$c36 = /^[eE]/, peg$c37 = peg$classExpectation(["e", "E"], false, false), peg$c38 = "-", peg$c39 = peg$literalExpectation("-", false), peg$c40 = "+", peg$c41 = peg$literalExpectation("+", false), peg$c42 = "0", peg$c43 = peg$literalExpectation("0", false), peg$c44 = peg$otherExpectation("string"), peg$c45 = function(chars) {
        return chars.join("");
      }, peg$c46 = "\n", peg$c47 = peg$literalExpectation("\n", false), peg$c48 = "	", peg$c49 = peg$literalExpectation("	", false), peg$c50 = '"', peg$c51 = peg$literalExpectation('"', false), peg$c52 = "\\", peg$c53 = peg$literalExpectation("\\", false), peg$c54 = "/", peg$c55 = peg$literalExpectation("/", false), peg$c56 = "b", peg$c57 = peg$literalExpectation("b", false), peg$c58 = function() {
        return "\b";
      }, peg$c59 = "f", peg$c60 = peg$literalExpectation("f", false), peg$c61 = function() {
        return "\f";
      }, peg$c62 = "n", peg$c63 = peg$literalExpectation("n", false), peg$c64 = function() {
        return "\n";
      }, peg$c65 = "r", peg$c66 = peg$literalExpectation("r", false), peg$c67 = function() {
        return "\r";
      }, peg$c68 = "t", peg$c69 = peg$literalExpectation("t", false), peg$c70 = function() {
        return "	";
      }, peg$c71 = "u", peg$c72 = peg$literalExpectation("u", false), peg$c73 = function(digits) {
        return String.fromCharCode(parseInt(digits, 16));
      }, peg$c74 = function(sequence) {
        return sequence;
      }, peg$c75 = /^[^\0-\x1F"\\]/, peg$c76 = peg$classExpectation([["\0", ""], '"', "\\"], true, false), peg$c77 = peg$otherExpectation("unquoted string"), peg$c78 = function(first_char, chars) {
        return first_char + chars.join("");
      }, peg$c79 = /^[a-z ]/, peg$c80 = peg$classExpectation([["a", "z"], " "], false, false), peg$c81 = /^[^,}]/, peg$c82 = peg$classExpectation([",", "}"], true, false), peg$c83 = peg$otherExpectation("date"), peg$c84 = "date", peg$c85 = peg$literalExpectation("date", false), peg$c86 = function(date) {
        var dateObject = new Date(date);
        return !isNaN(dateObject.getTime()) ? dateObject : date;
      }, peg$c87 = /^[0-9]/, peg$c88 = peg$classExpectation([["0", "9"]], false, false), peg$c89 = /^[0-9a-f]/i, peg$c90 = peg$classExpectation([["0", "9"], ["a", "f"]], false, true), peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{ line: 1, column: 1 }], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location2);
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos], p2;
        if (details) {
          return details;
        } else {
          p2 = pos - 1;
          while (!peg$posDetailsCache[p2]) {
            p2--;
          }
          details = peg$posDetailsCache[p2];
          details = {
            line: details.line,
            column: details.column
          };
          while (p2 < pos) {
            if (input.charCodeAt(p2) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p2++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);
      }
      function peg$parseosascript() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsews();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsevalue();
          if (s22 !== peg$FAILED) {
            s32 = peg$parsews();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c0(s22);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebegin_object() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsews();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 123) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c2);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsews();
            if (s32 !== peg$FAILED) {
              s1 = [s1, s22, s32];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseend_object() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsews();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 125) {
            s22 = peg$c3;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c4);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsews();
            if (s32 !== peg$FAILED) {
              s1 = [s1, s22, s32];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsename_separator() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsews();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s22 = peg$c5;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsews();
            if (s32 !== peg$FAILED) {
              s1 = [s1, s22, s32];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsevalue_separator() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsews();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s22 = peg$c7;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsews();
            if (s32 !== peg$FAILED) {
              s1 = [s1, s22, s32];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsews() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        if (peg$c10.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c11);
          }
        }
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (peg$c10.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c9);
          }
        }
        return s0;
      }
      function peg$parsevalue() {
        var s0;
        s0 = peg$parsefalse();
        if (s0 === peg$FAILED) {
          s0 = peg$parsetrue();
          if (s0 === peg$FAILED) {
            s0 = peg$parseobject();
            if (s0 === peg$FAILED) {
              s0 = peg$parsearray();
              if (s0 === peg$FAILED) {
                s0 = peg$parsenumber();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsestring();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsedate();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseunquoted_string();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseraw();
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsefalse() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c12) {
          s1 = peg$c12;
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c13);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c14();
        }
        s0 = s1;
        return s0;
      }
      function peg$parsetrue() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c15) {
          s1 = peg$c15;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c16);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c17();
        }
        s0 = s1;
        return s0;
      }
      function peg$parseraw() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsews();
        if (s1 !== peg$FAILED) {
          s22 = [];
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c18);
            }
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            if (input.length > peg$currPos) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c18);
              }
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsews();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c19(s22);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseobject() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parsebegin_object();
        if (s1 !== peg$FAILED) {
          s22 = peg$currPos;
          s32 = peg$parsemember();
          if (s32 !== peg$FAILED) {
            s42 = [];
            s5 = peg$currPos;
            s6 = peg$parsevalue_separator();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsemember();
              if (s7 !== peg$FAILED) {
                peg$savedPos = s5;
                s6 = peg$c20(s32, s7);
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              s5 = peg$currPos;
              s6 = peg$parsevalue_separator();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsemember();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s5;
                  s6 = peg$c20(s32, s7);
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
            if (s42 !== peg$FAILED) {
              peg$savedPos = s22;
              s32 = peg$c21(s32, s42);
              s22 = s32;
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parseend_object();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c22(s22);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemember() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsekey();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsename_separator();
          if (s22 !== peg$FAILED) {
            s32 = peg$parsevalue();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c23(s1, s32);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsekey() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        if (peg$c24.test(input.charAt(peg$currPos))) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c25);
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            if (peg$c24.test(input.charAt(peg$currPos))) {
              s22 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c25);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c26(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsearray() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parsebegin_object();
        if (s1 !== peg$FAILED) {
          s22 = peg$currPos;
          s32 = peg$parsevalue();
          if (s32 !== peg$FAILED) {
            s42 = [];
            s5 = peg$currPos;
            s6 = peg$parsevalue_separator();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsevalue();
              if (s7 !== peg$FAILED) {
                peg$savedPos = s5;
                s6 = peg$c27(s32, s7);
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              s5 = peg$currPos;
              s6 = peg$parsevalue_separator();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsevalue();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s5;
                  s6 = peg$c27(s32, s7);
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
            if (s42 !== peg$FAILED) {
              peg$savedPos = s22;
              s32 = peg$c28(s32, s42);
              s22 = s32;
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parseend_object();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c29(s22);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsenumber() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseminus();
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseint();
          if (s22 !== peg$FAILED) {
            s32 = peg$parsefrac();
            if (s32 === peg$FAILED) {
              s32 = null;
            }
            if (s32 !== peg$FAILED) {
              s42 = peg$parseexp();
              if (s42 === peg$FAILED) {
                s42 = null;
              }
              if (s42 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c31();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }
        return s0;
      }
      function peg$parsedecimal_point() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 46) {
          s0 = peg$c32;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c33);
          }
        }
        return s0;
      }
      function peg$parsedigit1_9() {
        var s0;
        if (peg$c34.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }
        return s0;
      }
      function peg$parsee() {
        var s0;
        if (peg$c36.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }
        return s0;
      }
      function peg$parseexp() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$parsee();
        if (s1 !== peg$FAILED) {
          s22 = peg$parseminus();
          if (s22 === peg$FAILED) {
            s22 = peg$parseplus();
          }
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          if (s22 !== peg$FAILED) {
            s32 = [];
            s42 = peg$parseDIGIT();
            if (s42 !== peg$FAILED) {
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parseDIGIT();
              }
            } else {
              s32 = peg$FAILED;
            }
            if (s32 !== peg$FAILED) {
              s1 = [s1, s22, s32];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsefrac() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsedecimal_point();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parseDIGIT();
          if (s32 !== peg$FAILED) {
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$parseDIGIT();
            }
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseint() {
        var s0, s1, s22, s32;
        s0 = peg$parsezero();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsedigit1_9();
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$parseDIGIT();
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$parseDIGIT();
            }
            if (s22 !== peg$FAILED) {
              s1 = [s1, s22];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseminus() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 45) {
          s0 = peg$c38;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c39);
          }
        }
        return s0;
      }
      function peg$parseplus() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 43) {
          s0 = peg$c40;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c41);
          }
        }
        return s0;
      }
      function peg$parsezero() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 48) {
          s0 = peg$c42;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c43);
          }
        }
        return s0;
      }
      function peg$parsestring() {
        var s0, s1, s22, s32;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsequotation_mark();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsechar();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsechar();
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsequotation_mark();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c45(s22);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c44);
          }
        }
        return s0;
      }
      function peg$parsechar() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        s0 = peg$parseunescaped();
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 10) {
            s0 = peg$c46;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c47);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 9) {
              s0 = peg$c48;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c49);
              }
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseescape();
              if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 34) {
                  s22 = peg$c50;
                  peg$currPos++;
                } else {
                  s22 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c51);
                  }
                }
                if (s22 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 92) {
                    s22 = peg$c52;
                    peg$currPos++;
                  } else {
                    s22 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c53);
                    }
                  }
                  if (s22 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 47) {
                      s22 = peg$c54;
                      peg$currPos++;
                    } else {
                      s22 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c55);
                      }
                    }
                    if (s22 === peg$FAILED) {
                      s22 = peg$currPos;
                      if (input.charCodeAt(peg$currPos) === 98) {
                        s32 = peg$c56;
                        peg$currPos++;
                      } else {
                        s32 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c57);
                        }
                      }
                      if (s32 !== peg$FAILED) {
                        peg$savedPos = s22;
                        s32 = peg$c58();
                      }
                      s22 = s32;
                      if (s22 === peg$FAILED) {
                        s22 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 102) {
                          s32 = peg$c59;
                          peg$currPos++;
                        } else {
                          s32 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c60);
                          }
                        }
                        if (s32 !== peg$FAILED) {
                          peg$savedPos = s22;
                          s32 = peg$c61();
                        }
                        s22 = s32;
                        if (s22 === peg$FAILED) {
                          s22 = peg$currPos;
                          if (input.charCodeAt(peg$currPos) === 110) {
                            s32 = peg$c62;
                            peg$currPos++;
                          } else {
                            s32 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c63);
                            }
                          }
                          if (s32 !== peg$FAILED) {
                            peg$savedPos = s22;
                            s32 = peg$c64();
                          }
                          s22 = s32;
                          if (s22 === peg$FAILED) {
                            s22 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 114) {
                              s32 = peg$c65;
                              peg$currPos++;
                            } else {
                              s32 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c66);
                              }
                            }
                            if (s32 !== peg$FAILED) {
                              peg$savedPos = s22;
                              s32 = peg$c67();
                            }
                            s22 = s32;
                            if (s22 === peg$FAILED) {
                              s22 = peg$currPos;
                              if (input.charCodeAt(peg$currPos) === 116) {
                                s32 = peg$c68;
                                peg$currPos++;
                              } else {
                                s32 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$c69);
                                }
                              }
                              if (s32 !== peg$FAILED) {
                                peg$savedPos = s22;
                                s32 = peg$c70();
                              }
                              s22 = s32;
                              if (s22 === peg$FAILED) {
                                s22 = peg$currPos;
                                if (input.charCodeAt(peg$currPos) === 117) {
                                  s32 = peg$c71;
                                  peg$currPos++;
                                } else {
                                  s32 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c72);
                                  }
                                }
                                if (s32 !== peg$FAILED) {
                                  s42 = peg$currPos;
                                  s5 = peg$currPos;
                                  s6 = peg$parseHEXDIG();
                                  if (s6 !== peg$FAILED) {
                                    s7 = peg$parseHEXDIG();
                                    if (s7 !== peg$FAILED) {
                                      s8 = peg$parseHEXDIG();
                                      if (s8 !== peg$FAILED) {
                                        s9 = peg$parseHEXDIG();
                                        if (s9 !== peg$FAILED) {
                                          s6 = [s6, s7, s8, s9];
                                          s5 = s6;
                                        } else {
                                          peg$currPos = s5;
                                          s5 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s5;
                                        s5 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s5;
                                      s5 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s5;
                                    s5 = peg$FAILED;
                                  }
                                  if (s5 !== peg$FAILED) {
                                    s42 = input.substring(s42, peg$currPos);
                                  } else {
                                    s42 = s5;
                                  }
                                  if (s42 !== peg$FAILED) {
                                    peg$savedPos = s22;
                                    s32 = peg$c73(s42);
                                    s22 = s32;
                                  } else {
                                    peg$currPos = s22;
                                    s22 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s22;
                                  s22 = peg$FAILED;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
                if (s22 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c74(s22);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
        }
        return s0;
      }
      function peg$parseescape() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 92) {
          s0 = peg$c52;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c53);
          }
        }
        return s0;
      }
      function peg$parsequotation_mark() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 34) {
          s0 = peg$c50;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c51);
          }
        }
        return s0;
      }
      function peg$parseunescaped() {
        var s0;
        if (peg$c75.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c76);
          }
        }
        return s0;
      }
      function peg$parseunquoted_string() {
        var s0, s1, s22, s32;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsefirst_unquoted_char();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parseunquoted_char();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parseunquoted_char();
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c78(s1, s22);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c77);
          }
        }
        return s0;
      }
      function peg$parsefirst_unquoted_char() {
        var s0;
        if (peg$c79.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c80);
          }
        }
        return s0;
      }
      function peg$parseunquoted_char() {
        var s0;
        if (peg$c81.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c82);
          }
        }
        return s0;
      }
      function peg$parsedate() {
        var s0, s1, s22, s32;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c84) {
          s1 = peg$c84;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c85);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsews();
          if (s22 !== peg$FAILED) {
            s32 = peg$parsestring();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c86(s32);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c83);
          }
        }
        return s0;
      }
      function peg$parseDIGIT() {
        var s0;
        if (peg$c87.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c88);
          }
        }
        return s0;
      }
      function peg$parseHEXDIG() {
        var s0;
        if (peg$c89.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c90);
          }
        }
        return s0;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }
    module2.exports = {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }
});

// node_modules/node-osascript/lib/osa-vargen.js
var require_osa_vargen = __commonJS({
  "node_modules/node-osascript/lib/osa-vargen.js"(exports, module2) {
    function serializeObject(value) {
      if (value === null) {
        return "";
      }
      var result;
      var typeOf = typeof value;
      if (typeOf === "object" && value !== null) {
        result = "{";
        if (Array.isArray(value)) {
          value.forEach(function(arrayValue, i4) {
            if (i4 !== 0) {
              result += ",";
            }
            result += serializeObject(arrayValue);
          });
        } else {
          Object.keys(value).forEach(function(key, i4) {
            if (i4 !== 0) {
              result += ",";
            }
            result += key + ":" + serializeObject(value[key]);
          });
        }
        result += "}";
      } else if (typeOf === "string") {
        result = '"' + value + '"';
      } else if (value === void 0) {
        result = "null";
      }
      return result || value;
    }
    module2.exports = {
      serializeObject,
      generate: function(object) {
        var aScript = "";
        Object.keys(object).forEach(function(key) {
          aScript += "set " + key + " to " + serializeObject(object[key]) + "\n";
        });
        return aScript;
      }
    };
  }
});

// node_modules/node-osascript/lib/index.js
var require_lib = __commonJS({
  "node_modules/node-osascript/lib/index.js"(exports, module2) {
    var spawn = require("child_process").spawn;
    var dirname = require("path").dirname;
    var readFileSync = require("fs").readFileSync;
    var Buffers = require_buffers();
    var parse3 = require_osa_parser().parse;
    var varGenerator = require_osa_vargen().generate;
    var bufferStream = function(stream) {
      var buffer = new Buffers();
      stream.on("data", function(chunk) {
        buffer.push(chunk);
      });
      return buffer;
    };
    var execute = function(path, script, vars, cb) {
      if (cb === void 0) {
        cb = vars;
      }
      var opts;
      if (typeof path === "undefined") {
        opts = {};
      } else {
        opts = { cwd: dirname(path) };
      }
      var cp = spawn("osascript", ["-ss", "-"], opts);
      var outBuffer = bufferStream(cp.stdout);
      var errBuffer = bufferStream(cp.stderr);
      cp.on("close", function(code) {
        var error;
        var result;
        if (code) {
          error = new Error(errBuffer.toString());
        } else {
          try {
            result = parse3(outBuffer.toString());
          } catch (err) {
            error = err;
          }
        }
        if (cb) {
          cb(error, result, outBuffer);
        }
      });
      if (!script) {
        script = readFileSync(path);
      }
      if (vars) {
        script = varGenerator(vars) + "\n" + script;
      }
      cp.stdin.write(script);
      cp.stdin.end();
      return cp;
    };
    module2.exports = {
      execute: function(script, vars, cb) {
        return execute(void 0, script, vars, cb);
      },
      executeFile: function(path, vars, cb) {
        return execute(path, void 0, vars, cb);
      }
    };
  }
});

// node_modules/chrono-node/dist/utils/pattern.js
var require_pattern = __commonJS({
  "node_modules/chrono-node/dist/utils/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.matchAnyPattern = exports.extractTerms = exports.repeatedTimeunitPattern = void 0;
    function repeatedTimeunitPattern(prefix, singleTimeunitPattern) {
      const singleTimeunitPatternNoCapture = singleTimeunitPattern.replace(/\((?!\?)/g, "(?:");
      return `${prefix}${singleTimeunitPatternNoCapture}\\s{0,5}(?:,?\\s{0,5}${singleTimeunitPatternNoCapture}){0,10}`;
    }
    exports.repeatedTimeunitPattern = repeatedTimeunitPattern;
    function extractTerms(dictionary) {
      let keys;
      if (dictionary instanceof Array) {
        keys = [...dictionary];
      } else if (dictionary instanceof Map) {
        keys = Array.from(dictionary.keys());
      } else {
        keys = Object.keys(dictionary);
      }
      return keys;
    }
    exports.extractTerms = extractTerms;
    function matchAnyPattern(dictionary) {
      const joinedTerms = extractTerms(dictionary).sort((a3, b2) => b2.length - a3.length).join("|").replace(/\./g, "\\.");
      return `(?:${joinedTerms})`;
    }
    exports.matchAnyPattern = matchAnyPattern;
  }
});

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module2) {
    !function(t3, e7) {
      typeof exports == "object" && typeof module2 != "undefined" ? module2.exports = e7() : typeof define == "function" && define.amd ? define(e7) : (t3 = typeof globalThis != "undefined" ? globalThis : t3 || self).dayjs = e7();
    }(exports, function() {
      "use strict";
      var t3 = 1e3, e7 = 6e4, n6 = 36e5, r4 = "millisecond", i4 = "second", s5 = "minute", u2 = "hour", a3 = "day", o6 = "week", f2 = "month", h3 = "quarter", c3 = "year", d3 = "date", $2 = "Invalid Date", l5 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, m2 = function(t4, e8, n7) {
        var r5 = String(t4);
        return !r5 || r5.length >= e8 ? t4 : "" + Array(e8 + 1 - r5.length).join(n7) + t4;
      }, g2 = { s: m2, z: function(t4) {
        var e8 = -t4.utcOffset(), n7 = Math.abs(e8), r5 = Math.floor(n7 / 60), i5 = n7 % 60;
        return (e8 <= 0 ? "+" : "-") + m2(r5, 2, "0") + ":" + m2(i5, 2, "0");
      }, m: function t4(e8, n7) {
        if (e8.date() < n7.date())
          return -t4(n7, e8);
        var r5 = 12 * (n7.year() - e8.year()) + (n7.month() - e8.month()), i5 = e8.clone().add(r5, f2), s6 = n7 - i5 < 0, u3 = e8.clone().add(r5 + (s6 ? -1 : 1), f2);
        return +(-(r5 + (n7 - i5) / (s6 ? i5 - u3 : u3 - i5)) || 0);
      }, a: function(t4) {
        return t4 < 0 ? Math.ceil(t4) || 0 : Math.floor(t4);
      }, p: function(t4) {
        return { M: f2, y: c3, w: o6, d: a3, D: d3, h: u2, m: s5, s: i4, ms: r4, Q: h3 }[t4] || String(t4 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t4) {
        return t4 === void 0;
      } }, v2 = "en", D = {};
      D[v2] = M2;
      var p2 = function(t4) {
        return t4 instanceof _2;
      }, S3 = function t4(e8, n7, r5) {
        var i5;
        if (!e8)
          return v2;
        if (typeof e8 == "string") {
          var s6 = e8.toLowerCase();
          D[s6] && (i5 = s6), n7 && (D[s6] = n7, i5 = s6);
          var u3 = e8.split("-");
          if (!i5 && u3.length > 1)
            return t4(u3[0]);
        } else {
          var a4 = e8.name;
          D[a4] = e8, i5 = a4;
        }
        return !r5 && i5 && (v2 = i5), i5 || !r5 && v2;
      }, w2 = function(t4, e8) {
        if (p2(t4))
          return t4.clone();
        var n7 = typeof e8 == "object" ? e8 : {};
        return n7.date = t4, n7.args = arguments, new _2(n7);
      }, O = g2;
      O.l = S3, O.i = p2, O.w = function(t4, e8) {
        return w2(t4, { locale: e8.$L, utc: e8.$u, x: e8.$x, $offset: e8.$offset });
      };
      var _2 = function() {
        function M3(t4) {
          this.$L = S3(t4.locale, null, true), this.parse(t4);
        }
        var m3 = M3.prototype;
        return m3.parse = function(t4) {
          this.$d = function(t5) {
            var e8 = t5.date, n7 = t5.utc;
            if (e8 === null)
              return new Date(NaN);
            if (O.u(e8))
              return new Date();
            if (e8 instanceof Date)
              return new Date(e8);
            if (typeof e8 == "string" && !/Z$/i.test(e8)) {
              var r5 = e8.match(l5);
              if (r5) {
                var i5 = r5[2] - 1 || 0, s6 = (r5[7] || "0").substring(0, 3);
                return n7 ? new Date(Date.UTC(r5[1], i5, r5[3] || 1, r5[4] || 0, r5[5] || 0, r5[6] || 0, s6)) : new Date(r5[1], i5, r5[3] || 1, r5[4] || 0, r5[5] || 0, r5[6] || 0, s6);
              }
            }
            return new Date(e8);
          }(t4), this.$x = t4.x || {}, this.init();
        }, m3.init = function() {
          var t4 = this.$d;
          this.$y = t4.getFullYear(), this.$M = t4.getMonth(), this.$D = t4.getDate(), this.$W = t4.getDay(), this.$H = t4.getHours(), this.$m = t4.getMinutes(), this.$s = t4.getSeconds(), this.$ms = t4.getMilliseconds();
        }, m3.$utils = function() {
          return O;
        }, m3.isValid = function() {
          return !(this.$d.toString() === $2);
        }, m3.isSame = function(t4, e8) {
          var n7 = w2(t4);
          return this.startOf(e8) <= n7 && n7 <= this.endOf(e8);
        }, m3.isAfter = function(t4, e8) {
          return w2(t4) < this.startOf(e8);
        }, m3.isBefore = function(t4, e8) {
          return this.endOf(e8) < w2(t4);
        }, m3.$g = function(t4, e8, n7) {
          return O.u(t4) ? this[e8] : this.set(n7, t4);
        }, m3.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m3.valueOf = function() {
          return this.$d.getTime();
        }, m3.startOf = function(t4, e8) {
          var n7 = this, r5 = !!O.u(e8) || e8, h4 = O.p(t4), $3 = function(t5, e9) {
            var i5 = O.w(n7.$u ? Date.UTC(n7.$y, e9, t5) : new Date(n7.$y, e9, t5), n7);
            return r5 ? i5 : i5.endOf(a3);
          }, l6 = function(t5, e9) {
            return O.w(n7.toDate()[t5].apply(n7.toDate("s"), (r5 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e9)), n7);
          }, y3 = this.$W, M4 = this.$M, m4 = this.$D, g3 = "set" + (this.$u ? "UTC" : "");
          switch (h4) {
            case c3:
              return r5 ? $3(1, 0) : $3(31, 11);
            case f2:
              return r5 ? $3(1, M4) : $3(0, M4 + 1);
            case o6:
              var v3 = this.$locale().weekStart || 0, D2 = (y3 < v3 ? y3 + 7 : y3) - v3;
              return $3(r5 ? m4 - D2 : m4 + (6 - D2), M4);
            case a3:
            case d3:
              return l6(g3 + "Hours", 0);
            case u2:
              return l6(g3 + "Minutes", 1);
            case s5:
              return l6(g3 + "Seconds", 2);
            case i4:
              return l6(g3 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m3.endOf = function(t4) {
          return this.startOf(t4, false);
        }, m3.$set = function(t4, e8) {
          var n7, o7 = O.p(t4), h4 = "set" + (this.$u ? "UTC" : ""), $3 = (n7 = {}, n7[a3] = h4 + "Date", n7[d3] = h4 + "Date", n7[f2] = h4 + "Month", n7[c3] = h4 + "FullYear", n7[u2] = h4 + "Hours", n7[s5] = h4 + "Minutes", n7[i4] = h4 + "Seconds", n7[r4] = h4 + "Milliseconds", n7)[o7], l6 = o7 === a3 ? this.$D + (e8 - this.$W) : e8;
          if (o7 === f2 || o7 === c3) {
            var y3 = this.clone().set(d3, 1);
            y3.$d[$3](l6), y3.init(), this.$d = y3.set(d3, Math.min(this.$D, y3.daysInMonth())).$d;
          } else
            $3 && this.$d[$3](l6);
          return this.init(), this;
        }, m3.set = function(t4, e8) {
          return this.clone().$set(t4, e8);
        }, m3.get = function(t4) {
          return this[O.p(t4)]();
        }, m3.add = function(r5, h4) {
          var d4, $3 = this;
          r5 = Number(r5);
          var l6 = O.p(h4), y3 = function(t4) {
            var e8 = w2($3);
            return O.w(e8.date(e8.date() + Math.round(t4 * r5)), $3);
          };
          if (l6 === f2)
            return this.set(f2, this.$M + r5);
          if (l6 === c3)
            return this.set(c3, this.$y + r5);
          if (l6 === a3)
            return y3(1);
          if (l6 === o6)
            return y3(7);
          var M4 = (d4 = {}, d4[s5] = e7, d4[u2] = n6, d4[i4] = t3, d4)[l6] || 1, m4 = this.$d.getTime() + r5 * M4;
          return O.w(m4, this);
        }, m3.subtract = function(t4, e8) {
          return this.add(-1 * t4, e8);
        }, m3.format = function(t4) {
          var e8 = this, n7 = this.$locale();
          if (!this.isValid())
            return n7.invalidDate || $2;
          var r5 = t4 || "YYYY-MM-DDTHH:mm:ssZ", i5 = O.z(this), s6 = this.$H, u3 = this.$m, a4 = this.$M, o7 = n7.weekdays, f3 = n7.months, h4 = function(t5, n8, i6, s7) {
            return t5 && (t5[n8] || t5(e8, r5)) || i6[n8].slice(0, s7);
          }, c4 = function(t5) {
            return O.s(s6 % 12 || 12, t5, "0");
          }, d4 = n7.meridiem || function(t5, e9, n8) {
            var r6 = t5 < 12 ? "AM" : "PM";
            return n8 ? r6.toLowerCase() : r6;
          }, l6 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a4 + 1, MM: O.s(a4 + 1, 2, "0"), MMM: h4(n7.monthsShort, a4, f3, 3), MMMM: h4(f3, a4), D: this.$D, DD: O.s(this.$D, 2, "0"), d: String(this.$W), dd: h4(n7.weekdaysMin, this.$W, o7, 2), ddd: h4(n7.weekdaysShort, this.$W, o7, 3), dddd: o7[this.$W], H: String(s6), HH: O.s(s6, 2, "0"), h: c4(1), hh: c4(2), a: d4(s6, u3, true), A: d4(s6, u3, false), m: String(u3), mm: O.s(u3, 2, "0"), s: String(this.$s), ss: O.s(this.$s, 2, "0"), SSS: O.s(this.$ms, 3, "0"), Z: i5 };
          return r5.replace(y2, function(t5, e9) {
            return e9 || l6[t5] || i5.replace(":", "");
          });
        }, m3.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m3.diff = function(r5, d4, $3) {
          var l6, y3 = O.p(d4), M4 = w2(r5), m4 = (M4.utcOffset() - this.utcOffset()) * e7, g3 = this - M4, v3 = O.m(this, M4);
          return v3 = (l6 = {}, l6[c3] = v3 / 12, l6[f2] = v3, l6[h3] = v3 / 3, l6[o6] = (g3 - m4) / 6048e5, l6[a3] = (g3 - m4) / 864e5, l6[u2] = g3 / n6, l6[s5] = g3 / e7, l6[i4] = g3 / t3, l6)[y3] || g3, $3 ? v3 : O.a(v3);
        }, m3.daysInMonth = function() {
          return this.endOf(f2).$D;
        }, m3.$locale = function() {
          return D[this.$L];
        }, m3.locale = function(t4, e8) {
          if (!t4)
            return this.$L;
          var n7 = this.clone(), r5 = S3(t4, e8, true);
          return r5 && (n7.$L = r5), n7;
        }, m3.clone = function() {
          return O.w(this.$d, this);
        }, m3.toDate = function() {
          return new Date(this.valueOf());
        }, m3.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m3.toISOString = function() {
          return this.$d.toISOString();
        }, m3.toString = function() {
          return this.$d.toUTCString();
        }, M3;
      }(), T2 = _2.prototype;
      return w2.prototype = T2, [["$ms", r4], ["$s", i4], ["$m", s5], ["$H", u2], ["$W", a3], ["$M", f2], ["$y", c3], ["$D", d3]].forEach(function(t4) {
        T2[t4[1]] = function(e8) {
          return this.$g(e8, t4[0], t4[1]);
        };
      }), w2.extend = function(t4, e8) {
        return t4.$i || (t4(e8, _2, w2), t4.$i = true), w2;
      }, w2.locale = S3, w2.isDayjs = p2, w2.unix = function(t4) {
        return w2(1e3 * t4);
      }, w2.en = D[v2], w2.Ls = D, w2.p = {}, w2;
    });
  }
});

// node_modules/chrono-node/dist/calculation/years.js
var require_years = __commonJS({
  "node_modules/chrono-node/dist/calculation/years.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findYearClosestToRef = exports.findMostLikelyADYear = void 0;
    var dayjs_1 = __importDefault2(require_dayjs_min());
    function findMostLikelyADYear(yearNumber) {
      if (yearNumber < 100) {
        if (yearNumber > 50) {
          yearNumber = yearNumber + 1900;
        } else {
          yearNumber = yearNumber + 2e3;
        }
      }
      return yearNumber;
    }
    exports.findMostLikelyADYear = findMostLikelyADYear;
    function findYearClosestToRef(refDate, day, month) {
      const refMoment = dayjs_1.default(refDate);
      let dateMoment = refMoment;
      dateMoment = dateMoment.month(month - 1);
      dateMoment = dateMoment.date(day);
      dateMoment = dateMoment.year(refMoment.year());
      const nextYear = dateMoment.add(1, "y");
      const lastYear = dateMoment.add(-1, "y");
      if (Math.abs(nextYear.diff(refMoment)) < Math.abs(dateMoment.diff(refMoment))) {
        dateMoment = nextYear;
      } else if (Math.abs(lastYear.diff(refMoment)) < Math.abs(dateMoment.diff(refMoment))) {
        dateMoment = lastYear;
      }
      return dateMoment.year();
    }
    exports.findYearClosestToRef = findYearClosestToRef;
  }
});

// node_modules/chrono-node/dist/locales/en/constants.js
var require_constants = __commonJS({
  "node_modules/chrono-node/dist/locales/en/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseOrdinalNumberPattern = exports.ORDINAL_NUMBER_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.ORDINAL_WORD_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.FULL_MONTH_NAME_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    var pattern_1 = require_pattern();
    var years_1 = require_years();
    exports.WEEKDAY_DICTIONARY = {
      sunday: 0,
      sun: 0,
      "sun.": 0,
      monday: 1,
      mon: 1,
      "mon.": 1,
      tuesday: 2,
      tue: 2,
      "tue.": 2,
      wednesday: 3,
      wed: 3,
      "wed.": 3,
      thursday: 4,
      thurs: 4,
      "thurs.": 4,
      thur: 4,
      "thur.": 4,
      thu: 4,
      "thu.": 4,
      friday: 5,
      fri: 5,
      "fri.": 5,
      saturday: 6,
      sat: 6,
      "sat.": 6
    };
    exports.FULL_MONTH_NAME_DICTIONARY = {
      january: 1,
      february: 2,
      march: 3,
      april: 4,
      may: 5,
      june: 6,
      july: 7,
      august: 8,
      september: 9,
      october: 10,
      november: 11,
      december: 12
    };
    exports.MONTH_DICTIONARY = Object.assign(Object.assign({}, exports.FULL_MONTH_NAME_DICTIONARY), { jan: 1, "jan.": 1, feb: 2, "feb.": 2, mar: 3, "mar.": 3, apr: 4, "apr.": 4, jun: 6, "jun.": 6, jul: 7, "jul.": 7, aug: 8, "aug.": 8, sep: 9, "sep.": 9, sept: 9, "sept.": 9, oct: 10, "oct.": 10, nov: 11, "nov.": 11, dec: 12, "dec.": 12 });
    exports.INTEGER_WORD_DICTIONARY = {
      one: 1,
      two: 2,
      three: 3,
      four: 4,
      five: 5,
      six: 6,
      seven: 7,
      eight: 8,
      nine: 9,
      ten: 10,
      eleven: 11,
      twelve: 12
    };
    exports.ORDINAL_WORD_DICTIONARY = {
      first: 1,
      second: 2,
      third: 3,
      fourth: 4,
      fifth: 5,
      sixth: 6,
      seventh: 7,
      eighth: 8,
      ninth: 9,
      tenth: 10,
      eleventh: 11,
      twelfth: 12,
      thirteenth: 13,
      fourteenth: 14,
      fifteenth: 15,
      sixteenth: 16,
      seventeenth: 17,
      eighteenth: 18,
      nineteenth: 19,
      twentieth: 20,
      "twenty first": 21,
      "twenty-first": 21,
      "twenty second": 22,
      "twenty-second": 22,
      "twenty third": 23,
      "twenty-third": 23,
      "twenty fourth": 24,
      "twenty-fourth": 24,
      "twenty fifth": 25,
      "twenty-fifth": 25,
      "twenty sixth": 26,
      "twenty-sixth": 26,
      "twenty seventh": 27,
      "twenty-seventh": 27,
      "twenty eighth": 28,
      "twenty-eighth": 28,
      "twenty ninth": 29,
      "twenty-ninth": 29,
      "thirtieth": 30,
      "thirty first": 31,
      "thirty-first": 31
    };
    exports.TIME_UNIT_DICTIONARY = {
      sec: "second",
      second: "second",
      seconds: "second",
      min: "minute",
      mins: "minute",
      minute: "minute",
      minutes: "minute",
      h: "hour",
      hr: "hour",
      hrs: "hour",
      hour: "hour",
      hours: "hour",
      day: "d",
      days: "d",
      week: "week",
      weeks: "week",
      month: "month",
      months: "month",
      qtr: "quarter",
      quarter: "quarter",
      quarters: "quarter",
      y: "year",
      yr: "year",
      year: "year",
      years: "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|half(?:\\s{0,2}an?)?|an?\\b(?:\\s{0,2}few)?|few|several|a?\\s{0,2}couple\\s{0,2}(?:of)?)`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      } else if (num === "a" || num === "an") {
        return 1;
      } else if (num.match(/few/)) {
        return 3;
      } else if (num.match(/half/)) {
        return 0.5;
      } else if (num.match(/couple/)) {
        return 2;
      } else if (num.match(/several/)) {
        return 7;
      }
      return parseFloat(num);
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.ORDINAL_NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:st|nd|rd|th)?)`;
    function parseOrdinalNumberPattern(match) {
      let num = match.toLowerCase();
      if (exports.ORDINAL_WORD_DICTIONARY[num] !== void 0) {
        return exports.ORDINAL_WORD_DICTIONARY[num];
      }
      num = num.replace(/(?:st|nd|rd|th)$/i, "");
      return parseInt(num);
    }
    exports.parseOrdinalNumberPattern = parseOrdinalNumberPattern;
    exports.YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\s{0,2}(?:BE|AD|BC|BCE|CE)|[1-2][0-9]{3}|[5-9][0-9])`;
    function parseYear(match) {
      if (/BE/i.test(match)) {
        match = match.replace(/BE/i, "");
        return parseInt(match) - 543;
      }
      if (/BCE?/i.test(match)) {
        match = match.replace(/BCE?/i, "");
        return -parseInt(match);
      }
      if (/(AD|CE)/i.test(match)) {
        match = match.replace(/(AD|CE)/i, "");
        return parseInt(match);
      }
      const rawYearNumber = parseInt(match);
      return years_1.findMostLikelyADYear(rawYearNumber);
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,3}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern(`(?:(?:about|around)\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length).trim();
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/dayjs/plugin/quarterOfYear.js
var require_quarterOfYear = __commonJS({
  "node_modules/dayjs/plugin/quarterOfYear.js"(exports, module2) {
    !function(t3, n6) {
      typeof exports == "object" && typeof module2 != "undefined" ? module2.exports = n6() : typeof define == "function" && define.amd ? define(n6) : (t3 = typeof globalThis != "undefined" ? globalThis : t3 || self).dayjs_plugin_quarterOfYear = n6();
    }(exports, function() {
      "use strict";
      var t3 = "month", n6 = "quarter";
      return function(e7, i4) {
        var r4 = i4.prototype;
        r4.quarter = function(t4) {
          return this.$utils().u(t4) ? Math.ceil((this.month() + 1) / 3) : this.month(this.month() % 3 + 3 * (t4 - 1));
        };
        var s5 = r4.add;
        r4.add = function(e8, i5) {
          return e8 = Number(e8), this.$utils().p(i5) === n6 ? this.add(3 * e8, t3) : s5.bind(this)(e8, i5);
        };
        var u2 = r4.startOf;
        r4.startOf = function(e8, i5) {
          var r5 = this.$utils(), s6 = !!r5.u(i5) || i5;
          if (r5.p(e8) === n6) {
            var o6 = this.quarter() - 1;
            return s6 ? this.month(3 * o6).startOf(t3).startOf("day") : this.month(3 * o6 + 2).endOf(t3).endOf("day");
          }
          return u2.bind(this)(e8, i5);
        };
      };
    });
  }
});

// node_modules/chrono-node/dist/utils/dayjs.js
var require_dayjs = __commonJS({
  "node_modules/chrono-node/dist/utils/dayjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.implySimilarTime = exports.assignSimilarTime = exports.assignSimilarDate = exports.assignTheNextDay = void 0;
    var index_1 = require_dist();
    function assignTheNextDay(component, targetDayJs) {
      targetDayJs = targetDayJs.add(1, "day");
      assignSimilarDate(component, targetDayJs);
      implySimilarTime(component, targetDayJs);
    }
    exports.assignTheNextDay = assignTheNextDay;
    function assignSimilarDate(component, targetDayJs) {
      component.assign("day", targetDayJs.date());
      component.assign("month", targetDayJs.month() + 1);
      component.assign("year", targetDayJs.year());
    }
    exports.assignSimilarDate = assignSimilarDate;
    function assignSimilarTime(component, targetDayJs) {
      component.assign("hour", targetDayJs.hour());
      component.assign("minute", targetDayJs.minute());
      component.assign("second", targetDayJs.second());
      component.assign("millisecond", targetDayJs.millisecond());
      if (component.get("hour") < 12) {
        component.assign("meridiem", index_1.Meridiem.AM);
      } else {
        component.assign("meridiem", index_1.Meridiem.PM);
      }
    }
    exports.assignSimilarTime = assignSimilarTime;
    function implySimilarTime(component, targetDayJs) {
      component.imply("hour", targetDayJs.hour());
      component.imply("minute", targetDayJs.minute());
      component.imply("second", targetDayJs.second());
      component.imply("millisecond", targetDayJs.millisecond());
    }
    exports.implySimilarTime = implySimilarTime;
  }
});

// node_modules/chrono-node/dist/timezone.js
var require_timezone = __commonJS({
  "node_modules/chrono-node/dist/timezone.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toTimezoneOffset = exports.TIMEZONE_ABBR_MAP = void 0;
    exports.TIMEZONE_ABBR_MAP = {
      ACDT: 630,
      ACST: 570,
      ADT: -180,
      AEDT: 660,
      AEST: 600,
      AFT: 270,
      AKDT: -480,
      AKST: -540,
      ALMT: 360,
      AMST: -180,
      AMT: -240,
      ANAST: 720,
      ANAT: 720,
      AQTT: 300,
      ART: -180,
      AST: -240,
      AWDT: 540,
      AWST: 480,
      AZOST: 0,
      AZOT: -60,
      AZST: 300,
      AZT: 240,
      BNT: 480,
      BOT: -240,
      BRST: -120,
      BRT: -180,
      BST: 60,
      BTT: 360,
      CAST: 480,
      CAT: 120,
      CCT: 390,
      CDT: -300,
      CEST: 120,
      CET: 60,
      CHADT: 825,
      CHAST: 765,
      CKT: -600,
      CLST: -180,
      CLT: -240,
      COT: -300,
      CST: -360,
      CVT: -60,
      CXT: 420,
      ChST: 600,
      DAVT: 420,
      EASST: -300,
      EAST: -360,
      EAT: 180,
      ECT: -300,
      EDT: -240,
      EEST: 180,
      EET: 120,
      EGST: 0,
      EGT: -60,
      EST: -300,
      ET: -300,
      FJST: 780,
      FJT: 720,
      FKST: -180,
      FKT: -240,
      FNT: -120,
      GALT: -360,
      GAMT: -540,
      GET: 240,
      GFT: -180,
      GILT: 720,
      GMT: 0,
      GST: 240,
      GYT: -240,
      HAA: -180,
      HAC: -300,
      HADT: -540,
      HAE: -240,
      HAP: -420,
      HAR: -360,
      HAST: -600,
      HAT: -90,
      HAY: -480,
      HKT: 480,
      HLV: -210,
      HNA: -240,
      HNC: -360,
      HNE: -300,
      HNP: -480,
      HNR: -420,
      HNT: -150,
      HNY: -540,
      HOVT: 420,
      ICT: 420,
      IDT: 180,
      IOT: 360,
      IRDT: 270,
      IRKST: 540,
      IRKT: 540,
      IRST: 210,
      IST: 330,
      JST: 540,
      KGT: 360,
      KRAST: 480,
      KRAT: 480,
      KST: 540,
      KUYT: 240,
      LHDT: 660,
      LHST: 630,
      LINT: 840,
      MAGST: 720,
      MAGT: 720,
      MART: -510,
      MAWT: 300,
      MDT: -360,
      MESZ: 120,
      MEZ: 60,
      MHT: 720,
      MMT: 390,
      MSD: 240,
      MSK: 180,
      MST: -420,
      MUT: 240,
      MVT: 300,
      MYT: 480,
      NCT: 660,
      NDT: -90,
      NFT: 690,
      NOVST: 420,
      NOVT: 360,
      NPT: 345,
      NST: -150,
      NUT: -660,
      NZDT: 780,
      NZST: 720,
      OMSST: 420,
      OMST: 420,
      PDT: -420,
      PET: -300,
      PETST: 720,
      PETT: 720,
      PGT: 600,
      PHOT: 780,
      PHT: 480,
      PKT: 300,
      PMDT: -120,
      PMST: -180,
      PONT: 660,
      PST: -480,
      PT: -480,
      PWT: 540,
      PYST: -180,
      PYT: -240,
      RET: 240,
      SAMT: 240,
      SAST: 120,
      SBT: 660,
      SCT: 240,
      SGT: 480,
      SRT: -180,
      SST: -660,
      TAHT: -600,
      TFT: 300,
      TJT: 300,
      TKT: 780,
      TLT: 540,
      TMT: 300,
      TVT: 720,
      ULAT: 480,
      UTC: 0,
      UYST: -120,
      UYT: -180,
      UZT: 300,
      VET: -210,
      VLAST: 660,
      VLAT: 660,
      VUT: 660,
      WAST: 120,
      WAT: 60,
      WEST: 60,
      WESZ: 60,
      WET: 0,
      WEZ: 0,
      WFT: 720,
      WGST: -120,
      WGT: -180,
      WIB: 420,
      WIT: 540,
      WITA: 480,
      WST: 780,
      WT: 0,
      YAKST: 600,
      YAKT: 600,
      YAPT: 600,
      YEKST: 360,
      YEKT: 360
    };
    function toTimezoneOffset(timezoneInput) {
      var _a;
      if (timezoneInput === null || timezoneInput === void 0) {
        return null;
      }
      if (typeof timezoneInput === "number") {
        return timezoneInput;
      }
      return (_a = exports.TIMEZONE_ABBR_MAP[timezoneInput]) !== null && _a !== void 0 ? _a : null;
    }
    exports.toTimezoneOffset = toTimezoneOffset;
  }
});

// node_modules/chrono-node/dist/results.js
var require_results = __commonJS({
  "node_modules/chrono-node/dist/results.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParsingResult = exports.ParsingComponents = exports.ReferenceWithTimezone = void 0;
    var quarterOfYear_1 = __importDefault2(require_quarterOfYear());
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var dayjs_2 = require_dayjs();
    var timezone_1 = require_timezone();
    dayjs_1.default.extend(quarterOfYear_1.default);
    var ReferenceWithTimezone = class {
      constructor(input) {
        var _a;
        input = input !== null && input !== void 0 ? input : new Date();
        if (input instanceof Date) {
          this.instant = input;
        } else {
          this.instant = (_a = input.instant) !== null && _a !== void 0 ? _a : new Date();
          this.timezoneOffset = timezone_1.toTimezoneOffset(input.timezone);
        }
      }
      getDateWithAdjustedTimezone() {
        return new Date(this.instant.getTime() + this.getSystemTimezoneAdjustmentMinute(this.instant) * 6e4);
      }
      getSystemTimezoneAdjustmentMinute(date, overrideTimezoneOffset) {
        var _a;
        if (!date || date.getTime() < 0) {
          date = new Date();
        }
        const currentTimezoneOffset = -date.getTimezoneOffset();
        const targetTimezoneOffset = (_a = overrideTimezoneOffset !== null && overrideTimezoneOffset !== void 0 ? overrideTimezoneOffset : this.timezoneOffset) !== null && _a !== void 0 ? _a : currentTimezoneOffset;
        return currentTimezoneOffset - targetTimezoneOffset;
      }
    };
    exports.ReferenceWithTimezone = ReferenceWithTimezone;
    var ParsingComponents = class {
      constructor(reference, knownComponents) {
        this.reference = reference;
        this.knownValues = {};
        this.impliedValues = {};
        if (knownComponents) {
          for (const key in knownComponents) {
            this.knownValues[key] = knownComponents[key];
          }
        }
        const refDayJs = dayjs_1.default(reference.instant);
        this.imply("day", refDayJs.date());
        this.imply("month", refDayJs.month() + 1);
        this.imply("year", refDayJs.year());
        this.imply("hour", 12);
        this.imply("minute", 0);
        this.imply("second", 0);
        this.imply("millisecond", 0);
      }
      get(component) {
        if (component in this.knownValues) {
          return this.knownValues[component];
        }
        if (component in this.impliedValues) {
          return this.impliedValues[component];
        }
        return null;
      }
      isCertain(component) {
        return component in this.knownValues;
      }
      getCertainComponents() {
        return Object.keys(this.knownValues);
      }
      imply(component, value) {
        if (component in this.knownValues) {
          return this;
        }
        this.impliedValues[component] = value;
        return this;
      }
      assign(component, value) {
        this.knownValues[component] = value;
        delete this.impliedValues[component];
        return this;
      }
      delete(component) {
        delete this.knownValues[component];
        delete this.impliedValues[component];
      }
      clone() {
        const component = new ParsingComponents(this.reference);
        component.knownValues = {};
        component.impliedValues = {};
        for (const key in this.knownValues) {
          component.knownValues[key] = this.knownValues[key];
        }
        for (const key in this.impliedValues) {
          component.impliedValues[key] = this.impliedValues[key];
        }
        return component;
      }
      isOnlyDate() {
        return !this.isCertain("hour") && !this.isCertain("minute") && !this.isCertain("second");
      }
      isOnlyTime() {
        return !this.isCertain("weekday") && !this.isCertain("day") && !this.isCertain("month");
      }
      isOnlyWeekdayComponent() {
        return this.isCertain("weekday") && !this.isCertain("day") && !this.isCertain("month");
      }
      isOnlyDayMonthComponent() {
        return this.isCertain("day") && this.isCertain("month") && !this.isCertain("year");
      }
      isValidDate() {
        const date = this.dateWithoutTimezoneAdjustment();
        if (date.getFullYear() !== this.get("year"))
          return false;
        if (date.getMonth() !== this.get("month") - 1)
          return false;
        if (date.getDate() !== this.get("day"))
          return false;
        if (this.get("hour") != null && date.getHours() != this.get("hour"))
          return false;
        if (this.get("minute") != null && date.getMinutes() != this.get("minute"))
          return false;
        return true;
      }
      toString() {
        return `[ParsingComponents {knownValues: ${JSON.stringify(this.knownValues)}, impliedValues: ${JSON.stringify(this.impliedValues)}}, reference: ${JSON.stringify(this.reference)}]`;
      }
      dayjs() {
        return dayjs_1.default(this.date());
      }
      date() {
        const date = this.dateWithoutTimezoneAdjustment();
        const timezoneAdjustment = this.reference.getSystemTimezoneAdjustmentMinute(date, this.get("timezoneOffset"));
        return new Date(date.getTime() + timezoneAdjustment * 6e4);
      }
      dateWithoutTimezoneAdjustment() {
        const date = new Date(this.get("year"), this.get("month") - 1, this.get("day"), this.get("hour"), this.get("minute"), this.get("second"), this.get("millisecond"));
        date.setFullYear(this.get("year"));
        return date;
      }
      static createRelativeFromReference(reference, fragments) {
        let date = dayjs_1.default(reference.instant);
        for (const key in fragments) {
          date = date.add(fragments[key], key);
        }
        const components = new ParsingComponents(reference);
        if (fragments["hour"] || fragments["minute"] || fragments["second"]) {
          dayjs_2.assignSimilarTime(components, date);
          dayjs_2.assignSimilarDate(components, date);
          if (reference.timezoneOffset !== null) {
            components.assign("timezoneOffset", -reference.instant.getTimezoneOffset());
          }
        } else {
          dayjs_2.implySimilarTime(components, date);
          if (reference.timezoneOffset !== null) {
            components.imply("timezoneOffset", -reference.instant.getTimezoneOffset());
          }
          if (fragments["d"]) {
            components.assign("day", date.date());
            components.assign("month", date.month() + 1);
            components.assign("year", date.year());
          } else {
            if (fragments["week"]) {
              components.imply("weekday", date.day());
            }
            components.imply("day", date.date());
            if (fragments["month"]) {
              components.assign("month", date.month() + 1);
              components.assign("year", date.year());
            } else {
              components.imply("month", date.month() + 1);
              if (fragments["year"]) {
                components.assign("year", date.year());
              } else {
                components.imply("year", date.year());
              }
            }
          }
        }
        return components;
      }
    };
    exports.ParsingComponents = ParsingComponents;
    var ParsingResult = class {
      constructor(reference, index, text, start, end) {
        this.reference = reference;
        this.refDate = reference.instant;
        this.index = index;
        this.text = text;
        this.start = start || new ParsingComponents(reference);
        this.end = end;
      }
      clone() {
        const result = new ParsingResult(this.reference, this.index, this.text);
        result.start = this.start ? this.start.clone() : null;
        result.end = this.end ? this.end.clone() : null;
        return result;
      }
      date() {
        return this.start.date();
      }
      toString() {
        return `[ParsingResult {index: ${this.index}, text: '${this.text}', ...}]`;
      }
    };
    exports.ParsingResult = ParsingResult;
  }
});

// node_modules/chrono-node/dist/common/parsers/AbstractParserWithWordBoundary.js
var require_AbstractParserWithWordBoundary = __commonJS({
  "node_modules/chrono-node/dist/common/parsers/AbstractParserWithWordBoundary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractParserWithWordBoundaryChecking = void 0;
    var AbstractParserWithWordBoundaryChecking = class {
      constructor() {
        this.cachedInnerPattern = null;
        this.cachedPattern = null;
      }
      patternLeftBoundary() {
        return `(\\W|^)`;
      }
      pattern(context2) {
        const innerPattern = this.innerPattern(context2);
        if (innerPattern == this.cachedInnerPattern) {
          return this.cachedPattern;
        }
        this.cachedPattern = new RegExp(`${this.patternLeftBoundary()}${innerPattern.source}`, innerPattern.flags);
        this.cachedInnerPattern = innerPattern;
        return this.cachedPattern;
      }
      extract(context2, match) {
        var _a;
        const header = (_a = match[1]) !== null && _a !== void 0 ? _a : "";
        match.index = match.index + header.length;
        match[0] = match[0].substring(header.length);
        for (let i4 = 2; i4 < match.length; i4++) {
          match[i4 - 1] = match[i4];
        }
        return this.innerExtract(context2, match);
      }
    };
    exports.AbstractParserWithWordBoundaryChecking = AbstractParserWithWordBoundaryChecking;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitWithinFormatParser.js
var require_ENTimeUnitWithinFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitWithinFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN_WITH_PREFIX = new RegExp(`(?:within|in|for)\\s*(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
    var PATTERN_WITHOUT_PREFIX = new RegExp(`(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
    var ENTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context2) {
        return context2.option.forwardDate ? PATTERN_WITHOUT_PREFIX : PATTERN_WITH_PREFIX;
      }
      innerExtract(context2, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        return results_1.ParsingComponents.createRelativeFromReference(context2.reference, timeUnits);
      }
    };
    exports.default = ENTimeUnitWithinFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameLittleEndianParser.js
var require_ENMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants();
    var constants_2 = require_constants();
    var constants_3 = require_constants();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:on\\s{0,3})?(${constants_3.ORDINAL_NUMBER_PATTERN})(?:\\s{0,3}(?:to|\\-|\\\u2013|until|through|till)?\\s{0,3}(${constants_3.ORDINAL_NUMBER_PATTERN}))?(?:-|/|\\s{0,3}(?:of)?\\s{0,3})(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:(?:-|/|,?\\s{0,3})(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var ENMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const result = context2.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_3.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context2.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = constants_3.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = ENMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameMiddleEndianParser.js
var require_ENMonthNameMiddleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameMiddleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants();
    var constants_2 = require_constants();
    var constants_3 = require_constants();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:-|/|\\s*,?\\s*)(${constants_2.ORDINAL_NUMBER_PATTERN})(?!\\s*(?:am|pm))\\s*(?:(?:to|\\-)\\s*(${constants_2.ORDINAL_NUMBER_PATTERN})\\s*)?(?:(?:-|/|\\s*,?\\s*)(${constants_3.YEAR_PATTERN}))?(?=\\W|$)(?!\\:\\d)`, "i");
    var MONTH_NAME_GROUP = 1;
    var DATE_GROUP = 2;
    var DATE_TO_GROUP = 3;
    var YEAR_GROUP = 4;
    var ENMonthNameMiddleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_2.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          return null;
        }
        const components = context2.createParsingComponents({
          day,
          month
        });
        if (match[YEAR_GROUP]) {
          const year = constants_3.parseYear(match[YEAR_GROUP]);
          components.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context2.refDate, day, month);
          components.imply("year", year);
        }
        if (!match[DATE_TO_GROUP]) {
          return components;
        }
        const endDate = constants_2.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
        const result = context2.createParsingResult(match.index, match[0]);
        result.start = components;
        result.end = components.clone();
        result.end.assign("day", endDate);
        return result;
      }
    };
    exports.default = ENMonthNameMiddleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameParser.js
var require_ENMonthNameParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var years_1 = require_years();
    var pattern_1 = require_pattern();
    var constants_2 = require_constants();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`((?:in)\\s*)?(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})\\s*(?:[,-]?\\s*(${constants_2.YEAR_PATTERN})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, "i");
    var PREFIX_GROUP = 1;
    var MONTH_NAME_GROUP = 2;
    var YEAR_GROUP = 3;
    var ENMonthNameParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const monthName = match[MONTH_NAME_GROUP].toLowerCase();
        if (match[0].length <= 3 && !constants_1.FULL_MONTH_NAME_DICTIONARY[monthName]) {
          return null;
        }
        const result = context2.createParsingResult(match.index + (match[PREFIX_GROUP] || "").length, match.index + match[0].length);
        result.start.imply("day", 1);
        const month = constants_1.MONTH_DICTIONARY[monthName];
        result.start.assign("month", month);
        if (match[YEAR_GROUP]) {
          const year = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context2.refDate, 1, month);
          result.start.imply("year", year);
        }
        return result;
      }
    };
    exports.default = ENMonthNameParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENCasualYearMonthDayParser.js
var require_ENCasualYearMonthDayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENCasualYearMonthDayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`([0-9]{4})[\\.\\/\\s](?:(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})|([0-9]{1,2}))[\\.\\/\\s]([0-9]{1,2})(?=\\W|$)`, "i");
    var YEAR_NUMBER_GROUP = 1;
    var MONTH_NAME_GROUP = 2;
    var MONTH_NUMBER_GROUP = 3;
    var DATE_NUMBER_GROUP = 4;
    var ENCasualYearMonthDayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const month = match[MONTH_NUMBER_GROUP] ? parseInt(match[MONTH_NUMBER_GROUP]) : constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        if (month < 1 || month > 12) {
          return null;
        }
        const year = parseInt(match[YEAR_NUMBER_GROUP]);
        const day = parseInt(match[DATE_NUMBER_GROUP]);
        return {
          day,
          month,
          year
        };
      }
    };
    exports.default = ENCasualYearMonthDayParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENSlashMonthFormatParser.js
var require_ENSlashMonthFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENSlashMonthFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp("([0-9]|0[1-9]|1[012])/([0-9]{4})", "i");
    var MONTH_GROUP = 1;
    var YEAR_GROUP = 2;
    var ENSlashMonthFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const year = parseInt(match[YEAR_GROUP]);
        const month = parseInt(match[MONTH_GROUP]);
        return context2.createParsingComponents().imply("day", 1).assign("month", month).assign("year", year);
      }
    };
    exports.default = ENSlashMonthFormatParser;
  }
});

// node_modules/chrono-node/dist/common/parsers/AbstractTimeExpressionParser.js
var require_AbstractTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/common/parsers/AbstractTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractTimeExpressionParser = void 0;
    var index_1 = require_dist();
    function primaryTimePattern(leftBoundary, primaryPrefix, primarySuffix, flags) {
      return new RegExp(`${leftBoundary}${primaryPrefix}(\\d{1,4})(?:(?:\\.|:|\uFF1A)(\\d{1,2})(?:(?::|\uFF1A)(\\d{2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?${primarySuffix}`, flags);
    }
    function followingTimePatten(followingPhase, followingSuffix) {
      return new RegExp(`^(${followingPhase})(\\d{1,4})(?:(?:\\.|\\:|\\\uFF1A)(\\d{1,2})(?:(?:\\.|\\:|\\\uFF1A)(\\d{1,2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?${followingSuffix}`, "i");
    }
    var HOUR_GROUP = 2;
    var MINUTE_GROUP = 3;
    var SECOND_GROUP = 4;
    var MILLI_SECOND_GROUP = 5;
    var AM_PM_HOUR_GROUP = 6;
    var AbstractTimeExpressionParser = class {
      constructor(strictMode = false) {
        this.cachedPrimaryPrefix = null;
        this.cachedPrimarySuffix = null;
        this.cachedPrimaryTimePattern = null;
        this.cachedFollowingPhase = null;
        this.cachedFollowingSuffix = null;
        this.cachedFollowingTimePatten = null;
        this.strictMode = strictMode;
      }
      patternFlags() {
        return "i";
      }
      primaryPatternLeftBoundary() {
        return `(^|\\s|T|\\b)`;
      }
      primarySuffix() {
        return `(?=\\W|$)`;
      }
      followingSuffix() {
        return `(?=\\W|$)`;
      }
      pattern(context2) {
        return this.getPrimaryTimePatternThroughCache();
      }
      extract(context2, match) {
        const startComponents = this.extractPrimaryTimeComponents(context2, match);
        if (!startComponents) {
          match.index += match[0].length;
          return null;
        }
        const index = match.index + match[1].length;
        const text = match[0].substring(match[1].length);
        const result = context2.createParsingResult(index, text, startComponents);
        match.index += match[0].length;
        const remainingText = context2.text.substring(match.index);
        const followingPattern = this.getFollowingTimePatternThroughCache();
        const followingMatch = followingPattern.exec(remainingText);
        if (text.match(/^\d{3,4}/) && followingMatch && followingMatch[0].match(/^\s*([+-])\s*\d{2,4}$/)) {
          return null;
        }
        if (!followingMatch || followingMatch[0].match(/^\s*([+-])\s*\d{3,4}$/)) {
          return this.checkAndReturnWithoutFollowingPattern(result);
        }
        result.end = this.extractFollowingTimeComponents(context2, followingMatch, result);
        if (result.end) {
          result.text += followingMatch[0];
        }
        return this.checkAndReturnWithFollowingPattern(result);
      }
      extractPrimaryTimeComponents(context2, match, strict = false) {
        const components = context2.createParsingComponents();
        let minute = 0;
        let meridiem = null;
        let hour = parseInt(match[HOUR_GROUP]);
        if (hour > 100) {
          if (this.strictMode || match[MINUTE_GROUP] != null) {
            return null;
          }
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (hour > 24) {
          return null;
        }
        if (match[MINUTE_GROUP] != null) {
          if (match[MINUTE_GROUP].length == 1 && !match[AM_PM_HOUR_GROUP]) {
            return null;
          }
          minute = parseInt(match[MINUTE_GROUP]);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 12) {
          meridiem = index_1.Meridiem.PM;
        }
        if (match[AM_PM_HOUR_GROUP] != null) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = index_1.Meridiem.AM;
            if (hour == 12) {
              hour = 0;
            }
          }
          if (ampm == "p") {
            meridiem = index_1.Meridiem.PM;
            if (hour != 12) {
              hour += 12;
            }
          }
        }
        components.assign("hour", hour);
        components.assign("minute", minute);
        if (meridiem !== null) {
          components.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            components.imply("meridiem", index_1.Meridiem.AM);
          } else {
            components.imply("meridiem", index_1.Meridiem.PM);
          }
        }
        if (match[MILLI_SECOND_GROUP] != null) {
          const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));
          if (millisecond >= 1e3)
            return null;
          components.assign("millisecond", millisecond);
        }
        if (match[SECOND_GROUP] != null) {
          const second = parseInt(match[SECOND_GROUP]);
          if (second >= 60)
            return null;
          components.assign("second", second);
        }
        return components;
      }
      extractFollowingTimeComponents(context2, match, result) {
        const components = context2.createParsingComponents();
        if (match[MILLI_SECOND_GROUP] != null) {
          const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));
          if (millisecond >= 1e3)
            return null;
          components.assign("millisecond", millisecond);
        }
        if (match[SECOND_GROUP] != null) {
          const second = parseInt(match[SECOND_GROUP]);
          if (second >= 60)
            return null;
          components.assign("second", second);
        }
        let hour = parseInt(match[HOUR_GROUP]);
        let minute = 0;
        let meridiem = -1;
        if (match[MINUTE_GROUP] != null) {
          minute = parseInt(match[MINUTE_GROUP]);
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60 || hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = index_1.Meridiem.PM;
        }
        if (match[AM_PM_HOUR_GROUP] != null) {
          if (hour > 12) {
            return null;
          }
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = index_1.Meridiem.AM;
            if (hour == 12) {
              hour = 0;
              if (!components.isCertain("day")) {
                components.imply("day", components.get("day") + 1);
              }
            }
          }
          if (ampm == "p") {
            meridiem = index_1.Meridiem.PM;
            if (hour != 12)
              hour += 12;
          }
          if (!result.start.isCertain("meridiem")) {
            if (meridiem == index_1.Meridiem.AM) {
              result.start.imply("meridiem", index_1.Meridiem.AM);
              if (result.start.get("hour") == 12) {
                result.start.assign("hour", 0);
              }
            } else {
              result.start.imply("meridiem", index_1.Meridiem.PM);
              if (result.start.get("hour") != 12) {
                result.start.assign("hour", result.start.get("hour") + 12);
              }
            }
          }
        }
        components.assign("hour", hour);
        components.assign("minute", minute);
        if (meridiem >= 0) {
          components.assign("meridiem", meridiem);
        } else {
          const startAtPM = result.start.isCertain("meridiem") && result.start.get("hour") > 12;
          if (startAtPM) {
            if (result.start.get("hour") - 12 > hour) {
              components.imply("meridiem", index_1.Meridiem.AM);
            } else if (hour <= 12) {
              components.assign("hour", hour + 12);
              components.assign("meridiem", index_1.Meridiem.PM);
            }
          } else if (hour > 12) {
            components.imply("meridiem", index_1.Meridiem.PM);
          } else if (hour <= 12) {
            components.imply("meridiem", index_1.Meridiem.AM);
          }
        }
        if (components.date().getTime() < result.start.date().getTime()) {
          components.imply("day", components.get("day") + 1);
        }
        return components;
      }
      checkAndReturnWithoutFollowingPattern(result) {
        if (result.text.match(/^\d$/)) {
          return null;
        }
        if (result.text.match(/^\d\d\d+$/)) {
          return null;
        }
        if (result.text.match(/\d[apAP]$/)) {
          return null;
        }
        const endingWithNumbers = result.text.match(/[^\d:.](\d[\d.]+)$/);
        if (endingWithNumbers) {
          const endingNumbers = endingWithNumbers[1];
          if (this.strictMode) {
            return null;
          }
          if (endingNumbers.includes(".") && !endingNumbers.match(/\d(\.\d{2})+$/)) {
            return null;
          }
          const endingNumberVal = parseInt(endingNumbers);
          if (endingNumberVal > 24) {
            return null;
          }
        }
        return result;
      }
      checkAndReturnWithFollowingPattern(result) {
        if (result.text.match(/^\d+-\d+$/)) {
          return null;
        }
        const endingWithNumbers = result.text.match(/[^\d:.](\d[\d.]+)\s*-\s*(\d[\d.]+)$/);
        if (endingWithNumbers) {
          if (this.strictMode) {
            return null;
          }
          const startingNumbers = endingWithNumbers[1];
          const endingNumbers = endingWithNumbers[2];
          if (endingNumbers.includes(".") && !endingNumbers.match(/\d(\.\d{2})+$/)) {
            return null;
          }
          const endingNumberVal = parseInt(endingNumbers);
          const startingNumberVal = parseInt(startingNumbers);
          if (endingNumberVal > 24 || startingNumberVal > 24) {
            return null;
          }
        }
        return result;
      }
      getPrimaryTimePatternThroughCache() {
        const primaryPrefix = this.primaryPrefix();
        const primarySuffix = this.primarySuffix();
        if (this.cachedPrimaryPrefix === primaryPrefix && this.cachedPrimarySuffix === primarySuffix) {
          return this.cachedPrimaryTimePattern;
        }
        this.cachedPrimaryTimePattern = primaryTimePattern(this.primaryPatternLeftBoundary(), primaryPrefix, primarySuffix, this.patternFlags());
        this.cachedPrimaryPrefix = primaryPrefix;
        this.cachedPrimarySuffix = primarySuffix;
        return this.cachedPrimaryTimePattern;
      }
      getFollowingTimePatternThroughCache() {
        const followingPhase = this.followingPhase();
        const followingSuffix = this.followingSuffix();
        if (this.cachedFollowingPhase === followingPhase && this.cachedFollowingSuffix === followingSuffix) {
          return this.cachedFollowingTimePatten;
        }
        this.cachedFollowingTimePatten = followingTimePatten(followingPhase, followingSuffix);
        this.cachedFollowingPhase = followingPhase;
        this.cachedFollowingSuffix = followingSuffix;
        return this.cachedFollowingTimePatten;
      }
    };
    exports.AbstractTimeExpressionParser = AbstractTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeExpressionParser.js
var require_ENTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var ENTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      constructor(strictMode) {
        super(strictMode);
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|to|\\?)\\s*";
      }
      primaryPrefix() {
        return "(?:(?:at|from)\\s*)??";
      }
      primarySuffix() {
        return "(?:\\s*(?:o\\W*clock|at\\s*night|in\\s*the\\s*(?:morning|afternoon)))?(?!/)(?=\\W|$)";
      }
      extractPrimaryTimeComponents(context2, match) {
        const components = super.extractPrimaryTimeComponents(context2, match);
        if (components) {
          if (match[0].endsWith("night")) {
            const hour = components.get("hour");
            if (hour >= 6 && hour < 12) {
              components.assign("hour", components.get("hour") + 12);
              components.assign("meridiem", index_1.Meridiem.PM);
            } else if (hour < 6) {
              components.assign("meridiem", index_1.Meridiem.AM);
            }
          }
          if (match[0].endsWith("afternoon")) {
            components.assign("meridiem", index_1.Meridiem.PM);
            const hour = components.get("hour");
            if (hour >= 0 && hour <= 6) {
              components.assign("hour", components.get("hour") + 12);
            }
          }
          if (match[0].endsWith("morning")) {
            components.assign("meridiem", index_1.Meridiem.AM);
            const hour = components.get("hour");
            if (hour < 12) {
              components.assign("hour", components.get("hour"));
            }
          }
        }
        return components;
      }
    };
    exports.default = ENTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/utils/timeunits.js
var require_timeunits = __commonJS({
  "node_modules/chrono-node/dist/utils/timeunits.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addImpliedTimeUnits = exports.reverseTimeUnits = void 0;
    function reverseTimeUnits(timeUnits) {
      const reversed = {};
      for (const key in timeUnits) {
        reversed[key] = -timeUnits[key];
      }
      return reversed;
    }
    exports.reverseTimeUnits = reverseTimeUnits;
    function addImpliedTimeUnits(components, timeUnits) {
      const output = components.clone();
      let date = components.dayjs();
      for (const key in timeUnits) {
        date = date.add(timeUnits[key], key);
      }
      if ("day" in timeUnits || "d" in timeUnits || "week" in timeUnits || "month" in timeUnits || "year" in timeUnits) {
        output.imply("day", date.date());
        output.imply("month", date.month() + 1);
        output.imply("year", date.year());
      }
      if ("second" in timeUnits || "minute" in timeUnits || "hour" in timeUnits) {
        output.imply("second", date.second());
        output.imply("minute", date.minute());
        output.imply("hour", date.hour());
      }
      return output;
    }
    exports.addImpliedTimeUnits = addImpliedTimeUnits;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitAgoFormatParser.js
var require_ENTimeUnitAgoFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitAgoFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(${constants_1.TIME_UNITS_PATTERN})\\s{0,5}(?:ago|before|earlier)(?=(?:\\W|$))`, "i");
    var STRICT_PATTERN = new RegExp(`(${constants_1.TIME_UNITS_PATTERN})\\s{0,5}ago(?=(?:\\W|$))`, "i");
    var ENTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      innerPattern() {
        return this.strictMode ? STRICT_PATTERN : PATTERN;
      }
      innerExtract(context2, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        const outputTimeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        return results_1.ParsingComponents.createRelativeFromReference(context2.reference, outputTimeUnits);
      }
    };
    exports.default = ENTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitLaterFormatParser.js
var require_ENTimeUnitLaterFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitLaterFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(${constants_1.TIME_UNITS_PATTERN})\\s{0,5}(?:later|after|from now|henceforth|forward|out)(?=(?:\\W|$))`, "i");
    var STRICT_PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")(later|from now)(?=(?:\\W|$))", "i");
    var GROUP_NUM_TIMEUNITS = 1;
    var ENTimeUnitLaterFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      innerPattern() {
        return this.strictMode ? STRICT_PATTERN : PATTERN;
      }
      innerExtract(context2, match) {
        const fragments = constants_1.parseTimeUnits(match[GROUP_NUM_TIMEUNITS]);
        return results_1.ParsingComponents.createRelativeFromReference(context2.reference, fragments);
      }
    };
    exports.default = ENTimeUnitLaterFormatParser;
  }
});

// node_modules/chrono-node/dist/common/abstractRefiners.js
var require_abstractRefiners = __commonJS({
  "node_modules/chrono-node/dist/common/abstractRefiners.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MergingRefiner = exports.Filter = void 0;
    var Filter = class {
      refine(context2, results) {
        return results.filter((r4) => this.isValid(context2, r4));
      }
    };
    exports.Filter = Filter;
    var MergingRefiner = class {
      refine(context2, results) {
        if (results.length < 2) {
          return results;
        }
        const mergedResults = [];
        let curResult = results[0];
        let nextResult = null;
        for (let i4 = 1; i4 < results.length; i4++) {
          nextResult = results[i4];
          const textBetween = context2.text.substring(curResult.index + curResult.text.length, nextResult.index);
          if (!this.shouldMergeResults(textBetween, curResult, nextResult, context2)) {
            mergedResults.push(curResult);
            curResult = nextResult;
          } else {
            const left = curResult;
            const right = nextResult;
            const mergedResult = this.mergeResults(textBetween, left, right, context2);
            context2.debug(() => {
              console.log(`${this.constructor.name} merged ${left} and ${right} into ${mergedResult}`);
            });
            curResult = mergedResult;
          }
        }
        if (curResult != null) {
          mergedResults.push(curResult);
        }
        return mergedResults;
      }
    };
    exports.MergingRefiner = MergingRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/AbstractMergeDateRangeRefiner.js
var require_AbstractMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/AbstractMergeDateRangeRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var AbstractMergeDateRangeRefiner = class extends abstractRefiners_1.MergingRefiner {
      shouldMergeResults(textBetween, currentResult, nextResult) {
        return !currentResult.end && !nextResult.end && textBetween.match(this.patternBetween()) != null;
      }
      mergeResults(textBetween, fromResult, toResult) {
        if (!fromResult.start.isOnlyWeekdayComponent() && !toResult.start.isOnlyWeekdayComponent()) {
          toResult.start.getCertainComponents().forEach((key) => {
            if (!fromResult.start.isCertain(key)) {
              fromResult.start.assign(key, toResult.start.get(key));
            }
          });
          fromResult.start.getCertainComponents().forEach((key) => {
            if (!toResult.start.isCertain(key)) {
              toResult.start.assign(key, fromResult.start.get(key));
            }
          });
        }
        if (fromResult.start.date().getTime() > toResult.start.date().getTime()) {
          let fromMoment = fromResult.start.dayjs();
          let toMoment = toResult.start.dayjs();
          if (fromResult.start.isOnlyWeekdayComponent() && fromMoment.add(-7, "days").isBefore(toMoment)) {
            fromMoment = fromMoment.add(-7, "days");
            fromResult.start.imply("day", fromMoment.date());
            fromResult.start.imply("month", fromMoment.month() + 1);
            fromResult.start.imply("year", fromMoment.year());
          } else if (toResult.start.isOnlyWeekdayComponent() && toMoment.add(7, "days").isAfter(fromMoment)) {
            toMoment = toMoment.add(7, "days");
            toResult.start.imply("day", toMoment.date());
            toResult.start.imply("month", toMoment.month() + 1);
            toResult.start.imply("year", toMoment.year());
          } else {
            [toResult, fromResult] = [fromResult, toResult];
          }
        }
        const result = fromResult.clone();
        result.start = fromResult.start;
        result.end = toResult.start;
        result.index = Math.min(fromResult.index, toResult.index);
        if (fromResult.index < toResult.index) {
          result.text = fromResult.text + textBetween + toResult.text;
        } else {
          result.text = toResult.text + textBetween + fromResult.text;
        }
        return result;
      }
    };
    exports.default = AbstractMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/en/refiners/ENMergeDateRangeRefiner.js
var require_ENMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/en/refiners/ENMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var ENMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(to|-)\s*$/i;
      }
    };
    exports.default = ENMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/calculation/mergingCalculation.js
var require_mergingCalculation = __commonJS({
  "node_modules/chrono-node/dist/calculation/mergingCalculation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeDateTimeComponent = exports.mergeDateTimeResult = void 0;
    var index_1 = require_dist();
    function mergeDateTimeResult(dateResult, timeResult) {
      const result = dateResult.clone();
      const beginDate = dateResult.start;
      const beginTime = timeResult.start;
      result.start = mergeDateTimeComponent(beginDate, beginTime);
      if (dateResult.end != null || timeResult.end != null) {
        const endDate = dateResult.end == null ? dateResult.start : dateResult.end;
        const endTime = timeResult.end == null ? timeResult.start : timeResult.end;
        const endDateTime = mergeDateTimeComponent(endDate, endTime);
        if (dateResult.end == null && endDateTime.date().getTime() < result.start.date().getTime()) {
          if (endDateTime.isCertain("day")) {
            endDateTime.assign("day", endDateTime.get("day") + 1);
          } else {
            endDateTime.imply("day", endDateTime.get("day") + 1);
          }
        }
        result.end = endDateTime;
      }
      return result;
    }
    exports.mergeDateTimeResult = mergeDateTimeResult;
    function mergeDateTimeComponent(dateComponent, timeComponent) {
      const dateTimeComponent = dateComponent.clone();
      if (timeComponent.isCertain("hour")) {
        dateTimeComponent.assign("hour", timeComponent.get("hour"));
        dateTimeComponent.assign("minute", timeComponent.get("minute"));
        if (timeComponent.isCertain("second")) {
          dateTimeComponent.assign("second", timeComponent.get("second"));
          if (timeComponent.isCertain("millisecond")) {
            dateTimeComponent.assign("millisecond", timeComponent.get("millisecond"));
          } else {
            dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
          }
        } else {
          dateTimeComponent.imply("second", timeComponent.get("second"));
          dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
        }
      } else {
        dateTimeComponent.imply("hour", timeComponent.get("hour"));
        dateTimeComponent.imply("minute", timeComponent.get("minute"));
        dateTimeComponent.imply("second", timeComponent.get("second"));
        dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
      }
      if (timeComponent.isCertain("timezoneOffset")) {
        dateTimeComponent.assign("timezoneOffset", timeComponent.get("timezoneOffset"));
      }
      if (timeComponent.isCertain("meridiem")) {
        dateTimeComponent.assign("meridiem", timeComponent.get("meridiem"));
      } else if (timeComponent.get("meridiem") != null && dateTimeComponent.get("meridiem") == null) {
        dateTimeComponent.imply("meridiem", timeComponent.get("meridiem"));
      }
      if (dateTimeComponent.get("meridiem") == index_1.Meridiem.PM && dateTimeComponent.get("hour") < 12) {
        if (timeComponent.isCertain("hour")) {
          dateTimeComponent.assign("hour", dateTimeComponent.get("hour") + 12);
        } else {
          dateTimeComponent.imply("hour", dateTimeComponent.get("hour") + 12);
        }
      }
      return dateTimeComponent;
    }
    exports.mergeDateTimeComponent = mergeDateTimeComponent;
  }
});

// node_modules/chrono-node/dist/common/refiners/AbstractMergeDateTimeRefiner.js
var require_AbstractMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/AbstractMergeDateTimeRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var mergingCalculation_1 = require_mergingCalculation();
    var ENMergeDateTimeRefiner = class extends abstractRefiners_1.MergingRefiner {
      shouldMergeResults(textBetween, currentResult, nextResult) {
        return (currentResult.start.isOnlyDate() && nextResult.start.isOnlyTime() || nextResult.start.isOnlyDate() && currentResult.start.isOnlyTime()) && textBetween.match(this.patternBetween()) != null;
      }
      mergeResults(textBetween, currentResult, nextResult) {
        const result = currentResult.start.isOnlyDate() ? mergingCalculation_1.mergeDateTimeResult(currentResult, nextResult) : mergingCalculation_1.mergeDateTimeResult(nextResult, currentResult);
        result.index = currentResult.index;
        result.text = currentResult.text + textBetween + nextResult.text;
        return result;
      }
    };
    exports.default = ENMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/en/refiners/ENMergeDateTimeRefiner.js
var require_ENMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/en/refiners/ENMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault2(require_AbstractMergeDateTimeRefiner());
    var ENMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(T|at|after|before|on|of|,|-)?\\s*$");
      }
    };
    exports.default = ENMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/ExtractTimezoneAbbrRefiner.js
var require_ExtractTimezoneAbbrRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/ExtractTimezoneAbbrRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TIMEZONE_NAME_PATTERN = new RegExp("^\\s*,?\\s*\\(?([A-Z]{2,4})\\)?(?=\\W|$)", "i");
    var DEFAULT_TIMEZONE_ABBR_MAP = {
      ACDT: 630,
      ACST: 570,
      ADT: -180,
      AEDT: 660,
      AEST: 600,
      AFT: 270,
      AKDT: -480,
      AKST: -540,
      ALMT: 360,
      AMST: -180,
      AMT: -240,
      ANAST: 720,
      ANAT: 720,
      AQTT: 300,
      ART: -180,
      AST: -240,
      AWDT: 540,
      AWST: 480,
      AZOST: 0,
      AZOT: -60,
      AZST: 300,
      AZT: 240,
      BNT: 480,
      BOT: -240,
      BRST: -120,
      BRT: -180,
      BST: 60,
      BTT: 360,
      CAST: 480,
      CAT: 120,
      CCT: 390,
      CDT: -300,
      CEST: 120,
      CET: 60,
      CHADT: 825,
      CHAST: 765,
      CKT: -600,
      CLST: -180,
      CLT: -240,
      COT: -300,
      CST: -360,
      CVT: -60,
      CXT: 420,
      ChST: 600,
      DAVT: 420,
      EASST: -300,
      EAST: -360,
      EAT: 180,
      ECT: -300,
      EDT: -240,
      EEST: 180,
      EET: 120,
      EGST: 0,
      EGT: -60,
      EST: -300,
      ET: -300,
      FJST: 780,
      FJT: 720,
      FKST: -180,
      FKT: -240,
      FNT: -120,
      GALT: -360,
      GAMT: -540,
      GET: 240,
      GFT: -180,
      GILT: 720,
      GMT: 0,
      GST: 240,
      GYT: -240,
      HAA: -180,
      HAC: -300,
      HADT: -540,
      HAE: -240,
      HAP: -420,
      HAR: -360,
      HAST: -600,
      HAT: -90,
      HAY: -480,
      HKT: 480,
      HLV: -210,
      HNA: -240,
      HNC: -360,
      HNE: -300,
      HNP: -480,
      HNR: -420,
      HNT: -150,
      HNY: -540,
      HOVT: 420,
      ICT: 420,
      IDT: 180,
      IOT: 360,
      IRDT: 270,
      IRKST: 540,
      IRKT: 540,
      IRST: 210,
      IST: 330,
      JST: 540,
      KGT: 360,
      KRAST: 480,
      KRAT: 480,
      KST: 540,
      KUYT: 240,
      LHDT: 660,
      LHST: 630,
      LINT: 840,
      MAGST: 720,
      MAGT: 720,
      MART: -510,
      MAWT: 300,
      MDT: -360,
      MESZ: 120,
      MEZ: 60,
      MHT: 720,
      MMT: 390,
      MSD: 240,
      MSK: 240,
      MST: -420,
      MUT: 240,
      MVT: 300,
      MYT: 480,
      NCT: 660,
      NDT: -90,
      NFT: 690,
      NOVST: 420,
      NOVT: 360,
      NPT: 345,
      NST: -150,
      NUT: -660,
      NZDT: 780,
      NZST: 720,
      OMSST: 420,
      OMST: 420,
      PDT: -420,
      PET: -300,
      PETST: 720,
      PETT: 720,
      PGT: 600,
      PHOT: 780,
      PHT: 480,
      PKT: 300,
      PMDT: -120,
      PMST: -180,
      PONT: 660,
      PST: -480,
      PT: -480,
      PWT: 540,
      PYST: -180,
      PYT: -240,
      RET: 240,
      SAMT: 240,
      SAST: 120,
      SBT: 660,
      SCT: 240,
      SGT: 480,
      SRT: -180,
      SST: -660,
      TAHT: -600,
      TFT: 300,
      TJT: 300,
      TKT: 780,
      TLT: 540,
      TMT: 300,
      TVT: 720,
      ULAT: 480,
      UTC: 0,
      UYST: -120,
      UYT: -180,
      UZT: 300,
      VET: -210,
      VLAST: 660,
      VLAT: 660,
      VUT: 660,
      WAST: 120,
      WAT: 60,
      WEST: 60,
      WESZ: 60,
      WET: 0,
      WEZ: 0,
      WFT: 720,
      WGST: -120,
      WGT: -180,
      WIB: 420,
      WIT: 540,
      WITA: 480,
      WST: 780,
      WT: 0,
      YAKST: 600,
      YAKT: 600,
      YAPT: 600,
      YEKST: 360,
      YEKT: 360
    };
    var ExtractTimezoneAbbrRefiner = class {
      constructor(timezoneOverrides) {
        this.timezone = Object.assign(Object.assign({}, DEFAULT_TIMEZONE_ABBR_MAP), timezoneOverrides);
      }
      refine(context2, results) {
        var _a;
        const timezoneOverrides = (_a = context2.option.timezones) !== null && _a !== void 0 ? _a : {};
        results.forEach((result) => {
          var _a2, _b;
          const suffix = context2.text.substring(result.index + result.text.length);
          const match = TIMEZONE_NAME_PATTERN.exec(suffix);
          if (!match) {
            return;
          }
          const timezoneAbbr = match[1].toUpperCase();
          const extractedTimezoneOffset = (_b = (_a2 = timezoneOverrides[timezoneAbbr]) !== null && _a2 !== void 0 ? _a2 : this.timezone[timezoneAbbr]) !== null && _b !== void 0 ? _b : null;
          if (extractedTimezoneOffset === null) {
            return;
          }
          context2.debug(() => {
            console.log(`Extracting timezone: '${timezoneAbbr}' into: ${extractedTimezoneOffset} for: ${result.start}`);
          });
          const currentTimezoneOffset = result.start.get("timezoneOffset");
          if (currentTimezoneOffset !== null && extractedTimezoneOffset != currentTimezoneOffset) {
            if (result.start.isCertain("timezoneOffset")) {
              return;
            }
            if (timezoneAbbr != match[1]) {
              return;
            }
          }
          if (result.start.isOnlyDate()) {
            if (timezoneAbbr != match[1]) {
              return;
            }
          }
          result.text += match[0];
          if (!result.start.isCertain("timezoneOffset")) {
            result.start.assign("timezoneOffset", extractedTimezoneOffset);
          }
          if (result.end != null && !result.end.isCertain("timezoneOffset")) {
            result.end.assign("timezoneOffset", extractedTimezoneOffset);
          }
        });
        return results;
      }
    };
    exports.default = ExtractTimezoneAbbrRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/ExtractTimezoneOffsetRefiner.js
var require_ExtractTimezoneOffsetRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/ExtractTimezoneOffsetRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TIMEZONE_OFFSET_PATTERN = new RegExp("^\\s*(?:\\(?(?:GMT|UTC)\\s?)?([+-])(\\d{1,2})(?::?(\\d{2}))?\\)?", "i");
    var TIMEZONE_OFFSET_SIGN_GROUP = 1;
    var TIMEZONE_OFFSET_HOUR_OFFSET_GROUP = 2;
    var TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP = 3;
    var ExtractTimezoneOffsetRefiner = class {
      refine(context2, results) {
        results.forEach(function(result) {
          if (result.start.isCertain("timezoneOffset")) {
            return;
          }
          const suffix = context2.text.substring(result.index + result.text.length);
          const match = TIMEZONE_OFFSET_PATTERN.exec(suffix);
          if (!match) {
            return;
          }
          context2.debug(() => {
            console.log(`Extracting timezone: '${match[0]}' into : ${result}`);
          });
          const hourOffset = parseInt(match[TIMEZONE_OFFSET_HOUR_OFFSET_GROUP]);
          const minuteOffset = parseInt(match[TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP] || "0");
          let timezoneOffset = hourOffset * 60 + minuteOffset;
          if (timezoneOffset > 14 * 60) {
            return;
          }
          if (match[TIMEZONE_OFFSET_SIGN_GROUP] === "-") {
            timezoneOffset = -timezoneOffset;
          }
          if (result.end != null) {
            result.end.assign("timezoneOffset", timezoneOffset);
          }
          result.start.assign("timezoneOffset", timezoneOffset);
          result.text += match[0];
        });
        return results;
      }
    };
    exports.default = ExtractTimezoneOffsetRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/OverlapRemovalRefiner.js
var require_OverlapRemovalRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/OverlapRemovalRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var OverlapRemovalRefiner = class {
      refine(context2, results) {
        if (results.length < 2) {
          return results;
        }
        const filteredResults = [];
        let prevResult = results[0];
        for (let i4 = 1; i4 < results.length; i4++) {
          const result = results[i4];
          if (result.index < prevResult.index + prevResult.text.length) {
            if (result.text.length > prevResult.text.length) {
              prevResult = result;
            }
          } else {
            filteredResults.push(prevResult);
            prevResult = result;
          }
        }
        if (prevResult != null) {
          filteredResults.push(prevResult);
        }
        return filteredResults;
      }
    };
    exports.default = OverlapRemovalRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/ForwardDateRefiner.js
var require_ForwardDateRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/ForwardDateRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var ForwardDateRefiner = class {
      refine(context2, results) {
        if (!context2.option.forwardDate) {
          return results;
        }
        results.forEach(function(result) {
          let refMoment = dayjs_1.default(context2.refDate);
          if (result.start.isOnlyDayMonthComponent() && refMoment.isAfter(result.start.dayjs())) {
            for (let i4 = 0; i4 < 3 && refMoment.isAfter(result.start.dayjs()); i4++) {
              result.start.imply("year", result.start.get("year") + 1);
              context2.debug(() => {
                console.log(`Forward yearly adjusted for ${result} (${result.start})`);
              });
              if (result.end && !result.end.isCertain("year")) {
                result.end.imply("year", result.end.get("year") + 1);
                context2.debug(() => {
                  console.log(`Forward yearly adjusted for ${result} (${result.end})`);
                });
              }
            }
          }
          if (result.start.isOnlyWeekdayComponent() && refMoment.isAfter(result.start.dayjs())) {
            if (refMoment.day() >= result.start.get("weekday")) {
              refMoment = refMoment.day(result.start.get("weekday") + 7);
            } else {
              refMoment = refMoment.day(result.start.get("weekday"));
            }
            result.start.imply("day", refMoment.date());
            result.start.imply("month", refMoment.month() + 1);
            result.start.imply("year", refMoment.year());
            context2.debug(() => {
              console.log(`Forward weekly adjusted for ${result} (${result.start})`);
            });
            if (result.end && result.end.isOnlyWeekdayComponent()) {
              if (refMoment.day() > result.end.get("weekday")) {
                refMoment = refMoment.day(result.end.get("weekday") + 7);
              } else {
                refMoment = refMoment.day(result.end.get("weekday"));
              }
              result.end.imply("day", refMoment.date());
              result.end.imply("month", refMoment.month() + 1);
              result.end.imply("year", refMoment.year());
              context2.debug(() => {
                console.log(`Forward weekly adjusted for ${result} (${result.end})`);
              });
            }
          }
        });
        return results;
      }
    };
    exports.default = ForwardDateRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/UnlikelyFormatFilter.js
var require_UnlikelyFormatFilter = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/UnlikelyFormatFilter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var UnlikelyFormatFilter = class extends abstractRefiners_1.Filter {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      isValid(context2, result) {
        if (result.text.replace(" ", "").match(/^\d*(\.\d*)?$/)) {
          context2.debug(() => {
            console.log(`Removing unlikely result '${result.text}'`);
          });
          return false;
        }
        if (!result.start.isValidDate()) {
          context2.debug(() => {
            console.log(`Removing invalid result: ${result} (${result.start})`);
          });
          return false;
        }
        if (result.end && !result.end.isValidDate()) {
          context2.debug(() => {
            console.log(`Removing invalid result: ${result} (${result.end})`);
          });
          return false;
        }
        if (this.strictMode) {
          return this.isStrictModeValid(context2, result);
        }
        return true;
      }
      isStrictModeValid(context2, result) {
        if (result.start.isOnlyWeekdayComponent()) {
          context2.debug(() => {
            console.log(`(Strict) Removing weekday only component: ${result} (${result.end})`);
          });
          return false;
        }
        if (result.start.isOnlyTime() && (!result.start.isCertain("hour") || !result.start.isCertain("minute"))) {
          context2.debug(() => {
            console.log(`(Strict) Removing uncertain time component: ${result} (${result.end})`);
          });
          return false;
        }
        return true;
      }
    };
    exports.default = UnlikelyFormatFilter;
  }
});

// node_modules/chrono-node/dist/common/parsers/ISOFormatParser.js
var require_ISOFormatParser = __commonJS({
  "node_modules/chrono-node/dist/common/parsers/ISOFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp("([0-9]{4})\\-([0-9]{1,2})\\-([0-9]{1,2})(?:T([0-9]{1,2}):([0-9]{1,2})(?::([0-9]{1,2})(?:\\.(\\d{1,4}))?)?(?:Z|([+-]\\d{2}):?(\\d{2})?)?)?(?=\\W|$)", "i");
    var YEAR_NUMBER_GROUP = 1;
    var MONTH_NUMBER_GROUP = 2;
    var DATE_NUMBER_GROUP = 3;
    var HOUR_NUMBER_GROUP = 4;
    var MINUTE_NUMBER_GROUP = 5;
    var SECOND_NUMBER_GROUP = 6;
    var MILLISECOND_NUMBER_GROUP = 7;
    var TZD_HOUR_OFFSET_GROUP = 8;
    var TZD_MINUTE_OFFSET_GROUP = 9;
    var ISOFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const components = {};
        components["year"] = parseInt(match[YEAR_NUMBER_GROUP]);
        components["month"] = parseInt(match[MONTH_NUMBER_GROUP]);
        components["day"] = parseInt(match[DATE_NUMBER_GROUP]);
        if (match[HOUR_NUMBER_GROUP] != null) {
          components["hour"] = parseInt(match[HOUR_NUMBER_GROUP]);
          components["minute"] = parseInt(match[MINUTE_NUMBER_GROUP]);
          if (match[SECOND_NUMBER_GROUP] != null) {
            components["second"] = parseInt(match[SECOND_NUMBER_GROUP]);
          }
          if (match[MILLISECOND_NUMBER_GROUP] != null) {
            components["millisecond"] = parseInt(match[MILLISECOND_NUMBER_GROUP]);
          }
          if (match[TZD_HOUR_OFFSET_GROUP] == null) {
            components["timezoneOffset"] = 0;
          } else {
            const hourOffset = parseInt(match[TZD_HOUR_OFFSET_GROUP]);
            let minuteOffset = 0;
            if (match[TZD_MINUTE_OFFSET_GROUP] != null) {
              minuteOffset = parseInt(match[TZD_MINUTE_OFFSET_GROUP]);
            }
            let offset = hourOffset * 60;
            if (offset < 0) {
              offset -= minuteOffset;
            } else {
              offset += minuteOffset;
            }
            components["timezoneOffset"] = offset;
          }
        }
        return components;
      }
    };
    exports.default = ISOFormatParser;
  }
});

// node_modules/chrono-node/dist/common/refiners/MergeWeekdayComponentRefiner.js
var require_MergeWeekdayComponentRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/MergeWeekdayComponentRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var MergeWeekdayComponentRefiner = class extends abstractRefiners_1.MergingRefiner {
      mergeResults(textBetween, currentResult, nextResult) {
        const newResult = nextResult.clone();
        newResult.index = currentResult.index;
        newResult.text = currentResult.text + textBetween + newResult.text;
        newResult.start.assign("weekday", currentResult.start.get("weekday"));
        if (newResult.end) {
          newResult.end.assign("weekday", currentResult.start.get("weekday"));
        }
        return newResult;
      }
      shouldMergeResults(textBetween, currentResult, nextResult) {
        const weekdayThenNormalDate = currentResult.start.isOnlyWeekdayComponent() && !currentResult.start.isCertain("hour") && nextResult.start.isCertain("day");
        return weekdayThenNormalDate && textBetween.match(/^,?\s*$/) != null;
      }
    };
    exports.default = MergeWeekdayComponentRefiner;
  }
});

// node_modules/chrono-node/dist/configurations.js
var require_configurations = __commonJS({
  "node_modules/chrono-node/dist/configurations.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.includeCommonConfiguration = void 0;
    var ExtractTimezoneAbbrRefiner_1 = __importDefault2(require_ExtractTimezoneAbbrRefiner());
    var ExtractTimezoneOffsetRefiner_1 = __importDefault2(require_ExtractTimezoneOffsetRefiner());
    var OverlapRemovalRefiner_1 = __importDefault2(require_OverlapRemovalRefiner());
    var ForwardDateRefiner_1 = __importDefault2(require_ForwardDateRefiner());
    var UnlikelyFormatFilter_1 = __importDefault2(require_UnlikelyFormatFilter());
    var ISOFormatParser_1 = __importDefault2(require_ISOFormatParser());
    var MergeWeekdayComponentRefiner_1 = __importDefault2(require_MergeWeekdayComponentRefiner());
    function includeCommonConfiguration(configuration, strictMode = false) {
      configuration.parsers.unshift(new ISOFormatParser_1.default());
      configuration.refiners.unshift(new MergeWeekdayComponentRefiner_1.default());
      configuration.refiners.unshift(new ExtractTimezoneAbbrRefiner_1.default());
      configuration.refiners.unshift(new ExtractTimezoneOffsetRefiner_1.default());
      configuration.refiners.unshift(new OverlapRemovalRefiner_1.default());
      configuration.refiners.push(new OverlapRemovalRefiner_1.default());
      configuration.refiners.push(new ForwardDateRefiner_1.default());
      configuration.refiners.push(new UnlikelyFormatFilter_1.default(strictMode));
      return configuration;
    }
    exports.includeCommonConfiguration = includeCommonConfiguration;
  }
});

// node_modules/chrono-node/dist/common/casualReferences.js
var require_casualReferences = __commonJS({
  "node_modules/chrono-node/dist/common/casualReferences.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.noon = exports.morning = exports.midnight = exports.yesterdayEvening = exports.evening = exports.lastNight = exports.tonight = exports.theDayAfter = exports.tomorrow = exports.theDayBefore = exports.yesterday = exports.today = exports.now = void 0;
    var results_1 = require_results();
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var dayjs_2 = require_dayjs();
    var index_1 = require_dist();
    function now(reference) {
      const targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      dayjs_2.assignSimilarDate(component, targetDate);
      dayjs_2.assignSimilarTime(component, targetDate);
      if (reference.timezoneOffset !== null) {
        component.assign("timezoneOffset", targetDate.utcOffset());
      }
      return component;
    }
    exports.now = now;
    function today(reference) {
      const targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      dayjs_2.assignSimilarDate(component, targetDate);
      dayjs_2.implySimilarTime(component, targetDate);
      return component;
    }
    exports.today = today;
    function yesterday(reference) {
      return theDayBefore(reference, 1);
    }
    exports.yesterday = yesterday;
    function theDayBefore(reference, numDay) {
      return theDayAfter(reference, -numDay);
    }
    exports.theDayBefore = theDayBefore;
    function tomorrow(reference) {
      return theDayAfter(reference, 1);
    }
    exports.tomorrow = tomorrow;
    function theDayAfter(reference, nDays) {
      let targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      targetDate = targetDate.add(nDays, "day");
      dayjs_2.assignSimilarDate(component, targetDate);
      dayjs_2.implySimilarTime(component, targetDate);
      return component;
    }
    exports.theDayAfter = theDayAfter;
    function tonight(reference, implyHour = 22) {
      const targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("hour", implyHour);
      component.imply("meridiem", index_1.Meridiem.PM);
      dayjs_2.assignSimilarDate(component, targetDate);
      return component;
    }
    exports.tonight = tonight;
    function lastNight(reference, implyHour = 0) {
      let targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      if (targetDate.hour() < 6) {
        targetDate = targetDate.add(-1, "day");
      }
      dayjs_2.assignSimilarDate(component, targetDate);
      component.imply("hour", implyHour);
      return component;
    }
    exports.lastNight = lastNight;
    function evening(reference, implyHour = 20) {
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("meridiem", index_1.Meridiem.PM);
      component.imply("hour", implyHour);
      return component;
    }
    exports.evening = evening;
    function yesterdayEvening(reference, implyHour = 20) {
      let targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      targetDate = targetDate.add(-1, "day");
      dayjs_2.assignSimilarDate(component, targetDate);
      component.imply("hour", implyHour);
      component.imply("meridiem", index_1.Meridiem.PM);
      return component;
    }
    exports.yesterdayEvening = yesterdayEvening;
    function midnight(reference) {
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("hour", 0);
      component.imply("minute", 0);
      component.imply("second", 0);
      return component;
    }
    exports.midnight = midnight;
    function morning(reference, implyHour = 6) {
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("meridiem", index_1.Meridiem.AM);
      component.imply("hour", implyHour);
      return component;
    }
    exports.morning = morning;
    function noon(reference) {
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("meridiem", index_1.Meridiem.AM);
      component.imply("hour", 12);
      return component;
    }
    exports.noon = noon;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENCasualDateParser.js
var require_ENCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o6, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o6, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o6, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o6[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o6, v2) {
      Object.defineProperty(o6, "default", { enumerable: true, value: v2 });
    } : function(o6, v2) {
      o6["default"] = v2;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding2(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_2 = require_dayjs();
    var references = __importStar2(require_casualReferences());
    var PATTERN = /(now|today|tonight|tomorrow|tmr|tmrw|yesterday|last\s*night)(?=\W|$)/i;
    var ENCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context2) {
        return PATTERN;
      }
      innerExtract(context2, match) {
        let targetDate = dayjs_1.default(context2.refDate);
        const lowerText = match[0].toLowerCase();
        const component = context2.createParsingComponents();
        switch (lowerText) {
          case "now":
            return references.now(context2.reference);
          case "today":
            return references.today(context2.reference);
          case "yesterday":
            return references.yesterday(context2.reference);
          case "tomorrow":
          case "tmr":
          case "tmrw":
            return references.tomorrow(context2.reference);
          case "tonight":
            return references.tonight(context2.reference);
          default:
            if (lowerText.match(/last\s*night/)) {
              if (targetDate.hour() > 6) {
                targetDate = targetDate.add(-1, "day");
              }
              dayjs_2.assignSimilarDate(component, targetDate);
              component.imply("hour", 0);
            }
            break;
        }
        return component;
      }
    };
    exports.default = ENCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENCasualTimeParser.js
var require_ENCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENCasualTimeParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var dayjs_2 = require_dayjs();
    var PATTERN = /(?:this)?\s{0,3}(morning|afternoon|evening|night|midnight|noon)(?=\W|$)/i;
    var ENCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const targetDate = dayjs_1.default(context2.refDate);
        const component = context2.createParsingComponents();
        switch (match[1].toLowerCase()) {
          case "afternoon":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 15);
            break;
          case "evening":
          case "night":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 20);
            break;
          case "midnight":
            dayjs_2.assignTheNextDay(component, targetDate);
            component.imply("hour", 0);
            component.imply("minute", 0);
            component.imply("second", 0);
            break;
          case "morning":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 6);
            break;
          case "noon":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 12);
            break;
        }
        return component;
      }
    };
    exports.default = ENCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/common/calculation/weekdays.js
var require_weekdays = __commonJS({
  "node_modules/chrono-node/dist/common/calculation/weekdays.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBackwardDaysToWeekday = exports.getDaysForwardToWeekday = exports.getDaysToWeekdayClosest = exports.getDaysToWeekday = exports.createParsingComponentsAtWeekday = void 0;
    var index_1 = require_dist();
    var results_1 = require_results();
    var timeunits_1 = require_timeunits();
    function createParsingComponentsAtWeekday(reference, weekday, modifier) {
      const refDate = reference.getDateWithAdjustedTimezone();
      const daysToWeekday = getDaysToWeekday(refDate, weekday, modifier);
      let components = new results_1.ParsingComponents(reference);
      components = timeunits_1.addImpliedTimeUnits(components, { "day": daysToWeekday });
      components.assign("weekday", weekday);
      return components;
    }
    exports.createParsingComponentsAtWeekday = createParsingComponentsAtWeekday;
    function getDaysToWeekday(refDate, weekday, modifier) {
      const refWeekday = refDate.getDay();
      switch (modifier) {
        case "this":
          return getDaysForwardToWeekday(refDate, weekday);
        case "last":
          return getBackwardDaysToWeekday(refDate, weekday);
        case "next":
          if (refWeekday == index_1.Weekday.SUNDAY) {
            return weekday == index_1.Weekday.SUNDAY ? 7 : weekday;
          }
          if (refWeekday == index_1.Weekday.SATURDAY) {
            if (weekday == index_1.Weekday.SATURDAY)
              return 7;
            if (weekday == index_1.Weekday.SUNDAY)
              return 8;
            return 1 + weekday;
          }
          if (weekday < refWeekday && weekday != index_1.Weekday.SUNDAY) {
            return getDaysForwardToWeekday(refDate, weekday);
          } else {
            return getDaysForwardToWeekday(refDate, weekday) + 7;
          }
      }
      return getDaysToWeekdayClosest(refDate, weekday);
    }
    exports.getDaysToWeekday = getDaysToWeekday;
    function getDaysToWeekdayClosest(refDate, weekday) {
      const backward = getBackwardDaysToWeekday(refDate, weekday);
      const forward = getDaysForwardToWeekday(refDate, weekday);
      return forward < -backward ? forward : backward;
    }
    exports.getDaysToWeekdayClosest = getDaysToWeekdayClosest;
    function getDaysForwardToWeekday(refDate, weekday) {
      const refWeekday = refDate.getDay();
      let forwardCount = weekday - refWeekday;
      if (forwardCount < 0) {
        forwardCount += 7;
      }
      return forwardCount;
    }
    exports.getDaysForwardToWeekday = getDaysForwardToWeekday;
    function getBackwardDaysToWeekday(refDate, weekday) {
      const refWeekday = refDate.getDay();
      let backwardCount = weekday - refWeekday;
      if (backwardCount >= 0) {
        backwardCount -= 7;
      }
      return backwardCount;
    }
    exports.getBackwardDaysToWeekday = getBackwardDaysToWeekday;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENWeekdayParser.js
var require_ENWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weekdays_1 = require_weekdays();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:on\\s*?)?(?:(this|last|past|next)\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(this|last|past|next)\\s*week)?(?=\\W|$)`, "i");
    var PREFIX_GROUP = 1;
    var WEEKDAY_GROUP = 2;
    var POSTFIX_GROUP = 3;
    var ENWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const weekday = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        const prefix = match[PREFIX_GROUP];
        const postfix = match[POSTFIX_GROUP];
        let modifierWord = prefix || postfix;
        modifierWord = modifierWord || "";
        modifierWord = modifierWord.toLowerCase();
        let modifier = null;
        if (modifierWord == "last" || modifierWord == "past") {
          modifier = "last";
        } else if (modifierWord == "next") {
          modifier = "next";
        } else if (modifierWord == "this") {
          modifier = "this";
        }
        return weekdays_1.createParsingComponentsAtWeekday(context2.reference, weekday, modifier);
      }
    };
    exports.default = ENWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENRelativeDateFormatParser.js
var require_ENRelativeDateFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENRelativeDateFormatParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var pattern_1 = require_pattern();
    var PATTERN = new RegExp(`(this|last|past|next|after\\s*this)\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})(?=\\s*)(?=\\W|$)`, "i");
    var MODIFIER_WORD_GROUP = 1;
    var RELATIVE_WORD_GROUP = 2;
    var ENRelativeDateFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();
        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();
        const timeunit = constants_1.TIME_UNIT_DICTIONARY[unitWord];
        if (modifier == "next" || modifier.startsWith("after")) {
          const timeUnits = {};
          timeUnits[timeunit] = 1;
          return results_1.ParsingComponents.createRelativeFromReference(context2.reference, timeUnits);
        }
        if (modifier == "last" || modifier == "past") {
          const timeUnits = {};
          timeUnits[timeunit] = -1;
          return results_1.ParsingComponents.createRelativeFromReference(context2.reference, timeUnits);
        }
        const components = context2.createParsingComponents();
        let date = dayjs_1.default(context2.reference.instant);
        if (unitWord.match(/week/i)) {
          date = date.add(-date.get("d"), "d");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.imply("year", date.year());
        } else if (unitWord.match(/month/i)) {
          date = date.add(-date.date() + 1, "d");
          components.imply("day", date.date());
          components.assign("year", date.year());
          components.assign("month", date.month() + 1);
        } else if (unitWord.match(/year/i)) {
          date = date.add(-date.date() + 1, "d");
          date = date.add(-date.month(), "month");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.assign("year", date.year());
        }
        return components;
      }
    };
    exports.default = ENRelativeDateFormatParser;
  }
});

// node_modules/chrono-node/dist/chrono.js
var require_chrono = __commonJS({
  "node_modules/chrono-node/dist/chrono.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParsingContext = exports.Chrono = void 0;
    var results_1 = require_results();
    var en_1 = require_en();
    var Chrono = class {
      constructor(configuration) {
        configuration = configuration || en_1.createCasualConfiguration();
        this.parsers = [...configuration.parsers];
        this.refiners = [...configuration.refiners];
      }
      clone() {
        return new Chrono({
          parsers: [...this.parsers],
          refiners: [...this.refiners]
        });
      }
      parseDate(text, referenceDate, option) {
        const results = this.parse(text, referenceDate, option);
        return results.length > 0 ? results[0].start.date() : null;
      }
      parse(text, referenceDate, option) {
        const context2 = new ParsingContext(text, referenceDate, option);
        let results = [];
        this.parsers.forEach((parser) => {
          const parsedResults = Chrono.executeParser(context2, parser);
          results = results.concat(parsedResults);
        });
        results.sort((a3, b2) => {
          return a3.index - b2.index;
        });
        this.refiners.forEach(function(refiner) {
          results = refiner.refine(context2, results);
        });
        return results;
      }
      static executeParser(context2, parser) {
        const results = [];
        const pattern = parser.pattern(context2);
        const originalText = context2.text;
        let remainingText = context2.text;
        let match = pattern.exec(remainingText);
        while (match) {
          const index = match.index + originalText.length - remainingText.length;
          match.index = index;
          const result = parser.extract(context2, match);
          if (!result) {
            remainingText = originalText.substring(match.index + 1);
            match = pattern.exec(remainingText);
            continue;
          }
          let parsedResult = null;
          if (result instanceof results_1.ParsingResult) {
            parsedResult = result;
          } else if (result instanceof results_1.ParsingComponents) {
            parsedResult = context2.createParsingResult(match.index, match[0]);
            parsedResult.start = result;
          } else {
            parsedResult = context2.createParsingResult(match.index, match[0], result);
          }
          context2.debug(() => console.log(`${parser.constructor.name} extracted result ${parsedResult}`));
          results.push(parsedResult);
          remainingText = originalText.substring(index + parsedResult.text.length);
          match = pattern.exec(remainingText);
        }
        return results;
      }
    };
    exports.Chrono = Chrono;
    var ParsingContext = class {
      constructor(text, refDate, option) {
        this.text = text;
        this.reference = new results_1.ReferenceWithTimezone(refDate);
        this.option = option !== null && option !== void 0 ? option : {};
        this.refDate = this.reference.instant;
      }
      createParsingComponents(components) {
        if (components instanceof results_1.ParsingComponents) {
          return components;
        }
        return new results_1.ParsingComponents(this.reference, components);
      }
      createParsingResult(index, textOrEndIndex, startComponents, endComponents) {
        const text = typeof textOrEndIndex === "string" ? textOrEndIndex : this.text.substring(index, textOrEndIndex);
        const start = startComponents ? this.createParsingComponents(startComponents) : null;
        const end = endComponents ? this.createParsingComponents(endComponents) : null;
        return new results_1.ParsingResult(this.reference, index, text, start, end);
      }
      debug(block) {
        if (this.option.debug) {
          if (this.option.debug instanceof Function) {
            this.option.debug(block);
          } else {
            const handler = this.option.debug;
            handler.debug(block);
          }
        }
      }
    };
    exports.ParsingContext = ParsingContext;
  }
});

// node_modules/chrono-node/dist/common/parsers/SlashDateFormatParser.js
var require_SlashDateFormatParser = __commonJS({
  "node_modules/chrono-node/dist/common/parsers/SlashDateFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var PATTERN = new RegExp("([^\\d]|^)([0-3]{0,1}[0-9]{1})[\\/\\.\\-]([0-3]{0,1}[0-9]{1})(?:[\\/\\.\\-]([0-9]{4}|[0-9]{2}))?(\\W|$)", "i");
    var OPENING_GROUP = 1;
    var ENDING_GROUP = 5;
    var FIRST_NUMBERS_GROUP = 2;
    var SECOND_NUMBERS_GROUP = 3;
    var YEAR_GROUP = 4;
    var SlashDateFormatParser = class {
      constructor(littleEndian) {
        this.groupNumberMonth = littleEndian ? SECOND_NUMBERS_GROUP : FIRST_NUMBERS_GROUP;
        this.groupNumberDay = littleEndian ? FIRST_NUMBERS_GROUP : SECOND_NUMBERS_GROUP;
      }
      pattern() {
        return PATTERN;
      }
      extract(context2, match) {
        if (match[OPENING_GROUP] == "/" || match[ENDING_GROUP] == "/") {
          match.index += match[0].length;
          return;
        }
        const index = match.index + match[OPENING_GROUP].length;
        const text = match[0].substr(match[OPENING_GROUP].length, match[0].length - match[OPENING_GROUP].length - match[ENDING_GROUP].length);
        if (text.match(/^\d\.\d$/) || text.match(/^\d\.\d{1,2}\.\d{1,2}\s*$/)) {
          return;
        }
        if (!match[YEAR_GROUP] && match[0].indexOf("/") < 0) {
          return;
        }
        const result = context2.createParsingResult(index, text);
        let month = parseInt(match[this.groupNumberMonth]);
        let day = parseInt(match[this.groupNumberDay]);
        if (month < 1 || month > 12) {
          if (month > 12) {
            if (day >= 1 && day <= 12 && month <= 31) {
              [day, month] = [month, day];
            } else {
              return null;
            }
          }
        }
        if (day < 1 || day > 31) {
          return null;
        }
        result.start.assign("day", day);
        result.start.assign("month", month);
        if (match[YEAR_GROUP]) {
          const rawYearNumber = parseInt(match[YEAR_GROUP]);
          const year = years_1.findMostLikelyADYear(rawYearNumber);
          result.start.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context2.refDate, day, month);
          result.start.imply("year", year);
        }
        return result;
      }
    };
    exports.default = SlashDateFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitCasualRelativeFormatParser.js
var require_ENTimeUnitCasualRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitCasualRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(this|last|past|next|after|\\+|-)\\s*(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
    var ENTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const prefix = match[1].toLowerCase();
        let timeUnits = constants_1.parseTimeUnits(match[2]);
        switch (prefix) {
          case "last":
          case "past":
          case "-":
            timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
            break;
        }
        return results_1.ParsingComponents.createRelativeFromReference(context2.reference, timeUnits);
      }
    };
    exports.default = ENTimeUnitCasualRelativeFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/en/refiners/ENMergeRelativeDateRefiner.js
var require_ENMergeRelativeDateRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/en/refiners/ENMergeRelativeDateRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var results_1 = require_results();
    var constants_1 = require_constants();
    var timeunits_1 = require_timeunits();
    function hasImpliedEarlierReferenceDate(result) {
      return result.text.match(/\s+(before|from)$/i) != null;
    }
    function hasImpliedLaterReferenceDate(result) {
      return result.text.match(/\s+(after|since)$/i) != null;
    }
    var ENMergeRelativeDateRefiner = class extends abstractRefiners_1.MergingRefiner {
      patternBetween() {
        return /^\s*$/i;
      }
      shouldMergeResults(textBetween, currentResult, nextResult) {
        if (!textBetween.match(this.patternBetween())) {
          return false;
        }
        if (!hasImpliedEarlierReferenceDate(currentResult) && !hasImpliedLaterReferenceDate(currentResult)) {
          return false;
        }
        return !!nextResult.start.get("day") && !!nextResult.start.get("month") && !!nextResult.start.get("year");
      }
      mergeResults(textBetween, currentResult, nextResult) {
        let timeUnits = constants_1.parseTimeUnits(currentResult.text);
        if (hasImpliedEarlierReferenceDate(currentResult)) {
          timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        }
        const components = results_1.ParsingComponents.createRelativeFromReference(new results_1.ReferenceWithTimezone(nextResult.start.date()), timeUnits);
        return new results_1.ParsingResult(nextResult.reference, currentResult.index, `${currentResult.text}${textBetween}${nextResult.text}`, components);
      }
    };
    exports.default = ENMergeRelativeDateRefiner;
  }
});

// node_modules/chrono-node/dist/locales/en/index.js
var require_en = __commonJS({
  "node_modules/chrono-node/dist/locales/en/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.GB = exports.strict = exports.casual = void 0;
    var ENTimeUnitWithinFormatParser_1 = __importDefault2(require_ENTimeUnitWithinFormatParser());
    var ENMonthNameLittleEndianParser_1 = __importDefault2(require_ENMonthNameLittleEndianParser());
    var ENMonthNameMiddleEndianParser_1 = __importDefault2(require_ENMonthNameMiddleEndianParser());
    var ENMonthNameParser_1 = __importDefault2(require_ENMonthNameParser());
    var ENCasualYearMonthDayParser_1 = __importDefault2(require_ENCasualYearMonthDayParser());
    var ENSlashMonthFormatParser_1 = __importDefault2(require_ENSlashMonthFormatParser());
    var ENTimeExpressionParser_1 = __importDefault2(require_ENTimeExpressionParser());
    var ENTimeUnitAgoFormatParser_1 = __importDefault2(require_ENTimeUnitAgoFormatParser());
    var ENTimeUnitLaterFormatParser_1 = __importDefault2(require_ENTimeUnitLaterFormatParser());
    var ENMergeDateRangeRefiner_1 = __importDefault2(require_ENMergeDateRangeRefiner());
    var ENMergeDateTimeRefiner_1 = __importDefault2(require_ENMergeDateTimeRefiner());
    var configurations_1 = require_configurations();
    var ENCasualDateParser_1 = __importDefault2(require_ENCasualDateParser());
    var ENCasualTimeParser_1 = __importDefault2(require_ENCasualTimeParser());
    var ENWeekdayParser_1 = __importDefault2(require_ENWeekdayParser());
    var ENRelativeDateFormatParser_1 = __importDefault2(require_ENRelativeDateFormatParser());
    var chrono_1 = require_chrono();
    var SlashDateFormatParser_1 = __importDefault2(require_SlashDateFormatParser());
    var ENTimeUnitCasualRelativeFormatParser_1 = __importDefault2(require_ENTimeUnitCasualRelativeFormatParser());
    var ENMergeRelativeDateRefiner_1 = __importDefault2(require_ENMergeRelativeDateRefiner());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration(false));
    exports.strict = new chrono_1.Chrono(createConfiguration(true, false));
    exports.GB = new chrono_1.Chrono(createConfiguration(false, true));
    function parse3(text, ref, option) {
      return exports.casual.parse(text, ref, option);
    }
    exports.parse = parse3;
    function parseDate(text, ref, option) {
      return exports.casual.parseDate(text, ref, option);
    }
    exports.parseDate = parseDate;
    function createCasualConfiguration(littleEndian = false) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.unshift(new ENCasualDateParser_1.default());
      option.parsers.unshift(new ENCasualTimeParser_1.default());
      option.parsers.unshift(new ENMonthNameParser_1.default());
      option.parsers.unshift(new ENRelativeDateFormatParser_1.default());
      option.parsers.unshift(new ENTimeUnitCasualRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = false) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(littleEndian),
          new ENTimeUnitWithinFormatParser_1.default(),
          new ENMonthNameLittleEndianParser_1.default(),
          new ENMonthNameMiddleEndianParser_1.default(),
          new ENWeekdayParser_1.default(),
          new ENCasualYearMonthDayParser_1.default(),
          new ENSlashMonthFormatParser_1.default(),
          new ENTimeExpressionParser_1.default(strictMode),
          new ENTimeUnitAgoFormatParser_1.default(strictMode),
          new ENTimeUnitLaterFormatParser_1.default(strictMode)
        ],
        refiners: [new ENMergeRelativeDateRefiner_1.default(), new ENMergeDateTimeRefiner_1.default(), new ENMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DETimeExpressionParser.js
var require_DETimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DETimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var DETimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      primaryPrefix() {
        return "(?:(?:um|von)\\s*)?";
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|bis)\\s*";
      }
      extractPrimaryTimeComponents(context2, match) {
        if (match[0].match(/^\s*\d{4}\s*$/)) {
          return null;
        }
        return super.extractPrimaryTimeComponents(context2, match);
      }
    };
    exports.default = DETimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/de/constants.js
var require_constants2 = __commonJS({
  "node_modules/chrono-node/dist/locales/de/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    var pattern_1 = require_pattern();
    var years_1 = require_years();
    exports.WEEKDAY_DICTIONARY = {
      "sonntag": 0,
      "so": 0,
      "montag": 1,
      "mo": 1,
      "dienstag": 2,
      "di": 2,
      "mittwoch": 3,
      "mi": 3,
      "donnerstag": 4,
      "do": 4,
      "freitag": 5,
      "fr": 5,
      "samstag": 6,
      "sa": 6
    };
    exports.MONTH_DICTIONARY = {
      "januar": 1,
      "j\xE4nner": 1,
      "janner": 1,
      "jan": 1,
      "jan.": 1,
      "februar": 2,
      "feber": 2,
      "feb": 2,
      "feb.": 2,
      "m\xE4rz": 3,
      "maerz": 3,
      "m\xE4r": 3,
      "m\xE4r.": 3,
      "mrz": 3,
      "mrz.": 3,
      "april": 4,
      "apr": 4,
      "apr.": 4,
      "mai": 5,
      "juni": 6,
      "jun": 6,
      "jun.": 6,
      "juli": 7,
      "jul": 7,
      "jul.": 7,
      "august": 8,
      "aug": 8,
      "aug.": 8,
      "september": 9,
      "sep": 9,
      "sep.": 9,
      "sept": 9,
      "sept.": 9,
      "oktober": 10,
      "okt": 10,
      "okt.": 10,
      "november": 11,
      "nov": 11,
      "nov.": 11,
      "dezember": 12,
      "dez": 12,
      "dez.": 12
    };
    exports.INTEGER_WORD_DICTIONARY = {
      "eins": 1,
      "eine": 1,
      "einem": 1,
      "einen": 1,
      "einer": 1,
      "zwei": 2,
      "drei": 3,
      "vier": 4,
      "f\xFCnf": 5,
      "fuenf": 5,
      "sechs": 6,
      "sieben": 7,
      "acht": 8,
      "neun": 9,
      "zehn": 10,
      "elf": 11,
      "zw\xF6lf": 12,
      "zwoelf": 12
    };
    exports.TIME_UNIT_DICTIONARY = {
      sek: "second",
      sekunde: "second",
      sekunden: "second",
      min: "minute",
      minute: "minute",
      minuten: "minute",
      h: "hour",
      std: "hour",
      stunde: "hour",
      stunden: "hour",
      tag: "d",
      tage: "d",
      tagen: "d",
      woche: "week",
      wochen: "week",
      monat: "month",
      monate: "month",
      monaten: "month",
      monats: "month",
      quartal: "quarter",
      quartals: "quarter",
      quartale: "quarter",
      quartalen: "quarter",
      a: "year",
      j: "year",
      jr: "year",
      jahr: "year",
      jahre: "year",
      jahren: "year",
      jahres: "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|half(?:\\s*an?)?|an?\\b(?:\\s*few)?|few|several|a?\\s*couple\\s*(?:of)?)`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      } else if (num === "a" || num === "an") {
        return 1;
      } else if (num.match(/few/)) {
        return 3;
      } else if (num.match(/half/)) {
        return 0.5;
      } else if (num.match(/couple/)) {
        return 2;
      } else if (num.match(/several/)) {
        return 7;
      }
      return parseFloat(num);
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.YEAR_PATTERN = `(?:[0-9]{1,4}(?:\\s*[vn]\\.?\\s*(?:C(?:hr)?|(?:u\\.?|d\\.?(?:\\s*g\\.?)?)?\\s*Z)\\.?|\\s*(?:u\\.?|d\\.?(?:\\s*g\\.)?)\\s*Z\\.?)?)`;
    function parseYear(match) {
      if (/v/i.test(match)) {
        return -parseInt(match.replace(/[^0-9]+/gi, ""));
      }
      if (/n/i.test(match)) {
        return parseInt(match.replace(/[^0-9]+/gi, ""));
      }
      if (/z/i.test(match)) {
        return parseInt(match.replace(/[^0-9]+/gi, ""));
      }
      const rawYearNumber = parseInt(match);
      return years_1.findMostLikelyADYear(rawYearNumber);
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,5}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})\\s{0,5}`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern("", SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length);
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DEWeekdayParser.js
var require_DEWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DEWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants2();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weekdays_1 = require_weekdays();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:a[mn]\\s*?)?(?:(diese[mn]|letzte[mn]|n(?:\xE4|ae)chste[mn])\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(diese|letzte|n(?:\xE4|ae)chste)\\s*woche)?(?=\\W|$)`, "i");
    var PREFIX_GROUP = 1;
    var SUFFIX_GROUP = 3;
    var WEEKDAY_GROUP = 2;
    var DEWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        const prefix = match[PREFIX_GROUP];
        const postfix = match[SUFFIX_GROUP];
        let modifierWord = prefix || postfix;
        modifierWord = modifierWord || "";
        modifierWord = modifierWord.toLowerCase();
        let modifier = null;
        if (modifierWord.match(/letzte/)) {
          modifier = "last";
        } else if (modifierWord.match(/chste/)) {
          modifier = "next";
        } else if (modifierWord.match(/diese/)) {
          modifier = "this";
        }
        return weekdays_1.createParsingComponentsAtWeekday(context2.reference, offset, modifier);
      }
    };
    exports.default = DEWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DESpecificTimeExpressionParser.js
var require_DESpecificTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DESpecificTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var FIRST_REG_PATTERN = new RegExp("(^|\\s|T)(?:(?:um|von)\\s*)?(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s)?)?(?:\\s*Uhr)?(?:\\s*(morgens|vormittags|nachmittags|abends|nachts|am\\s+(?:Morgen|Vormittag|Nachmittag|Abend)|in\\s+der\\s+Nacht))?(?=\\W|$)", "i");
    var SECOND_REG_PATTERN = new RegExp("^\\s*(\\-|\\\u2013|\\~|\\\u301C|bis(?:\\s+um)?|\\?)\\s*(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s)?)?(?:\\s*Uhr)?(?:\\s*(morgens|vormittags|nachmittags|abends|nachts|am\\s+(?:Morgen|Vormittag|Nachmittag|Abend)|in\\s+der\\s+Nacht))?(?=\\W|$)", "i");
    var HOUR_GROUP = 2;
    var MINUTE_GROUP = 3;
    var SECOND_GROUP = 4;
    var AM_PM_HOUR_GROUP = 5;
    var DESpecificTimeExpressionParser = class {
      pattern(context2) {
        return FIRST_REG_PATTERN;
      }
      extract(context2, match) {
        const result = context2.createParsingResult(match.index + match[1].length, match[0].substring(match[1].length));
        if (result.text.match(/^\d{4}$/)) {
          match.index += match[0].length;
          return null;
        }
        result.start = DESpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match);
        if (!result.start) {
          match.index += match[0].length;
          return null;
        }
        const remainingText = context2.text.substring(match.index + match[0].length);
        const secondMatch = SECOND_REG_PATTERN.exec(remainingText);
        if (secondMatch) {
          result.end = DESpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), secondMatch);
          if (result.end) {
            result.text += secondMatch[0];
          }
        }
        return result;
      }
      static extractTimeComponent(extractingComponents, match) {
        let hour = 0;
        let minute = 0;
        let meridiem = null;
        hour = parseInt(match[HOUR_GROUP]);
        if (match[MINUTE_GROUP] != null) {
          minute = parseInt(match[MINUTE_GROUP]);
        }
        if (minute >= 60 || hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = index_1.Meridiem.PM;
        }
        if (match[AM_PM_HOUR_GROUP] != null) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP].toLowerCase();
          if (ampm.match(/morgen|vormittag/)) {
            meridiem = index_1.Meridiem.AM;
            if (hour == 12) {
              hour = 0;
            }
          }
          if (ampm.match(/nachmittag|abend/)) {
            meridiem = index_1.Meridiem.PM;
            if (hour != 12) {
              hour += 12;
            }
          }
          if (ampm.match(/nacht/)) {
            if (hour == 12) {
              meridiem = index_1.Meridiem.AM;
              hour = 0;
            } else if (hour < 6) {
              meridiem = index_1.Meridiem.AM;
            } else {
              meridiem = index_1.Meridiem.PM;
              hour += 12;
            }
          }
        }
        extractingComponents.assign("hour", hour);
        extractingComponents.assign("minute", minute);
        if (meridiem !== null) {
          extractingComponents.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            extractingComponents.imply("meridiem", index_1.Meridiem.AM);
          } else {
            extractingComponents.imply("meridiem", index_1.Meridiem.PM);
          }
        }
        if (match[SECOND_GROUP] != null) {
          const second = parseInt(match[SECOND_GROUP]);
          if (second >= 60)
            return null;
          extractingComponents.assign("second", second);
        }
        return extractingComponents;
      }
    };
    exports.default = DESpecificTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/de/refiners/DEMergeDateRangeRefiner.js
var require_DEMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/de/refiners/DEMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var DEMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(bis(?:\s*(?:am|zum))?|-)\s*$/i;
      }
    };
    exports.default = DEMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/de/refiners/DEMergeDateTimeRefiner.js
var require_DEMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/de/refiners/DEMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault2(require_AbstractMergeDateTimeRefiner());
    var DEMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(T|um|am|,|-)?\\s*$");
      }
    };
    exports.default = DEMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DECasualTimeParser.js
var require_DECasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DECasualTimeParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_2 = require_dayjs();
    var timeunits_1 = require_timeunits();
    var DECasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context2) {
        return /(diesen)?\s*(morgen|vormittag|mittags?|nachmittag|abend|nacht|mitternacht)(?=\W|$)/i;
      }
      innerExtract(context2, match) {
        const targetDate = dayjs_1.default(context2.refDate);
        const timeKeywordPattern = match[2].toLowerCase();
        const component = context2.createParsingComponents();
        dayjs_2.implySimilarTime(component, targetDate);
        return DECasualTimeParser.extractTimeComponents(component, timeKeywordPattern);
      }
      static extractTimeComponents(component, timeKeywordPattern) {
        switch (timeKeywordPattern) {
          case "morgen":
            component.imply("hour", 6);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "vormittag":
            component.imply("hour", 9);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "mittag":
          case "mittags":
            component.imply("hour", 12);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "nachmittag":
            component.imply("hour", 15);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "abend":
            component.imply("hour", 18);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "nacht":
            component.imply("hour", 22);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "mitternacht":
            if (component.get("hour") > 1) {
              component = timeunits_1.addImpliedTimeUnits(component, { "day": 1 });
            }
            component.imply("hour", 0);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
        }
        return component;
      }
    };
    exports.default = DECasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DECasualDateParser.js
var require_DECasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DECasualDateParser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o6, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o6, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o6, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o6[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o6, v2) {
      Object.defineProperty(o6, "default", { enumerable: true, value: v2 });
    } : function(o6, v2) {
      o6["default"] = v2;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding2(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_2 = require_dayjs();
    var DECasualTimeParser_1 = __importDefault2(require_DECasualTimeParser());
    var references = __importStar2(require_casualReferences());
    var PATTERN = new RegExp(`(jetzt|heute|morgen|\xFCbermorgen|uebermorgen|gestern|vorgestern|letzte\\s*nacht)(?:\\s*(morgen|vormittag|mittags?|nachmittag|abend|nacht|mitternacht))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var TIME_GROUP = 2;
    var DECasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context2) {
        return PATTERN;
      }
      innerExtract(context2, match) {
        let targetDate = dayjs_1.default(context2.refDate);
        const dateKeyword = (match[DATE_GROUP] || "").toLowerCase();
        const timeKeyword = (match[TIME_GROUP] || "").toLowerCase();
        let component = context2.createParsingComponents();
        switch (dateKeyword) {
          case "jetzt":
            component = references.now(context2.reference);
            break;
          case "heute":
            component = references.today(context2.reference);
            break;
          case "morgen":
            dayjs_2.assignTheNextDay(component, targetDate);
            break;
          case "\xFCbermorgen":
          case "uebermorgen":
            targetDate = targetDate.add(1, "day");
            dayjs_2.assignTheNextDay(component, targetDate);
            break;
          case "gestern":
            targetDate = targetDate.add(-1, "day");
            dayjs_2.assignSimilarDate(component, targetDate);
            dayjs_2.implySimilarTime(component, targetDate);
            break;
          case "vorgestern":
            targetDate = targetDate.add(-2, "day");
            dayjs_2.assignSimilarDate(component, targetDate);
            dayjs_2.implySimilarTime(component, targetDate);
            break;
          default:
            if (dateKeyword.match(/letzte\s*nacht/)) {
              if (targetDate.hour() > 6) {
                targetDate = targetDate.add(-1, "day");
              }
              dayjs_2.assignSimilarDate(component, targetDate);
              component.imply("hour", 0);
            }
            break;
        }
        if (timeKeyword) {
          component = DECasualTimeParser_1.default.extractTimeComponents(component, timeKeyword);
        }
        return component;
      }
    };
    exports.default = DECasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DEMonthNameLittleEndianParser.js
var require_DEMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DEMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants2();
    var constants_2 = require_constants2();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:am\\s*?)?(?:den\\s*?)?([0-9]{1,2})\\.(?:\\s*(?:bis(?:\\s*(?:am|zum))?|\\-|\\\u2013|\\s)\\s*([0-9]{1,2})\\.?)?\\s*(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:(?:-|/|,?\\s*)(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var DEMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const result = context2.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = parseInt(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context2.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = parseInt(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = DEMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DETimeUnitRelativeFormatParser.js
var require_DETimeUnitRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DETimeUnitRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants2();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var pattern_1 = require_pattern();
    var DETimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor() {
        super();
      }
      innerPattern() {
        return new RegExp(`(?:\\s*((?:n\xE4chste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?|vor|in)\\s*)?(${constants_1.NUMBER_PATTERN})?(?:\\s*(n\xE4chste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?)?\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})`, "i");
      }
      innerExtract(context2, match) {
        const num = match[2] ? constants_1.parseNumberPattern(match[2]) : 1;
        const unit = constants_1.TIME_UNIT_DICTIONARY[match[4].toLowerCase()];
        let timeUnits = {};
        timeUnits[unit] = num;
        let modifier = match[1] || match[3] || "";
        modifier = modifier.toLowerCase();
        if (!modifier) {
          return;
        }
        if (/vor/.test(modifier) || /letzte/.test(modifier) || /vergangen/.test(modifier)) {
          timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        }
        return results_1.ParsingComponents.createRelativeFromReference(context2.reference, timeUnits);
      }
    };
    exports.default = DETimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/de/index.js
var require_de = __commonJS({
  "node_modules/chrono-node/dist/locales/de/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var configurations_1 = require_configurations();
    var chrono_1 = require_chrono();
    var SlashDateFormatParser_1 = __importDefault2(require_SlashDateFormatParser());
    var ISOFormatParser_1 = __importDefault2(require_ISOFormatParser());
    var DETimeExpressionParser_1 = __importDefault2(require_DETimeExpressionParser());
    var DEWeekdayParser_1 = __importDefault2(require_DEWeekdayParser());
    var DESpecificTimeExpressionParser_1 = __importDefault2(require_DESpecificTimeExpressionParser());
    var DEMergeDateRangeRefiner_1 = __importDefault2(require_DEMergeDateRangeRefiner());
    var DEMergeDateTimeRefiner_1 = __importDefault2(require_DEMergeDateTimeRefiner());
    var DECasualDateParser_1 = __importDefault2(require_DECasualDateParser());
    var DECasualTimeParser_1 = __importDefault2(require_DECasualTimeParser());
    var DEMonthNameLittleEndianParser_1 = __importDefault2(require_DEMonthNameLittleEndianParser());
    var DETimeUnitRelativeFormatParser_1 = __importDefault2(require_DETimeUnitRelativeFormatParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse3(text, ref, option) {
      return exports.casual.parse(text, ref, option);
    }
    exports.parse = parse3;
    function parseDate(text, ref, option) {
      return exports.casual.parseDate(text, ref, option);
    }
    exports.parseDate = parseDate;
    function createCasualConfiguration(littleEndian = true) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.unshift(new DECasualTimeParser_1.default());
      option.parsers.unshift(new DECasualDateParser_1.default());
      option.parsers.unshift(new DETimeUnitRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new ISOFormatParser_1.default(),
          new SlashDateFormatParser_1.default(littleEndian),
          new DETimeExpressionParser_1.default(),
          new DESpecificTimeExpressionParser_1.default(),
          new DEMonthNameLittleEndianParser_1.default(),
          new DEWeekdayParser_1.default()
        ],
        refiners: [new DEMergeDateRangeRefiner_1.default(), new DEMergeDateTimeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRCasualDateParser.js
var require_FRCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o6, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o6, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o6, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o6[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o6, v2) {
      Object.defineProperty(o6, "default", { enumerable: true, value: v2 });
    } : function(o6, v2) {
      o6["default"] = v2;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding2(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_2 = require_dayjs();
    var references = __importStar2(require_casualReferences());
    var FRCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context2) {
        return /(maintenant|aujourd'hui|demain|hier|cette\s*nuit|la\s*veille)(?=\W|$)/i;
      }
      innerExtract(context2, match) {
        let targetDate = dayjs_1.default(context2.refDate);
        const lowerText = match[0].toLowerCase();
        const component = context2.createParsingComponents();
        switch (lowerText) {
          case "maintenant":
            return references.now(context2.reference);
          case "aujourd'hui":
            return references.today(context2.reference);
          case "hier":
            return references.yesterday(context2.reference);
          case "demain":
            return references.tomorrow(context2.reference);
          default:
            if (lowerText.match(/cette\s*nuit/)) {
              dayjs_2.assignSimilarDate(component, targetDate);
              component.imply("hour", 22);
              component.imply("meridiem", index_1.Meridiem.PM);
            } else if (lowerText.match(/la\s*veille/)) {
              targetDate = targetDate.add(-1, "day");
              dayjs_2.assignSimilarDate(component, targetDate);
              component.imply("hour", 0);
            }
        }
        return component;
      }
    };
    exports.default = FRCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRCasualTimeParser.js
var require_FRCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRCasualTimeParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var FRCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context2) {
        return /(cet?)?\s*(matin|soir|après-midi|aprem|a midi|à minuit)(?=\W|$)/i;
      }
      innerExtract(context2, match) {
        const suffixLower = match[2].toLowerCase();
        const component = context2.createParsingComponents();
        switch (suffixLower) {
          case "apr\xE8s-midi":
          case "aprem":
            component.imply("hour", 14);
            component.imply("minute", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "soir":
            component.imply("hour", 18);
            component.imply("minute", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "matin":
            component.imply("hour", 8);
            component.imply("minute", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "a midi":
            component.imply("hour", 12);
            component.imply("minute", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "\xE0 minuit":
            component.imply("hour", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
        }
        return component;
      }
    };
    exports.default = FRCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRTimeExpressionParser.js
var require_FRTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var FRTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      primaryPrefix() {
        return "(?:(?:[\xE0a])\\s*)?";
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|[\xE0a]|\\?)\\s*";
      }
      extractPrimaryTimeComponents(context2, match) {
        if (match[0].match(/^\s*\d{4}\s*$/)) {
          return null;
        }
        return super.extractPrimaryTimeComponents(context2, match);
      }
    };
    exports.default = FRTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/refiners/FRMergeDateTimeRefiner.js
var require_FRMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/refiners/FRMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault2(require_AbstractMergeDateTimeRefiner());
    var FRMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(T|\xE0|a|vers|de|,|-)?\\s*$");
      }
    };
    exports.default = FRMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/fr/refiners/FRMergeDateRangeRefiner.js
var require_FRMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/refiners/FRMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var FRMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(à|a|-)\s*$/i;
      }
    };
    exports.default = FRMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/fr/constants.js
var require_constants3 = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseOrdinalNumberPattern = exports.ORDINAL_NUMBER_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    var pattern_1 = require_pattern();
    exports.WEEKDAY_DICTIONARY = {
      "dimanche": 0,
      "dim": 0,
      "lundi": 1,
      "lun": 1,
      "mardi": 2,
      "mar": 2,
      "mercredi": 3,
      "mer": 3,
      "jeudi": 4,
      "jeu": 4,
      "vendredi": 5,
      "ven": 5,
      "samedi": 6,
      "sam": 6
    };
    exports.MONTH_DICTIONARY = {
      "janvier": 1,
      "jan": 1,
      "jan.": 1,
      "f\xE9vrier": 2,
      "f\xE9v": 2,
      "f\xE9v.": 2,
      "fevrier": 2,
      "fev": 2,
      "fev.": 2,
      "mars": 3,
      "mar": 3,
      "mar.": 3,
      "avril": 4,
      "avr": 4,
      "avr.": 4,
      "mai": 5,
      "juin": 6,
      "jun": 6,
      "juillet": 7,
      "juil": 7,
      "jul": 7,
      "jul.": 7,
      "ao\xFBt": 8,
      "aout": 8,
      "septembre": 9,
      "sep": 9,
      "sep.": 9,
      "sept": 9,
      "sept.": 9,
      "octobre": 10,
      "oct": 10,
      "oct.": 10,
      "novembre": 11,
      "nov": 11,
      "nov.": 11,
      "d\xE9cembre": 12,
      "decembre": 12,
      "dec": 12,
      "dec.": 12
    };
    exports.INTEGER_WORD_DICTIONARY = {
      "un": 1,
      "deux": 2,
      "trois": 3,
      "quatre": 4,
      "cinq": 5,
      "six": 6,
      "sept": 7,
      "huit": 8,
      "neuf": 9,
      "dix": 10,
      "onze": 11,
      "douze": 12,
      "treize": 13
    };
    exports.TIME_UNIT_DICTIONARY = {
      "sec": "second",
      "seconde": "second",
      "secondes": "second",
      "min": "minute",
      "mins": "minute",
      "minute": "minute",
      "minutes": "minute",
      "h": "hour",
      "hr": "hour",
      "hrs": "hour",
      "heure": "hour",
      "heures": "hour",
      "jour": "d",
      "jours": "d",
      "semaine": "week",
      "semaines": "week",
      "mois": "month",
      "trimestre": "quarter",
      "trimestres": "quarter",
      "ans": "year",
      "ann\xE9e": "year",
      "ann\xE9es": "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|une?\\b|quelques?|demi-?)`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      } else if (num === "une" || num === "un") {
        return 1;
      } else if (num.match(/quelques?/)) {
        return 3;
      } else if (num.match(/demi-?/)) {
        return 0.5;
      }
      return parseFloat(num);
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.ORDINAL_NUMBER_PATTERN = `(?:[0-9]{1,2}(?:er)?)`;
    function parseOrdinalNumberPattern(match) {
      let num = match.toLowerCase();
      num = num.replace(/(?:er)$/i, "");
      return parseInt(num);
    }
    exports.parseOrdinalNumberPattern = parseOrdinalNumberPattern;
    exports.YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\s*(?:AC|AD|p\\.\\s*C(?:hr?)?\\.\\s*n\\.)|[1-2][0-9]{3}|[5-9][0-9])`;
    function parseYear(match) {
      if (/AC/i.test(match)) {
        match = match.replace(/BC/i, "");
        return -parseInt(match);
      }
      if (/AD/i.test(match) || /C/i.test(match)) {
        match = match.replace(/[^\d]+/i, "");
        return parseInt(match);
      }
      let yearNumber = parseInt(match);
      if (yearNumber < 100) {
        if (yearNumber > 50) {
          yearNumber = yearNumber + 1900;
        } else {
          yearNumber = yearNumber + 2e3;
        }
      }
      return yearNumber;
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,5}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})\\s{0,5}`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern("", SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length);
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRWeekdayParser.js
var require_FRWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants3();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weekdays_1 = require_weekdays();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:(?:ce)\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(dernier|prochain)\\s*)?(?=\\W|\\d|$)`, "i");
    var WEEKDAY_GROUP = 1;
    var POSTFIX_GROUP = 2;
    var FRWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const weekday = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        if (weekday === void 0) {
          return null;
        }
        let suffix = match[POSTFIX_GROUP];
        suffix = suffix || "";
        suffix = suffix.toLowerCase();
        let modifier = null;
        if (suffix == "dernier") {
          modifier = "last";
        } else if (suffix == "prochain") {
          modifier = "next";
        }
        return weekdays_1.createParsingComponentsAtWeekday(context2.reference, weekday, modifier);
      }
    };
    exports.default = FRWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRSpecificTimeExpressionParser.js
var require_FRSpecificTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRSpecificTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var FIRST_REG_PATTERN = new RegExp("(^|\\s|T)(?:(?:[\xE0a])\\s*)?(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s|:)?)?(?:\\s*(A\\.M\\.|P\\.M\\.|AM?|PM?))?(?=\\W|$)", "i");
    var SECOND_REG_PATTERN = new RegExp("^\\s*(\\-|\\\u2013|\\~|\\\u301C|[\xE0a]|\\?)\\s*(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s|:)?)?(?:\\s*(A\\.M\\.|P\\.M\\.|AM?|PM?))?(?=\\W|$)", "i");
    var HOUR_GROUP = 2;
    var MINUTE_GROUP = 3;
    var SECOND_GROUP = 4;
    var AM_PM_HOUR_GROUP = 5;
    var FRSpecificTimeExpressionParser = class {
      pattern(context2) {
        return FIRST_REG_PATTERN;
      }
      extract(context2, match) {
        const result = context2.createParsingResult(match.index + match[1].length, match[0].substring(match[1].length));
        if (result.text.match(/^\d{4}$/)) {
          match.index += match[0].length;
          return null;
        }
        result.start = FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match);
        if (!result.start) {
          match.index += match[0].length;
          return null;
        }
        const remainingText = context2.text.substring(match.index + match[0].length);
        const secondMatch = SECOND_REG_PATTERN.exec(remainingText);
        if (secondMatch) {
          result.end = FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), secondMatch);
          if (result.end) {
            result.text += secondMatch[0];
          }
        }
        return result;
      }
      static extractTimeComponent(extractingComponents, match) {
        let hour = 0;
        let minute = 0;
        let meridiem = null;
        hour = parseInt(match[HOUR_GROUP]);
        if (match[MINUTE_GROUP] != null) {
          minute = parseInt(match[MINUTE_GROUP]);
        }
        if (minute >= 60 || hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = index_1.Meridiem.PM;
        }
        if (match[AM_PM_HOUR_GROUP] != null) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = index_1.Meridiem.AM;
            if (hour == 12) {
              hour = 0;
            }
          }
          if (ampm == "p") {
            meridiem = index_1.Meridiem.PM;
            if (hour != 12) {
              hour += 12;
            }
          }
        }
        extractingComponents.assign("hour", hour);
        extractingComponents.assign("minute", minute);
        if (meridiem !== null) {
          extractingComponents.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            extractingComponents.imply("meridiem", index_1.Meridiem.AM);
          } else {
            extractingComponents.imply("meridiem", index_1.Meridiem.PM);
          }
        }
        if (match[SECOND_GROUP] != null) {
          const second = parseInt(match[SECOND_GROUP]);
          if (second >= 60)
            return null;
          extractingComponents.assign("second", second);
        }
        return extractingComponents;
      }
    };
    exports.default = FRSpecificTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRMonthNameLittleEndianParser.js
var require_FRMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants3();
    var constants_2 = require_constants3();
    var constants_3 = require_constants3();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:on\\s*?)?(${constants_3.ORDINAL_NUMBER_PATTERN})(?:\\s*(?:au|\\-|\\\u2013|jusqu'au?|\\s)\\s*(${constants_3.ORDINAL_NUMBER_PATTERN}))?(?:-|/|\\s*(?:de)?\\s*)(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:(?:-|/|,?\\s*)(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var FRMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const result = context2.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_3.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context2.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = constants_3.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = FRMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitAgoFormatParser.js
var require_FRTimeUnitAgoFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitAgoFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants3();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var FRTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor() {
        super();
      }
      innerPattern() {
        return new RegExp(`il y a\\s*(${constants_1.TIME_UNITS_PATTERN})(?=(?:\\W|$))`, "i");
      }
      innerExtract(context2, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        const outputTimeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        return results_1.ParsingComponents.createRelativeFromReference(context2.reference, outputTimeUnits);
      }
    };
    exports.default = FRTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitWithinFormatParser.js
var require_FRTimeUnitWithinFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitWithinFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants3();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var FRTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return new RegExp(`(?:dans|en|pour|pendant|de)\\s*(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
      }
      innerExtract(context2, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        return results_1.ParsingComponents.createRelativeFromReference(context2.reference, timeUnits);
      }
    };
    exports.default = FRTimeUnitWithinFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitRelativeFormatParser.js
var require_FRTimeUnitRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants3();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var pattern_1 = require_pattern();
    var FRTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor() {
        super();
      }
      innerPattern() {
        return new RegExp(`(?:les?|la|l'|du|des?)\\s*(${constants_1.NUMBER_PATTERN})?(?:\\s*(prochaine?s?|derni[e\xE8]re?s?|pass[\xE9e]e?s?|pr[\xE9e]c[\xE9e]dents?|suivante?s?))?\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})(?:\\s*(prochaine?s?|derni[e\xE8]re?s?|pass[\xE9e]e?s?|pr[\xE9e]c[\xE9e]dents?|suivante?s?))?`, "i");
      }
      innerExtract(context2, match) {
        const num = match[1] ? constants_1.parseNumberPattern(match[1]) : 1;
        const unit = constants_1.TIME_UNIT_DICTIONARY[match[3].toLowerCase()];
        let timeUnits = {};
        timeUnits[unit] = num;
        let modifier = match[2] || match[4] || "";
        modifier = modifier.toLowerCase();
        if (!modifier) {
          return;
        }
        if (/derni[eè]re?s?/.test(modifier) || /pass[ée]e?s?/.test(modifier) || /pr[ée]c[ée]dents?/.test(modifier)) {
          timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        }
        return results_1.ParsingComponents.createRelativeFromReference(context2.reference, timeUnits);
      }
    };
    exports.default = FRTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/index.js
var require_fr = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var configurations_1 = require_configurations();
    var chrono_1 = require_chrono();
    var FRCasualDateParser_1 = __importDefault2(require_FRCasualDateParser());
    var FRCasualTimeParser_1 = __importDefault2(require_FRCasualTimeParser());
    var SlashDateFormatParser_1 = __importDefault2(require_SlashDateFormatParser());
    var FRTimeExpressionParser_1 = __importDefault2(require_FRTimeExpressionParser());
    var FRMergeDateTimeRefiner_1 = __importDefault2(require_FRMergeDateTimeRefiner());
    var FRMergeDateRangeRefiner_1 = __importDefault2(require_FRMergeDateRangeRefiner());
    var FRWeekdayParser_1 = __importDefault2(require_FRWeekdayParser());
    var FRSpecificTimeExpressionParser_1 = __importDefault2(require_FRSpecificTimeExpressionParser());
    var FRMonthNameLittleEndianParser_1 = __importDefault2(require_FRMonthNameLittleEndianParser());
    var FRTimeUnitAgoFormatParser_1 = __importDefault2(require_FRTimeUnitAgoFormatParser());
    var FRTimeUnitWithinFormatParser_1 = __importDefault2(require_FRTimeUnitWithinFormatParser());
    var FRTimeUnitRelativeFormatParser_1 = __importDefault2(require_FRTimeUnitRelativeFormatParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse3(text, ref, option) {
      return exports.casual.parse(text, ref, option);
    }
    exports.parse = parse3;
    function parseDate(text, ref, option) {
      return exports.casual.parseDate(text, ref, option);
    }
    exports.parseDate = parseDate;
    function createCasualConfiguration(littleEndian = true) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.unshift(new FRCasualDateParser_1.default());
      option.parsers.unshift(new FRCasualTimeParser_1.default());
      option.parsers.unshift(new FRTimeUnitRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(littleEndian),
          new FRMonthNameLittleEndianParser_1.default(),
          new FRTimeExpressionParser_1.default(),
          new FRSpecificTimeExpressionParser_1.default(),
          new FRTimeUnitAgoFormatParser_1.default(),
          new FRTimeUnitWithinFormatParser_1.default(),
          new FRWeekdayParser_1.default()
        ],
        refiners: [new FRMergeDateTimeRefiner_1.default(), new FRMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/ja/constants.js
var require_constants4 = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toHankaku = void 0;
    function toHankaku(text) {
      return String(text).replace(/\u2019/g, "'").replace(/\u201D/g, '"').replace(/\u3000/g, " ").replace(/\uFFE5/g, "\xA5").replace(/[\uFF01\uFF03-\uFF06\uFF08\uFF09\uFF0C-\uFF19\uFF1C-\uFF1F\uFF21-\uFF3B\uFF3D\uFF3F\uFF41-\uFF5B\uFF5D\uFF5E]/g, alphaNum);
    }
    exports.toHankaku = toHankaku;
    function alphaNum(token) {
      return String.fromCharCode(token.charCodeAt(0) - 65248);
    }
  }
});

// node_modules/chrono-node/dist/locales/ja/parsers/JPStandardParser.js
var require_JPStandardParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/parsers/JPStandardParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants4();
    var years_1 = require_years();
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var PATTERN = /(?:(?:([同今本])|((昭和|平成|令和)?([0-9０-９]{1,4}|元)))年\s*)?([0-9０-９]{1,2})月\s*([0-9０-９]{1,2})日/i;
    var SPECIAL_YEAR_GROUP = 1;
    var TYPICAL_YEAR_GROUP = 2;
    var ERA_GROUP = 3;
    var YEAR_NUMBER_GROUP = 4;
    var MONTH_GROUP = 5;
    var DAY_GROUP = 6;
    var JPStandardParser = class {
      pattern() {
        return PATTERN;
      }
      extract(context2, match) {
        const month = parseInt(constants_1.toHankaku(match[MONTH_GROUP]));
        const day = parseInt(constants_1.toHankaku(match[DAY_GROUP]));
        const components = context2.createParsingComponents({
          day,
          month
        });
        if (match[SPECIAL_YEAR_GROUP] && match[SPECIAL_YEAR_GROUP].match("\u540C|\u4ECA|\u672C")) {
          const moment3 = dayjs_1.default(context2.refDate);
          components.assign("year", moment3.year());
        }
        if (match[TYPICAL_YEAR_GROUP]) {
          const yearNumText = match[YEAR_NUMBER_GROUP];
          let year = yearNumText == "\u5143" ? 1 : parseInt(constants_1.toHankaku(yearNumText));
          if (match[ERA_GROUP] == "\u4EE4\u548C") {
            year += 2018;
          } else if (match[ERA_GROUP] == "\u5E73\u6210") {
            year += 1988;
          } else if (match[ERA_GROUP] == "\u662D\u548C") {
            year += 1925;
          }
          components.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context2.refDate, day, month);
          components.imply("year", year);
        }
        return components;
      }
    };
    exports.default = JPStandardParser;
  }
});

// node_modules/chrono-node/dist/locales/ja/refiners/JPMergeDateRangeRefiner.js
var require_JPMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/refiners/JPMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var JPMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(から|ー|-)\s*$/i;
      }
    };
    exports.default = JPMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/ja/parsers/JPCasualDateParser.js
var require_JPCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/parsers/JPCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o6, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o6, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o6, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o6[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o6, v2) {
      Object.defineProperty(o6, "default", { enumerable: true, value: v2 });
    } : function(o6, v2) {
      o6["default"] = v2;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding2(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var index_1 = require_dist();
    var references = __importStar2(require_casualReferences());
    var PATTERN = /今日|当日|昨日|明日|今夜|今夕|今晩|今朝/i;
    var JPCasualDateParser = class {
      pattern() {
        return PATTERN;
      }
      extract(context2, match) {
        const text = match[0];
        const date = dayjs_1.default(context2.refDate);
        const components = context2.createParsingComponents();
        switch (text) {
          case "\u6628\u65E5":
            return references.yesterday(context2.reference);
          case "\u660E\u65E5":
            return references.tomorrow(context2.reference);
          case "\u4ECA\u65E5":
          case "\u5F53\u65E5":
            return references.today(context2.reference);
        }
        if (text == "\u4ECA\u591C" || text == "\u4ECA\u5915" || text == "\u4ECA\u6669") {
          components.imply("hour", 22);
          components.assign("meridiem", index_1.Meridiem.PM);
        } else if (text.match("\u4ECA\u671D")) {
          components.imply("hour", 6);
          components.assign("meridiem", index_1.Meridiem.AM);
        }
        components.assign("day", date.date());
        components.assign("month", date.month() + 1);
        components.assign("year", date.year());
        return components;
      }
    };
    exports.default = JPCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/ja/index.js
var require_ja = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var JPStandardParser_1 = __importDefault2(require_JPStandardParser());
    var JPMergeDateRangeRefiner_1 = __importDefault2(require_JPMergeDateRangeRefiner());
    var JPCasualDateParser_1 = __importDefault2(require_JPCasualDateParser());
    var chrono_1 = require_chrono();
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration());
    function parse3(text, ref, option) {
      return exports.casual.parse(text, ref, option);
    }
    exports.parse = parse3;
    function parseDate(text, ref, option) {
      return exports.casual.parseDate(text, ref, option);
    }
    exports.parseDate = parseDate;
    function createCasualConfiguration() {
      const option = createConfiguration();
      option.parsers.unshift(new JPCasualDateParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration() {
      return {
        parsers: [new JPStandardParser_1.default()],
        refiners: [new JPMergeDateRangeRefiner_1.default()]
      };
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/pt/constants.js
var require_constants5 = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseYear = exports.YEAR_PATTERN = exports.MONTH_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    exports.WEEKDAY_DICTIONARY = {
      "domingo": 0,
      "dom": 0,
      "segunda": 1,
      "segunda-feira": 1,
      "seg": 1,
      "ter\xE7a": 2,
      "ter\xE7a-feira": 2,
      "ter": 2,
      "quarta": 3,
      "quarta-feira": 3,
      "qua": 3,
      "quinta": 4,
      "quinta-feira": 4,
      "qui": 4,
      "sexta": 5,
      "sexta-feira": 5,
      "sex": 5,
      "s\xE1bado": 6,
      "sabado": 6,
      "sab": 6
    };
    exports.MONTH_DICTIONARY = {
      "janeiro": 1,
      "jan": 1,
      "jan.": 1,
      "fevereiro": 2,
      "fev": 2,
      "fev.": 2,
      "mar\xE7o": 3,
      "mar": 3,
      "mar.": 3,
      "abril": 4,
      "abr": 4,
      "abr.": 4,
      "maio": 5,
      "mai": 5,
      "mai.": 5,
      "junho": 6,
      "jun": 6,
      "jun.": 6,
      "julho": 7,
      "jul": 7,
      "jul.": 7,
      "agosto": 8,
      "ago": 8,
      "ago.": 8,
      "setembro": 9,
      "set": 9,
      "set.": 9,
      "outubro": 10,
      "out": 10,
      "out.": 10,
      "novembro": 11,
      "nov": 11,
      "nov.": 11,
      "dezembro": 12,
      "dez": 12,
      "dez.": 12
    };
    exports.YEAR_PATTERN = "[0-9]{1,4}(?![^\\s]\\d)(?:\\s*[a|d]\\.?\\s*c\\.?|\\s*a\\.?\\s*d\\.?)?";
    function parseYear(match) {
      if (match.match(/^[0-9]{1,4}$/)) {
        let yearNumber = parseInt(match);
        if (yearNumber < 100) {
          if (yearNumber > 50) {
            yearNumber = yearNumber + 1900;
          } else {
            yearNumber = yearNumber + 2e3;
          }
        }
        return yearNumber;
      }
      if (match.match(/a\.?\s*c\.?/i)) {
        match = match.replace(/a\.?\s*c\.?/i, "");
        return -parseInt(match);
      }
      return parseInt(match);
    }
    exports.parseYear = parseYear;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTWeekdayParser.js
var require_PTWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants5();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weekdays_1 = require_weekdays();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:(este|esta|passado|pr[o\xF3]ximo)\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(este|esta|passado|pr[\xF3o]ximo)\\s*semana)?(?=\\W|\\d|$)`, "i");
    var PREFIX_GROUP = 1;
    var WEEKDAY_GROUP = 2;
    var POSTFIX_GROUP = 3;
    var PTWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const weekday = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        if (weekday === void 0) {
          return null;
        }
        const prefix = match[PREFIX_GROUP];
        const postfix = match[POSTFIX_GROUP];
        let norm = prefix || postfix || "";
        norm = norm.toLowerCase();
        let modifier = null;
        if (norm == "passado") {
          modifier = "this";
        } else if (norm == "pr\xF3ximo" || norm == "proximo") {
          modifier = "next";
        } else if (norm == "este") {
          modifier = "this";
        }
        return weekdays_1.createParsingComponentsAtWeekday(context2.reference, weekday, modifier);
      }
    };
    exports.default = PTWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTTimeExpressionParser.js
var require_PTTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var PTTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      primaryPrefix() {
        return "(?:(?:ao?|\xE0s?|das|da|de|do)\\s*)?";
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|a(?:o)?|\\?)\\s*";
      }
    };
    exports.default = PTTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/refiners/PTMergeDateTimeRefiner.js
var require_PTMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/refiners/PTMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault2(require_AbstractMergeDateTimeRefiner());
    var PTMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(?:,|\xE0)?\\s*$");
      }
    };
    exports.default = PTMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/pt/refiners/PTMergeDateRangeRefiner.js
var require_PTMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/refiners/PTMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var PTMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(?:-)\s*$/i;
      }
    };
    exports.default = PTMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTMonthNameLittleEndianParser.js
var require_PTMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants5();
    var constants_2 = require_constants5();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`([0-9]{1,2})(?:\xBA|\xAA|\xB0)?(?:\\s*(?:desde|de|\\-|\\\u2013|ao?|\\s)\\s*([0-9]{1,2})(?:\xBA|\xAA|\xB0)?)?\\s*(?:de)?\\s*(?:-|/|\\s*(?:de|,)?\\s*)(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:\\s*(?:de|,)?\\s*(${constants_2.YEAR_PATTERN}))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var PTMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const result = context2.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = parseInt(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context2.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = parseInt(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = PTMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTCasualDateParser.js
var require_PTCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o6, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o6, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o6, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o6[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o6, v2) {
      Object.defineProperty(o6, "default", { enumerable: true, value: v2 });
    } : function(o6, v2) {
      o6["default"] = v2;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding2(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var references = __importStar2(require_casualReferences());
    var PTCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context2) {
        return /(agora|hoje|amanha|amanhã|ontem)(?=\W|$)/i;
      }
      innerExtract(context2, match) {
        const lowerText = match[0].toLowerCase();
        const component = context2.createParsingComponents();
        switch (lowerText) {
          case "agora":
            return references.now(context2.reference);
          case "hoje":
            return references.today(context2.reference);
          case "amanha":
          case "amanh\xE3":
            return references.tomorrow(context2.reference);
          case "ontem":
            return references.yesterday(context2.reference);
        }
        return component;
      }
    };
    exports.default = PTCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTCasualTimeParser.js
var require_PTCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTCasualTimeParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_1 = require_dayjs();
    var dayjs_2 = __importDefault2(require_dayjs_min());
    var PTCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return /(?:esta\s*)?(manha|manhã|tarde|meia-noite|meio-dia|noite)(?=\W|$)/i;
      }
      innerExtract(context2, match) {
        const targetDate = dayjs_2.default(context2.refDate);
        const component = context2.createParsingComponents();
        switch (match[1].toLowerCase()) {
          case "tarde":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 15);
            break;
          case "noite":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 22);
            break;
          case "manha":
          case "manh\xE3":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 6);
            break;
          case "meia-noite":
            dayjs_1.assignTheNextDay(component, targetDate);
            component.imply("hour", 0);
            component.imply("minute", 0);
            component.imply("second", 0);
            break;
          case "meio-dia":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 12);
            break;
        }
        return component;
      }
    };
    exports.default = PTCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/index.js
var require_pt = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var configurations_1 = require_configurations();
    var chrono_1 = require_chrono();
    var SlashDateFormatParser_1 = __importDefault2(require_SlashDateFormatParser());
    var PTWeekdayParser_1 = __importDefault2(require_PTWeekdayParser());
    var PTTimeExpressionParser_1 = __importDefault2(require_PTTimeExpressionParser());
    var PTMergeDateTimeRefiner_1 = __importDefault2(require_PTMergeDateTimeRefiner());
    var PTMergeDateRangeRefiner_1 = __importDefault2(require_PTMergeDateRangeRefiner());
    var PTMonthNameLittleEndianParser_1 = __importDefault2(require_PTMonthNameLittleEndianParser());
    var PTCasualDateParser_1 = __importDefault2(require_PTCasualDateParser());
    var PTCasualTimeParser_1 = __importDefault2(require_PTCasualTimeParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse3(text, ref, option) {
      return exports.casual.parse(text, ref, option);
    }
    exports.parse = parse3;
    function parseDate(text, ref, option) {
      return exports.casual.parseDate(text, ref, option);
    }
    exports.parseDate = parseDate;
    function createCasualConfiguration(littleEndian = true) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.push(new PTCasualDateParser_1.default());
      option.parsers.push(new PTCasualTimeParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(littleEndian),
          new PTWeekdayParser_1.default(),
          new PTTimeExpressionParser_1.default(),
          new PTMonthNameLittleEndianParser_1.default()
        ],
        refiners: [new PTMergeDateTimeRefiner_1.default(), new PTMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/nl/refiners/NLMergeDateRangeRefiner.js
var require_NLMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/refiners/NLMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var NLMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(tot|-)\s*$/i;
      }
    };
    exports.default = NLMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/nl/refiners/NLMergeDateTimeRefiner.js
var require_NLMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/refiners/NLMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault2(require_AbstractMergeDateTimeRefiner());
    var NLMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(om|na|voor|in de|,|-)?\\s*$");
      }
    };
    exports.default = NLMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLCasualDateParser.js
var require_NLCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o6, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o6, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o6, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o6[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o6, v2) {
      Object.defineProperty(o6, "default", { enumerable: true, value: v2 });
    } : function(o6, v2) {
      o6["default"] = v2;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding2(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var references = __importStar2(require_casualReferences());
    var NLCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context2) {
        return /(nu|vandaag|morgen|morgend|gisteren)(?=\W|$)/i;
      }
      innerExtract(context2, match) {
        const lowerText = match[0].toLowerCase();
        const component = context2.createParsingComponents();
        switch (lowerText) {
          case "nu":
            return references.now(context2.reference);
          case "vandaag":
            return references.today(context2.reference);
          case "morgen":
          case "morgend":
            return references.tomorrow(context2.reference);
          case "gisteren":
            return references.yesterday(context2.reference);
        }
        return component;
      }
    };
    exports.default = NLCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLCasualTimeParser.js
var require_NLCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLCasualTimeParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var dayjs_2 = require_dayjs();
    var DAY_GROUP = 1;
    var MOMENT_GROUP = 2;
    var NLCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return /(deze)?\s*(namiddag|avond|middernacht|ochtend|middag|'s middags|'s avonds|'s ochtends)(?=\W|$)/i;
      }
      innerExtract(context2, match) {
        const targetDate = dayjs_1.default(context2.refDate);
        const component = context2.createParsingComponents();
        if (match[DAY_GROUP] === "deze") {
          component.assign("day", context2.refDate.getDate());
          component.assign("month", context2.refDate.getMonth() + 1);
          component.assign("year", context2.refDate.getFullYear());
        }
        switch (match[MOMENT_GROUP].toLowerCase()) {
          case "namiddag":
          case "'s namiddags":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 15);
            break;
          case "avond":
          case "'s avonds'":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 20);
            break;
          case "middernacht":
            dayjs_2.assignTheNextDay(component, targetDate);
            component.imply("hour", 0);
            component.imply("minute", 0);
            component.imply("second", 0);
            break;
          case "ochtend":
          case "'s ochtends":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 6);
            break;
          case "middag":
          case "'s middags":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 12);
            break;
        }
        return component;
      }
    };
    exports.default = NLCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/constants.js
var require_constants6 = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseOrdinalNumberPattern = exports.ORDINAL_NUMBER_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.ORDINAL_WORD_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    var pattern_1 = require_pattern();
    var years_1 = require_years();
    exports.WEEKDAY_DICTIONARY = {
      zondag: 0,
      zon: 0,
      "zon.": 0,
      zo: 0,
      "zo.": 0,
      maandag: 1,
      ma: 1,
      "ma.": 1,
      dinsdag: 2,
      din: 2,
      "din.": 2,
      di: 2,
      "di.": 2,
      woensdag: 3,
      woe: 3,
      "woe.": 3,
      wo: 3,
      "wo.": 3,
      donderdag: 4,
      dond: 4,
      "dond.": 4,
      do: 4,
      "do.": 4,
      vrijdag: 5,
      vrij: 5,
      "vrij.": 5,
      vr: 5,
      "vr.": 5,
      zaterdag: 6,
      zat: 6,
      "zat.": 6,
      "za": 6,
      "za.": 6
    };
    exports.MONTH_DICTIONARY = {
      januari: 1,
      jan: 1,
      "jan.": 1,
      februari: 2,
      feb: 2,
      "feb.": 2,
      maart: 3,
      mar: 3,
      "mar.": 3,
      april: 4,
      apr: 4,
      "apr.": 4,
      mei: 5,
      juni: 6,
      jun: 6,
      "jun.": 6,
      juli: 7,
      jul: 7,
      "jul.": 7,
      augustus: 8,
      aug: 8,
      "aug.": 8,
      september: 9,
      sep: 9,
      "sep.": 9,
      sept: 9,
      "sept.": 9,
      oktober: 10,
      okt: 10,
      "okt.": 10,
      november: 11,
      nov: 11,
      "nov.": 11,
      december: 12,
      dec: 12,
      "dec.": 12
    };
    exports.INTEGER_WORD_DICTIONARY = {
      een: 1,
      twee: 2,
      drie: 3,
      vier: 4,
      vijf: 5,
      zes: 6,
      zeven: 7,
      acht: 8,
      negen: 9,
      tien: 10,
      elf: 11,
      twaalf: 12
    };
    exports.ORDINAL_WORD_DICTIONARY = {
      eerste: 1,
      tweede: 2,
      derde: 3,
      vierde: 4,
      vijfde: 5,
      zesde: 6,
      zevende: 7,
      achtste: 8,
      negende: 9,
      tiende: 10,
      elfde: 11,
      twaalfde: 12,
      dertiende: 13,
      veertiende: 14,
      vijftiende: 15,
      zestiende: 16,
      zeventiende: 17,
      achttiende: 18,
      negentiende: 19,
      twintigste: 20,
      "eenentwintigste": 21,
      "twee\xEBntwintigste": 22,
      "drieentwintigste": 23,
      "vierentwintigste": 24,
      "vijfentwintigste": 25,
      "zesentwintigste": 26,
      "zevenentwintigste": 27,
      "achtentwintig": 28,
      "negenentwintig": 29,
      "dertigste": 30,
      "eenendertigste": 31
    };
    exports.TIME_UNIT_DICTIONARY = {
      sec: "second",
      second: "second",
      seconden: "second",
      min: "minute",
      mins: "minute",
      minute: "minute",
      minuut: "minute",
      minuten: "minute",
      minuutje: "minute",
      h: "hour",
      hr: "hour",
      hrs: "hour",
      uur: "hour",
      u: "hour",
      uren: "hour",
      dag: "d",
      dagen: "d",
      week: "week",
      weken: "week",
      maand: "month",
      maanden: "month",
      jaar: "year",
      jr: "year",
      jaren: "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+[\\.,][0-9]+|halve?|half|paar)`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      } else if (num === "paar") {
        return 2;
      } else if (num === "half" || num.match(/halve?/)) {
        return 0.5;
      }
      return parseFloat(num.replace(",", "."));
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.ORDINAL_NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:ste|de)?)`;
    function parseOrdinalNumberPattern(match) {
      let num = match.toLowerCase();
      if (exports.ORDINAL_WORD_DICTIONARY[num] !== void 0) {
        return exports.ORDINAL_WORD_DICTIONARY[num];
      }
      num = num.replace(/(?:ste|de)$/i, "");
      return parseInt(num);
    }
    exports.parseOrdinalNumberPattern = parseOrdinalNumberPattern;
    exports.YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\s*(?:voor Christus|na Christus)|[1-2][0-9]{3}|[5-9][0-9])`;
    function parseYear(match) {
      if (/voor Christus/i.test(match)) {
        match = match.replace(/voor Christus/i, "");
        return -parseInt(match);
      }
      if (/na Christus/i.test(match)) {
        match = match.replace(/na Christus/i, "");
        return parseInt(match);
      }
      const rawYearNumber = parseInt(match);
      return years_1.findMostLikelyADYear(rawYearNumber);
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,5}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})\\s{0,5}`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern(`(?:(?:binnen|in)\\s*)?`, SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length);
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitWithinFormatParser.js
var require_NLTimeUnitWithinFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitWithinFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var NLTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return new RegExp(`(?:binnen|in|binnen de|voor)\\s*(` + constants_1.TIME_UNITS_PATTERN + `)(?=\\W|$)`, "i");
      }
      innerExtract(context2, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        return results_1.ParsingComponents.createRelativeFromReference(context2.reference, timeUnits);
      }
    };
    exports.default = NLTimeUnitWithinFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLWeekdayParser.js
var require_NLWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weekdays_1 = require_weekdays();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:op\\s*?)?(?:(deze|vorige|volgende)\\s*(?:week\\s*)?)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?=\\W|$)`, "i");
    var PREFIX_GROUP = 1;
    var WEEKDAY_GROUP = 2;
    var POSTFIX_GROUP = 3;
    var NLWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const weekday = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        const prefix = match[PREFIX_GROUP];
        const postfix = match[POSTFIX_GROUP];
        let modifierWord = prefix || postfix;
        modifierWord = modifierWord || "";
        modifierWord = modifierWord.toLowerCase();
        let modifier = null;
        if (modifierWord == "vorige") {
          modifier = "last";
        } else if (modifierWord == "volgende") {
          modifier = "next";
        } else if (modifierWord == "deze") {
          modifier = "this";
        }
        return weekdays_1.createParsingComponentsAtWeekday(context2.reference, weekday, modifier);
      }
    };
    exports.default = NLWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLMonthNameMiddleEndianParser.js
var require_NLMonthNameMiddleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLMonthNameMiddleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants6();
    var constants_2 = require_constants6();
    var constants_3 = require_constants6();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:on\\s*?)?(${constants_2.ORDINAL_NUMBER_PATTERN})(?:\\s*(?:tot|\\-|\\\u2013|until|through|till|\\s)\\s*(${constants_2.ORDINAL_NUMBER_PATTERN}))?(?:-|/|\\s*(?:of)?\\s*)(` + pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY) + `)(?:(?:-|/|,?\\s*)(${constants_3.YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
    var MONTH_NAME_GROUP = 3;
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var YEAR_GROUP = 4;
    var NLMonthNameMiddleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_2.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        const components = context2.createParsingComponents({
          day,
          month
        });
        if (match[YEAR_GROUP]) {
          const year = constants_3.parseYear(match[YEAR_GROUP]);
          components.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context2.refDate, day, month);
          components.imply("year", year);
        }
        if (!match[DATE_TO_GROUP]) {
          return components;
        }
        const endDate = constants_2.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
        const result = context2.createParsingResult(match.index, match[0]);
        result.start = components;
        result.end = components.clone();
        result.end.assign("day", endDate);
        return result;
      }
    };
    exports.default = NLMonthNameMiddleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLMonthNameParser.js
var require_NLMonthNameParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLMonthNameParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var years_1 = require_years();
    var pattern_1 = require_pattern();
    var constants_2 = require_constants6();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})\\s*(?:[,-]?\\s*(${constants_2.YEAR_PATTERN})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, "i");
    var MONTH_NAME_GROUP = 1;
    var YEAR_GROUP = 2;
    var NLMonthNameParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const components = context2.createParsingComponents();
        components.imply("day", 1);
        const monthName = match[MONTH_NAME_GROUP];
        const month = constants_1.MONTH_DICTIONARY[monthName.toLowerCase()];
        components.assign("month", month);
        if (match[YEAR_GROUP]) {
          const year = constants_2.parseYear(match[YEAR_GROUP]);
          components.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context2.refDate, 1, month);
          components.imply("year", year);
        }
        return components;
      }
    };
    exports.default = NLMonthNameParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLSlashMonthFormatParser.js
var require_NLSlashMonthFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLSlashMonthFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp("([0-9]|0[1-9]|1[012])/([0-9]{4})", "i");
    var MONTH_GROUP = 1;
    var YEAR_GROUP = 2;
    var NLSlashMonthFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const year = parseInt(match[YEAR_GROUP]);
        const month = parseInt(match[MONTH_GROUP]);
        return context2.createParsingComponents().imply("day", 1).assign("month", month).assign("year", year);
      }
    };
    exports.default = NLSlashMonthFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeExpressionParser.js
var require_NLTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var NLTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      primaryPrefix() {
        return "(?:(?:om)\\s*)?";
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|om|\\?)\\s*";
      }
      primarySuffix() {
        return "(?:\\s*(?:uur))?(?!/)(?=\\W|$)";
      }
      extractPrimaryTimeComponents(context2, match) {
        if (match[0].match(/^\s*\d{4}\s*$/)) {
          return null;
        }
        return super.extractPrimaryTimeComponents(context2, match);
      }
    };
    exports.default = NLTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLCasualYearMonthDayParser.js
var require_NLCasualYearMonthDayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLCasualYearMonthDayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`([0-9]{4})[\\.\\/\\s](?:(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})|([0-9]{1,2}))[\\.\\/\\s]([0-9]{1,2})(?=\\W|$)`, "i");
    var YEAR_NUMBER_GROUP = 1;
    var MONTH_NAME_GROUP = 2;
    var MONTH_NUMBER_GROUP = 3;
    var DATE_NUMBER_GROUP = 4;
    var NLCasualYearMonthDayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const month = match[MONTH_NUMBER_GROUP] ? parseInt(match[MONTH_NUMBER_GROUP]) : constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        if (month < 1 || month > 12) {
          return null;
        }
        const year = parseInt(match[YEAR_NUMBER_GROUP]);
        const day = parseInt(match[DATE_NUMBER_GROUP]);
        return {
          day,
          month,
          year
        };
      }
    };
    exports.default = NLCasualYearMonthDayParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLCasualDateTimeParser.js
var require_NLCasualDateTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLCasualDateTimeParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var index_1 = require_dist();
    var dayjs_1 = require_dayjs();
    var dayjs_2 = __importDefault2(require_dayjs_min());
    var DATE_GROUP = 1;
    var TIME_OF_DAY_GROUP = 2;
    var NLCasualDateTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context2) {
        return /(gisteren|morgen|van)(ochtend|middag|namiddag|avond|nacht)(?=\W|$)/i;
      }
      innerExtract(context2, match) {
        const dateText = match[DATE_GROUP].toLowerCase();
        const timeText = match[TIME_OF_DAY_GROUP].toLowerCase();
        const component = context2.createParsingComponents();
        const targetDate = dayjs_2.default(context2.refDate);
        switch (dateText) {
          case "gisteren":
            dayjs_1.assignSimilarDate(component, targetDate.add(-1, "day"));
            break;
          case "van":
            dayjs_1.assignSimilarDate(component, targetDate);
            break;
          case "morgen":
            dayjs_1.assignTheNextDay(component, targetDate);
            break;
        }
        switch (timeText) {
          case "ochtend":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 6);
            break;
          case "middag":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 12);
            break;
          case "namiddag":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 15);
            break;
          case "avond":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 20);
            break;
        }
        return component;
      }
    };
    exports.default = NLCasualDateTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitCasualRelativeFormatParser.js
var require_NLTimeUnitCasualRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitCasualRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(deze|vorige|afgelopen|komende|over|\\+|-)\\s*(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
    var NLTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const prefix = match[1].toLowerCase();
        let timeUnits = constants_1.parseTimeUnits(match[2]);
        switch (prefix) {
          case "vorige":
          case "afgelopen":
          case "-":
            timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
            break;
        }
        return results_1.ParsingComponents.createRelativeFromReference(context2.reference, timeUnits);
      }
    };
    exports.default = NLTimeUnitCasualRelativeFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLRelativeDateFormatParser.js
var require_NLRelativeDateFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLRelativeDateFormatParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var pattern_1 = require_pattern();
    var PATTERN = new RegExp(`(dit|deze|komende|volgend|volgende|afgelopen|vorige)\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})(?=\\s*)(?=\\W|$)`, "i");
    var MODIFIER_WORD_GROUP = 1;
    var RELATIVE_WORD_GROUP = 2;
    var NLRelativeDateFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();
        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();
        const timeunit = constants_1.TIME_UNIT_DICTIONARY[unitWord];
        if (modifier == "volgend" || modifier == "volgende" || modifier == "komende") {
          const timeUnits = {};
          timeUnits[timeunit] = 1;
          return results_1.ParsingComponents.createRelativeFromReference(context2.reference, timeUnits);
        }
        if (modifier == "afgelopen" || modifier == "vorige") {
          const timeUnits = {};
          timeUnits[timeunit] = -1;
          return results_1.ParsingComponents.createRelativeFromReference(context2.reference, timeUnits);
        }
        const components = context2.createParsingComponents();
        let date = dayjs_1.default(context2.reference.instant);
        if (unitWord.match(/week/i)) {
          date = date.add(-date.get("d"), "d");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.imply("year", date.year());
        } else if (unitWord.match(/maand/i)) {
          date = date.add(-date.date() + 1, "d");
          components.imply("day", date.date());
          components.assign("year", date.year());
          components.assign("month", date.month() + 1);
        } else if (unitWord.match(/jaar/i)) {
          date = date.add(-date.date() + 1, "d");
          date = date.add(-date.month(), "month");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.assign("year", date.year());
        }
        return components;
      }
    };
    exports.default = NLRelativeDateFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitAgoFormatParser.js
var require_NLTimeUnitAgoFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitAgoFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")(?:geleden|voor|eerder)(?=(?:\\W|$))", "i");
    var STRICT_PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")geleden(?=(?:\\W|$))", "i");
    var NLTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      innerPattern() {
        return this.strictMode ? STRICT_PATTERN : PATTERN;
      }
      innerExtract(context2, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        const outputTimeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        return results_1.ParsingComponents.createRelativeFromReference(context2.reference, outputTimeUnits);
      }
    };
    exports.default = NLTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitLaterFormatParser.js
var require_NLTimeUnitLaterFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitLaterFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")(later|na|vanaf nu|voortaan|vooruit|uit)(?=(?:\\W|$))", "i");
    var STRICT_PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")(later|vanaf nu)(?=(?:\\W|$))", "i");
    var GROUP_NUM_TIMEUNITS = 1;
    var NLTimeUnitLaterFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      innerPattern() {
        return this.strictMode ? STRICT_PATTERN : PATTERN;
      }
      innerExtract(context2, match) {
        const fragments = constants_1.parseTimeUnits(match[GROUP_NUM_TIMEUNITS]);
        return results_1.ParsingComponents.createRelativeFromReference(context2.reference, fragments);
      }
    };
    exports.default = NLTimeUnitLaterFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/index.js
var require_nl = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var configurations_1 = require_configurations();
    var chrono_1 = require_chrono();
    var NLMergeDateRangeRefiner_1 = __importDefault2(require_NLMergeDateRangeRefiner());
    var NLMergeDateTimeRefiner_1 = __importDefault2(require_NLMergeDateTimeRefiner());
    var NLCasualDateParser_1 = __importDefault2(require_NLCasualDateParser());
    var NLCasualTimeParser_1 = __importDefault2(require_NLCasualTimeParser());
    var SlashDateFormatParser_1 = __importDefault2(require_SlashDateFormatParser());
    var NLTimeUnitWithinFormatParser_1 = __importDefault2(require_NLTimeUnitWithinFormatParser());
    var NLWeekdayParser_1 = __importDefault2(require_NLWeekdayParser());
    var NLMonthNameMiddleEndianParser_1 = __importDefault2(require_NLMonthNameMiddleEndianParser());
    var NLMonthNameParser_1 = __importDefault2(require_NLMonthNameParser());
    var NLSlashMonthFormatParser_1 = __importDefault2(require_NLSlashMonthFormatParser());
    var NLTimeExpressionParser_1 = __importDefault2(require_NLTimeExpressionParser());
    var NLCasualYearMonthDayParser_1 = __importDefault2(require_NLCasualYearMonthDayParser());
    var NLCasualDateTimeParser_1 = __importDefault2(require_NLCasualDateTimeParser());
    var NLTimeUnitCasualRelativeFormatParser_1 = __importDefault2(require_NLTimeUnitCasualRelativeFormatParser());
    var NLRelativeDateFormatParser_1 = __importDefault2(require_NLRelativeDateFormatParser());
    var NLTimeUnitAgoFormatParser_1 = __importDefault2(require_NLTimeUnitAgoFormatParser());
    var NLTimeUnitLaterFormatParser_1 = __importDefault2(require_NLTimeUnitLaterFormatParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse3(text, ref, option) {
      return exports.casual.parse(text, ref, option);
    }
    exports.parse = parse3;
    function parseDate(text, ref, option) {
      return exports.casual.parseDate(text, ref, option);
    }
    exports.parseDate = parseDate;
    function createCasualConfiguration(littleEndian = true) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.unshift(new NLCasualDateParser_1.default());
      option.parsers.unshift(new NLCasualTimeParser_1.default());
      option.parsers.unshift(new NLCasualDateTimeParser_1.default());
      option.parsers.unshift(new NLMonthNameParser_1.default());
      option.parsers.unshift(new NLRelativeDateFormatParser_1.default());
      option.parsers.unshift(new NLTimeUnitCasualRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(littleEndian),
          new NLTimeUnitWithinFormatParser_1.default(),
          new NLMonthNameMiddleEndianParser_1.default(),
          new NLMonthNameParser_1.default(),
          new NLWeekdayParser_1.default(),
          new NLCasualYearMonthDayParser_1.default(),
          new NLSlashMonthFormatParser_1.default(),
          new NLTimeExpressionParser_1.default(strictMode),
          new NLTimeUnitAgoFormatParser_1.default(strictMode),
          new NLTimeUnitLaterFormatParser_1.default(strictMode)
        ],
        refiners: [new NLMergeDateTimeRefiner_1.default(), new NLMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantCasualDateParser.js
var require_ZHHantCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantCasualDateParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var NOW_GROUP = 1;
    var DAY_GROUP_1 = 2;
    var TIME_GROUP_1 = 3;
    var TIME_GROUP_2 = 4;
    var DAY_GROUP_3 = 5;
    var TIME_GROUP_3 = 6;
    var ZHHantCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context2) {
        return new RegExp("(\u800C\u5BB6|\u7ACB(?:\u523B|\u5373)|\u5373\u523B)|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(?:\u65E5|\u5929)(?:[\\s|,|\uFF0C]*)(?:(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?", "i");
      }
      innerExtract(context2, match) {
        const index = match.index;
        const result = context2.createParsingResult(index, match[0]);
        const refMoment = dayjs_1.default(context2.refDate);
        let startMoment = refMoment;
        if (match[NOW_GROUP]) {
          result.start.imply("hour", refMoment.hour());
          result.start.imply("minute", refMoment.minute());
          result.start.imply("second", refMoment.second());
          result.start.imply("millisecond", refMoment.millisecond());
        } else if (match[DAY_GROUP_1]) {
          const day1 = match[DAY_GROUP_1];
          const time1 = match[TIME_GROUP_1];
          if (day1 == "\u660E" || day1 == "\u807D") {
            if (refMoment.hour() > 1) {
              startMoment = startMoment.add(1, "day");
            }
          } else if (day1 == "\u6628" || day1 == "\u5C0B" || day1 == "\u7434") {
            startMoment = startMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            startMoment = startMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            startMoment = startMoment.add(-3, "day");
          } else if (day1 == "\u5F8C") {
            startMoment = startMoment.add(2, "day");
          } else if (day1 == "\u5927\u5F8C") {
            startMoment = startMoment.add(3, "day");
          }
          if (time1 == "\u65E9" || time1 == "\u671D") {
            result.start.imply("hour", 6);
          } else if (time1 == "\u665A") {
            result.start.imply("hour", 22);
            result.start.imply("meridiem", 1);
          }
        } else if (match[TIME_GROUP_2]) {
          const timeString2 = match[TIME_GROUP_2];
          const time2 = timeString2[0];
          if (time2 == "\u65E9" || time2 == "\u671D" || time2 == "\u4E0A") {
            result.start.imply("hour", 6);
          } else if (time2 == "\u4E0B" || time2 == "\u664F") {
            result.start.imply("hour", 15);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u4E2D") {
            result.start.imply("hour", 12);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u591C" || time2 == "\u665A") {
            result.start.imply("hour", 22);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u51CC") {
            result.start.imply("hour", 0);
          }
        } else if (match[DAY_GROUP_3]) {
          const day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E" || day3 == "\u807D") {
            if (refMoment.hour() > 1) {
              startMoment = startMoment.add(1, "day");
            }
          } else if (day3 == "\u6628" || day3 == "\u5C0B" || day3 == "\u7434") {
            startMoment = startMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            startMoment = startMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            startMoment = startMoment.add(-3, "day");
          } else if (day3 == "\u5F8C") {
            startMoment = startMoment.add(2, "day");
          } else if (day3 == "\u5927\u5F8C") {
            startMoment = startMoment.add(3, "day");
          }
          const timeString3 = match[TIME_GROUP_3];
          if (timeString3) {
            const time3 = timeString3[0];
            if (time3 == "\u65E9" || time3 == "\u671D" || time3 == "\u4E0A") {
              result.start.imply("hour", 6);
            } else if (time3 == "\u4E0B" || time3 == "\u664F") {
              result.start.imply("hour", 15);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u4E2D") {
              result.start.imply("hour", 12);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u591C" || time3 == "\u665A") {
              result.start.imply("hour", 22);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u51CC") {
              result.start.imply("hour", 0);
            }
          }
        }
        result.start.assign("day", startMoment.date());
        result.start.assign("month", startMoment.month() + 1);
        result.start.assign("year", startMoment.year());
        return result;
      }
    };
    exports.default = ZHHantCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/constants.js
var require_constants7 = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zhStringToYear = exports.zhStringToNumber = exports.WEEKDAY_OFFSET = exports.NUMBER = void 0;
    exports.NUMBER = {
      "\u96F6": 0,
      "\u4E00": 1,
      "\u4E8C": 2,
      "\u5169": 2,
      "\u4E09": 3,
      "\u56DB": 4,
      "\u4E94": 5,
      "\u516D": 6,
      "\u4E03": 7,
      "\u516B": 8,
      "\u4E5D": 9,
      "\u5341": 10,
      "\u5EFF": 20,
      "\u5345": 30
    };
    exports.WEEKDAY_OFFSET = {
      "\u5929": 0,
      "\u65E5": 0,
      "\u4E00": 1,
      "\u4E8C": 2,
      "\u4E09": 3,
      "\u56DB": 4,
      "\u4E94": 5,
      "\u516D": 6
    };
    function zhStringToNumber(text) {
      let number = 0;
      for (let i4 = 0; i4 < text.length; i4++) {
        const char = text[i4];
        if (char === "\u5341") {
          number = number === 0 ? exports.NUMBER[char] : number * exports.NUMBER[char];
        } else {
          number += exports.NUMBER[char];
        }
      }
      return number;
    }
    exports.zhStringToNumber = zhStringToNumber;
    function zhStringToYear(text) {
      let string2 = "";
      for (let i4 = 0; i4 < text.length; i4++) {
        const char = text[i4];
        string2 = string2 + exports.NUMBER[char];
      }
      return parseInt(string2);
    }
    exports.zhStringToYear = zhStringToYear;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantDateParser.js
var require_ZHHantDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantDateParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var YEAR_GROUP = 1;
    var MONTH_GROUP = 2;
    var DAY_GROUP = 3;
    var ZHHantDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return new RegExp("(\\d{2,4}|[" + Object.keys(constants_1.NUMBER).join("") + "]{4}|[" + Object.keys(constants_1.NUMBER).join("") + "]{2})?(?:\\s*)(?:\u5E74)?(?:[\\s|,|\uFF0C]*)(\\d{1,2}|[" + Object.keys(constants_1.NUMBER).join("") + "]{1,2})(?:\\s*)(?:\u6708)(?:\\s*)(\\d{1,2}|[" + Object.keys(constants_1.NUMBER).join("") + "]{1,2})?(?:\\s*)(?:\u65E5|\u865F)?");
      }
      innerExtract(context2, match) {
        const startMoment = dayjs_1.default(context2.refDate);
        const result = context2.createParsingResult(match.index, match[0]);
        let month = parseInt(match[MONTH_GROUP]);
        if (isNaN(month))
          month = constants_1.zhStringToNumber(match[MONTH_GROUP]);
        result.start.assign("month", month);
        if (match[DAY_GROUP]) {
          let day = parseInt(match[DAY_GROUP]);
          if (isNaN(day))
            day = constants_1.zhStringToNumber(match[DAY_GROUP]);
          result.start.assign("day", day);
        } else {
          result.start.imply("day", startMoment.date());
        }
        if (match[YEAR_GROUP]) {
          let year = parseInt(match[YEAR_GROUP]);
          if (isNaN(year))
            year = constants_1.zhStringToYear(match[YEAR_GROUP]);
          result.start.assign("year", year);
        } else {
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHantDateParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantDeadlineFormatParser.js
var require_ZHHantDeadlineFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantDeadlineFormatParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var PATTERN = new RegExp("(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+|\u534A|\u5E7E)(?:\\s*)(?:\u500B)?(\u79D2(?:\u9418)?|\u5206\u9418|\u5C0F\u6642|\u9418|\u65E5|\u5929|\u661F\u671F|\u79AE\u62DC|\u6708|\u5E74)(?:(?:\u4E4B|\u904E)?\u5F8C|(?:\u4E4B)?\u5167)", "i");
    var NUMBER_GROUP = 1;
    var UNIT_GROUP = 2;
    var ZHHantDeadlineFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const result = context2.createParsingResult(match.index, match[0]);
        let number = parseInt(match[NUMBER_GROUP]);
        if (isNaN(number)) {
          number = constants_1.zhStringToNumber(match[NUMBER_GROUP]);
        }
        if (isNaN(number)) {
          const string2 = match[NUMBER_GROUP];
          if (string2 === "\u5E7E") {
            number = 3;
          } else if (string2 === "\u534A") {
            number = 0.5;
          } else {
            return null;
          }
        }
        let date = dayjs_1.default(context2.refDate);
        const unit = match[UNIT_GROUP];
        const unitAbbr = unit[0];
        if (unitAbbr.match(/[日天星禮月年]/)) {
          if (unitAbbr == "\u65E5" || unitAbbr == "\u5929") {
            date = date.add(number, "d");
          } else if (unitAbbr == "\u661F" || unitAbbr == "\u79AE") {
            date = date.add(number * 7, "d");
          } else if (unitAbbr == "\u6708") {
            date = date.add(number, "month");
          } else if (unitAbbr == "\u5E74") {
            date = date.add(number, "year");
          }
          result.start.assign("year", date.year());
          result.start.assign("month", date.month() + 1);
          result.start.assign("day", date.date());
          return result;
        }
        if (unitAbbr == "\u79D2") {
          date = date.add(number, "second");
        } else if (unitAbbr == "\u5206") {
          date = date.add(number, "minute");
        } else if (unitAbbr == "\u5C0F" || unitAbbr == "\u9418") {
          date = date.add(number, "hour");
        }
        result.start.imply("year", date.year());
        result.start.imply("month", date.month() + 1);
        result.start.imply("day", date.date());
        result.start.assign("hour", date.hour());
        result.start.assign("minute", date.minute());
        result.start.assign("second", date.second());
        return result;
      }
    };
    exports.default = ZHHantDeadlineFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantRelationWeekdayParser.js
var require_ZHHantRelationWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantRelationWeekdayParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var PATTERN = new RegExp("(?<prefix>\u4E0A|\u4ECA|\u4E0B|\u9019|\u5462)(?:\u500B)?(?:\u661F\u671F|\u79AE\u62DC|\u9031)(?<weekday>" + Object.keys(constants_1.WEEKDAY_OFFSET).join("|") + ")");
    var ZHHantRelationWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const result = context2.createParsingResult(match.index, match[0]);
        const dayOfWeek = match.groups.weekday;
        const offset = constants_1.WEEKDAY_OFFSET[dayOfWeek];
        if (offset === void 0)
          return null;
        let modifier = null;
        const prefix = match.groups.prefix;
        if (prefix == "\u4E0A") {
          modifier = "last";
        } else if (prefix == "\u4E0B") {
          modifier = "next";
        } else if (prefix == "\u4ECA" || prefix == "\u9019" || prefix == "\u5462") {
          modifier = "this";
        }
        let startMoment = dayjs_1.default(context2.refDate);
        let startMomentFixed = false;
        const refOffset = startMoment.day();
        if (modifier == "last" || modifier == "past") {
          startMoment = startMoment.day(offset - 7);
          startMomentFixed = true;
        } else if (modifier == "next") {
          startMoment = startMoment.day(offset + 7);
          startMomentFixed = true;
        } else if (modifier == "this") {
          startMoment = startMoment.day(offset);
        } else {
          if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {
            startMoment = startMoment.day(offset - 7);
          } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {
            startMoment = startMoment.day(offset + 7);
          } else {
            startMoment = startMoment.day(offset);
          }
        }
        result.start.assign("weekday", offset);
        if (startMomentFixed) {
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHantRelationWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantTimeExpressionParser.js
var require_ZHHantTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantTimeExpressionParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var FIRST_REG_PATTERN = new RegExp("(?:\u7531|\u5F9E|\u81EA)?(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)(?:\\s*)(?:\u9EDE|\u6642|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
    var SECOND_REG_PATTERN = new RegExp("(?:^\\s*(?:\u5230|\u81F3|\\-|\\\u2013|\\~|\\\u301C)\\s*)(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)(?:\\s*)(?:\u9EDE|\u6642|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
    var DAY_GROUP_1 = 1;
    var ZH_AM_PM_HOUR_GROUP_1 = 2;
    var ZH_AM_PM_HOUR_GROUP_2 = 3;
    var DAY_GROUP_3 = 4;
    var ZH_AM_PM_HOUR_GROUP_3 = 5;
    var HOUR_GROUP = 6;
    var MINUTE_GROUP = 7;
    var SECOND_GROUP = 8;
    var AM_PM_HOUR_GROUP = 9;
    var ZHHantTimeExpressionParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return FIRST_REG_PATTERN;
      }
      innerExtract(context2, match) {
        if (match.index > 0 && context2.text[match.index - 1].match(/\w/)) {
          return null;
        }
        const refMoment = dayjs_1.default(context2.refDate);
        const result = context2.createParsingResult(match.index, match[0]);
        const startMoment = refMoment.clone();
        if (match[DAY_GROUP_1]) {
          var day1 = match[DAY_GROUP_1];
          if (day1 == "\u660E" || day1 == "\u807D") {
            if (refMoment.hour() > 1) {
              startMoment.add(1, "day");
            }
          } else if (day1 == "\u6628" || day1 == "\u5C0B" || day1 == "\u7434") {
            startMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            startMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            startMoment.add(-3, "day");
          } else if (day1 == "\u5F8C") {
            startMoment.add(2, "day");
          } else if (day1 == "\u5927\u5F8C") {
            startMoment.add(3, "day");
          }
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else if (match[DAY_GROUP_3]) {
          var day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E" || day3 == "\u807D") {
            startMoment.add(1, "day");
          } else if (day3 == "\u6628" || day3 == "\u5C0B" || day3 == "\u7434") {
            startMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            startMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            startMoment.add(-3, "day");
          } else if (day3 == "\u5F8C") {
            startMoment.add(2, "day");
          } else if (day3 == "\u5927\u5F8C") {
            startMoment.add(3, "day");
          }
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        let hour = 0;
        let minute = 0;
        let meridiem = -1;
        if (match[SECOND_GROUP]) {
          var second = parseInt(match[SECOND_GROUP]);
          if (isNaN(second)) {
            second = constants_1.zhStringToNumber(match[SECOND_GROUP]);
          }
          if (second >= 60)
            return null;
          result.start.assign("second", second);
        }
        hour = parseInt(match[HOUR_GROUP]);
        if (isNaN(hour)) {
          hour = constants_1.zhStringToNumber(match[HOUR_GROUP]);
        }
        if (match[MINUTE_GROUP]) {
          if (match[MINUTE_GROUP] == "\u534A") {
            minute = 30;
          } else if (match[MINUTE_GROUP] == "\u6B63" || match[MINUTE_GROUP] == "\u6574") {
            minute = 0;
          } else {
            minute = parseInt(match[MINUTE_GROUP]);
            if (isNaN(minute)) {
              minute = constants_1.zhStringToNumber(match[MINUTE_GROUP]);
            }
          }
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = 1;
        }
        if (match[AM_PM_HOUR_GROUP]) {
          if (hour > 12)
            return null;
          var ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          }
          if (ampm == "p") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
          var zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
          var zhAMPM1 = zhAMPMString1[0];
          if (zhAMPM1 == "\u671D" || zhAMPM1 == "\u65E9") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM1 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
          var zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
          var zhAMPM2 = zhAMPMString2[0];
          if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u671D" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u664F" || zhAMPM2 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
          var zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
          var zhAMPM3 = zhAMPMString3[0];
          if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u671D" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u664F" || zhAMPM3 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        }
        result.start.assign("hour", hour);
        result.start.assign("minute", minute);
        if (meridiem >= 0) {
          result.start.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            result.start.imply("meridiem", 0);
          } else {
            result.start.imply("meridiem", 1);
          }
        }
        match = SECOND_REG_PATTERN.exec(context2.text.substring(result.index + result.text.length));
        if (!match) {
          if (result.text.match(/^\d+$/)) {
            return null;
          }
          return result;
        }
        const endMoment = startMoment.clone();
        result.end = context2.createParsingComponents();
        if (match[DAY_GROUP_1]) {
          var day1 = match[DAY_GROUP_1];
          if (day1 == "\u660E" || day1 == "\u807D") {
            if (refMoment.hour() > 1) {
              endMoment.add(1, "day");
            }
          } else if (day1 == "\u6628" || day1 == "\u5C0B" || day1 == "\u7434") {
            endMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            endMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            endMoment.add(-3, "day");
          } else if (day1 == "\u5F8C") {
            endMoment.add(2, "day");
          } else if (day1 == "\u5927\u5F8C") {
            endMoment.add(3, "day");
          }
          result.end.assign("day", endMoment.date());
          result.end.assign("month", endMoment.month() + 1);
          result.end.assign("year", endMoment.year());
        } else if (match[DAY_GROUP_3]) {
          var day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E" || day3 == "\u807D") {
            endMoment.add(1, "day");
          } else if (day3 == "\u6628" || day3 == "\u5C0B" || day3 == "\u7434") {
            endMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            endMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            endMoment.add(-3, "day");
          } else if (day3 == "\u5F8C") {
            endMoment.add(2, "day");
          } else if (day3 == "\u5927\u5F8C") {
            endMoment.add(3, "day");
          }
          result.end.assign("day", endMoment.date());
          result.end.assign("month", endMoment.month() + 1);
          result.end.assign("year", endMoment.year());
        } else {
          result.end.imply("day", endMoment.date());
          result.end.imply("month", endMoment.month() + 1);
          result.end.imply("year", endMoment.year());
        }
        hour = 0;
        minute = 0;
        meridiem = -1;
        if (match[SECOND_GROUP]) {
          var second = parseInt(match[SECOND_GROUP]);
          if (isNaN(second)) {
            second = constants_1.zhStringToNumber(match[SECOND_GROUP]);
          }
          if (second >= 60)
            return null;
          result.end.assign("second", second);
        }
        hour = parseInt(match[HOUR_GROUP]);
        if (isNaN(hour)) {
          hour = constants_1.zhStringToNumber(match[HOUR_GROUP]);
        }
        if (match[MINUTE_GROUP]) {
          if (match[MINUTE_GROUP] == "\u534A") {
            minute = 30;
          } else if (match[MINUTE_GROUP] == "\u6B63" || match[MINUTE_GROUP] == "\u6574") {
            minute = 0;
          } else {
            minute = parseInt(match[MINUTE_GROUP]);
            if (isNaN(minute)) {
              minute = constants_1.zhStringToNumber(match[MINUTE_GROUP]);
            }
          }
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = 1;
        }
        if (match[AM_PM_HOUR_GROUP]) {
          if (hour > 12)
            return null;
          var ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          }
          if (ampm == "p") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
          if (!result.start.isCertain("meridiem")) {
            if (meridiem == 0) {
              result.start.imply("meridiem", 0);
              if (result.start.get("hour") == 12) {
                result.start.assign("hour", 0);
              }
            } else {
              result.start.imply("meridiem", 1);
              if (result.start.get("hour") != 12) {
                result.start.assign("hour", result.start.get("hour") + 12);
              }
            }
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
          var zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
          var zhAMPM1 = zhAMPMString1[0];
          if (zhAMPM1 == "\u671D" || zhAMPM1 == "\u65E9") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM1 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
          var zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
          var zhAMPM2 = zhAMPMString2[0];
          if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u671D" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u664F" || zhAMPM2 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
          var zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
          var zhAMPM3 = zhAMPMString3[0];
          if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u671D" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u664F" || zhAMPM3 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        }
        result.text = result.text + match[0];
        result.end.assign("hour", hour);
        result.end.assign("minute", minute);
        if (meridiem >= 0) {
          result.end.assign("meridiem", meridiem);
        } else {
          const startAtPM = result.start.isCertain("meridiem") && result.start.get("meridiem") == 1;
          if (startAtPM && result.start.get("hour") > hour) {
            result.end.imply("meridiem", 0);
          } else if (hour > 12) {
            result.end.imply("meridiem", 1);
          }
        }
        if (result.end.date().getTime() < result.start.date().getTime()) {
          result.end.imply("day", result.end.get("day") + 1);
        }
        return result;
      }
    };
    exports.default = ZHHantTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantWeekdayParser.js
var require_ZHHantWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantWeekdayParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var PATTERN = new RegExp("(?:\u661F\u671F|\u79AE\u62DC|\u9031)(?<weekday>" + Object.keys(constants_1.WEEKDAY_OFFSET).join("|") + ")");
    var ZHHantWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const result = context2.createParsingResult(match.index, match[0]);
        const dayOfWeek = match.groups.weekday;
        const offset = constants_1.WEEKDAY_OFFSET[dayOfWeek];
        if (offset === void 0)
          return null;
        let startMoment = dayjs_1.default(context2.refDate);
        const startMomentFixed = false;
        const refOffset = startMoment.day();
        if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {
          startMoment = startMoment.day(offset - 7);
        } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {
          startMoment = startMoment.day(offset + 7);
        } else {
          startMoment = startMoment.day(offset);
        }
        result.start.assign("weekday", offset);
        if (startMomentFixed) {
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHantWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/refiners/ZHHantMergeDateRangeRefiner.js
var require_ZHHantMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/refiners/ZHHantMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var ZHHantMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(至|到|\-|\~|～|－|ー)\s*$/i;
      }
    };
    exports.default = ZHHantMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/refiners/ZHHantMergeDateTimeRefiner.js
var require_ZHHantMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/refiners/ZHHantMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault2(require_AbstractMergeDateTimeRefiner());
    var ZHHantMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return /^\s*$/i;
      }
    };
    exports.default = ZHHantMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/index.js
var require_hant = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = exports.hant = void 0;
    var chrono_1 = require_chrono();
    var ExtractTimezoneOffsetRefiner_1 = __importDefault2(require_ExtractTimezoneOffsetRefiner());
    var configurations_1 = require_configurations();
    var ZHHantCasualDateParser_1 = __importDefault2(require_ZHHantCasualDateParser());
    var ZHHantDateParser_1 = __importDefault2(require_ZHHantDateParser());
    var ZHHantDeadlineFormatParser_1 = __importDefault2(require_ZHHantDeadlineFormatParser());
    var ZHHantRelationWeekdayParser_1 = __importDefault2(require_ZHHantRelationWeekdayParser());
    var ZHHantTimeExpressionParser_1 = __importDefault2(require_ZHHantTimeExpressionParser());
    var ZHHantWeekdayParser_1 = __importDefault2(require_ZHHantWeekdayParser());
    var ZHHantMergeDateRangeRefiner_1 = __importDefault2(require_ZHHantMergeDateRangeRefiner());
    var ZHHantMergeDateTimeRefiner_1 = __importDefault2(require_ZHHantMergeDateTimeRefiner());
    exports.hant = new chrono_1.Chrono(createCasualConfiguration());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration());
    function parse3(text, ref, option) {
      return exports.casual.parse(text, ref, option);
    }
    exports.parse = parse3;
    function parseDate(text, ref, option) {
      return exports.casual.parseDate(text, ref, option);
    }
    exports.parseDate = parseDate;
    function createCasualConfiguration() {
      const option = createConfiguration();
      option.parsers.unshift(new ZHHantCasualDateParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration() {
      const configuration = configurations_1.includeCommonConfiguration({
        parsers: [
          new ZHHantDateParser_1.default(),
          new ZHHantRelationWeekdayParser_1.default(),
          new ZHHantWeekdayParser_1.default(),
          new ZHHantTimeExpressionParser_1.default(),
          new ZHHantDeadlineFormatParser_1.default()
        ],
        refiners: [new ZHHantMergeDateRangeRefiner_1.default(), new ZHHantMergeDateTimeRefiner_1.default()]
      });
      configuration.refiners = configuration.refiners.filter((refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner_1.default));
      return configuration;
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansCasualDateParser.js
var require_ZHHansCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansCasualDateParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var NOW_GROUP = 1;
    var DAY_GROUP_1 = 2;
    var TIME_GROUP_1 = 3;
    var TIME_GROUP_2 = 4;
    var DAY_GROUP_3 = 5;
    var TIME_GROUP_3 = 6;
    var ZHHansCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context2) {
        return new RegExp("(\u73B0\u5728|\u7ACB(?:\u523B|\u5373)|\u5373\u523B)|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(\u65E9|\u665A)|(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(?:\u65E5|\u5929)(?:[\\s|,|\uFF0C]*)(?:(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?", "i");
      }
      innerExtract(context2, match) {
        const index = match.index;
        const result = context2.createParsingResult(index, match[0]);
        const refMoment = dayjs_1.default(context2.refDate);
        let startMoment = refMoment;
        if (match[NOW_GROUP]) {
          result.start.imply("hour", refMoment.hour());
          result.start.imply("minute", refMoment.minute());
          result.start.imply("second", refMoment.second());
          result.start.imply("millisecond", refMoment.millisecond());
        } else if (match[DAY_GROUP_1]) {
          const day1 = match[DAY_GROUP_1];
          const time1 = match[TIME_GROUP_1];
          if (day1 == "\u660E") {
            if (refMoment.hour() > 1) {
              startMoment = startMoment.add(1, "day");
            }
          } else if (day1 == "\u6628") {
            startMoment = startMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            startMoment = startMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            startMoment = startMoment.add(-3, "day");
          } else if (day1 == "\u540E") {
            startMoment = startMoment.add(2, "day");
          } else if (day1 == "\u5927\u540E") {
            startMoment = startMoment.add(3, "day");
          }
          if (time1 == "\u65E9") {
            result.start.imply("hour", 6);
          } else if (time1 == "\u665A") {
            result.start.imply("hour", 22);
            result.start.imply("meridiem", 1);
          }
        } else if (match[TIME_GROUP_2]) {
          const timeString2 = match[TIME_GROUP_2];
          const time2 = timeString2[0];
          if (time2 == "\u65E9" || time2 == "\u4E0A") {
            result.start.imply("hour", 6);
          } else if (time2 == "\u4E0B") {
            result.start.imply("hour", 15);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u4E2D") {
            result.start.imply("hour", 12);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u591C" || time2 == "\u665A") {
            result.start.imply("hour", 22);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u51CC") {
            result.start.imply("hour", 0);
          }
        } else if (match[DAY_GROUP_3]) {
          const day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E") {
            if (refMoment.hour() > 1) {
              startMoment = startMoment.add(1, "day");
            }
          } else if (day3 == "\u6628") {
            startMoment = startMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            startMoment = startMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            startMoment = startMoment.add(-3, "day");
          } else if (day3 == "\u540E") {
            startMoment = startMoment.add(2, "day");
          } else if (day3 == "\u5927\u540E") {
            startMoment = startMoment.add(3, "day");
          }
          const timeString3 = match[TIME_GROUP_3];
          if (timeString3) {
            const time3 = timeString3[0];
            if (time3 == "\u65E9" || time3 == "\u4E0A") {
              result.start.imply("hour", 6);
            } else if (time3 == "\u4E0B") {
              result.start.imply("hour", 15);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u4E2D") {
              result.start.imply("hour", 12);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u591C" || time3 == "\u665A") {
              result.start.imply("hour", 22);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u51CC") {
              result.start.imply("hour", 0);
            }
          }
        }
        result.start.assign("day", startMoment.date());
        result.start.assign("month", startMoment.month() + 1);
        result.start.assign("year", startMoment.year());
        return result;
      }
    };
    exports.default = ZHHansCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/constants.js
var require_constants8 = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zhStringToYear = exports.zhStringToNumber = exports.WEEKDAY_OFFSET = exports.NUMBER = void 0;
    exports.NUMBER = {
      "\u96F6": 0,
      "\u3007": 0,
      "\u4E00": 1,
      "\u4E8C": 2,
      "\u4E24": 2,
      "\u4E09": 3,
      "\u56DB": 4,
      "\u4E94": 5,
      "\u516D": 6,
      "\u4E03": 7,
      "\u516B": 8,
      "\u4E5D": 9,
      "\u5341": 10
    };
    exports.WEEKDAY_OFFSET = {
      "\u5929": 0,
      "\u65E5": 0,
      "\u4E00": 1,
      "\u4E8C": 2,
      "\u4E09": 3,
      "\u56DB": 4,
      "\u4E94": 5,
      "\u516D": 6
    };
    function zhStringToNumber(text) {
      let number = 0;
      for (let i4 = 0; i4 < text.length; i4++) {
        const char = text[i4];
        if (char === "\u5341") {
          number = number === 0 ? exports.NUMBER[char] : number * exports.NUMBER[char];
        } else {
          number += exports.NUMBER[char];
        }
      }
      return number;
    }
    exports.zhStringToNumber = zhStringToNumber;
    function zhStringToYear(text) {
      let string2 = "";
      for (let i4 = 0; i4 < text.length; i4++) {
        const char = text[i4];
        string2 = string2 + exports.NUMBER[char];
      }
      return parseInt(string2);
    }
    exports.zhStringToYear = zhStringToYear;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansDateParser.js
var require_ZHHansDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansDateParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var YEAR_GROUP = 1;
    var MONTH_GROUP = 2;
    var DAY_GROUP = 3;
    var ZHHansDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return new RegExp("(\\d{2,4}|[" + Object.keys(constants_1.NUMBER).join("") + "]{4}|[" + Object.keys(constants_1.NUMBER).join("") + "]{2})?(?:\\s*)(?:\u5E74)?(?:[\\s|,|\uFF0C]*)(\\d{1,2}|[" + Object.keys(constants_1.NUMBER).join("") + "]{1,3})(?:\\s*)(?:\u6708)(?:\\s*)(\\d{1,2}|[" + Object.keys(constants_1.NUMBER).join("") + "]{1,3})?(?:\\s*)(?:\u65E5|\u53F7)?");
      }
      innerExtract(context2, match) {
        const startMoment = dayjs_1.default(context2.refDate);
        const result = context2.createParsingResult(match.index, match[0]);
        let month = parseInt(match[MONTH_GROUP]);
        if (isNaN(month))
          month = constants_1.zhStringToNumber(match[MONTH_GROUP]);
        result.start.assign("month", month);
        if (match[DAY_GROUP]) {
          let day = parseInt(match[DAY_GROUP]);
          if (isNaN(day))
            day = constants_1.zhStringToNumber(match[DAY_GROUP]);
          result.start.assign("day", day);
        } else {
          result.start.imply("day", startMoment.date());
        }
        if (match[YEAR_GROUP]) {
          let year = parseInt(match[YEAR_GROUP]);
          if (isNaN(year))
            year = constants_1.zhStringToYear(match[YEAR_GROUP]);
          result.start.assign("year", year);
        } else {
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHansDateParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansDeadlineFormatParser.js
var require_ZHHansDeadlineFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansDeadlineFormatParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var PATTERN = new RegExp("(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+|\u534A|\u51E0)(?:\\s*)(?:\u4E2A)?(\u79D2(?:\u949F)?|\u5206\u949F|\u5C0F\u65F6|\u949F|\u65E5|\u5929|\u661F\u671F|\u793C\u62DC|\u6708|\u5E74)(?:(?:\u4E4B|\u8FC7)?\u540E|(?:\u4E4B)?\u5185)", "i");
    var NUMBER_GROUP = 1;
    var UNIT_GROUP = 2;
    var ZHHansDeadlineFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const result = context2.createParsingResult(match.index, match[0]);
        let number = parseInt(match[NUMBER_GROUP]);
        if (isNaN(number)) {
          number = constants_1.zhStringToNumber(match[NUMBER_GROUP]);
        }
        if (isNaN(number)) {
          const string2 = match[NUMBER_GROUP];
          if (string2 === "\u51E0") {
            number = 3;
          } else if (string2 === "\u534A") {
            number = 0.5;
          } else {
            return null;
          }
        }
        let date = dayjs_1.default(context2.refDate);
        const unit = match[UNIT_GROUP];
        const unitAbbr = unit[0];
        if (unitAbbr.match(/[日天星礼月年]/)) {
          if (unitAbbr == "\u65E5" || unitAbbr == "\u5929") {
            date = date.add(number, "d");
          } else if (unitAbbr == "\u661F" || unitAbbr == "\u793C") {
            date = date.add(number * 7, "d");
          } else if (unitAbbr == "\u6708") {
            date = date.add(number, "month");
          } else if (unitAbbr == "\u5E74") {
            date = date.add(number, "year");
          }
          result.start.assign("year", date.year());
          result.start.assign("month", date.month() + 1);
          result.start.assign("day", date.date());
          return result;
        }
        if (unitAbbr == "\u79D2") {
          date = date.add(number, "second");
        } else if (unitAbbr == "\u5206") {
          date = date.add(number, "minute");
        } else if (unitAbbr == "\u5C0F" || unitAbbr == "\u949F") {
          date = date.add(number, "hour");
        }
        result.start.imply("year", date.year());
        result.start.imply("month", date.month() + 1);
        result.start.imply("day", date.date());
        result.start.assign("hour", date.hour());
        result.start.assign("minute", date.minute());
        result.start.assign("second", date.second());
        return result;
      }
    };
    exports.default = ZHHansDeadlineFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansRelationWeekdayParser.js
var require_ZHHansRelationWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansRelationWeekdayParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var PATTERN = new RegExp("(?<prefix>\u4E0A|\u4E0B|\u8FD9)(?:\u4E2A)?(?:\u661F\u671F|\u793C\u62DC|\u5468)(?<weekday>" + Object.keys(constants_1.WEEKDAY_OFFSET).join("|") + ")");
    var ZHHansRelationWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const result = context2.createParsingResult(match.index, match[0]);
        const dayOfWeek = match.groups.weekday;
        const offset = constants_1.WEEKDAY_OFFSET[dayOfWeek];
        if (offset === void 0)
          return null;
        let modifier = null;
        const prefix = match.groups.prefix;
        if (prefix == "\u4E0A") {
          modifier = "last";
        } else if (prefix == "\u4E0B") {
          modifier = "next";
        } else if (prefix == "\u8FD9") {
          modifier = "this";
        }
        let startMoment = dayjs_1.default(context2.refDate);
        let startMomentFixed = false;
        const refOffset = startMoment.day();
        if (modifier == "last" || modifier == "past") {
          startMoment = startMoment.day(offset - 7);
          startMomentFixed = true;
        } else if (modifier == "next") {
          startMoment = startMoment.day(offset + 7);
          startMomentFixed = true;
        } else if (modifier == "this") {
          startMoment = startMoment.day(offset);
        } else {
          if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {
            startMoment = startMoment.day(offset - 7);
          } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {
            startMoment = startMoment.day(offset + 7);
          } else {
            startMoment = startMoment.day(offset);
          }
        }
        result.start.assign("weekday", offset);
        if (startMomentFixed) {
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHansRelationWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansTimeExpressionParser.js
var require_ZHHansTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansTimeExpressionParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var FIRST_REG_PATTERN = new RegExp("(?:\u4ECE|\u81EA)?(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)(?:\\s*)(?:\u70B9|\u65F6|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
    var SECOND_REG_PATTERN = new RegExp("(?:^\\s*(?:\u5230|\u81F3|\\-|\\\u2013|\\~|\\\u301C)\\s*)(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)(?:\\s*)(?:\u70B9|\u65F6|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
    var DAY_GROUP_1 = 1;
    var ZH_AM_PM_HOUR_GROUP_1 = 2;
    var ZH_AM_PM_HOUR_GROUP_2 = 3;
    var DAY_GROUP_3 = 4;
    var ZH_AM_PM_HOUR_GROUP_3 = 5;
    var HOUR_GROUP = 6;
    var MINUTE_GROUP = 7;
    var SECOND_GROUP = 8;
    var AM_PM_HOUR_GROUP = 9;
    var ZHHansTimeExpressionParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return FIRST_REG_PATTERN;
      }
      innerExtract(context2, match) {
        if (match.index > 0 && context2.text[match.index - 1].match(/\w/)) {
          return null;
        }
        const refMoment = dayjs_1.default(context2.refDate);
        const result = context2.createParsingResult(match.index, match[0]);
        const startMoment = refMoment.clone();
        if (match[DAY_GROUP_1]) {
          const day1 = match[DAY_GROUP_1];
          if (day1 == "\u660E") {
            if (refMoment.hour() > 1) {
              startMoment.add(1, "day");
            }
          } else if (day1 == "\u6628") {
            startMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            startMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            startMoment.add(-3, "day");
          } else if (day1 == "\u540E") {
            startMoment.add(2, "day");
          } else if (day1 == "\u5927\u540E") {
            startMoment.add(3, "day");
          }
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else if (match[DAY_GROUP_3]) {
          const day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E") {
            startMoment.add(1, "day");
          } else if (day3 == "\u6628") {
            startMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            startMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            startMoment.add(-3, "day");
          } else if (day3 == "\u540E") {
            startMoment.add(2, "day");
          } else if (day3 == "\u5927\u540E") {
            startMoment.add(3, "day");
          }
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        let hour = 0;
        let minute = 0;
        let meridiem = -1;
        if (match[SECOND_GROUP]) {
          let second = parseInt(match[SECOND_GROUP]);
          if (isNaN(second)) {
            second = constants_1.zhStringToNumber(match[SECOND_GROUP]);
          }
          if (second >= 60)
            return null;
          result.start.assign("second", second);
        }
        hour = parseInt(match[HOUR_GROUP]);
        if (isNaN(hour)) {
          hour = constants_1.zhStringToNumber(match[HOUR_GROUP]);
        }
        if (match[MINUTE_GROUP]) {
          if (match[MINUTE_GROUP] == "\u534A") {
            minute = 30;
          } else if (match[MINUTE_GROUP] == "\u6B63" || match[MINUTE_GROUP] == "\u6574") {
            minute = 0;
          } else {
            minute = parseInt(match[MINUTE_GROUP]);
            if (isNaN(minute)) {
              minute = constants_1.zhStringToNumber(match[MINUTE_GROUP]);
            }
          }
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = 1;
        }
        if (match[AM_PM_HOUR_GROUP]) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          }
          if (ampm == "p") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
          const zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
          const zhAMPM1 = zhAMPMString1[0];
          if (zhAMPM1 == "\u65E9") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM1 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
          const zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
          const zhAMPM2 = zhAMPMString2[0];
          if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
          const zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
          const zhAMPM3 = zhAMPMString3[0];
          if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        }
        result.start.assign("hour", hour);
        result.start.assign("minute", minute);
        if (meridiem >= 0) {
          result.start.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            result.start.imply("meridiem", 0);
          } else {
            result.start.imply("meridiem", 1);
          }
        }
        match = SECOND_REG_PATTERN.exec(context2.text.substring(result.index + result.text.length));
        if (!match) {
          if (result.text.match(/^\d+$/)) {
            return null;
          }
          return result;
        }
        const endMoment = startMoment.clone();
        result.end = context2.createParsingComponents();
        if (match[DAY_GROUP_1]) {
          const day1 = match[DAY_GROUP_1];
          if (day1 == "\u660E") {
            if (refMoment.hour() > 1) {
              endMoment.add(1, "day");
            }
          } else if (day1 == "\u6628") {
            endMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            endMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            endMoment.add(-3, "day");
          } else if (day1 == "\u540E") {
            endMoment.add(2, "day");
          } else if (day1 == "\u5927\u540E") {
            endMoment.add(3, "day");
          }
          result.end.assign("day", endMoment.date());
          result.end.assign("month", endMoment.month() + 1);
          result.end.assign("year", endMoment.year());
        } else if (match[DAY_GROUP_3]) {
          const day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E") {
            endMoment.add(1, "day");
          } else if (day3 == "\u6628") {
            endMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            endMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            endMoment.add(-3, "day");
          } else if (day3 == "\u540E") {
            endMoment.add(2, "day");
          } else if (day3 == "\u5927\u540E") {
            endMoment.add(3, "day");
          }
          result.end.assign("day", endMoment.date());
          result.end.assign("month", endMoment.month() + 1);
          result.end.assign("year", endMoment.year());
        } else {
          result.end.imply("day", endMoment.date());
          result.end.imply("month", endMoment.month() + 1);
          result.end.imply("year", endMoment.year());
        }
        hour = 0;
        minute = 0;
        meridiem = -1;
        if (match[SECOND_GROUP]) {
          let second = parseInt(match[SECOND_GROUP]);
          if (isNaN(second)) {
            second = constants_1.zhStringToNumber(match[SECOND_GROUP]);
          }
          if (second >= 60)
            return null;
          result.end.assign("second", second);
        }
        hour = parseInt(match[HOUR_GROUP]);
        if (isNaN(hour)) {
          hour = constants_1.zhStringToNumber(match[HOUR_GROUP]);
        }
        if (match[MINUTE_GROUP]) {
          if (match[MINUTE_GROUP] == "\u534A") {
            minute = 30;
          } else if (match[MINUTE_GROUP] == "\u6B63" || match[MINUTE_GROUP] == "\u6574") {
            minute = 0;
          } else {
            minute = parseInt(match[MINUTE_GROUP]);
            if (isNaN(minute)) {
              minute = constants_1.zhStringToNumber(match[MINUTE_GROUP]);
            }
          }
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = 1;
        }
        if (match[AM_PM_HOUR_GROUP]) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          }
          if (ampm == "p") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
          if (!result.start.isCertain("meridiem")) {
            if (meridiem == 0) {
              result.start.imply("meridiem", 0);
              if (result.start.get("hour") == 12) {
                result.start.assign("hour", 0);
              }
            } else {
              result.start.imply("meridiem", 1);
              if (result.start.get("hour") != 12) {
                result.start.assign("hour", result.start.get("hour") + 12);
              }
            }
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
          const zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
          const zhAMPM1 = zhAMPMString1[0];
          if (zhAMPM1 == "\u65E9") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM1 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
          const zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
          const zhAMPM2 = zhAMPMString2[0];
          if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
          const zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
          const zhAMPM3 = zhAMPMString3[0];
          if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        }
        result.text = result.text + match[0];
        result.end.assign("hour", hour);
        result.end.assign("minute", minute);
        if (meridiem >= 0) {
          result.end.assign("meridiem", meridiem);
        } else {
          const startAtPM = result.start.isCertain("meridiem") && result.start.get("meridiem") == 1;
          if (startAtPM && result.start.get("hour") > hour) {
            result.end.imply("meridiem", 0);
          } else if (hour > 12) {
            result.end.imply("meridiem", 1);
          }
        }
        if (result.end.date().getTime() < result.start.date().getTime()) {
          result.end.imply("day", result.end.get("day") + 1);
        }
        return result;
      }
    };
    exports.default = ZHHansTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansWeekdayParser.js
var require_ZHHansWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansWeekdayParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var PATTERN = new RegExp("(?:\u661F\u671F|\u793C\u62DC|\u5468)(?<weekday>" + Object.keys(constants_1.WEEKDAY_OFFSET).join("|") + ")");
    var ZHHansWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const result = context2.createParsingResult(match.index, match[0]);
        const dayOfWeek = match.groups.weekday;
        const offset = constants_1.WEEKDAY_OFFSET[dayOfWeek];
        if (offset === void 0)
          return null;
        let startMoment = dayjs_1.default(context2.refDate);
        const startMomentFixed = false;
        const refOffset = startMoment.day();
        if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {
          startMoment = startMoment.day(offset - 7);
        } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {
          startMoment = startMoment.day(offset + 7);
        } else {
          startMoment = startMoment.day(offset);
        }
        result.start.assign("weekday", offset);
        if (startMomentFixed) {
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHansWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/refiners/ZHHansMergeDateRangeRefiner.js
var require_ZHHansMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/refiners/ZHHansMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var ZHHansMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(至|到|-|~|～|－|ー)\s*$/i;
      }
    };
    exports.default = ZHHansMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/refiners/ZHHansMergeDateTimeRefiner.js
var require_ZHHansMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/refiners/ZHHansMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault2(require_AbstractMergeDateTimeRefiner());
    var ZHHansMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return /^\s*$/i;
      }
    };
    exports.default = ZHHansMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/index.js
var require_hans = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = exports.hans = void 0;
    var chrono_1 = require_chrono();
    var ExtractTimezoneOffsetRefiner_1 = __importDefault2(require_ExtractTimezoneOffsetRefiner());
    var configurations_1 = require_configurations();
    var ZHHansCasualDateParser_1 = __importDefault2(require_ZHHansCasualDateParser());
    var ZHHansDateParser_1 = __importDefault2(require_ZHHansDateParser());
    var ZHHansDeadlineFormatParser_1 = __importDefault2(require_ZHHansDeadlineFormatParser());
    var ZHHansRelationWeekdayParser_1 = __importDefault2(require_ZHHansRelationWeekdayParser());
    var ZHHansTimeExpressionParser_1 = __importDefault2(require_ZHHansTimeExpressionParser());
    var ZHHansWeekdayParser_1 = __importDefault2(require_ZHHansWeekdayParser());
    var ZHHansMergeDateRangeRefiner_1 = __importDefault2(require_ZHHansMergeDateRangeRefiner());
    var ZHHansMergeDateTimeRefiner_1 = __importDefault2(require_ZHHansMergeDateTimeRefiner());
    exports.hans = new chrono_1.Chrono(createCasualConfiguration());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration());
    function parse3(text, ref, option) {
      return exports.casual.parse(text, ref, option);
    }
    exports.parse = parse3;
    function parseDate(text, ref, option) {
      return exports.casual.parseDate(text, ref, option);
    }
    exports.parseDate = parseDate;
    function createCasualConfiguration() {
      const option = createConfiguration();
      option.parsers.unshift(new ZHHansCasualDateParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration() {
      const configuration = configurations_1.includeCommonConfiguration({
        parsers: [
          new ZHHansDateParser_1.default(),
          new ZHHansRelationWeekdayParser_1.default(),
          new ZHHansWeekdayParser_1.default(),
          new ZHHansTimeExpressionParser_1.default(),
          new ZHHansDeadlineFormatParser_1.default()
        ],
        refiners: [new ZHHansMergeDateRangeRefiner_1.default(), new ZHHansMergeDateTimeRefiner_1.default()]
      });
      configuration.refiners = configuration.refiners.filter((refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner_1.default));
      return configuration;
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/zh/index.js
var require_zh = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o6, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o6, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o6, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o6[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o6, v2) {
      Object.defineProperty(o6, "default", { enumerable: true, value: v2 });
    } : function(o6, v2) {
      o6["default"] = v2;
    });
    var __exportStar2 = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding2(exports2, m2, p2);
    };
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding2(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hans = void 0;
    __exportStar2(require_hant(), exports);
    exports.hans = __importStar2(require_hans());
  }
});

// node_modules/chrono-node/dist/locales/ru/constants.js
var require_constants9 = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseOrdinalNumberPattern = exports.ORDINAL_NUMBER_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.ORDINAL_WORD_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.FULL_MONTH_NAME_DICTIONARY = exports.WEEKDAY_DICTIONARY = exports.REGEX_PARTS = void 0;
    var pattern_1 = require_pattern();
    var years_1 = require_years();
    exports.REGEX_PARTS = {
      leftBoundary: "([^\\p{L}\\p{N}_]|^)",
      rightBoundary: "(?=[^\\p{L}\\p{N}_]|$)",
      flags: "iu"
    };
    exports.WEEKDAY_DICTIONARY = {
      \u0432\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u0435: 0,
      \u0432\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u044F: 0,
      \u0432\u0441\u043A: 0,
      "\u0432\u0441\u043A.": 0,
      \u043F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A: 1,
      \u043F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A\u0430: 1,
      \u043F\u043D: 1,
      "\u043F\u043D.": 1,
      \u0432\u0442\u043E\u0440\u043D\u0438\u043A: 2,
      \u0432\u0442\u043E\u0440\u043D\u0438\u043A\u0430: 2,
      \u0432\u0442: 2,
      "\u0432\u0442.": 2,
      \u0441\u0440\u0435\u0434\u0430: 3,
      \u0441\u0440\u0435\u0434\u044B: 3,
      \u0441\u0440\u0435\u0434\u0443: 3,
      \u0441\u0440: 3,
      "\u0441\u0440.": 3,
      \u0447\u0435\u0442\u0432\u0435\u0440\u0433: 4,
      \u0447\u0435\u0442\u0432\u0435\u0440\u0433\u0430: 4,
      \u0447\u0442: 4,
      "\u0447\u0442.": 4,
      \u043F\u044F\u0442\u043D\u0438\u0446\u0430: 5,
      \u043F\u044F\u0442\u043D\u0438\u0446\u0443: 5,
      \u043F\u044F\u0442\u043D\u0438\u0446\u044B: 5,
      \u043F\u0442: 5,
      "\u043F\u0442.": 5,
      \u0441\u0443\u0431\u0431\u043E\u0442\u0430: 6,
      \u0441\u0443\u0431\u0431\u043E\u0442\u0443: 6,
      \u0441\u0443\u0431\u0431\u043E\u0442\u044B: 6,
      \u0441\u0431: 6,
      "\u0441\u0431.": 6
    };
    exports.FULL_MONTH_NAME_DICTIONARY = {
      \u044F\u043D\u0432\u0430\u0440\u044C: 1,
      \u044F\u043D\u0432\u0430\u0440\u044F: 1,
      \u044F\u043D\u0432\u0430\u0440\u0435: 1,
      \u0444\u0435\u0432\u0440\u0430\u043B\u044C: 2,
      \u0444\u0435\u0432\u0440\u0430\u043B\u044F: 2,
      \u0444\u0435\u0432\u0440\u0430\u043B\u0435: 2,
      \u043C\u0430\u0440\u0442: 3,
      \u043C\u0430\u0440\u0442\u0430: 3,
      \u043C\u0430\u0440\u0442\u0435: 3,
      \u0430\u043F\u0440\u0435\u043B\u044C: 4,
      \u0430\u043F\u0440\u0435\u043B\u044F: 4,
      \u0430\u043F\u0440\u0435\u043B\u0435: 4,
      \u043C\u0430\u0439: 5,
      \u043C\u0430\u044F: 5,
      \u043C\u0430\u0435: 5,
      \u0438\u044E\u043D\u044C: 6,
      \u0438\u044E\u043D\u044F: 6,
      \u0438\u044E\u043D\u0435: 6,
      \u0438\u044E\u043B\u044C: 7,
      \u0438\u044E\u043B\u044F: 7,
      \u0438\u044E\u043B\u0435: 7,
      \u0430\u0432\u0433\u0443\u0441\u0442: 8,
      \u0430\u0432\u0433\u0443\u0441\u0442\u0430: 8,
      \u0430\u0432\u0433\u0443\u0441\u0442\u0435: 8,
      \u0441\u0435\u043D\u0442\u044F\u0431\u0440\u044C: 9,
      \u0441\u0435\u043D\u0442\u044F\u0431\u0440\u044F: 9,
      \u0441\u0435\u043D\u0442\u044F\u0431\u0440\u0435: 9,
      \u043E\u043A\u0442\u044F\u0431\u0440\u044C: 10,
      \u043E\u043A\u0442\u044F\u0431\u0440\u044F: 10,
      \u043E\u043A\u0442\u044F\u0431\u0440\u0435: 10,
      \u043D\u043E\u044F\u0431\u0440\u044C: 11,
      \u043D\u043E\u044F\u0431\u0440\u044F: 11,
      \u043D\u043E\u044F\u0431\u0440\u0435: 11,
      \u0434\u0435\u043A\u0430\u0431\u0440\u044C: 12,
      \u0434\u0435\u043A\u0430\u0431\u0440\u044F: 12,
      \u0434\u0435\u043A\u0430\u0431\u0440\u0435: 12
    };
    exports.MONTH_DICTIONARY = Object.assign(Object.assign({}, exports.FULL_MONTH_NAME_DICTIONARY), { \u044F\u043D\u0432: 1, "\u044F\u043D\u0432.": 1, \u0444\u0435\u0432: 2, "\u0444\u0435\u0432.": 2, \u043C\u0430\u0440: 3, "\u043C\u0430\u0440.": 3, \u0430\u043F\u0440: 4, "\u0430\u043F\u0440.": 4, \u0430\u0432\u0433: 8, "\u0430\u0432\u0433.": 8, \u0441\u0435\u043D: 9, "\u0441\u0435\u043D.": 9, \u043E\u043A\u0442: 10, "\u043E\u043A\u0442.": 10, \u043D\u043E\u044F: 11, "\u043D\u043E\u044F.": 11, \u0434\u0435\u043A: 12, "\u0434\u0435\u043A.": 12 });
    exports.INTEGER_WORD_DICTIONARY = {
      \u043E\u0434\u0438\u043D: 1,
      \u043E\u0434\u043D\u0430: 1,
      \u043E\u0434\u043D\u043E\u0439: 1,
      \u043E\u0434\u043D\u0443: 1,
      \u0434\u0432\u0435: 2,
      \u0434\u0432\u0430: 2,
      \u0434\u0432\u0443\u0445: 2,
      \u0442\u0440\u0438: 3,
      \u0442\u0440\u0435\u0445: 3,
      \u0442\u0440\u0451\u0445: 3,
      \u0447\u0435\u0442\u044B\u0440\u0435: 4,
      \u0447\u0435\u0442\u044B\u0440\u0435\u0445: 4,
      \u0447\u0435\u0442\u044B\u0440\u0451\u0445: 4,
      \u043F\u044F\u0442\u044C: 5,
      \u043F\u044F\u0442\u0438: 5,
      \u0448\u0435\u0441\u0442\u044C: 6,
      \u0448\u0435\u0441\u0442\u0438: 6,
      \u0441\u0435\u043C\u044C: 7,
      \u0441\u0435\u043C\u0438: 7,
      \u0432\u043E\u0441\u0435\u043C\u044C: 8,
      \u0432\u043E\u0441\u044C\u043C\u0438: 8,
      \u0434\u0435\u0432\u044F\u0442\u044C: 9,
      \u0434\u0435\u0432\u044F\u0442\u0438: 9,
      \u0434\u0435\u0441\u044F\u0442\u044C: 10,
      \u0434\u0435\u0441\u044F\u0442\u0438: 10,
      \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u044C: 11,
      \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u0438: 11,
      \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u044C: 12,
      \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u0438: 12
    };
    exports.ORDINAL_WORD_DICTIONARY = {
      \u043F\u0435\u0440\u0432\u043E\u0435: 1,
      \u043F\u0435\u0440\u0432\u043E\u0433\u043E: 1,
      \u0432\u0442\u043E\u0440\u043E\u0435: 2,
      \u0432\u0442\u043E\u0440\u043E\u0433\u043E: 2,
      \u0442\u0440\u0435\u0442\u044C\u0435: 3,
      \u0442\u0440\u0435\u0442\u044C\u0435\u0433\u043E: 3,
      \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0435: 4,
      \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0433\u043E: 4,
      \u043F\u044F\u0442\u043E\u0435: 5,
      \u043F\u044F\u0442\u043E\u0433\u043E: 5,
      \u0448\u0435\u0441\u0442\u043E\u0435: 6,
      \u0448\u0435\u0441\u0442\u043E\u0433\u043E: 6,
      \u0441\u0435\u0434\u044C\u043C\u043E\u0435: 7,
      \u0441\u0435\u0434\u044C\u043C\u043E\u0433\u043E: 7,
      \u0432\u043E\u0441\u044C\u043C\u043E\u0435: 8,
      \u0432\u043E\u0441\u044C\u043C\u043E\u0433\u043E: 8,
      \u0434\u0435\u0432\u044F\u0442\u043E\u0435: 9,
      \u0434\u0435\u0432\u044F\u0442\u043E\u0433\u043E: 9,
      \u0434\u0435\u0441\u044F\u0442\u043E\u0435: 10,
      \u0434\u0435\u0441\u044F\u0442\u043E\u0433\u043E: 10,
      \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 11,
      \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 11,
      \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 12,
      \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 12,
      \u0442\u0440\u0438\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 13,
      \u0442\u0440\u0438\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 13,
      \u0447\u0435\u0442\u044B\u0440\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 14,
      \u0447\u0435\u0442\u044B\u0440\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 14,
      \u043F\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 15,
      \u043F\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 15,
      \u0448\u0435\u0441\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 16,
      \u0448\u0435\u0441\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 16,
      \u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 17,
      \u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 17,
      \u0432\u043E\u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 18,
      \u0432\u043E\u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 18,
      \u0434\u0435\u0432\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 19,
      \u0434\u0435\u0432\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 19,
      \u0434\u0432\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 20,
      \u0434\u0432\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 20,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0435": 21,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0433\u043E": 21,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u0442\u043E\u0440\u043E\u0435": 22,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u0442\u043E\u0440\u043E\u0433\u043E": 22,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0442\u0440\u0435\u0442\u044C\u0435": 23,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0442\u0440\u0435\u0442\u044C\u0435\u0433\u043E": 23,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0435": 24,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0433\u043E": 24,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u044F\u0442\u043E\u0435": 25,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u044F\u0442\u043E\u0433\u043E": 25,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0448\u0435\u0441\u0442\u043E\u0435": 26,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0448\u0435\u0441\u0442\u043E\u0433\u043E": 26,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0441\u0435\u0434\u044C\u043C\u043E\u0435": 27,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0441\u0435\u0434\u044C\u043C\u043E\u0433\u043E": 27,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u043E\u0441\u044C\u043C\u043E\u0435": 28,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u043E\u0441\u044C\u043C\u043E\u0433\u043E": 28,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0434\u0435\u0432\u044F\u0442\u043E\u0435": 29,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0434\u0435\u0432\u044F\u0442\u043E\u0433\u043E": 29,
      "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u043E\u0435": 30,
      "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u043E\u0433\u043E": 30,
      "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0435": 31,
      "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0433\u043E": 31
    };
    exports.TIME_UNIT_DICTIONARY = {
      \u0441\u0435\u043A: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u0430: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u044B: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u0443: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u043A\u0430: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u043A\u0438: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u0435\u043A: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u043A\u0443: "second",
      \u043C\u0438\u043D: "minute",
      \u043C\u0438\u043D\u0443\u0442\u0430: "minute",
      \u043C\u0438\u043D\u0443\u0442: "minute",
      \u043C\u0438\u043D\u0443\u0442\u044B: "minute",
      \u043C\u0438\u043D\u0443\u0442\u0443: "minute",
      \u043C\u0438\u043D\u0443\u0442\u043E\u043A: "minute",
      \u043C\u0438\u043D\u0443\u0442\u043A\u0438: "minute",
      \u043C\u0438\u043D\u0443\u0442\u043A\u0443: "minute",
      \u0447\u0430\u0441: "hour",
      \u0447\u0430\u0441\u043E\u0432: "hour",
      \u0447\u0430\u0441\u0430: "hour",
      \u0447\u0430\u0441\u0443: "hour",
      \u0447\u0430\u0441\u0438\u043A\u043E\u0432: "hour",
      \u0447\u0430\u0441\u0438\u043A\u0430: "hour",
      \u0447\u0430\u0441\u0438\u043A\u0435: "hour",
      \u0447\u0430\u0441\u0438\u043A: "hour",
      \u0434\u0435\u043D\u044C: "d",
      \u0434\u043D\u044F: "d",
      \u0434\u043D\u0435\u0439: "d",
      \u0441\u0443\u0442\u043E\u043A: "d",
      \u0441\u0443\u0442\u043A\u0438: "d",
      \u043D\u0435\u0434\u0435\u043B\u044F: "week",
      \u043D\u0435\u0434\u0435\u043B\u0435: "week",
      \u043D\u0435\u0434\u0435\u043B\u0438: "week",
      \u043D\u0435\u0434\u0435\u043B\u044E: "week",
      \u043D\u0435\u0434\u0435\u043B\u044C: "week",
      \u043D\u0435\u0434\u0435\u043B\u044C\u043A\u0435: "week",
      \u043D\u0435\u0434\u0435\u043B\u044C\u043A\u0438: "week",
      \u043D\u0435\u0434\u0435\u043B\u0435\u043A: "week",
      \u043C\u0435\u0441\u044F\u0446: "month",
      \u043C\u0435\u0441\u044F\u0446\u0435: "month",
      \u043C\u0435\u0441\u044F\u0446\u0435\u0432: "month",
      \u043C\u0435\u0441\u044F\u0446\u0430: "month",
      \u043A\u0432\u0430\u0440\u0442\u0430\u043B: "quarter",
      \u043A\u0432\u0430\u0440\u0442\u0430\u043B\u0435: "quarter",
      \u043A\u0432\u0430\u0440\u0442\u0430\u043B\u043E\u0432: "quarter",
      \u0433\u043E\u0434: "year",
      \u0433\u043E\u0434\u0430: "year",
      \u0433\u043E\u0434\u0443: "year",
      \u0433\u043E\u0434\u043E\u0432: "year",
      \u043B\u0435\u0442: "year",
      \u0433\u043E\u0434\u0438\u043A: "year",
      \u0433\u043E\u0434\u0438\u043A\u0430: "year",
      \u0433\u043E\u0434\u0438\u043A\u043E\u0432: "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|\u043F\u043E\u043B|\u043D\u0435\u0441\u043A\u043E\u043B\u044C\u043A\u043E|\u043F\u0430\u0440(?:\u044B|\u0443)|\\s{0,3})`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      }
      if (num.match(/несколько/)) {
        return 3;
      } else if (num.match(/пол/)) {
        return 0.5;
      } else if (num.match(/пар/)) {
        return 2;
      } else if (num === "") {
        return 1;
      }
      return parseFloat(num);
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.ORDINAL_NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:\u0433\u043E|\u043E\u0433\u043E|\u0435|\u043E\u0435)?)`;
    function parseOrdinalNumberPattern(match) {
      let num = match.toLowerCase();
      if (exports.ORDINAL_WORD_DICTIONARY[num] !== void 0) {
        return exports.ORDINAL_WORD_DICTIONARY[num];
      }
      return parseInt(num);
    }
    exports.parseOrdinalNumberPattern = parseOrdinalNumberPattern;
    var year = "(?:\\s+(?:\u0433\u043E\u0434\u0443|\u0433\u043E\u0434\u0430|\u0433\u043E\u0434|\u0433|\u0433.))?";
    exports.YEAR_PATTERN = `(?:[1-9][0-9]{0,3}${year}\\s*(?:\u043D.\u044D.|\u0434\u043E \u043D.\u044D.|\u043D. \u044D.|\u0434\u043E \u043D. \u044D.)|[1-2][0-9]{3}${year}|[5-9][0-9]${year})`;
    function parseYear(match) {
      if (/(год|года|г|г.)/i.test(match)) {
        match = match.replace(/(год|года|г|г.)/i, "");
      }
      if (/(до н.э.|до н. э.)/i.test(match)) {
        match = match.replace(/(до н.э.|до н. э.)/i, "");
        return -parseInt(match);
      }
      if (/(н. э.|н.э.)/i.test(match)) {
        match = match.replace(/(н. э.|н.э.)/i, "");
        return parseInt(match);
      }
      const rawYearNumber = parseInt(match);
      return years_1.findMostLikelyADYear(rawYearNumber);
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,3}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern(`(?:(?:\u043E\u043A\u043E\u043B\u043E|\u043F\u0440\u0438\u043C\u0435\u0440\u043D\u043E)\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length).trim();
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitWithinFormatParser.js
var require_RUTimeUnitWithinFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitWithinFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = `(?:(?:\u043E\u043A\u043E\u043B\u043E|\u043F\u0440\u0438\u043C\u0435\u0440\u043D\u043E)\\s*(?:~\\s*)?)?(${constants_1.TIME_UNITS_PATTERN})${constants_1.REGEX_PARTS.rightBoundary}`;
    var PATTERN_WITH_PREFIX = new RegExp(`(?:\u0432 \u0442\u0435\u0447\u0435\u043D\u0438\u0435|\u0432 \u0442\u0435\u0447\u0435\u043D\u0438\u0438)\\s*${PATTERN}`, constants_1.REGEX_PARTS.flags);
    var PATTERN_WITHOUT_PREFIX = new RegExp(PATTERN, "i");
    var RUTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern(context2) {
        return context2.option.forwardDate ? PATTERN_WITHOUT_PREFIX : PATTERN_WITH_PREFIX;
      }
      innerExtract(context2, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        return results_1.ParsingComponents.createRelativeFromReference(context2.reference, timeUnits);
      }
    };
    exports.default = RUTimeUnitWithinFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUMonthNameLittleEndianParser.js
var require_RUMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants9();
    var constants_2 = require_constants9();
    var constants_3 = require_constants9();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:\u0441)?\\s*(${constants_3.ORDINAL_NUMBER_PATTERN})(?:\\s{0,3}(?:\u043F\u043E|-|\u2013|\u0434\u043E)?\\s{0,3}(${constants_3.ORDINAL_NUMBER_PATTERN}))?(?:-|\\/|\\s{0,3}(?:of)?\\s{0,3})(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:(?:-|\\/|,?\\s{0,3})(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var RUMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const result = context2.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_3.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context2.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = constants_3.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = RUMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUMonthNameParser.js
var require_RUMonthNameParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUMonthNameParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var years_1 = require_years();
    var pattern_1 = require_pattern();
    var constants_2 = require_constants9();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`((?:\u0432)\\s*)?(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})\\s*(?:[,-]?\\s*(${constants_2.YEAR_PATTERN})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, constants_1.REGEX_PARTS.flags);
    var MONTH_NAME_GROUP = 2;
    var YEAR_GROUP = 3;
    var RUMonthNameParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const monthName = match[MONTH_NAME_GROUP].toLowerCase();
        if (match[0].length <= 3 && !constants_1.FULL_MONTH_NAME_DICTIONARY[monthName]) {
          return null;
        }
        const result = context2.createParsingResult(match.index, match.index + match[0].length);
        result.start.imply("day", 1);
        const month = constants_1.MONTH_DICTIONARY[monthName];
        result.start.assign("month", month);
        if (match[YEAR_GROUP]) {
          const year = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context2.refDate, 1, month);
          result.start.imply("year", year);
        }
        return result;
      }
    };
    exports.default = RUMonthNameParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUTimeExpressionParser.js
var require_RUTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var constants_1 = require_constants9();
    var RUTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      constructor(strictMode) {
        super(strictMode);
      }
      patternFlags() {
        return constants_1.REGEX_PARTS.flags;
      }
      primaryPatternLeftBoundary() {
        return `(^|\\s|T|(?:[^\\p{L}\\p{N}_]))`;
      }
      followingPhase() {
        return `\\s*(?:\\-|\\\u2013|\\~|\\\u301C|\u0434\u043E|\u0438|\u043F\u043E|\\?)\\s*`;
      }
      primaryPrefix() {
        return `(?:(?:\u0432|\u0441)\\s*)??`;
      }
      primarySuffix() {
        return `(?:\\s*(?:\u0443\u0442\u0440\u0430|\u0432\u0435\u0447\u0435\u0440\u0430|\u043F\u043E\u0441\u043B\u0435 \u043F\u043E\u043B\u0443\u0434\u043D\u044F))?(?!\\/)${constants_1.REGEX_PARTS.rightBoundary}`;
      }
      extractPrimaryTimeComponents(context2, match) {
        const components = super.extractPrimaryTimeComponents(context2, match);
        if (components) {
          if (match[0].endsWith("\u0432\u0435\u0447\u0435\u0440\u0430")) {
            const hour = components.get("hour");
            if (hour >= 6 && hour < 12) {
              components.assign("hour", components.get("hour") + 12);
              components.assign("meridiem", index_1.Meridiem.PM);
            } else if (hour < 6) {
              components.assign("meridiem", index_1.Meridiem.AM);
            }
          }
          if (match[0].endsWith("\u043F\u043E\u0441\u043B\u0435 \u043F\u043E\u043B\u0443\u0434\u043D\u044F")) {
            components.assign("meridiem", index_1.Meridiem.PM);
            const hour = components.get("hour");
            if (hour >= 0 && hour <= 6) {
              components.assign("hour", components.get("hour") + 12);
            }
          }
          if (match[0].endsWith("\u0443\u0442\u0440\u0430")) {
            components.assign("meridiem", index_1.Meridiem.AM);
            const hour = components.get("hour");
            if (hour < 12) {
              components.assign("hour", components.get("hour"));
            }
          }
        }
        return components;
      }
    };
    exports.default = RUTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitAgoFormatParser.js
var require_RUTimeUnitAgoFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitAgoFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(${constants_1.TIME_UNITS_PATTERN})\\s{0,5}\u043D\u0430\u0437\u0430\u0434(?=(?:\\W|$))`, constants_1.REGEX_PARTS.flags);
    var RUTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        const outputTimeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        return results_1.ParsingComponents.createRelativeFromReference(context2.reference, outputTimeUnits);
      }
    };
    exports.default = RUTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/refiners/RUMergeDateRangeRefiner.js
var require_RUMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/refiners/RUMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var RUMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(и до|и по|до|по|-)\s*$/i;
      }
    };
    exports.default = RUMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/ru/refiners/RUMergeDateTimeRefiner.js
var require_RUMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/refiners/RUMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault2(require_AbstractMergeDateTimeRefiner());
    var RUMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp(`^\\s*(T|\u0432|,|-)?\\s*$`);
      }
    };
    exports.default = RUMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUCasualDateParser.js
var require_RUCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o6, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o6, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o6, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o6[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o6, v2) {
      Object.defineProperty(o6, "default", { enumerable: true, value: v2 });
    } : function(o6, v2) {
      o6["default"] = v2;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding2(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var references = __importStar2(require_casualReferences());
    var constants_1 = require_constants9();
    var PATTERN = new RegExp(`(?:\u0441|\u0441\u043E)?\\s*(\u0441\u0435\u0433\u043E\u0434\u043D\u044F|\u0432\u0447\u0435\u0440\u0430|\u0437\u0430\u0432\u0442\u0440\u0430|\u043F\u043E\u0441\u043B\u0435\u0437\u0430\u0432\u0442\u0440\u0430|\u043F\u043E\u0437\u0430\u0432\u0447\u0435\u0440\u0430)${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var RUCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern(context2) {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const lowerText = match[1].toLowerCase();
        const component = context2.createParsingComponents();
        switch (lowerText) {
          case "\u0441\u0435\u0433\u043E\u0434\u043D\u044F":
            return references.today(context2.reference);
          case "\u0432\u0447\u0435\u0440\u0430":
            return references.yesterday(context2.reference);
          case "\u0437\u0430\u0432\u0442\u0440\u0430":
            return references.tomorrow(context2.reference);
          case "\u043F\u043E\u0441\u043B\u0435\u0437\u0430\u0432\u0442\u0440\u0430":
            return references.theDayAfter(context2.reference, 2);
          case "\u043F\u043E\u0437\u0430\u0432\u0447\u0435\u0440\u0430":
            return references.theDayBefore(context2.reference, 2);
        }
        return component;
      }
    };
    exports.default = RUCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUCasualTimeParser.js
var require_RUCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUCasualTimeParser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o6, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o6, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o6, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o6[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o6, v2) {
      Object.defineProperty(o6, "default", { enumerable: true, value: v2 });
    } : function(o6, v2) {
      o6["default"] = v2;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding2(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var references = __importStar2(require_casualReferences());
    var dayjs_1 = require_dayjs();
    var dayjs_2 = __importDefault2(require_dayjs_min());
    var constants_1 = require_constants9();
    var PATTERN = new RegExp(`(\u0441\u0435\u0439\u0447\u0430\u0441|\u043F\u0440\u043E\u0448\u043B\u044B\u043C\\s*\u0432\u0435\u0447\u0435\u0440\u043E\u043C|\u043F\u0440\u043E\u0448\u043B\u043E\u0439\\s*\u043D\u043E\u0447\u044C\u044E|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439\\s*\u043D\u043E\u0447\u044C\u044E|\u0441\u0435\u0433\u043E\u0434\u043D\u044F\\s*\u043D\u043E\u0447\u044C\u044E|\u044D\u0442\u043E\u0439\\s*\u043D\u043E\u0447\u044C\u044E|\u043D\u043E\u0447\u044C\u044E|\u044D\u0442\u0438\u043C \u0443\u0442\u0440\u043E\u043C|\u0443\u0442\u0440\u043E\u043C|\u0443\u0442\u0440\u0430|\u0432\\s*\u043F\u043E\u043B\u0434\u0435\u043D\u044C|\u0432\u0435\u0447\u0435\u0440\u043E\u043C|\u0432\u0435\u0447\u0435\u0440\u0430|\u0432\\s*\u043F\u043E\u043B\u043D\u043E\u0447\u044C)${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var RUCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        let targetDate = dayjs_2.default(context2.refDate);
        const lowerText = match[0].toLowerCase();
        const component = context2.createParsingComponents();
        if (lowerText === "\u0441\u0435\u0439\u0447\u0430\u0441") {
          return references.now(context2.reference);
        }
        if (lowerText === "\u0432\u0435\u0447\u0435\u0440\u043E\u043C" || lowerText === "\u0432\u0435\u0447\u0435\u0440\u0430") {
          return references.evening(context2.reference);
        }
        if (lowerText.endsWith("\u0443\u0442\u0440\u043E\u043C") || lowerText.endsWith("\u0443\u0442\u0440\u0430")) {
          return references.morning(context2.reference);
        }
        if (lowerText.match(/в\s*полдень/)) {
          return references.noon(context2.reference);
        }
        if (lowerText.match(/прошлой\s*ночью/)) {
          return references.lastNight(context2.reference);
        }
        if (lowerText.match(/прошлым\s*вечером/)) {
          return references.yesterdayEvening(context2.reference);
        }
        if (lowerText.match(/следующей\s*ночью/)) {
          const daysToAdd = targetDate.hour() < 22 ? 1 : 2;
          targetDate = targetDate.add(daysToAdd, "day");
          dayjs_1.assignSimilarDate(component, targetDate);
          component.imply("hour", 0);
        }
        if (lowerText.match(/в\s*полночь/) || lowerText.endsWith("\u043D\u043E\u0447\u044C\u044E")) {
          return references.midnight(context2.reference);
        }
        return component;
      }
    };
    exports.default = RUCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUWeekdayParser.js
var require_RUWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weekdays_1 = require_weekdays();
    var PATTERN = new RegExp(`(?:(?:,|\\(|\uFF08)\\s*)?(?:\u0432\\s*?)?(?:(\u044D\u0442\u0443|\u044D\u0442\u043E\u0442|\u043F\u0440\u043E\u0448\u043B\u044B\u0439|\u043F\u0440\u043E\u0448\u043B\u0443\u044E|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0439|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0443\u044E|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0433\u043E)\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:,|\\)|\uFF09))?(?:\\s*\u043D\u0430\\s*(\u044D\u0442\u043E\u0439|\u043F\u0440\u043E\u0448\u043B\u043E\u0439|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439)\\s*\u043D\u0435\u0434\u0435\u043B\u0435)?${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var PREFIX_GROUP = 1;
    var WEEKDAY_GROUP = 2;
    var POSTFIX_GROUP = 3;
    var RUWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerExtract(context2, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const weekday = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        const prefix = match[PREFIX_GROUP];
        const postfix = match[POSTFIX_GROUP];
        let modifierWord = prefix || postfix;
        modifierWord = modifierWord || "";
        modifierWord = modifierWord.toLowerCase();
        let modifier = null;
        if (modifierWord == "\u043F\u0440\u043E\u0448\u043B\u044B\u0439" || modifierWord == "\u043F\u0440\u043E\u0448\u043B\u0443\u044E" || modifierWord == "\u043F\u0440\u043E\u0448\u043B\u043E\u0439") {
          modifier = "last";
        } else if (modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0439" || modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0443\u044E" || modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439" || modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0433\u043E") {
          modifier = "next";
        } else if (modifierWord == "\u044D\u0442\u043E\u0442" || modifierWord == "\u044D\u0442\u0443" || modifierWord == "\u044D\u0442\u043E\u0439") {
          modifier = "this";
        }
        return weekdays_1.createParsingComponentsAtWeekday(context2.reference, weekday, modifier);
      }
    };
    exports.default = RUWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RURelativeDateFormatParser.js
var require_RURelativeDateFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RURelativeDateFormatParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var results_1 = require_results();
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var pattern_1 = require_pattern();
    var PATTERN = new RegExp(`(\u0432 \u043F\u0440\u043E\u0448\u043B\u043E\u043C|\u043D\u0430 \u043F\u0440\u043E\u0448\u043B\u043E\u0439|\u043D\u0430 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439|\u0432 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u043C|\u043D\u0430 \u044D\u0442\u043E\u0439|\u0432 \u044D\u0442\u043E\u043C)\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})(?=\\s*)${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var MODIFIER_WORD_GROUP = 1;
    var RELATIVE_WORD_GROUP = 2;
    var RURelativeDateFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();
        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();
        const timeunit = constants_1.TIME_UNIT_DICTIONARY[unitWord];
        if (modifier == "\u043D\u0430 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439" || modifier == "\u0432 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u043C") {
          const timeUnits = {};
          timeUnits[timeunit] = 1;
          return results_1.ParsingComponents.createRelativeFromReference(context2.reference, timeUnits);
        }
        if (modifier == "\u0432 \u043F\u0440\u043E\u0448\u043B\u043E\u043C" || modifier == "\u043D\u0430 \u043F\u0440\u043E\u0448\u043B\u043E\u0439") {
          const timeUnits = {};
          timeUnits[timeunit] = -1;
          return results_1.ParsingComponents.createRelativeFromReference(context2.reference, timeUnits);
        }
        const components = context2.createParsingComponents();
        let date = dayjs_1.default(context2.reference.instant);
        if (timeunit.match(/week/i)) {
          date = date.add(-date.get("d"), "d");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.imply("year", date.year());
        } else if (timeunit.match(/month/i)) {
          date = date.add(-date.date() + 1, "d");
          components.imply("day", date.date());
          components.assign("year", date.year());
          components.assign("month", date.month() + 1);
        } else if (timeunit.match(/year/i)) {
          date = date.add(-date.date() + 1, "d");
          date = date.add(-date.month(), "month");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.assign("year", date.year());
        }
        return components;
      }
    };
    exports.default = RURelativeDateFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitCasualRelativeFormatParser.js
var require_RUTimeUnitCasualRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitCasualRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(\u044D\u0442\u0438|\u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\u0435|\u043F\u0440\u043E\u0448\u043B\u044B\u0435|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0435|\u043F\u043E\u0441\u043B\u0435|\u0447\u0435\u0440\u0435\u0437|\\+|-)\\s*(${constants_1.TIME_UNITS_PATTERN})${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var RUTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context2, match) {
        const prefix = match[1].toLowerCase();
        let timeUnits = constants_1.parseTimeUnits(match[2]);
        switch (prefix) {
          case "\u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\u0435":
          case "\u043F\u0440\u043E\u0448\u043B\u044B\u0435":
          case "-":
            timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
            break;
        }
        return results_1.ParsingComponents.createRelativeFromReference(context2.reference, timeUnits);
      }
    };
    exports.default = RUTimeUnitCasualRelativeFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/index.js
var require_ru = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var RUTimeUnitWithinFormatParser_1 = __importDefault2(require_RUTimeUnitWithinFormatParser());
    var RUMonthNameLittleEndianParser_1 = __importDefault2(require_RUMonthNameLittleEndianParser());
    var RUMonthNameParser_1 = __importDefault2(require_RUMonthNameParser());
    var RUTimeExpressionParser_1 = __importDefault2(require_RUTimeExpressionParser());
    var RUTimeUnitAgoFormatParser_1 = __importDefault2(require_RUTimeUnitAgoFormatParser());
    var RUMergeDateRangeRefiner_1 = __importDefault2(require_RUMergeDateRangeRefiner());
    var RUMergeDateTimeRefiner_1 = __importDefault2(require_RUMergeDateTimeRefiner());
    var configurations_1 = require_configurations();
    var RUCasualDateParser_1 = __importDefault2(require_RUCasualDateParser());
    var RUCasualTimeParser_1 = __importDefault2(require_RUCasualTimeParser());
    var RUWeekdayParser_1 = __importDefault2(require_RUWeekdayParser());
    var RURelativeDateFormatParser_1 = __importDefault2(require_RURelativeDateFormatParser());
    var chrono_1 = require_chrono();
    var SlashDateFormatParser_1 = __importDefault2(require_SlashDateFormatParser());
    var RUTimeUnitCasualRelativeFormatParser_1 = __importDefault2(require_RUTimeUnitCasualRelativeFormatParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse3(text, ref, option) {
      return exports.casual.parse(text, ref, option);
    }
    exports.parse = parse3;
    function parseDate(text, ref, option) {
      return exports.casual.parseDate(text, ref, option);
    }
    exports.parseDate = parseDate;
    function createCasualConfiguration() {
      const option = createConfiguration(false);
      option.parsers.unshift(new RUCasualDateParser_1.default());
      option.parsers.unshift(new RUCasualTimeParser_1.default());
      option.parsers.unshift(new RUMonthNameParser_1.default());
      option.parsers.unshift(new RURelativeDateFormatParser_1.default());
      option.parsers.unshift(new RUTimeUnitCasualRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(true),
          new RUTimeUnitWithinFormatParser_1.default(),
          new RUMonthNameLittleEndianParser_1.default(),
          new RUWeekdayParser_1.default(),
          new RUTimeExpressionParser_1.default(strictMode),
          new RUTimeUnitAgoFormatParser_1.default()
        ],
        refiners: [new RUMergeDateTimeRefiner_1.default(), new RUMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/index.js
var require_dist = __commonJS({
  "node_modules/chrono-node/dist/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o6, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o6, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o6, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o6[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o6, v2) {
      Object.defineProperty(o6, "default", { enumerable: true, value: v2 });
    } : function(o6, v2) {
      o6["default"] = v2;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding2(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseDate = exports.parse = exports.casual = exports.strict = exports.ru = exports.zh = exports.nl = exports.pt = exports.ja = exports.fr = exports.de = exports.Weekday = exports.Meridiem = exports.Chrono = exports.en = void 0;
    var en = __importStar2(require_en());
    exports.en = en;
    var chrono_1 = require_chrono();
    Object.defineProperty(exports, "Chrono", { enumerable: true, get: function() {
      return chrono_1.Chrono;
    } });
    var Meridiem;
    (function(Meridiem2) {
      Meridiem2[Meridiem2["AM"] = 0] = "AM";
      Meridiem2[Meridiem2["PM"] = 1] = "PM";
    })(Meridiem = exports.Meridiem || (exports.Meridiem = {}));
    var Weekday;
    (function(Weekday2) {
      Weekday2[Weekday2["SUNDAY"] = 0] = "SUNDAY";
      Weekday2[Weekday2["MONDAY"] = 1] = "MONDAY";
      Weekday2[Weekday2["TUESDAY"] = 2] = "TUESDAY";
      Weekday2[Weekday2["WEDNESDAY"] = 3] = "WEDNESDAY";
      Weekday2[Weekday2["THURSDAY"] = 4] = "THURSDAY";
      Weekday2[Weekday2["FRIDAY"] = 5] = "FRIDAY";
      Weekday2[Weekday2["SATURDAY"] = 6] = "SATURDAY";
    })(Weekday = exports.Weekday || (exports.Weekday = {}));
    var de = __importStar2(require_de());
    exports.de = de;
    var fr = __importStar2(require_fr());
    exports.fr = fr;
    var ja = __importStar2(require_ja());
    exports.ja = ja;
    var pt = __importStar2(require_pt());
    exports.pt = pt;
    var nl = __importStar2(require_nl());
    exports.nl = nl;
    var zh = __importStar2(require_zh());
    exports.zh = zh;
    var ru = __importStar2(require_ru());
    exports.ru = ru;
    exports.strict = en.strict;
    exports.casual = en.casual;
    function parse3(text, ref, option) {
      return exports.casual.parse(text, ref, option);
    }
    exports.parse = parse3;
    function parseDate(text, ref, option) {
      return exports.casual.parseDate(text, ref, option);
    }
    exports.parseDate = parseDate;
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports, module2) {
    var __extends2;
    var __assign2;
    var __rest2;
    var __decorate2;
    var __param2;
    var __metadata2;
    var __awaiter2;
    var __generator2;
    var __exportStar2;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays2;
    var __spreadArray2;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __classPrivateFieldIn2;
    var __createBinding2;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v2) {
          return exports2[id] = previous ? previous(id, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
        d3.__proto__ = b2;
      } || function(d3, b2) {
        for (var p2 in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p2))
            d3[p2] = b2[p2];
      };
      __extends2 = function(d3, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d3, b2);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign2 = Object.assign || function(t3) {
        for (var s5, i4 = 1, n6 = arguments.length; i4 < n6; i4++) {
          s5 = arguments[i4];
          for (var p2 in s5)
            if (Object.prototype.hasOwnProperty.call(s5, p2))
              t3[p2] = s5[p2];
        }
        return t3;
      };
      __rest2 = function(s5, e7) {
        var t3 = {};
        for (var p2 in s5)
          if (Object.prototype.hasOwnProperty.call(s5, p2) && e7.indexOf(p2) < 0)
            t3[p2] = s5[p2];
        if (s5 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i4 = 0, p2 = Object.getOwnPropertySymbols(s5); i4 < p2.length; i4++) {
            if (e7.indexOf(p2[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s5, p2[i4]))
              t3[p2[i4]] = s5[p2[i4]];
          }
        return t3;
      };
      __decorate2 = function(decorators, target, key, desc) {
        var c3 = arguments.length, r4 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r4 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i4 = decorators.length - 1; i4 >= 0; i4--)
            if (d3 = decorators[i4])
              r4 = (c3 < 3 ? d3(r4) : c3 > 3 ? d3(target, key, r4) : d3(target, key)) || r4;
        return c3 > 3 && r4 && Object.defineProperty(target, key, r4), r4;
      };
      __param2 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata2 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e7) {
              reject(e7);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e7) {
              reject(e7);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _2 = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f2, y2, t3, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n6) {
          return function(v2) {
            return step([n6, v2]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_2)
            try {
              if (f2 = 1, y2 && (t3 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t3 = y2["return"]) && t3.call(y2), 0) : y2.next) && !(t3 = t3.call(y2, op[1])).done)
                return t3;
              if (y2 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _2.label++;
                  return { value: op[1], done: false };
                case 5:
                  _2.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _2.ops.pop();
                  _2.trys.pop();
                  continue;
                default:
                  if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _2 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _2.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _2.label < t3[1]) {
                    _2.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _2.label < t3[2]) {
                    _2.label = t3[2];
                    _2.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _2.ops.pop();
                  _2.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _2);
            } catch (e7) {
              op = [6, e7];
              y2 = 0;
            } finally {
              f2 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar2 = function(m2, o6) {
        for (var p2 in m2)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o6, p2))
            __createBinding2(o6, m2, p2);
      };
      __createBinding2 = Object.create ? function(o6, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m2, k2);
        if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m2[k2];
          } };
        }
        Object.defineProperty(o6, k22, desc);
      } : function(o6, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o6[k22] = m2[k2];
      };
      __values2 = function(o6) {
        var s5 = typeof Symbol === "function" && Symbol.iterator, m2 = s5 && o6[s5], i4 = 0;
        if (m2)
          return m2.call(o6);
        if (o6 && typeof o6.length === "number")
          return {
            next: function() {
              if (o6 && i4 >= o6.length)
                o6 = void 0;
              return { value: o6 && o6[i4++], done: !o6 };
            }
          };
        throw new TypeError(s5 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read2 = function(o6, n6) {
        var m2 = typeof Symbol === "function" && o6[Symbol.iterator];
        if (!m2)
          return o6;
        var i4 = m2.call(o6), r4, ar = [], e7;
        try {
          while ((n6 === void 0 || n6-- > 0) && !(r4 = i4.next()).done)
            ar.push(r4.value);
        } catch (error) {
          e7 = { error };
        } finally {
          try {
            if (r4 && !r4.done && (m2 = i4["return"]))
              m2.call(i4);
          } finally {
            if (e7)
              throw e7.error;
          }
        }
        return ar;
      };
      __spread2 = function() {
        for (var ar = [], i4 = 0; i4 < arguments.length; i4++)
          ar = ar.concat(__read2(arguments[i4]));
        return ar;
      };
      __spreadArrays2 = function() {
        for (var s5 = 0, i4 = 0, il = arguments.length; i4 < il; i4++)
          s5 += arguments[i4].length;
        for (var r4 = Array(s5), k2 = 0, i4 = 0; i4 < il; i4++)
          for (var a3 = arguments[i4], j = 0, jl = a3.length; j < jl; j++, k2++)
            r4[k2] = a3[j];
        return r4;
      };
      __spreadArray2 = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i4 = 0, l5 = from.length, ar; i4 < l5; i4++) {
            if (ar || !(i4 in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i4);
              ar[i4] = from[i4];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await2 = function(v2) {
        return this instanceof __await2 ? (this.v = v2, this) : new __await2(v2);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i4, q = [];
        return i4 = {}, verb("next"), verb("throw"), verb("return"), i4[Symbol.asyncIterator] = function() {
          return this;
        }, i4;
        function verb(n6) {
          if (g2[n6])
            i4[n6] = function(v2) {
              return new Promise(function(a3, b2) {
                q.push([n6, v2, a3, b2]) > 1 || resume(n6, v2);
              });
            };
        }
        function resume(n6, v2) {
          try {
            step(g2[n6](v2));
          } catch (e7) {
            settle(q[0][3], e7);
          }
        }
        function step(r4) {
          r4.value instanceof __await2 ? Promise.resolve(r4.value.v).then(fulfill, reject) : settle(q[0][2], r4);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f2, v2) {
          if (f2(v2), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator2 = function(o6) {
        var i4, p2;
        return i4 = {}, verb("next"), verb("throw", function(e7) {
          throw e7;
        }), verb("return"), i4[Symbol.iterator] = function() {
          return this;
        }, i4;
        function verb(n6, f2) {
          i4[n6] = o6[n6] ? function(v2) {
            return (p2 = !p2) ? { value: __await2(o6[n6](v2)), done: n6 === "return" } : f2 ? f2(v2) : v2;
          } : f2;
        }
      };
      __asyncValues2 = function(o6) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o6[Symbol.asyncIterator], i4;
        return m2 ? m2.call(o6) : (o6 = typeof __values2 === "function" ? __values2(o6) : o6[Symbol.iterator](), i4 = {}, verb("next"), verb("throw"), verb("return"), i4[Symbol.asyncIterator] = function() {
          return this;
        }, i4);
        function verb(n6) {
          i4[n6] = o6[n6] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o6[n6](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d3, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d3 });
          }, reject);
        }
      };
      __makeTemplateObject2 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o6, v2) {
        Object.defineProperty(o6, "default", { enumerable: true, value: v2 });
      } : function(o6, v2) {
        o6["default"] = v2;
      };
      __importStar2 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
              __createBinding2(result, mod, k2);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault2 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, state, kind, f2) {
        if (kind === "a" && !f2)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, state, value, kind, f2) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f2)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
      };
      __classPrivateFieldIn2 = function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate2);
      exporter("__param", __param2);
      exporter("__metadata", __metadata2);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar2);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray2);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn2);
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AppleRemindersPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// node_modules/@lit/reactive-element/css-tag.js
var t = window;
var e = t.ShadowRoot && (t.ShadyCSS === void 0 || t.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s = Symbol();
var n = /* @__PURE__ */ new WeakMap();
var o = class {
  constructor(t3, e7, n6) {
    if (this._$cssResult$ = true, n6 !== s)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t3, this.t = e7;
  }
  get styleSheet() {
    let t3 = this.o;
    const s5 = this.t;
    if (e && t3 === void 0) {
      const e7 = s5 !== void 0 && s5.length === 1;
      e7 && (t3 = n.get(s5)), t3 === void 0 && ((this.o = t3 = new CSSStyleSheet()).replaceSync(this.cssText), e7 && n.set(s5, t3));
    }
    return t3;
  }
  toString() {
    return this.cssText;
  }
};
var r = (t3) => new o(typeof t3 == "string" ? t3 : t3 + "", void 0, s);
var i = (t3, ...e7) => {
  const n6 = t3.length === 1 ? t3[0] : e7.reduce((e8, s5, n7) => e8 + ((t4) => {
    if (t4._$cssResult$ === true)
      return t4.cssText;
    if (typeof t4 == "number")
      return t4;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t4 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s5) + t3[n7 + 1], t3[0]);
  return new o(n6, t3, s);
};
var S = (s5, n6) => {
  e ? s5.adoptedStyleSheets = n6.map((t3) => t3 instanceof CSSStyleSheet ? t3 : t3.styleSheet) : n6.forEach((e7) => {
    const n7 = document.createElement("style"), o6 = t.litNonce;
    o6 !== void 0 && n7.setAttribute("nonce", o6), n7.textContent = e7.cssText, s5.appendChild(n7);
  });
};
var c = e ? (t3) => t3 : (t3) => t3 instanceof CSSStyleSheet ? ((t4) => {
  let e7 = "";
  for (const s5 of t4.cssRules)
    e7 += s5.cssText;
  return r(e7);
})(t3) : t3;

// node_modules/@lit/reactive-element/reactive-element.js
var s2;
var e2 = window;
var r2 = e2.trustedTypes;
var h = r2 ? r2.emptyScript : "";
var o2 = e2.reactiveElementPolyfillSupport;
var n2 = { toAttribute(t3, i4) {
  switch (i4) {
    case Boolean:
      t3 = t3 ? h : null;
      break;
    case Object:
    case Array:
      t3 = t3 == null ? t3 : JSON.stringify(t3);
  }
  return t3;
}, fromAttribute(t3, i4) {
  let s5 = t3;
  switch (i4) {
    case Boolean:
      s5 = t3 !== null;
      break;
    case Number:
      s5 = t3 === null ? null : Number(t3);
      break;
    case Object:
    case Array:
      try {
        s5 = JSON.parse(t3);
      } catch (t4) {
        s5 = null;
      }
  }
  return s5;
} };
var a = (t3, i4) => i4 !== t3 && (i4 == i4 || t3 == t3);
var l = { attribute: true, type: String, converter: n2, reflect: false, hasChanged: a };
var d = class extends HTMLElement {
  constructor() {
    super(), this._$Ei = /* @__PURE__ */ new Map(), this.isUpdatePending = false, this.hasUpdated = false, this._$El = null, this.u();
  }
  static addInitializer(t3) {
    var i4;
    (i4 = this.h) !== null && i4 !== void 0 || (this.h = []), this.h.push(t3);
  }
  static get observedAttributes() {
    this.finalize();
    const t3 = [];
    return this.elementProperties.forEach((i4, s5) => {
      const e7 = this._$Ep(s5, i4);
      e7 !== void 0 && (this._$Ev.set(e7, s5), t3.push(e7));
    }), t3;
  }
  static createProperty(t3, i4 = l) {
    if (i4.state && (i4.attribute = false), this.finalize(), this.elementProperties.set(t3, i4), !i4.noAccessor && !this.prototype.hasOwnProperty(t3)) {
      const s5 = typeof t3 == "symbol" ? Symbol() : "__" + t3, e7 = this.getPropertyDescriptor(t3, s5, i4);
      e7 !== void 0 && Object.defineProperty(this.prototype, t3, e7);
    }
  }
  static getPropertyDescriptor(t3, i4, s5) {
    return { get() {
      return this[i4];
    }, set(e7) {
      const r4 = this[t3];
      this[i4] = e7, this.requestUpdate(t3, r4, s5);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t3) {
    return this.elementProperties.get(t3) || l;
  }
  static finalize() {
    if (this.hasOwnProperty("finalized"))
      return false;
    this.finalized = true;
    const t3 = Object.getPrototypeOf(this);
    if (t3.finalize(), this.elementProperties = new Map(t3.elementProperties), this._$Ev = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
      const t4 = this.properties, i4 = [...Object.getOwnPropertyNames(t4), ...Object.getOwnPropertySymbols(t4)];
      for (const s5 of i4)
        this.createProperty(s5, t4[s5]);
    }
    return this.elementStyles = this.finalizeStyles(this.styles), true;
  }
  static finalizeStyles(i4) {
    const s5 = [];
    if (Array.isArray(i4)) {
      const e7 = new Set(i4.flat(1 / 0).reverse());
      for (const i5 of e7)
        s5.unshift(c(i5));
    } else
      i4 !== void 0 && s5.push(c(i4));
    return s5;
  }
  static _$Ep(t3, i4) {
    const s5 = i4.attribute;
    return s5 === false ? void 0 : typeof s5 == "string" ? s5 : typeof t3 == "string" ? t3.toLowerCase() : void 0;
  }
  u() {
    var t3;
    this._$E_ = new Promise((t4) => this.enableUpdating = t4), this._$AL = /* @__PURE__ */ new Map(), this._$Eg(), this.requestUpdate(), (t3 = this.constructor.h) === null || t3 === void 0 || t3.forEach((t4) => t4(this));
  }
  addController(t3) {
    var i4, s5;
    ((i4 = this._$ES) !== null && i4 !== void 0 ? i4 : this._$ES = []).push(t3), this.renderRoot !== void 0 && this.isConnected && ((s5 = t3.hostConnected) === null || s5 === void 0 || s5.call(t3));
  }
  removeController(t3) {
    var i4;
    (i4 = this._$ES) === null || i4 === void 0 || i4.splice(this._$ES.indexOf(t3) >>> 0, 1);
  }
  _$Eg() {
    this.constructor.elementProperties.forEach((t3, i4) => {
      this.hasOwnProperty(i4) && (this._$Ei.set(i4, this[i4]), delete this[i4]);
    });
  }
  createRenderRoot() {
    var t3;
    const s5 = (t3 = this.shadowRoot) !== null && t3 !== void 0 ? t3 : this.attachShadow(this.constructor.shadowRootOptions);
    return S(s5, this.constructor.elementStyles), s5;
  }
  connectedCallback() {
    var t3;
    this.renderRoot === void 0 && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), (t3 = this._$ES) === null || t3 === void 0 || t3.forEach((t4) => {
      var i4;
      return (i4 = t4.hostConnected) === null || i4 === void 0 ? void 0 : i4.call(t4);
    });
  }
  enableUpdating(t3) {
  }
  disconnectedCallback() {
    var t3;
    (t3 = this._$ES) === null || t3 === void 0 || t3.forEach((t4) => {
      var i4;
      return (i4 = t4.hostDisconnected) === null || i4 === void 0 ? void 0 : i4.call(t4);
    });
  }
  attributeChangedCallback(t3, i4, s5) {
    this._$AK(t3, s5);
  }
  _$EO(t3, i4, s5 = l) {
    var e7;
    const r4 = this.constructor._$Ep(t3, s5);
    if (r4 !== void 0 && s5.reflect === true) {
      const h3 = (((e7 = s5.converter) === null || e7 === void 0 ? void 0 : e7.toAttribute) !== void 0 ? s5.converter : n2).toAttribute(i4, s5.type);
      this._$El = t3, h3 == null ? this.removeAttribute(r4) : this.setAttribute(r4, h3), this._$El = null;
    }
  }
  _$AK(t3, i4) {
    var s5;
    const e7 = this.constructor, r4 = e7._$Ev.get(t3);
    if (r4 !== void 0 && this._$El !== r4) {
      const t4 = e7.getPropertyOptions(r4), h3 = typeof t4.converter == "function" ? { fromAttribute: t4.converter } : ((s5 = t4.converter) === null || s5 === void 0 ? void 0 : s5.fromAttribute) !== void 0 ? t4.converter : n2;
      this._$El = r4, this[r4] = h3.fromAttribute(i4, t4.type), this._$El = null;
    }
  }
  requestUpdate(t3, i4, s5) {
    let e7 = true;
    t3 !== void 0 && (((s5 = s5 || this.constructor.getPropertyOptions(t3)).hasChanged || a)(this[t3], i4) ? (this._$AL.has(t3) || this._$AL.set(t3, i4), s5.reflect === true && this._$El !== t3 && (this._$EC === void 0 && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(t3, s5))) : e7 = false), !this.isUpdatePending && e7 && (this._$E_ = this._$Ej());
  }
  _$Ej() {
    return __async(this, null, function* () {
      this.isUpdatePending = true;
      try {
        yield this._$E_;
      } catch (t4) {
        Promise.reject(t4);
      }
      const t3 = this.scheduleUpdate();
      return t3 != null && (yield t3), !this.isUpdatePending;
    });
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var t3;
    if (!this.isUpdatePending)
      return;
    this.hasUpdated, this._$Ei && (this._$Ei.forEach((t4, i5) => this[i5] = t4), this._$Ei = void 0);
    let i4 = false;
    const s5 = this._$AL;
    try {
      i4 = this.shouldUpdate(s5), i4 ? (this.willUpdate(s5), (t3 = this._$ES) === null || t3 === void 0 || t3.forEach((t4) => {
        var i5;
        return (i5 = t4.hostUpdate) === null || i5 === void 0 ? void 0 : i5.call(t4);
      }), this.update(s5)) : this._$Ek();
    } catch (t4) {
      throw i4 = false, this._$Ek(), t4;
    }
    i4 && this._$AE(s5);
  }
  willUpdate(t3) {
  }
  _$AE(t3) {
    var i4;
    (i4 = this._$ES) === null || i4 === void 0 || i4.forEach((t4) => {
      var i5;
      return (i5 = t4.hostUpdated) === null || i5 === void 0 ? void 0 : i5.call(t4);
    }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t3)), this.updated(t3);
  }
  _$Ek() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$E_;
  }
  shouldUpdate(t3) {
    return true;
  }
  update(t3) {
    this._$EC !== void 0 && (this._$EC.forEach((t4, i4) => this._$EO(i4, this[i4], t4)), this._$EC = void 0), this._$Ek();
  }
  updated(t3) {
  }
  firstUpdated(t3) {
  }
};
d.finalized = true, d.elementProperties = /* @__PURE__ */ new Map(), d.elementStyles = [], d.shadowRootOptions = { mode: "open" }, o2 == null || o2({ ReactiveElement: d }), ((s2 = e2.reactiveElementVersions) !== null && s2 !== void 0 ? s2 : e2.reactiveElementVersions = []).push("1.4.1");

// node_modules/lit-html/lit-html.js
var t2;
var i2 = window;
var s3 = i2.trustedTypes;
var e3 = s3 ? s3.createPolicy("lit-html", { createHTML: (t3) => t3 }) : void 0;
var o3 = `lit$${(Math.random() + "").slice(9)}$`;
var n3 = "?" + o3;
var l2 = `<${n3}>`;
var h2 = document;
var r3 = (t3 = "") => h2.createComment(t3);
var d2 = (t3) => t3 === null || typeof t3 != "object" && typeof t3 != "function";
var u = Array.isArray;
var c2 = (t3) => u(t3) || typeof (t3 == null ? void 0 : t3[Symbol.iterator]) == "function";
var v = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var a2 = /-->/g;
var f = />/g;
var _ = RegExp(`>|[ 	
\f\r](?:([^\\s"'>=/]+)([ 	
\f\r]*=[ 	
\f\r]*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var m = /'/g;
var p = /"/g;
var $ = /^(?:script|style|textarea|title)$/i;
var g = (t3) => (i4, ...s5) => ({ _$litType$: t3, strings: i4, values: s5 });
var y = g(1);
var w = g(2);
var x = Symbol.for("lit-noChange");
var b = Symbol.for("lit-nothing");
var T = /* @__PURE__ */ new WeakMap();
var A = (t3, i4, s5) => {
  var e7, o6;
  const n6 = (e7 = s5 == null ? void 0 : s5.renderBefore) !== null && e7 !== void 0 ? e7 : i4;
  let l5 = n6._$litPart$;
  if (l5 === void 0) {
    const t4 = (o6 = s5 == null ? void 0 : s5.renderBefore) !== null && o6 !== void 0 ? o6 : null;
    n6._$litPart$ = l5 = new S2(i4.insertBefore(r3(), t4), t4, void 0, s5 != null ? s5 : {});
  }
  return l5._$AI(t3), l5;
};
var E = h2.createTreeWalker(h2, 129, null, false);
var C = (t3, i4) => {
  const s5 = t3.length - 1, n6 = [];
  let h3, r4 = i4 === 2 ? "<svg>" : "", d3 = v;
  for (let i5 = 0; i5 < s5; i5++) {
    const s6 = t3[i5];
    let e7, u3, c3 = -1, g2 = 0;
    for (; g2 < s6.length && (d3.lastIndex = g2, u3 = d3.exec(s6), u3 !== null); )
      g2 = d3.lastIndex, d3 === v ? u3[1] === "!--" ? d3 = a2 : u3[1] !== void 0 ? d3 = f : u3[2] !== void 0 ? ($.test(u3[2]) && (h3 = RegExp("</" + u3[2], "g")), d3 = _) : u3[3] !== void 0 && (d3 = _) : d3 === _ ? u3[0] === ">" ? (d3 = h3 != null ? h3 : v, c3 = -1) : u3[1] === void 0 ? c3 = -2 : (c3 = d3.lastIndex - u3[2].length, e7 = u3[1], d3 = u3[3] === void 0 ? _ : u3[3] === '"' ? p : m) : d3 === p || d3 === m ? d3 = _ : d3 === a2 || d3 === f ? d3 = v : (d3 = _, h3 = void 0);
    const y2 = d3 === _ && t3[i5 + 1].startsWith("/>") ? " " : "";
    r4 += d3 === v ? s6 + l2 : c3 >= 0 ? (n6.push(e7), s6.slice(0, c3) + "$lit$" + s6.slice(c3) + o3 + y2) : s6 + o3 + (c3 === -2 ? (n6.push(void 0), i5) : y2);
  }
  const u2 = r4 + (t3[s5] || "<?>") + (i4 === 2 ? "</svg>" : "");
  if (!Array.isArray(t3) || !t3.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return [e3 !== void 0 ? e3.createHTML(u2) : u2, n6];
};
var P = class {
  constructor({ strings: t3, _$litType$: i4 }, e7) {
    let l5;
    this.parts = [];
    let h3 = 0, d3 = 0;
    const u2 = t3.length - 1, c3 = this.parts, [v2, a3] = C(t3, i4);
    if (this.el = P.createElement(v2, e7), E.currentNode = this.el.content, i4 === 2) {
      const t4 = this.el.content, i5 = t4.firstChild;
      i5.remove(), t4.append(...i5.childNodes);
    }
    for (; (l5 = E.nextNode()) !== null && c3.length < u2; ) {
      if (l5.nodeType === 1) {
        if (l5.hasAttributes()) {
          const t4 = [];
          for (const i5 of l5.getAttributeNames())
            if (i5.endsWith("$lit$") || i5.startsWith(o3)) {
              const s5 = a3[d3++];
              if (t4.push(i5), s5 !== void 0) {
                const t5 = l5.getAttribute(s5.toLowerCase() + "$lit$").split(o3), i6 = /([.?@])?(.*)/.exec(s5);
                c3.push({ type: 1, index: h3, name: i6[2], strings: t5, ctor: i6[1] === "." ? R : i6[1] === "?" ? H : i6[1] === "@" ? I : M });
              } else
                c3.push({ type: 6, index: h3 });
            }
          for (const i5 of t4)
            l5.removeAttribute(i5);
        }
        if ($.test(l5.tagName)) {
          const t4 = l5.textContent.split(o3), i5 = t4.length - 1;
          if (i5 > 0) {
            l5.textContent = s3 ? s3.emptyScript : "";
            for (let s5 = 0; s5 < i5; s5++)
              l5.append(t4[s5], r3()), E.nextNode(), c3.push({ type: 2, index: ++h3 });
            l5.append(t4[i5], r3());
          }
        }
      } else if (l5.nodeType === 8)
        if (l5.data === n3)
          c3.push({ type: 2, index: h3 });
        else {
          let t4 = -1;
          for (; (t4 = l5.data.indexOf(o3, t4 + 1)) !== -1; )
            c3.push({ type: 7, index: h3 }), t4 += o3.length - 1;
        }
      h3++;
    }
  }
  static createElement(t3, i4) {
    const s5 = h2.createElement("template");
    return s5.innerHTML = t3, s5;
  }
};
function V(t3, i4, s5 = t3, e7) {
  var o6, n6, l5, h3;
  if (i4 === x)
    return i4;
  let r4 = e7 !== void 0 ? (o6 = s5._$Cl) === null || o6 === void 0 ? void 0 : o6[e7] : s5._$Cu;
  const u2 = d2(i4) ? void 0 : i4._$litDirective$;
  return (r4 == null ? void 0 : r4.constructor) !== u2 && ((n6 = r4 == null ? void 0 : r4._$AO) === null || n6 === void 0 || n6.call(r4, false), u2 === void 0 ? r4 = void 0 : (r4 = new u2(t3), r4._$AT(t3, s5, e7)), e7 !== void 0 ? ((l5 = (h3 = s5)._$Cl) !== null && l5 !== void 0 ? l5 : h3._$Cl = [])[e7] = r4 : s5._$Cu = r4), r4 !== void 0 && (i4 = V(t3, r4._$AS(t3, i4.values), r4, e7)), i4;
}
var N = class {
  constructor(t3, i4) {
    this.v = [], this._$AN = void 0, this._$AD = t3, this._$AM = i4;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  p(t3) {
    var i4;
    const { el: { content: s5 }, parts: e7 } = this._$AD, o6 = ((i4 = t3 == null ? void 0 : t3.creationScope) !== null && i4 !== void 0 ? i4 : h2).importNode(s5, true);
    E.currentNode = o6;
    let n6 = E.nextNode(), l5 = 0, r4 = 0, d3 = e7[0];
    for (; d3 !== void 0; ) {
      if (l5 === d3.index) {
        let i5;
        d3.type === 2 ? i5 = new S2(n6, n6.nextSibling, this, t3) : d3.type === 1 ? i5 = new d3.ctor(n6, d3.name, d3.strings, this, t3) : d3.type === 6 && (i5 = new L(n6, this, t3)), this.v.push(i5), d3 = e7[++r4];
      }
      l5 !== (d3 == null ? void 0 : d3.index) && (n6 = E.nextNode(), l5++);
    }
    return o6;
  }
  m(t3) {
    let i4 = 0;
    for (const s5 of this.v)
      s5 !== void 0 && (s5.strings !== void 0 ? (s5._$AI(t3, s5, i4), i4 += s5.strings.length - 2) : s5._$AI(t3[i4])), i4++;
  }
};
var S2 = class {
  constructor(t3, i4, s5, e7) {
    var o6;
    this.type = 2, this._$AH = b, this._$AN = void 0, this._$AA = t3, this._$AB = i4, this._$AM = s5, this.options = e7, this._$C_ = (o6 = e7 == null ? void 0 : e7.isConnected) === null || o6 === void 0 || o6;
  }
  get _$AU() {
    var t3, i4;
    return (i4 = (t3 = this._$AM) === null || t3 === void 0 ? void 0 : t3._$AU) !== null && i4 !== void 0 ? i4 : this._$C_;
  }
  get parentNode() {
    let t3 = this._$AA.parentNode;
    const i4 = this._$AM;
    return i4 !== void 0 && t3.nodeType === 11 && (t3 = i4.parentNode), t3;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t3, i4 = this) {
    t3 = V(this, t3, i4), d2(t3) ? t3 === b || t3 == null || t3 === "" ? (this._$AH !== b && this._$AR(), this._$AH = b) : t3 !== this._$AH && t3 !== x && this.$(t3) : t3._$litType$ !== void 0 ? this.T(t3) : t3.nodeType !== void 0 ? this.k(t3) : c2(t3) ? this.O(t3) : this.$(t3);
  }
  S(t3, i4 = this._$AB) {
    return this._$AA.parentNode.insertBefore(t3, i4);
  }
  k(t3) {
    this._$AH !== t3 && (this._$AR(), this._$AH = this.S(t3));
  }
  $(t3) {
    this._$AH !== b && d2(this._$AH) ? this._$AA.nextSibling.data = t3 : this.k(h2.createTextNode(t3)), this._$AH = t3;
  }
  T(t3) {
    var i4;
    const { values: s5, _$litType$: e7 } = t3, o6 = typeof e7 == "number" ? this._$AC(t3) : (e7.el === void 0 && (e7.el = P.createElement(e7.h, this.options)), e7);
    if (((i4 = this._$AH) === null || i4 === void 0 ? void 0 : i4._$AD) === o6)
      this._$AH.m(s5);
    else {
      const t4 = new N(o6, this), i5 = t4.p(this.options);
      t4.m(s5), this.k(i5), this._$AH = t4;
    }
  }
  _$AC(t3) {
    let i4 = T.get(t3.strings);
    return i4 === void 0 && T.set(t3.strings, i4 = new P(t3)), i4;
  }
  O(t3) {
    u(this._$AH) || (this._$AH = [], this._$AR());
    const i4 = this._$AH;
    let s5, e7 = 0;
    for (const o6 of t3)
      e7 === i4.length ? i4.push(s5 = new S2(this.S(r3()), this.S(r3()), this, this.options)) : s5 = i4[e7], s5._$AI(o6), e7++;
    e7 < i4.length && (this._$AR(s5 && s5._$AB.nextSibling, e7), i4.length = e7);
  }
  _$AR(t3 = this._$AA.nextSibling, i4) {
    var s5;
    for ((s5 = this._$AP) === null || s5 === void 0 || s5.call(this, false, true, i4); t3 && t3 !== this._$AB; ) {
      const i5 = t3.nextSibling;
      t3.remove(), t3 = i5;
    }
  }
  setConnected(t3) {
    var i4;
    this._$AM === void 0 && (this._$C_ = t3, (i4 = this._$AP) === null || i4 === void 0 || i4.call(this, t3));
  }
};
var M = class {
  constructor(t3, i4, s5, e7, o6) {
    this.type = 1, this._$AH = b, this._$AN = void 0, this.element = t3, this.name = i4, this._$AM = e7, this.options = o6, s5.length > 2 || s5[0] !== "" || s5[1] !== "" ? (this._$AH = Array(s5.length - 1).fill(new String()), this.strings = s5) : this._$AH = b;
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t3, i4 = this, s5, e7) {
    const o6 = this.strings;
    let n6 = false;
    if (o6 === void 0)
      t3 = V(this, t3, i4, 0), n6 = !d2(t3) || t3 !== this._$AH && t3 !== x, n6 && (this._$AH = t3);
    else {
      const e8 = t3;
      let l5, h3;
      for (t3 = o6[0], l5 = 0; l5 < o6.length - 1; l5++)
        h3 = V(this, e8[s5 + l5], i4, l5), h3 === x && (h3 = this._$AH[l5]), n6 || (n6 = !d2(h3) || h3 !== this._$AH[l5]), h3 === b ? t3 = b : t3 !== b && (t3 += (h3 != null ? h3 : "") + o6[l5 + 1]), this._$AH[l5] = h3;
    }
    n6 && !e7 && this.P(t3);
  }
  P(t3) {
    t3 === b ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t3 != null ? t3 : "");
  }
};
var R = class extends M {
  constructor() {
    super(...arguments), this.type = 3;
  }
  P(t3) {
    this.element[this.name] = t3 === b ? void 0 : t3;
  }
};
var k = s3 ? s3.emptyScript : "";
var H = class extends M {
  constructor() {
    super(...arguments), this.type = 4;
  }
  P(t3) {
    t3 && t3 !== b ? this.element.setAttribute(this.name, k) : this.element.removeAttribute(this.name);
  }
};
var I = class extends M {
  constructor(t3, i4, s5, e7, o6) {
    super(t3, i4, s5, e7, o6), this.type = 5;
  }
  _$AI(t3, i4 = this) {
    var s5;
    if ((t3 = (s5 = V(this, t3, i4, 0)) !== null && s5 !== void 0 ? s5 : b) === x)
      return;
    const e7 = this._$AH, o6 = t3 === b && e7 !== b || t3.capture !== e7.capture || t3.once !== e7.once || t3.passive !== e7.passive, n6 = t3 !== b && (e7 === b || o6);
    o6 && this.element.removeEventListener(this.name, this, e7), n6 && this.element.addEventListener(this.name, this, t3), this._$AH = t3;
  }
  handleEvent(t3) {
    var i4, s5;
    typeof this._$AH == "function" ? this._$AH.call((s5 = (i4 = this.options) === null || i4 === void 0 ? void 0 : i4.host) !== null && s5 !== void 0 ? s5 : this.element, t3) : this._$AH.handleEvent(t3);
  }
};
var L = class {
  constructor(t3, i4, s5) {
    this.element = t3, this.type = 6, this._$AN = void 0, this._$AM = i4, this.options = s5;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t3) {
    V(this, t3);
  }
};
var Z = i2.litHtmlPolyfillSupport;
Z == null || Z(P, S2), ((t2 = i2.litHtmlVersions) !== null && t2 !== void 0 ? t2 : i2.litHtmlVersions = []).push("2.3.1");

// node_modules/lit-element/lit-element.js
var l3;
var o4;
var s4 = class extends d {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var t3, e7;
    const i4 = super.createRenderRoot();
    return (t3 = (e7 = this.renderOptions).renderBefore) !== null && t3 !== void 0 || (e7.renderBefore = i4.firstChild), i4;
  }
  update(t3) {
    const i4 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t3), this._$Do = A(i4, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t3;
    super.connectedCallback(), (t3 = this._$Do) === null || t3 === void 0 || t3.setConnected(true);
  }
  disconnectedCallback() {
    var t3;
    super.disconnectedCallback(), (t3 = this._$Do) === null || t3 === void 0 || t3.setConnected(false);
  }
  render() {
    return x;
  }
};
s4.finalized = true, s4._$litElement$ = true, (l3 = globalThis.litElementHydrateSupport) === null || l3 === void 0 || l3.call(globalThis, { LitElement: s4 });
var n4 = globalThis.litElementPolyfillSupport;
n4 == null || n4({ LitElement: s4 });
((o4 = globalThis.litElementVersions) !== null && o4 !== void 0 ? o4 : globalThis.litElementVersions = []).push("3.2.2");

// node_modules/@lit/reactive-element/decorators/custom-element.js
var e4 = (e7) => (n6) => typeof n6 == "function" ? ((e8, n7) => (customElements.define(e8, n7), n7))(e7, n6) : ((e8, n7) => {
  const { kind: t3, elements: s5 } = n7;
  return { kind: t3, elements: s5, finisher(n8) {
    customElements.define(e8, n8);
  } };
})(e7, n6);

// node_modules/@lit/reactive-element/decorators/property.js
var i3 = (i4, e7) => e7.kind === "method" && e7.descriptor && !("value" in e7.descriptor) ? __spreadProps(__spreadValues({}, e7), { finisher(n6) {
  n6.createProperty(e7.key, i4);
} }) : { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: e7.key, initializer() {
  typeof e7.initializer == "function" && (this[e7.key] = e7.initializer.call(this));
}, finisher(n6) {
  n6.createProperty(e7.key, i4);
} };
function e5(e7) {
  return (n6, t3) => t3 !== void 0 ? ((i4, e8, n7) => {
    e8.constructor.createProperty(n7, i4);
  })(e7, n6, t3) : i3(e7, n6);
}

// node_modules/@lit/reactive-element/decorators/query-assigned-elements.js
var n5;
var e6 = ((n5 = window.HTMLSlotElement) === null || n5 === void 0 ? void 0 : n5.prototype.assignedElements) != null ? (o6, n6) => o6.assignedElements(n6) : (o6, n6) => o6.assignedNodes(n6).filter((o7) => o7.nodeType === Node.ELEMENT_NODE);

// src/data/apple-integration.ts
var import_node_osascript = __toESM(require_lib());
var executor = (script, variables = null) => __async(void 0, null, function* () {
  return new Promise((resolve, reject) => {
    let childProcess = import_node_osascript.default.execute(script, variables, (err, res, raw) => {
      if (err)
        reject(err);
      resolve(res);
    });
    setTimeout(() => {
      childProcess.stdin.pause();
      childProcess.kill();
      reject("Apple Script timed out");
    }, 3e4);
  });
});

// src/ui/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  autoRefreshTime: 60
};
var SampleSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Apple Reminders Plugin" });
    new import_obsidian.Setting(containerEl).setName("Auto Refresh Time (seconds)").setDesc("Please input time in seconds. This controls the interval between which the plugin automatically refreshes with Apple Reminders. (Restart Obsidian for changes to take affect)").setTooltip("300 seconds = 5 minutes").addSlider((text) => text.setLimits(60, 600, 10).setValue(this.plugin.settings.autoRefreshTime).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.autoRefreshTime = value;
      yield this.plugin.saveSettings();
    })));
  }
};

// src/data/utilities.ts
var chrono = __toESM(require_dist());
var import_obsidian2 = require("obsidian");

// src/data/constants.ts
var APPLE_DATE_FORMAT = "dddd, DD MMMM at H:m:ss";

// src/data/utilities.ts
function predicate(reminder, filters, filename) {
  var match = true;
  if (filters == null)
    return true;
  filters.forEach((filter) => {
    if (filter != null) {
      if (filter.date != null) {
        if (reminder["due date"] == "missing value") {
          match && (match = false);
        } else {
          var date = filter.date == "daily note" ? filename : filter.date;
          if (date) {
            var range = chrono.parse(date)[0];
            var start = (0, import_obsidian2.moment)(range.start.date());
            if (range.end != null) {
              var end = (0, import_obsidian2.moment)(range.end.date());
              match && (match = (0, import_obsidian2.moment)(reminder["due date"], APPLE_DATE_FORMAT).isBetween(start, end, "day", "[]"));
            } else {
              match && (match = (0, import_obsidian2.moment)(reminder["due date"], APPLE_DATE_FORMAT).isSame(start, "day"));
            }
          }
        }
      }
      if (filter.priority != null) {
        var priority = 0;
        switch (filter.priority) {
          case "high":
            priority = 1;
            break;
          case "medium":
            priority = 5;
            break;
          case "low":
            priority = 9;
            break;
          default:
            priority = 0;
        }
        match && (match = reminder.priority == priority);
      }
    }
  });
  return match;
}

// src/data/reminders-data.service.ts
var RemindersDataService = function() {
  let logger = console.log;
  let settings = DEFAULT_SETTINGS;
  const getAllLists = () => __async(this, null, function* () {
    logger("Getting all lists");
    return yield executor(`tell application "Reminders" to return properties of lists`);
  });
  const getList = (list_name) => __async(this, null, function* () {
    logger("Looking for " + list_name);
    let ret = yield executor(`tell application "Reminders"
                        try
                            return properties of list list_name
                        on error
                            set lis to make new list
                            set name of lis to list_name
                            return properties of lis
                        end try
                    end tell`, { list_name });
    logger("Done", 3e3);
    return ret;
  });
  const getReminders = (list_name, filters) => __async(this, null, function* () {
    logger("Getting reminders in " + list_name);
    let x2 = yield executor(`tell list list_name in application "Reminders"
                        set buffer to ((current date) - hours * 1)
                        return properties of reminders whose completion date comes after buffer or completed is false	
                    end tell`, { list_name });
    logger("Done", 3e3);
    if (!Array.isArray(x2))
      return [];
    if (filters) {
      x2 = x2.filter((value) => predicate(value, filters, null));
    }
    return x2;
  });
  const getOrCreateReminder = (list_name, reminder_name) => __async(this, null, function* () {
    logger("Looking for " + reminder_name + " in " + list_name + " before attempting to create");
    return yield executor(`tell list list_name in application "Reminders"
                                    try
                                        return properties of reminder reminder_name
                                    on error
                                        set rem to make new reminder
                                        set name of rem to reminder_name
                                        return properties of rem
                                    end try
                                end tell`, { list_name, reminder_name });
  });
  const refreshReminder = (reminderId) => {
  };
  const toggleReminderDoneStatus = (list_name, reminder_name) => __async(this, null, function* () {
    logger("Toggling Reminder: " + reminder_name + " in list " + list_name);
    let ret = yield executor(`tell list list_name in application "Reminders"
                                    set rem to reminder reminder_name
                                    set completed in rem to not completed in rem
                                    return properties of rem
                                end tell`, { list_name, reminder_name });
    logger("Done", 3e3);
    return ret;
  });
  return {
    getAllLists,
    getList,
    getReminders,
    getOrCreateReminder,
    refreshReminder,
    toggleReminderDoneStatus,
    setLogger: (func) => {
      logger = (x2, clearAfter) => {
        func(x2, clearAfter);
      };
    },
    setSettings: (_settings) => {
      settings = _settings;
    },
    fetchData: (spec, fileName = null) => {
      return Promise.all([
        getList(spec.list),
        getReminders(spec["list"], spec["filters"])
      ]);
    },
    getSettings: () => settings
  };
}();

// src/ui/loading-bar.element.ts
var LoadingBarComponent = class extends s4 {
  render() {
    return w`
<!-- <?xml version="1.0" encoding="utf-8"?> -->
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="margin: auto; background-image: none; display: block; shape-rendering: auto;" width="100px" height="100px" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid">
<g transform="rotate(0 50 50)">
  <rect x="47" y="24" rx="3" ry="6" width="6" height="12" fill="#000000">
    <animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.9166666666666666s" repeatCount="indefinite"></animate>
  </rect>
</g><g transform="rotate(30 50 50)">
  <rect x="47" y="24" rx="3" ry="6" width="6" height="12" fill="#000000">
    <animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.8333333333333334s" repeatCount="indefinite"></animate>
  </rect>
</g><g transform="rotate(60 50 50)">
  <rect x="47" y="24" rx="3" ry="6" width="6" height="12" fill="#000000">
    <animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.75s" repeatCount="indefinite"></animate>
  </rect>
</g><g transform="rotate(90 50 50)">
  <rect x="47" y="24" rx="3" ry="6" width="6" height="12" fill="#000000">
    <animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.6666666666666666s" repeatCount="indefinite"></animate>
  </rect>
</g><g transform="rotate(120 50 50)">
  <rect x="47" y="24" rx="3" ry="6" width="6" height="12" fill="#000000">
    <animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.5833333333333334s" repeatCount="indefinite"></animate>
  </rect>
</g><g transform="rotate(150 50 50)">
  <rect x="47" y="24" rx="3" ry="6" width="6" height="12" fill="#000000">
    <animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.5s" repeatCount="indefinite"></animate>
  </rect>
</g><g transform="rotate(180 50 50)">
  <rect x="47" y="24" rx="3" ry="6" width="6" height="12" fill="#000000">
    <animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.4166666666666667s" repeatCount="indefinite"></animate>
  </rect>
</g><g transform="rotate(210 50 50)">
  <rect x="47" y="24" rx="3" ry="6" width="6" height="12" fill="#000000">
    <animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.3333333333333333s" repeatCount="indefinite"></animate>
  </rect>
</g><g transform="rotate(240 50 50)">
  <rect x="47" y="24" rx="3" ry="6" width="6" height="12" fill="#000000">
    <animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.25s" repeatCount="indefinite"></animate>
  </rect>
</g><g transform="rotate(270 50 50)">
  <rect x="47" y="24" rx="3" ry="6" width="6" height="12" fill="#000000">
    <animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.16666666666666666s" repeatCount="indefinite"></animate>
  </rect>
</g><g transform="rotate(300 50 50)">
  <rect x="47" y="24" rx="3" ry="6" width="6" height="12" fill="#000000">
    <animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.08333333333333333s" repeatCount="indefinite"></animate>
  </rect>
</g><g transform="rotate(330 50 50)">
  <rect x="47" y="24" rx="3" ry="6" width="6" height="12" fill="#000000">
    <animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="0s" repeatCount="indefinite"></animate>
  </rect>
</g>
</svg>
		`;
  }
};
LoadingBarComponent = __decorateClass([
  e4("apple-list-loading-bar")
], LoadingBarComponent);

// src/ui/reminder.element.ts
var import_obsidian3 = require("obsidian");
var ReminderElement = class extends s4 {
  onCheckboxChange(event) {
    RemindersDataService.toggleReminderDoneStatus(this.list_name, this.model.name).then((rem) => {
      this.model = rem;
    });
  }
  render() {
    return y`
			<span class="apple-reminder-container">
				<input
					type="checkbox"
					class="checkbox-round"
					@change=${this.onCheckboxChange}
					?checked=${this.model.completed} />
				<span class="apple-reminder-fields">
					${this.model.priority && this.model.priority > 0 ? y`
							<span class="apple-reminder-priority">
								${Array.from(Array(Math.ceil((10 - this.model.priority) / 3)).keys()).reduce((prev, curr) => prev + "!", "")}
							</span>
						` : ""}
					<span class="apple-reminder-name"> ${this.model.name} </span>
					${this.model.body && this.model.body != "missing value" ? y`<br /><small class="apple-reminder-note">${this.model.body}</small>` : ""}
					${this.model["due date"] && this.model["due date"] != "missing value" ? y`<br /><small class="apple-reminder-due-date">${(0, import_obsidian3.moment)(this.model["due date"], APPLE_DATE_FORMAT).format("	 YYYY/MM/DD, hh:mm a (Z)")}</small>` : ""}
				</span>
			</span>
									<br class="apple-list-break"/>
									<hr class="apple-list-reminder-break-line" />
		`;
  }
};
ReminderElement.styles = i`
		.checkbox-round {
			width: 1.3em;
			height: 1.3em;
			background-color: rgba(255, 255, 255, 0);
			border-radius: 50%;
			vertical-align: middle;
			border: 1px solid rgb(170, 168, 168);
			-webkit-appearance: none;
			outline: none;
			cursor: pointer;
			opacity: 0.3;
		}

		.checkbox-round:checked {
			background-color: gray;
		}

		.apple-reminder-name {
			padding-left: 1rem;
		}

		.apple-reminder-due-date {
			opacity: 0.3;
			padding-left: 4em;
		}
		.apple-reminder-container {
			padding: 0;
			margin: 0;
		}
		.apple-reminder-priority {
			color: red;
		}
		.apple-reminder-note {
			opacity: 0.3;
			padding-left: 4em;
		}
		.apple-list-break {
			margin: 0;
		}

		.apple-list-reminder-break-line {
			margin-left: 2em;
			margin-top: 0.5em;
			margin-bottom: 0.5em;
			padding: 0;
			height: 0.5px;
			opacity: 0.2;
		}
	`;
__decorateClass([
  e5()
], ReminderElement.prototype, "list_name", 2);
__decorateClass([
  e5()
], ReminderElement.prototype, "model", 2);
ReminderElement = __decorateClass([
  e4("apple-reminder-element")
], ReminderElement);

// src/ui/list.element.ts
var ListElement = class extends s4 {
  constructor(_spec) {
    super();
    this.refreshDisabled = false;
    this.reminders = [];
    this.loadingBar = new LoadingBarComponent();
    this.spec = _spec;
  }
  get elements() {
    return this.reminders.map((rem) => {
      let el = new ReminderElement();
      el.model = rem;
      el.list_name = this.listMeta.name;
      return el;
    });
  }
  refresh() {
    this.refreshDisabled = true;
    RemindersDataService.fetchData(this.spec).then(([listData, reminders]) => {
      this.listMeta = listData;
      this.reminders = reminders;
      this.refreshDisabled = false;
    });
  }
  render() {
    var _a, _b, _c;
    return y`
			<div class="apple-list-container">
				<hr class="apple-list-top-rule" />
				<h2>
					<span
						style="color: ${(_a = this.listMeta) == null ? void 0 : _a.color}">${!((_b = this.listMeta) == null ? void 0 : _b.name) ? (_c = this.spec) == null ? void 0 : _c.list : this.listMeta.name}</span>
				</h2>

				${this.listMeta ? y`
					<span class="apple-list-reminders">
						${this.elements.length > 0 ? this.elements : y`<small style="padding-bottom: 1rem;">No reminders found</small>`}
					</span>

				` : this.loadingBar}
				<br />
				<button @click="${this.refresh}" ?disabled="${this.refreshDisabled}">Refresh</button>
				<hr class="apple-list-bottom-rule" />
			</div>
		`;
  }
};
ListElement.styles = i`
		.apple-list-reminders {
			margin: 0;
			padding: 0;
		}

		.apple-list-top-rule,
		.apple-list-bottom-rule {
			opacity: 0;
		}
	`;
__decorateClass([
  e5()
], ListElement.prototype, "spec", 2);
__decorateClass([
  e5()
], ListElement.prototype, "refreshDisabled", 2);
__decorateClass([
  e5()
], ListElement.prototype, "reminders", 2);
__decorateClass([
  e5()
], ListElement.prototype, "listMeta", 2);
ListElement = __decorateClass([
  e4("apple-list-element")
], ListElement);

// node_modules/yaml/browser/dist/nodes/Node.js
var ALIAS = Symbol.for("yaml.alias");
var DOC = Symbol.for("yaml.document");
var MAP = Symbol.for("yaml.map");
var PAIR = Symbol.for("yaml.pair");
var SCALAR = Symbol.for("yaml.scalar");
var SEQ = Symbol.for("yaml.seq");
var NODE_TYPE = Symbol.for("yaml.node.type");
var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
function isCollection(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR:
      case SEQ:
        return true;
    }
  return false;
}
var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
var NodeBase = class {
  constructor(type) {
    Object.defineProperty(this, NODE_TYPE, { value: type });
  }
  clone() {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
};

// node_modules/yaml/browser/dist/visit.js
var BREAK = Symbol("break visit");
var SKIP = Symbol("skip children");
var REMOVE = Symbol("remove node");
function visit(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    visit_(null, node, visitor_, Object.freeze([]));
}
visit.BREAK = BREAK;
visit.SKIP = SKIP;
visit.REMOVE = REMOVE;
function visit_(key, node, visitor, path) {
  const ctrl = callVisitor(key, node, visitor, path);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path, ctrl);
    return visit_(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i4 = 0; i4 < node.items.length; ++i4) {
        const ci = visit_(i4, node.items[i4], visitor, path);
        if (typeof ci === "number")
          i4 = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i4, 1);
          i4 -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = visit_("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = visit_("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
function visitAsync(node, visitor) {
  return __async(this, null, function* () {
    const visitor_ = initVisitor(visitor);
    if (isDocument(node)) {
      const cd = yield visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      yield visitAsync_(null, node, visitor_, Object.freeze([]));
  });
}
visitAsync.BREAK = BREAK;
visitAsync.SKIP = SKIP;
visitAsync.REMOVE = REMOVE;
function visitAsync_(key, node, visitor, path) {
  return __async(this, null, function* () {
    const ctrl = yield callVisitor(key, node, visitor, path);
    if (isNode(ctrl) || isPair(ctrl)) {
      replaceNode(key, path, ctrl);
      return visitAsync_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
      if (isCollection(node)) {
        path = Object.freeze(path.concat(node));
        for (let i4 = 0; i4 < node.items.length; ++i4) {
          const ci = yield visitAsync_(i4, node.items[i4], visitor, path);
          if (typeof ci === "number")
            i4 = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i4, 1);
            i4 -= 1;
          }
        }
      } else if (isPair(node)) {
        path = Object.freeze(path.concat(node));
        const ck = yield visitAsync_("key", node.key, visitor, path);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = yield visitAsync_("value", node.value, visitor, path);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  });
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key, node, visitor, path) {
  var _a, _b, _c, _d, _e;
  if (typeof visitor === "function")
    return visitor(key, node, path);
  if (isMap(node))
    return (_a = visitor.Map) == null ? void 0 : _a.call(visitor, key, node, path);
  if (isSeq(node))
    return (_b = visitor.Seq) == null ? void 0 : _b.call(visitor, key, node, path);
  if (isPair(node))
    return (_c = visitor.Pair) == null ? void 0 : _c.call(visitor, key, node, path);
  if (isScalar(node))
    return (_d = visitor.Scalar) == null ? void 0 : _d.call(visitor, key, node, path);
  if (isAlias(node))
    return (_e = visitor.Alias) == null ? void 0 : _e.call(visitor, key, node, path);
  return void 0;
}
function replaceNode(key, path, node) {
  const parent = path[path.length - 1];
  if (isCollection(parent)) {
    parent.items[key] = node;
  } else if (isPair(parent)) {
    if (key === "key")
      parent.key = node;
    else
      parent.value = node;
  } else if (isDocument(parent)) {
    parent.contents = node;
  } else {
    const pt = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}

// node_modules/yaml/browser/dist/doc/directives.js
var escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
var Directives = class {
  constructor(yaml, tags) {
    this.docStart = null;
    this.docEnd = false;
    this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
    this.tags = Object.assign({}, Directives.defaultTags, tags);
  }
  clone() {
    const copy = new Directives(this.yaml, this.tags);
    copy.docStart = this.docStart;
    return copy;
  }
  atDocument() {
    const res = new Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false;
        this.yaml = {
          explicit: Directives.defaultYaml.explicit,
          version: "1.2"
        };
        this.tags = Object.assign({}, Directives.defaultTags);
        break;
    }
    return res;
  }
  add(line, onError) {
    if (this.atNextDocument) {
      this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
      this.tags = Object.assign({}, Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line.trim().split(/[ \t]+/);
    const name = parts.shift();
    switch (name) {
      case "%TAG": {
        if (parts.length !== 2) {
          onError(0, "%TAG directive should contain exactly two parts");
          if (parts.length < 2)
            return false;
        }
        const [handle, prefix] = parts;
        this.tags[handle] = prefix;
        return true;
      }
      case "%YAML": {
        this.yaml.explicit = true;
        if (parts.length !== 1) {
          onError(0, "%YAML directive should contain exactly one part");
          return false;
        }
        const [version] = parts;
        if (version === "1.1" || version === "1.2") {
          this.yaml.version = version;
          return true;
        } else {
          const isValid = /^\d+\.\d+$/.test(version);
          onError(6, `Unsupported YAML version ${version}`, isValid);
          return false;
        }
      }
      default:
        onError(0, `Unknown directive ${name}`, true);
        return false;
    }
  }
  tagName(source, onError) {
    if (source === "!")
      return "!";
    if (source[0] !== "!") {
      onError(`Not a valid tag: ${source}`);
      return null;
    }
    if (source[1] === "<") {
      const verbatim = source.slice(2, -1);
      if (verbatim === "!" || verbatim === "!!") {
        onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
        return null;
      }
      if (source[source.length - 1] !== ">")
        onError("Verbatim tags must end with a >");
      return verbatim;
    }
    const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);
    if (!suffix)
      onError(`The ${source} tag has no suffix`);
    const prefix = this.tags[handle];
    if (prefix)
      return prefix + decodeURIComponent(suffix);
    if (handle === "!")
      return source;
    onError(`Could not resolve tag: ${source}`);
    return null;
  }
  tagString(tag) {
    for (const [handle, prefix] of Object.entries(this.tags)) {
      if (tag.startsWith(prefix))
        return handle + escapeTagName(tag.substring(prefix.length));
    }
    return tag[0] === "!" ? tag : `!<${tag}>`;
  }
  toString(doc) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
      const tags = {};
      visit(doc.contents, (_key, node) => {
        if (isNode(node) && node.tag)
          tags[node.tag] = true;
      });
      tagNames = Object.keys(tags);
    } else
      tagNames = [];
    for (const [handle, prefix] of tagEntries) {
      if (handle === "!!" && prefix === "tag:yaml.org,2002:")
        continue;
      if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
        lines.push(`%TAG ${handle} ${prefix}`);
    }
    return lines.join("\n");
  }
};
Directives.defaultYaml = { explicit: false, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };

// node_modules/yaml/browser/dist/doc/anchors.js
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root) {
  const anchors = /* @__PURE__ */ new Set();
  visit(root, {
    Value(_key, node) {
      if (node.anchor)
        anchors.add(node.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i4 = 1; true; ++i4) {
    const name = `${prefix}${i4}`;
    if (!exclude.has(name))
      return name;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source) => {
      aliasObjects.push(source);
      if (!prevAnchors)
        prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref = sourceObjects.get(source);
        if (typeof ref === "object" && ref.anchor && (isScalar(ref.node) || isCollection(ref.node))) {
          ref.node.anchor = ref.anchor;
        } else {
          const error = new Error("Failed to resolve repeated object (this should not happen)");
          error.source = source;
          throw error;
        }
      }
    },
    sourceObjects
  };
}

// node_modules/yaml/browser/dist/nodes/Alias.js
var Alias = class extends NodeBase {
  constructor(source) {
    super(ALIAS);
    this.source = source;
    Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  resolve(doc) {
    let found = void 0;
    visit(doc, {
      Node: (_key, node) => {
        if (node === this)
          return visit.BREAK;
        if (node.anchor === this.source)
          found = node;
      }
    });
    return found;
  }
  toJSON(_arg, ctx) {
    if (!ctx)
      return { source: this.source };
    const { anchors, doc, maxAliasCount } = ctx;
    const source = this.resolve(doc);
    if (!source) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    const data = anchors.get(source);
    if (!data || data.res === void 0) {
      const msg = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data.count += 1;
      if (data.aliasCount === 0)
        data.aliasCount = getAliasCount(doc, source, anchors);
      if (data.count * data.aliasCount > maxAliasCount) {
        const msg = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(msg);
      }
    }
    return data.res;
  }
  toString(ctx, _onComment, _onChompKeep) {
    const src = `*${this.source}`;
    if (ctx) {
      anchorIsValid(this.source);
      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx.implicitKey)
        return `${src} `;
    }
    return src;
  }
};
function getAliasCount(doc, node, anchors) {
  if (isAlias(node)) {
    const source = node.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection(node)) {
    let count = 0;
    for (const item of node.items) {
      const c3 = getAliasCount(doc, item, anchors);
      if (c3 > count)
        count = c3;
    }
    return count;
  } else if (isPair(node)) {
    const kc = getAliasCount(doc, node.key, anchors);
    const vc = getAliasCount(doc, node.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}

// node_modules/yaml/browser/dist/nodes/toJS.js
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v2, i4) => toJS(v2, String(i4), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !(ctx == null ? void 0 : ctx.keep))
    return Number(value);
  return value;
}

// node_modules/yaml/browser/dist/nodes/Scalar.js
var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
var Scalar = class extends NodeBase {
  constructor(value) {
    super(SCALAR);
    this.value = value;
  }
  toJSON(arg, ctx) {
    return (ctx == null ? void 0 : ctx.keep) ? this.value : toJS(this.value, arg, ctx);
  }
  toString() {
    return String(this.value);
  }
};
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";

// node_modules/yaml/browser/dist/doc/createNode.js
var defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value, tagName, tags) {
  var _a;
  if (tagName) {
    const match = tags.filter((t3) => t3.tag === tagName);
    const tagObj = (_a = match.find((t3) => !t3.format)) != null ? _a : match[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t3) => {
    var _a2;
    return ((_a2 = t3.identify) == null ? void 0 : _a2.call(t3, value)) && !t3.format;
  });
}
function createNode(value, tagName, ctx) {
  var _a, _b;
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map2 = (_b = (_a = ctx.schema[MAP]).createNode) == null ? void 0 : _b.call(_a, ctx.schema, null, ctx);
    map2.items.push(value);
    return map2;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt === "function" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema4, sourceObjects } = ctx;
  let ref = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref = sourceObjects.get(value);
    if (ref) {
      if (!ref.anchor)
        ref.anchor = onAnchor(value);
      return new Alias(ref.anchor);
    } else {
      ref = { anchor: null, node: null };
      sourceObjects.set(value, ref);
    }
  }
  if (tagName == null ? void 0 : tagName.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema4.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function") {
      value = value.toJSON();
    }
    if (!value || typeof value !== "object") {
      const node2 = new Scalar(value);
      if (ref)
        ref.node = node2;
      return node2;
    }
    tagObj = value instanceof Map ? schema4[MAP] : Symbol.iterator in Object(value) ? schema4[SEQ] : schema4[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node = (tagObj == null ? void 0 : tagObj.createNode) ? tagObj.createNode(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node.tag = tagName;
  if (ref)
    ref.node = node;
  return node;
}

// node_modules/yaml/browser/dist/nodes/Collection.js
function collectionFromPath(schema4, path, value) {
  let v2 = value;
  for (let i4 = path.length - 1; i4 >= 0; --i4) {
    const k2 = path[i4];
    if (typeof k2 === "number" && Number.isInteger(k2) && k2 >= 0) {
      const a3 = [];
      a3[k2] = v2;
      v2 = a3;
    } else {
      v2 = /* @__PURE__ */ new Map([[k2, v2]]);
    }
  }
  return createNode(v2, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema4,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
var Collection = class extends NodeBase {
  constructor(type, schema4) {
    super(type);
    Object.defineProperty(this, "schema", {
      value: schema4,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  clone(schema4) {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema4)
      copy.schema = schema4;
    copy.items = copy.items.map((it) => isNode(it) || isPair(it) ? it.clone(schema4) : it);
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  addIn(path, value) {
    if (isEmptyPath(path))
      this.add(value);
    else {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (isCollection(node))
        node.addIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
  deleteIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0)
      return this.delete(key);
    const node = this.get(key, true);
    if (isCollection(node))
      return node.deleteIn(rest);
    else
      throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }
  getIn(path, keepScalar) {
    const [key, ...rest] = path;
    const node = this.get(key, true);
    if (rest.length === 0)
      return !keepScalar && isScalar(node) ? node.value : node;
    else
      return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every((node) => {
      if (!isPair(node))
        return false;
      const n6 = node.value;
      return n6 == null || allowScalar && isScalar(n6) && n6.value == null && !n6.commentBefore && !n6.comment && !n6.tag;
    });
  }
  hasIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0)
      return this.has(key);
    const node = this.get(key, true);
    return isCollection(node) ? node.hasIn(rest) : false;
  }
  setIn(path, value) {
    const [key, ...rest] = path;
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node = this.get(key, true);
      if (isCollection(node))
        node.setIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
};
Collection.maxFlowStringSingleLineLength = 60;

// node_modules/yaml/browser/dist/stringify/stringifyComment.js
var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
function indentComment(comment, indent) {
  if (/^\n+$/.test(comment))
    return comment.substring(1);
  return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
var lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;

// node_modules/yaml/browser/dist/stringify/foldFlowLines.js
var FOLD_FLOW = "flow";
var FOLD_BLOCK = "block";
var FOLD_QUOTED = "quoted";
function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i4 = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i4 = consumeMoreIndentedLines(text, i4);
    if (i4 !== -1)
      end = i4 + endStep;
  }
  for (let ch; ch = text[i4 += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i4;
      switch (text[i4 + 1]) {
        case "x":
          i4 += 3;
          break;
        case "u":
          i4 += 5;
          break;
        case "U":
          i4 += 9;
          break;
        default:
          i4 += 1;
      }
      escEnd = i4;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i4 = consumeMoreIndentedLines(text, i4);
      end = i4 + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text[i4 + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i4;
      }
      if (i4 >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i4 += 1];
            overflow = true;
          }
          const j = i4 > escEnd + 1 ? i4 - 2 : escStart - 1;
          if (escapedFolds[j])
            return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  let res = text.slice(0, folds[0]);
  for (let i5 = 0; i5 < folds.length; ++i5) {
    const fold = folds[i5];
    const end2 = folds[i5 + 1] || text.length;
    if (fold === 0)
      res = `
${indent}${text.slice(0, end2)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += `${text[fold]}\\`;
      res += `
${indent}${text.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text, i4) {
  let ch = text[i4 + 1];
  while (ch === " " || ch === "	") {
    do {
      ch = text[i4 += 1];
    } while (ch && ch !== "\n");
    ch = text[i4 + 1];
  }
  return i4;
}

// node_modules/yaml/browser/dist/stringify/stringifyString.js
var getFoldOptions = (ctx) => ({
  indentAtStart: ctx.indentAtStart,
  lineWidth: ctx.options.lineWidth,
  minContentWidth: ctx.options.minContentWidth
});
var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i4 = 0, start = 0; i4 < strLen; ++i4) {
    if (str[i4] === "\n") {
      if (i4 - start > limit)
        return true;
      start = i4 + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start = 0;
  for (let i4 = 0, ch = json[i4]; ch; ch = json[++i4]) {
    if (ch === " " && json[i4 + 1] === "\\" && json[i4 + 2] === "n") {
      str += json.slice(start, i4) + "\\ ";
      i4 += 1;
      start = i4;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i4 + 1]) {
        case "u":
          {
            str += json.slice(start, i4);
            const code = json.substr(i4 + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json.substr(i4, 6);
            }
            i4 += 5;
            start = i4 + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i4 + 2] === '"' || json.length < minMultiLineLength) {
            i4 += 1;
          } else {
            str += json.slice(start, i4) + "\n\n";
            while (json[i4 + 2] === "\\" && json[i4 + 3] === "n" && json[i4 + 4] !== '"') {
              str += "\n";
              i4 += 2;
            }
            str += indent;
            if (json[i4 + 2] === " ")
              str += "\\";
            i4 += 1;
            start = i4 + 1;
          }
          break;
        default:
          i4 += 1;
      }
  }
  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
}
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value = value.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(/\n+(?!\n|$)/g, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value = value.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
  if (comment) {
    header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (literal) {
    value = value.replace(/\n+/g, `$&${indent}`);
    return `${header}
${indent}${start}${value}${end}`;
  }
  value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines(`${start}${value}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx));
  return `${header}
${indent}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value } = item;
  const { actualString, implicitKey, indent, inFlow } = ctx;
  if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (indent === "" && containsDocumentMarker(value)) {
    ctx.forceBlockIndent = true;
    return blockString(item, ctx, onComment, onChompKeep);
  }
  const str = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag) => {
      var _a;
      return tag.default && tag.tag !== "tag:yaml.org,2002:str" && ((_a = tag.test) == null ? void 0 : _a.test(str));
    };
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test) || (compat == null ? void 0 : compat.some(test)))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t3 = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t3);
    if (res === null)
      throw new Error(`Unsupported default string type ${t3}`);
  }
  return res;
}

// node_modules/yaml/browser/dist/stringify/stringify.js
function createStringifyContext(doc, options) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  var _a, _b, _c, _d;
  if (item.tag) {
    const match = tags.filter((t3) => t3.tag === item.tag);
    if (match.length > 0)
      return (_a = match.find((t3) => t3.format === item.format)) != null ? _a : match[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar(item)) {
    obj = item.value;
    const match = tags.filter((t3) => {
      var _a2;
      return (_a2 = t3.identify) == null ? void 0 : _a2.call(t3, obj);
    });
    tagObj = (_b = match.find((t3) => t3.format === item.format)) != null ? _b : match.find((t3) => !t3.format);
  } else {
    obj = item;
    tagObj = tags.find((t3) => t3.nodeClass && obj instanceof t3.nodeClass);
  }
  if (!tagObj) {
    const name = (_d = (_c = obj == null ? void 0 : obj.constructor) == null ? void 0 : _c.name) != null ? _d : typeof obj;
    throw new Error(`Tag not resolved for ${name} value`);
  }
  return tagObj;
}
function stringifyProps(node, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
  if (tag)
    props.push(doc.directives.tagString(tag));
  return props.join(" ");
}
function stringify(item, ctx, onComment, onChompKeep) {
  var _a, _b;
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if ((_a = ctx.resolvedAliases) == null ? void 0 : _a.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o6) => tagObj = o6 });
  if (!tagObj)
    tagObj = getTagObject(ctx.doc.schema.tags, node);
  const props = stringifyProps(node, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = ((_b = ctx.indentAtStart) != null ? _b : 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}

// node_modules/yaml/browser/dist/stringify/stringifyPair.js
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection(key)) {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str === "" ? "?" : explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vcb = "";
  let valueComment = null;
  if (isNode(value)) {
    if (value.spaceBefore)
      vcb = "\n";
    if (value.commentBefore) {
      const cs = commentString(value.commentBefore);
      vcb += `
${indentComment(cs, ctx.indent)}`;
    }
    valueComment = value.comment;
  } else if (value && typeof value === "object") {
    value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substr(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (vcb || keyComment) {
    if (valueStr === "" && !ctx.inFlow)
      ws = vcb === "\n" ? "\n\n" : vcb;
    else
      ws = `${vcb}
${ctx.indent}`;
  } else if (!explicitKey && isCollection(value)) {
    const flow = valueStr[0] === "[" || valueStr[0] === "{";
    if (!flow || valueStr.includes("\n"))
      ws = `
${ctx.indent}`;
  } else if (valueStr === "" || valueStr[0] === "\n")
    ws = "";
  str += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}

// node_modules/yaml/browser/dist/log.js
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    if (typeof process !== "undefined" && process.emitWarning)
      process.emitWarning(warning);
    else
      console.warn(warning);
  }
}

// node_modules/yaml/browser/dist/nodes/addPairToJSMap.js
var MERGE_KEY = "<<";
function addPairToJSMap(ctx, map2, { key, value }) {
  if ((ctx == null ? void 0 : ctx.doc.schema.merge) && isMergeKey(key)) {
    value = isAlias(value) ? value.resolve(ctx.doc) : value;
    if (isSeq(value))
      for (const it of value.items)
        mergeToJSMap(ctx, map2, it);
    else if (Array.isArray(value))
      for (const it of value)
        mergeToJSMap(ctx, map2, it);
    else
      mergeToJSMap(ctx, map2, value);
  } else {
    const jsKey = toJS(key, "", ctx);
    if (map2 instanceof Map) {
      map2.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map2 instanceof Set) {
      map2.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map2)
        Object.defineProperty(map2, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map2[stringKey] = jsValue;
    }
  }
  return map2;
}
var isMergeKey = (key) => key === MERGE_KEY || isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.PLAIN);
function mergeToJSMap(ctx, map2, value) {
  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value2] of srcMap) {
    if (map2 instanceof Map) {
      if (!map2.has(key))
        map2.set(key, value2);
    } else if (map2 instanceof Set) {
      map2.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
      Object.defineProperty(map2, key, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map2;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key) && ctx && ctx.doc) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node of ctx.anchors.keys())
      strCtx.anchors.add(node.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}

// node_modules/yaml/browser/dist/nodes/Pair.js
function createPair(key, value, ctx) {
  const k2 = createNode(key, void 0, ctx);
  const v2 = createNode(value, void 0, ctx);
  return new Pair(k2, v2);
}
var Pair = class {
  constructor(key, value = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR });
    this.key = key;
    this.value = value;
  }
  clone(schema4) {
    let { key, value } = this;
    if (isNode(key))
      key = key.clone(schema4);
    if (isNode(value))
      value = value.clone(schema4);
    return new Pair(key, value);
  }
  toJSON(_2, ctx) {
    const pair = (ctx == null ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(ctx, pair, this);
  }
  toString(ctx, onComment, onChompKeep) {
    return (ctx == null ? void 0 : ctx.doc) ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyCollection.js
function stringifyCollection(collection, ctx, options) {
  var _a;
  const flow = (_a = ctx.inFlow) != null ? _a : collection.flow;
  const stringify4 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify4(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i4 = 0; i4 < items.length; ++i4) {
    const item = items[i4];
    let comment2 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (chompKeep && comment2)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i4 = 1; i4 < lines.length; ++i4) {
      const line = lines[i4];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment) {
    str += "\n" + indentComment(commentString(comment), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ comment, items }, ctx, { flowChars, itemIndent, onComment }) {
  const { indent, indentStep, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i4 = 0; i4 < items.length; ++i4) {
    const item = items[i4];
    let comment2 = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment2 = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && ik && ik.comment) {
        comment2 = ik.comment;
      }
    }
    if (comment2)
      reqNewline = true;
    let str2 = stringify(item, itemCtx, () => comment2 = null);
    if (i4 < items.length - 1)
      str2 += ",";
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (!reqNewline && (lines.length > linesAtValue || str2.includes("\n")))
      reqNewline = true;
    lines.push(str2);
    linesAtValue = lines.length;
  }
  let str;
  const { start, end } = flowChars;
  if (lines.length === 0) {
    str = start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = len > Collection.maxFlowStringSingleLineLength;
    }
    if (reqNewline) {
      str = start;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      str += `
${indent}${end}`;
    } else {
      str = `${start} ${lines.join(" ")} ${end}`;
    }
  }
  if (comment) {
    str += lineComment(str, commentString(comment), indent);
    if (onComment)
      onComment();
  }
  return str;
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
  if (comment && chompKeep)
    comment = comment.replace(/^\n+/, "");
  if (comment) {
    const ic = indentComment(commentString(comment), indent);
    lines.push(ic.trimStart());
  }
}

// node_modules/yaml/browser/dist/nodes/YAMLMap.js
function findPair(items, key) {
  const k2 = isScalar(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k2)
        return it;
      if (isScalar(it.key) && it.key.value === k2)
        return it;
    }
  }
  return void 0;
}
var YAMLMap = class extends Collection {
  constructor(schema4) {
    super(MAP, schema4);
    this.items = [];
  }
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  add(pair, overwrite) {
    var _a;
    let _pair;
    if (isPair(pair))
      _pair = pair;
    else if (!pair || typeof pair !== "object" || !("key" in pair)) {
      _pair = new Pair(pair, pair == null ? void 0 : pair.value);
    } else
      _pair = new Pair(pair.key, pair.value);
    const prev = findPair(this.items, _pair.key);
    const sortEntries = (_a = this.schema) == null ? void 0 : _a.sortMapEntries;
    if (prev) {
      if (!overwrite)
        throw new Error(`Key ${_pair.key} already set`);
      if (isScalar(prev.value) && isScalarValue(_pair.value))
        prev.value.value = _pair.value;
      else
        prev.value = _pair.value;
    } else if (sortEntries) {
      const i4 = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
      if (i4 === -1)
        this.items.push(_pair);
      else
        this.items.splice(i4, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key) {
    const it = findPair(this.items, key);
    if (!it)
      return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    var _a;
    const it = findPair(this.items, key);
    const node = it == null ? void 0 : it.value;
    return (_a = !keepScalar && isScalar(node) ? node.value : node) != null ? _a : void 0;
  }
  has(key) {
    return !!findPair(this.items, key);
  }
  set(key, value) {
    this.add(new Pair(key, value), true);
  }
  toJSON(_2, ctx, Type) {
    const map2 = Type ? new Type() : (ctx == null ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(map2);
    for (const item of this.items)
      addPairToJSMap(ctx, map2, item);
    return map2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    for (const item of this.items) {
      if (!isPair(item))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx.allNullValues && this.hasAllNullValues(false))
      ctx = Object.assign({}, ctx, { allNullValues: true });
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: ctx.indent || "",
      onChompKeep,
      onComment
    });
  }
};

// node_modules/yaml/browser/dist/schema/common/map.js
function createMap(schema4, obj, ctx) {
  const { keepUndefined, replacer } = ctx;
  const map2 = new YAMLMap(schema4);
  const add = (key, value) => {
    if (typeof replacer === "function")
      value = replacer.call(obj, key, value);
    else if (Array.isArray(replacer) && !replacer.includes(key))
      return;
    if (value !== void 0 || keepUndefined)
      map2.items.push(createPair(key, value, ctx));
  };
  if (obj instanceof Map) {
    for (const [key, value] of obj)
      add(key, value);
  } else if (obj && typeof obj === "object") {
    for (const key of Object.keys(obj))
      add(key, obj[key]);
  }
  if (typeof schema4.sortMapEntries === "function") {
    map2.items.sort(schema4.sortMapEntries);
  }
  return map2;
}
var map = {
  collection: "map",
  createNode: createMap,
  default: true,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(map2, onError) {
    if (!isMap(map2))
      onError("Expected a mapping for this tag");
    return map2;
  }
};

// node_modules/yaml/browser/dist/nodes/YAMLSeq.js
var YAMLSeq = class extends Collection {
  constructor(schema4) {
    super(SEQ, schema4);
    this.items = [];
  }
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  add(value) {
    this.items.push(value);
  }
  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return void 0;
    const it = this.items[idx];
    return !keepScalar && isScalar(it) ? it.value : it;
  }
  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === "number" && idx < this.items.length;
  }
  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      throw new Error(`Expected a valid index, not ${key}.`);
    const prev = this.items[idx];
    if (isScalar(prev) && isScalarValue(value))
      prev.value = value;
    else
      this.items[idx] = value;
  }
  toJSON(_2, ctx) {
    const seq2 = [];
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(seq2);
    let i4 = 0;
    for (const item of this.items)
      seq2.push(toJS(item, String(i4++), ctx));
    return seq2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (ctx.indent || "") + "  ",
      onChompKeep,
      onComment
    });
  }
};
function asItemIndex(key) {
  let idx = isScalar(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}

// node_modules/yaml/browser/dist/schema/common/seq.js
function createSeq(schema4, obj, ctx) {
  const { replacer } = ctx;
  const seq2 = new YAMLSeq(schema4);
  if (obj && Symbol.iterator in Object(obj)) {
    let i4 = 0;
    for (let it of obj) {
      if (typeof replacer === "function") {
        const key = obj instanceof Set ? it : String(i4++);
        it = replacer.call(obj, key, it);
      }
      seq2.items.push(createNode(it, void 0, ctx));
    }
  }
  return seq2;
}
var seq = {
  collection: "seq",
  createNode: createSeq,
  default: true,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(seq2, onError) {
    if (!isSeq(seq2))
      onError("Expected a sequence for this tag");
    return seq2;
  }
};

// node_modules/yaml/browser/dist/schema/common/string.js
var string = {
  identify: (value) => typeof value === "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (str) => str,
  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({ actualString: true }, ctx);
    return stringifyString(item, ctx, onComment, onChompKeep);
  }
};

// node_modules/yaml/browser/dist/schema/common/null.js
var nullTag = {
  identify: (value) => value == null,
  createNode: () => new Scalar(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Scalar(null),
  stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
};

// node_modules/yaml/browser/dist/schema/core/bool.js
var boolTag = {
  identify: (value) => typeof value === "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
  stringify({ source, value }, ctx) {
    if (source && boolTag.test.test(source)) {
      const sv = source[0] === "t" || source[0] === "T";
      if (value === sv)
        return source;
    }
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyNumber.js
function stringifyNumber({ format, minFractionDigits, tag, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n6 = JSON.stringify(value);
  if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n6)) {
    let i4 = n6.indexOf(".");
    if (i4 < 0) {
      i4 = n6.length;
      n6 += ".";
    }
    let d3 = minFractionDigits - (n6.length - i4 - 1);
    while (d3-- > 0)
      n6 += "0";
  }
  return n6;
}

// node_modules/yaml/browser/dist/schema/core/float.js
var floatNaN = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str));
    const dot = str.indexOf(".");
    if (dot !== -1 && str[str.length - 1] === "0")
      node.minFractionDigits = str.length - dot - 1;
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/yaml/browser/dist/schema/core/int.js
var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
function intStringify(node, radix, prefix) {
  const { value } = node;
  if (intIdentify(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node);
}
var intOct = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
  stringify: (node) => intStringify(node, 8, "0o")
};
var int = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
  stringify: (node) => intStringify(node, 16, "0x")
};

// node_modules/yaml/browser/dist/schema/core/schema.js
var schema = [
  map,
  seq,
  string,
  nullTag,
  boolTag,
  intOct,
  int,
  intHex,
  floatNaN,
  floatExp,
  float
];

// node_modules/yaml/browser/dist/schema/json/schema.js
function intIdentify2(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
var stringifyJSON = ({ value }) => JSON.stringify(value);
var jsonScalars = [
  {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify: stringifyJSON
  },
  {
    identify: (value) => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON
  },
  {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true|false$/,
    resolve: (str) => str === "true",
    stringify: stringifyJSON
  },
  {
    identify: intIdentify2,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
    stringify: ({ value }) => intIdentify2(value) ? value.toString() : JSON.stringify(value)
  },
  {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (str) => parseFloat(str),
    stringify: stringifyJSON
  }
];
var jsonError = {
  default: true,
  tag: "",
  test: /^/,
  resolve(str, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    return str;
  }
};
var schema2 = [map, seq].concat(jsonScalars, jsonError);

// node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js
var binary = {
  identify: (value) => value instanceof Uint8Array,
  default: false,
  tag: "tag:yaml.org,2002:binary",
  resolve(src, onError) {
    if (typeof Buffer === "function") {
      return Buffer.from(src, "base64");
    } else if (typeof atob === "function") {
      const str = atob(src.replace(/[\n\r]/g, ""));
      const buffer = new Uint8Array(str.length);
      for (let i4 = 0; i4 < str.length; ++i4)
        buffer[i4] = str.charCodeAt(i4);
      return buffer;
    } else {
      onError("This environment does not support reading binary tags; either Buffer or atob is required");
      return src;
    }
  },
  stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
    const buf = value;
    let str;
    if (typeof Buffer === "function") {
      str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
    } else if (typeof btoa === "function") {
      let s5 = "";
      for (let i4 = 0; i4 < buf.length; ++i4)
        s5 += String.fromCharCode(buf[i4]);
      str = btoa(s5);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    if (!type)
      type = Scalar.BLOCK_LITERAL;
    if (type !== Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
      const n6 = Math.ceil(str.length / lineWidth);
      const lines = new Array(n6);
      for (let i4 = 0, o6 = 0; i4 < n6; ++i4, o6 += lineWidth) {
        lines[i4] = str.substr(o6, lineWidth);
      }
      str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
  }
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js
function resolvePairs(seq2, onError) {
  var _a;
  if (isSeq(seq2)) {
    for (let i4 = 0; i4 < seq2.items.length; ++i4) {
      let item = seq2.items[i4];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = (_a = pair.value) != null ? _a : pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i4] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema4, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema4);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i4 = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i4++), it);
      let key, value;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value = it[key];
        } else
          throw new TypeError(`Expected { key: value } tuple: ${it}`);
      } else {
        key = it;
      }
      pairs2.items.push(createPair(key, value, ctx));
    }
  return pairs2;
}
var pairs = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js
var YAMLOMap = class extends YAMLSeq {
  constructor() {
    super();
    this.add = YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.prototype.set.bind(this);
    this.tag = YAMLOMap.tag;
  }
  toJSON(_2, ctx) {
    if (!ctx)
      return super.toJSON(_2);
    const map2 = /* @__PURE__ */ new Map();
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(map2);
    for (const pair of this.items) {
      let key, value;
      if (isPair(pair)) {
        key = toJS(pair.key, "", ctx);
        value = toJS(pair.value, key, ctx);
      } else {
        key = toJS(pair, "", ctx);
      }
      if (map2.has(key))
        throw new Error("Ordered maps must not include duplicate keys");
      map2.set(key, value);
    }
    return map2;
  }
};
YAMLOMap.tag = "tag:yaml.org,2002:omap";
var omap = {
  collection: "seq",
  identify: (value) => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(seq2, onError) {
    const pairs2 = resolvePairs(seq2, onError);
    const seenKeys = [];
    for (const { key } of pairs2.items) {
      if (isScalar(key)) {
        if (seenKeys.includes(key.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key.value}`);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs2);
  },
  createNode(schema4, iterable, ctx) {
    const pairs2 = createPairs(schema4, iterable, ctx);
    const omap2 = new YAMLOMap();
    omap2.items = pairs2.items;
    return omap2;
  }
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js
function boolStringify({ value, source }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
var trueTag = {
  identify: (value) => value === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Scalar(true),
  stringify: boolStringify
};
var falseTag = {
  identify: (value) => value === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
  resolve: () => new Scalar(false),
  stringify: boolStringify
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/float.js
var floatNaN2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str.replace(/_/g, "")),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str.replace(/_/g, "")));
    const dot = str.indexOf(".");
    if (dot !== -1) {
      const f2 = str.substring(dot + 1).replace(/_/g, "");
      if (f2[f2.length - 1] === "0")
        node.minFractionDigits = f2.length;
    }
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/int.js
var intIdentify3 = (value) => typeof value === "bigint" || Number.isInteger(value);
function intResolve2(str, offset, radix, { intAsBigInt }) {
  const sign = str[0];
  if (sign === "-" || sign === "+")
    offset += 1;
  str = str.substring(offset).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n7 = BigInt(str);
    return sign === "-" ? BigInt(-1) * n7 : n7;
  }
  const n6 = parseInt(str, radix);
  return sign === "-" ? -1 * n6 : n6;
}
function intStringify2(node, radix, prefix) {
  const { value } = node;
  if (intIdentify3(value)) {
    const str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
var intBin = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 2, opt),
  stringify: (node) => intStringify2(node, 2, "0b")
};
var intOct2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 1, 8, opt),
  stringify: (node) => intStringify2(node, 8, "0")
};
var int2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (str, _onError, opt) => intResolve2(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 16, opt),
  stringify: (node) => intStringify2(node, 16, "0x")
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/set.js
var YAMLSet = class extends YAMLMap {
  constructor(schema4) {
    super(schema4);
    this.tag = YAMLSet.tag;
  }
  add(key) {
    let pair;
    if (isPair(key))
      pair = key;
    else if (typeof key === "object" && "key" in key && "value" in key && key.value === null)
      pair = new Pair(key.key, null);
    else
      pair = new Pair(key, null);
    const prev = findPair(this.items, pair.key);
    if (!prev)
      this.items.push(pair);
  }
  get(key, keepPair) {
    const pair = findPair(this.items, key);
    return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key, value) {
    if (typeof value !== "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev = findPair(this.items, key);
    if (prev && !value) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value) {
      this.items.push(new Pair(key));
    }
  }
  toJSON(_2, ctx) {
    return super.toJSON(_2, ctx, Set);
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
    else
      throw new Error("Set items must all have null values");
  }
};
YAMLSet.tag = "tag:yaml.org,2002:set";
var set = {
  collection: "map",
  identify: (value) => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: "tag:yaml.org,2002:set",
  resolve(map2, onError) {
    if (isMap(map2)) {
      if (map2.hasAllNullValues(true))
        return Object.assign(new YAMLSet(), map2);
      else
        onError("Set items must all have null values");
    } else
      onError("Expected a mapping for this tag");
    return map2;
  },
  createNode(schema4, iterable, ctx) {
    const { replacer } = ctx;
    const set2 = new YAMLSet(schema4);
    if (iterable && Symbol.iterator in Object(iterable))
      for (let value of iterable) {
        if (typeof replacer === "function")
          value = replacer.call(iterable, value, value);
        set2.items.push(createPair(value, null, ctx));
      }
    return set2;
  }
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js
function parseSexagesimal(str, asBigInt) {
  const sign = str[0];
  const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
  const num = (n6) => asBigInt ? BigInt(n6) : Number(n6);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p2) => res2 * num(60) + num(p2), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node) {
  let { value } = node;
  let num = (n6) => n6;
  if (typeof value === "bigint")
    num = (n6) => BigInt(n6);
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node);
  let sign = "";
  if (value < 0) {
    sign = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign + parts.map((n6) => n6 < 10 ? "0" + String(n6) : String(n6)).join(":").replace(/000000\d*$/, "");
}
var intTime = {
  identify: (value) => typeof value === "bigint" || Number.isInteger(value),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
  stringify: stringifySexagesimal
};
var floatTime = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (str) => parseSexagesimal(str, false),
  stringify: stringifySexagesimal
};
var timestamp = {
  identify: (value) => value instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(str) {
    const match = str.match(timestamp.test);
    if (!match)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, year, month, day, hour, minute, second] = match.map(Number);
    const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
    const tz = match[8];
    if (tz && tz !== "Z") {
      let d3 = parseSexagesimal(tz, false);
      if (Math.abs(d3) < 30)
        d3 *= 60;
      date -= 6e4 * d3;
    }
    return new Date(date);
  },
  stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js
var schema3 = [
  map,
  seq,
  string,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct2,
  int2,
  intHex2,
  floatNaN2,
  floatExp2,
  float2,
  binary,
  omap,
  pairs,
  set,
  intTime,
  floatTime,
  timestamp
];

// node_modules/yaml/browser/dist/schema/tags.js
var schemas = /* @__PURE__ */ new Map([
  ["core", schema],
  ["failsafe", [map, seq, string]],
  ["json", schema2],
  ["yaml11", schema3],
  ["yaml-1.1", schema3]
]);
var tagsByName = {
  binary,
  bool: boolTag,
  float,
  floatExp,
  floatNaN,
  floatTime,
  int,
  intHex,
  intOct,
  intTime,
  map,
  null: nullTag,
  omap,
  pairs,
  seq,
  set,
  timestamp
};
var coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName) {
  let tags = schemas.get(schemaName);
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags)
      tags = tags.concat(tag);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  return tags.map((tag) => {
    if (typeof tag !== "string")
      return tag;
    const tagObj = tagsByName[tag];
    if (tagObj)
      return tagObj;
    const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
    throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
  });
}

// node_modules/yaml/browser/dist/schema/Schema.js
var sortMapEntriesByKey = (a3, b2) => a3.key < b2.key ? -1 : a3.key > b2.key ? 1 : 0;
var Schema = class {
  constructor({ compat, customTags, merge, resolveKnownTags, schema: schema4, sortMapEntries, toStringDefaults }) {
    this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
    this.merge = !!merge;
    this.name = typeof schema4 === "string" && schema4 || "core";
    this.knownTags = resolveKnownTags ? coreKnownTags : {};
    this.tags = getTags(customTags, this.name);
    this.toStringOptions = toStringDefaults != null ? toStringDefaults : null;
    Object.defineProperty(this, MAP, { value: map });
    Object.defineProperty(this, SCALAR, { value: string });
    Object.defineProperty(this, SEQ, { value: seq });
    this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
  }
  clone() {
    const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy.tags = this.tags.slice();
    return copy;
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyDocument.js
function stringifyDocument(doc, options) {
  var _a;
  const lines = [];
  let hasDirectives = options.directives === true;
  if (options.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify(doc.contents, ctx));
  }
  if ((_a = doc.directives) == null ? void 0 : _a.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}

// node_modules/yaml/browser/dist/doc/applyReviver.js
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i4 = 0, len = val.length; i4 < len; ++i4) {
        const v0 = val[i4];
        const v1 = applyReviver(reviver, val, String(i4), v0);
        if (v1 === void 0)
          delete val[i4];
        else if (v1 !== v0)
          val[i4] = v1;
      }
    } else if (val instanceof Map) {
      for (const k2 of Array.from(val.keys())) {
        const v0 = val.get(k2);
        const v1 = applyReviver(reviver, val, k2, v0);
        if (v1 === void 0)
          val.delete(k2);
        else if (v1 !== v0)
          val.set(k2, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k2, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k2, v0);
        if (v1 === void 0)
          delete val[k2];
        else if (v1 !== v0)
          val[k2] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}

// node_modules/yaml/browser/dist/doc/Document.js
var Document2 = class {
  constructor(value, replacer, options) {
    this.commentBefore = null;
    this.comment = null;
    this.errors = [];
    this.warnings = [];
    Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const opt = Object.assign({
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      uniqueKeys: true,
      version: "1.2"
    }, options);
    this.options = opt;
    let { version } = opt;
    if (options == null ? void 0 : options._directives) {
      this.directives = options._directives.atDocument();
      if (this.directives.yaml.explicit)
        version = this.directives.yaml.version;
    } else
      this.directives = new Directives({ version });
    this.setSchema(version, options);
    if (value === void 0)
      this.contents = null;
    else {
      this.contents = this.createNode(value, _replacer, options);
    }
  }
  clone() {
    const copy = Object.create(Document2.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    copy.commentBefore = this.commentBefore;
    copy.comment = this.comment;
    copy.errors = this.errors.slice();
    copy.warnings = this.warnings.slice();
    copy.options = Object.assign({}, this.options);
    if (this.directives)
      copy.directives = this.directives.clone();
    copy.schema = this.schema.clone();
    copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  add(value) {
    if (assertCollection(this.contents))
      this.contents.add(value);
  }
  addIn(path, value) {
    if (assertCollection(this.contents))
      this.contents.addIn(path, value);
  }
  createAlias(node, name) {
    if (!node.anchor) {
      const prev = anchorNames(this);
      node.anchor = !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
    }
    return new Alias(node.anchor);
  }
  createNode(value, replacer, options) {
    let _replacer = void 0;
    if (typeof replacer === "function") {
      value = replacer.call({ "": value }, "", value);
      _replacer = replacer;
    } else if (Array.isArray(replacer)) {
      const keyToStr = (v2) => typeof v2 === "number" || v2 instanceof String || v2 instanceof Number;
      const asStr = replacer.filter(keyToStr).map(String);
      if (asStr.length > 0)
        replacer = replacer.concat(asStr);
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options != null ? options : {};
    const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(this, anchorPrefix || "a");
    const ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects != null ? aliasDuplicateObjects : true,
      keepUndefined: keepUndefined != null ? keepUndefined : false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node = createNode(value, tag, ctx);
    if (flow && isCollection(node))
      node.flow = true;
    setAnchors();
    return node;
  }
  createPair(key, value, options = {}) {
    const k2 = this.createNode(key, null, options);
    const v2 = this.createNode(value, null, options);
    return new Pair(k2, v2);
  }
  delete(key) {
    return assertCollection(this.contents) ? this.contents.delete(key) : false;
  }
  deleteIn(path) {
    if (isEmptyPath(path)) {
      if (this.contents == null)
        return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
  }
  get(key, keepScalar) {
    return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
  }
  getIn(path, keepScalar) {
    if (isEmptyPath(path))
      return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
    return isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
  }
  has(key) {
    return isCollection(this.contents) ? this.contents.has(key) : false;
  }
  hasIn(path) {
    if (isEmptyPath(path))
      return this.contents !== void 0;
    return isCollection(this.contents) ? this.contents.hasIn(path) : false;
  }
  set(key, value) {
    if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, [key], value);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key, value);
    }
  }
  setIn(path, value) {
    if (isEmptyPath(path))
      this.contents = value;
    else if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, Array.from(path), value);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path, value);
    }
  }
  setSchema(version, options = {}) {
    if (typeof version === "number")
      version = String(version);
    let opt;
    switch (version) {
      case "1.1":
        if (this.directives)
          this.directives.yaml.version = "1.1";
        else
          this.directives = new Directives({ version: "1.1" });
        opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        if (this.directives)
          this.directives.yaml.version = version;
        else
          this.directives = new Directives({ version });
        opt = { merge: false, resolveKnownTags: true, schema: "core" };
        break;
      case null:
        if (this.directives)
          delete this.directives;
        opt = null;
        break;
      default: {
        const sv = JSON.stringify(version);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
    }
    if (options.schema instanceof Object)
      this.schema = options.schema;
    else if (opt)
      this.schema = new Schema(Object.assign(opt, options));
    else
      throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !json,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100,
      stringify
    };
    const res = toJS(this.contents, jsonArg != null ? jsonArg : "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
  toJSON(jsonArg, onAnchor) {
    return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
  }
  toString(options = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
      const s5 = JSON.stringify(options.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s5}`);
    }
    return stringifyDocument(this, options);
  }
};
function assertCollection(contents) {
  if (isCollection(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}

// node_modules/yaml/browser/dist/errors.js
var YAMLError = class extends Error {
  constructor(name, pos, code, message) {
    super();
    this.name = name;
    this.code = code;
    this.message = message;
    this.pos = pos;
  }
};
var YAMLParseError = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLParseError", pos, code, message);
  }
};
var YAMLWarning = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLWarning", pos, code, message);
  }
};
var prettifyError = (src, lc) => (error) => {
  if (error.pos[0] === -1)
    return;
  error.linePos = error.pos.map((pos) => lc.linePos(pos));
  const { line, col } = error.linePos[0];
  error.message += ` at line ${line}, column ${col}`;
  let ci = col - 1;
  let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
  if (ci >= 60 && lineStr.length > 80) {
    const trimStart = Math.min(ci - 39, lineStr.length - 79);
    lineStr = "\u2026" + lineStr.substring(trimStart);
    ci -= trimStart - 1;
  }
  if (lineStr.length > 80)
    lineStr = lineStr.substring(0, 79) + "\u2026";
  if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
    let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
    if (prev.length > 80)
      prev = prev.substring(0, 79) + "\u2026\n";
    lineStr = prev + lineStr;
  }
  if (/[^ ]/.test(lineStr)) {
    let count = 1;
    const end = error.linePos[1];
    if (end && end.line === line && end.col > col) {
      count = Math.min(end.col - col, 80 - ci);
    }
    const pointer = " ".repeat(ci) + "^".repeat(count);
    error.message += `:

${lineStr}
${pointer}
`;
  }
};

// node_modules/yaml/browser/dist/compose/resolve-props.js
function resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment = "";
  let commentSep = "";
  let hasNewline = false;
  let hasNewlineAfterProp = false;
  let reqSpace = false;
  let anchor = null;
  let tag = null;
  let comma = null;
  let found = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    switch (token.type) {
      case "space":
        if (!flow && atNewline && indicator !== "doc-start" && token.source[0] === "	")
          onError(token, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment)
          comment = cb;
        else
          comment += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment)
            comment += token.source;
          else
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag)
          hasNewlineAfterProp = true;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token.source.endsWith(":"))
          onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow != null ? flow : "collection"}`);
        found = token;
        atNewline = false;
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== ""))
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  return {
    comma,
    found,
    spaceBefore,
    comment,
    hasNewline,
    hasNewlineAfterProp,
    anchor,
    tag,
    end,
    start: start != null ? start : end
  };
}

// node_modules/yaml/browser/dist/compose/util-contains-newline.js
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}

// node_modules/yaml/browser/dist/compose/util-flow-indent-check.js
function flowIndentCheck(indent, fc, onError) {
  if ((fc == null ? void 0 : fc.type) === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}

// node_modules/yaml/browser/dist/compose/util-map-includes.js
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a3, b2) => a3 === b2 || isScalar(a3) && isScalar(b2) && a3.value === b2.value && !(a3.value === "<<" && ctx.schema.merge);
  return items.some((pair) => isEqual(pair.key, search));
}

// node_modules/yaml/browser/dist/compose/resolve-block-map.js
var startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError) {
  var _a;
  const map2 = new YAMLMap(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bm.offset;
  for (const collItem of bm.items) {
    const { start, key, sep, value } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key != null ? key : sep == null ? void 0 : sep[0],
      offset,
      onError,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep) {
        if (keyProps.comment) {
          if (map2.comment)
            map2.comment += "\n" + keyProps.comment;
          else
            map2.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.hasNewlineAfterProp || containsNewline(key)) {
        onError(key != null ? key : start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (((_a = keyProps.found) == null ? void 0 : _a.indent) !== bm.indent) {
      onError(offset, "BAD_INDENT", startColMsg);
    }
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    if (mapIncludes(ctx, map2.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep != null ? sep : [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if ((value == null ? void 0 : value.type) === "block-map" && !valueProps.hasNewline)
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset, sep, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    }
  }
  map2.range = [bm.offset, offset, offset];
  return map2;
}

// node_modules/yaml/browser/dist/compose/resolve-block-seq.js
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError) {
  const seq2 = new YAMLSeq(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bs.offset;
  for (const { start, value } of bs.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value,
      offset,
      onError,
      startOnNewline: true
    });
    offset = props.end;
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if (value && value.type === "block-seq")
          onError(offset, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, offset, start, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value, onError);
    offset = node.range[2];
    seq2.items.push(node);
  }
  seq2.range = [bs.offset, offset, offset];
  return seq2;
}

// node_modules/yaml/browser/dist/compose/resolve-end.js
function resolveEnd(end, offset, reqSpace, onError) {
  let comment = "";
  if (end) {
    let hasSpace = false;
    let sep = "";
    for (const token of end) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += sep + cb;
          sep = "";
          break;
        }
        case "newline":
          if (comment)
            sep += source;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset += source.length;
    }
  }
  return { comment, offset };
}

// node_modules/yaml/browser/dist/compose/resolve-flow-collection.js
var blockMsg = "Block collections are not allowed within flow collections";
var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError) {
  var _a;
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const coll = isMap2 ? new YAMLMap(ctx.schema) : new YAMLSeq(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  let offset = fc.offset + fc.start.source.length;
  for (let i4 = 0; i4 < fc.items.length; ++i4) {
    const collItem = fc.items[i4];
    const { start, key, sep, value } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key != null ? key : sep == null ? void 0 : sep[0],
      offset,
      onError,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep && !value) {
        if (i4 === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i4 < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
    }
    if (i4 === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop:
          for (const st of start) {
            switch (st.type) {
              case "comma":
              case "space":
                break;
              case "comment":
                prevItemComment = st.source.substring(1);
                break loop;
              default:
                break loop;
            }
          }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = (_a = prev.value) != null ? _a : prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep, null, props, onError);
      coll.items.push(valueNode);
      offset = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      const valueProps = resolveProps(sep != null ? sep : [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep)
            for (const st of sep) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && value.source && value.source[0] === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map2 = coll;
        if (mapIncludes(ctx, map2.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map2.items.push(pair);
      } else {
        const map2 = new YAMLMap(ctx.schema);
        map2.flow = true;
        map2.items.push(pair);
        coll.items.push(map2);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset;
  if (ce && ce.source === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}

// node_modules/yaml/browser/dist/compose/compose-collection.js
function composeCollection(CN2, ctx, token, tagToken, onError) {
  let coll;
  switch (token.type) {
    case "block-map": {
      coll = resolveBlockMap(CN2, ctx, token, onError);
      break;
    }
    case "block-seq": {
      coll = resolveBlockSeq(CN2, ctx, token, onError);
      break;
    }
    case "flow-collection": {
      coll = resolveFlowCollection(CN2, ctx, token, onError);
      break;
    }
  }
  if (!tagToken)
    return coll;
  const tagName = ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (!tagName)
    return coll;
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  const expType = isMap(coll) ? "map" : "seq";
  let tag = ctx.schema.tags.find((t3) => t3.collection === expType && t3.tag === tagName);
  if (!tag) {
    const kt = ctx.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag = kt;
    } else {
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      coll.tag = tagName;
      return coll;
    }
  }
  const res = tag.resolve(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options);
  const node = isNode(res) ? res : new Scalar(res);
  node.range = coll.range;
  node.tag = tagName;
  if (tag == null ? void 0 : tag.format)
    node.format = tag.format;
  return node;
}

// node_modules/yaml/browser/dist/compose/resolve-block-scalar.js
function resolveBlockScalar(scalar, strict, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i4 = lines.length - 1; i4 >= 0; --i4) {
    const content = lines[i4][1];
    if (content === "" || content === "\r")
      chompStart = i4;
    else
      break;
  }
  if (chompStart === 0) {
    const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset = scalar.offset + header.length;
  let contentStart = 0;
  for (let i4 = 0; i4 < chompStart; ++i4) {
    const [indent, content] = lines[i4];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i4;
      break;
    }
    offset += indent.length + content.length + 1;
  }
  for (let i4 = lines.length - 1; i4 >= chompStart; --i4) {
    if (lines[i4][0].length > trimIndent)
      chompStart = i4 + 1;
  }
  let value = "";
  let sep = "";
  let prevMoreIndented = false;
  for (let i4 = 0; i4 < contentStart; ++i4)
    value += lines[i4][0].slice(trimIndent) + "\n";
  for (let i4 = contentStart; i4 < chompStart; ++i4) {
    let [indent, content] = lines[i4];
    offset += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src}`;
      onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep === " ")
        sep = "\n";
      else if (!prevMoreIndented && sep === "\n")
        sep = "\n\n";
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep === "\n")
        value += "\n";
      else
        sep = "\n";
    } else {
      value += sep + content;
      sep = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i4 = chompStart; i4 < lines.length; ++i4)
        value += "\n" + lines[i4][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode = source[0];
  let indent = 0;
  let chomp = "";
  let error = -1;
  for (let i4 = 1; i4 < source.length; ++i4) {
    const ch = source[i4];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n6 = Number(ch);
      if (!indent && n6)
        indent = n6;
      else if (error === -1)
        error = offset + i4;
    }
  }
  if (error !== -1)
    onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment = "";
  let length = source.length;
  for (let i4 = 1; i4 < props.length; ++i4) {
    const token = props[i4];
    switch (token.type) {
      case "space":
        hasSpace = true;
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message);
        }
        length += token.source.length;
        comment = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      default: {
        const message = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode, indent, chomp, comment, length };
}
function splitLines(source) {
  const split = source.split(/\n( *)/);
  const first = split[0];
  const m2 = first.match(/^( *)/);
  const line0 = (m2 == null ? void 0 : m2[1]) ? [m2[1], first.slice(m2[1].length)] : ["", first];
  const lines = [line0];
  for (let i4 = 1; i4 < split.length; i4 += 2)
    lines.push([split[i4], split[i4 + 1]]);
  return lines;
}

// node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js
function resolveFlowScalar(scalar, strict, onError) {
  const { offset, type, source, end } = scalar;
  let _type;
  let value;
  const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source, _onError);
      break;
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset, offset + source.length, offset + source.length]
      };
  }
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re.comment,
    range: [offset, valueEnd, re.offset]
  };
}
function plainValue(source, onError) {
  let badChar = "";
  switch (source[0]) {
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  var _a;
  let first, line;
  try {
    first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch (_2) {
    first = new RegExp("(.*?)[ \\t]*\\r?\\n", "sy");
    line = new RegExp("[ \\t]*(.*?)[ \\t]*\\r?\\n", "sy");
  }
  let match = first.exec(source);
  if (!match)
    return source;
  let res = match[1];
  let sep = " ";
  let pos = first.lastIndex;
  line.lastIndex = pos;
  while (match = line.exec(source)) {
    if (match[1] === "") {
      if (sep === "\n")
        res += sep;
      else
        sep = "\n";
    } else {
      res += sep + match[1];
      sep = " ";
    }
    pos = line.lastIndex;
  }
  const last = new RegExp("[ \\t]*(.*)", "sy");
  last.lastIndex = pos;
  match = last.exec(source);
  return res + sep + ((_a = match == null ? void 0 : match[1]) != null ? _a : "");
}
function doubleQuotedValue(source, onError) {
  let res = "";
  for (let i4 = 1; i4 < source.length - 1; ++i4) {
    const ch = source[i4];
    if (ch === "\r" && source[i4 + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset } = foldNewline(source, i4);
      res += fold;
      i4 = offset;
    } else if (ch === "\\") {
      let next = source[++i4];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source[i4 + 1];
        while (next === " " || next === "	")
          next = source[++i4 + 1];
      } else if (next === "\r" && source[i4 + 1] === "\n") {
        next = source[++i4 + 1];
        while (next === " " || next === "	")
          next = source[++i4 + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source, i4 + 1, length, onError);
        i4 += length;
      } else {
        const raw = source.substr(i4 - 1, 2);
        onError(i4 - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i4;
      let next = source[i4 + 1];
      while (next === " " || next === "	")
        next = source[++i4 + 1];
      if (next !== "\n" && !(next === "\r" && source[i4 + 2] === "\n"))
        res += i4 > wsStart ? source.slice(wsStart, i4 + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset) {
  let fold = "";
  let ch = source[offset + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset += 1;
    ch = source[offset + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset };
}
var escapeCodes = {
  "0": "\0",
  a: "\x07",
  b: "\b",
  e: "\x1B",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	",
  v: "\v",
  N: "\x85",
  _: "\xA0",
  L: "\u2028",
  P: "\u2029",
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function parseCharCode(source, offset, length, onError) {
  const cc = source.substr(offset, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source.substr(offset - 2, length + 2);
    onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}

// node_modules/yaml/browser/dist/compose/compose-scalar.js
function composeScalar(ctx, token, tagToken, onError) {
  const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar(token, ctx.options.strict, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  const tag = tagToken && tagName ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : token.type === "scalar" ? findScalarTagByTest(ctx, value, token, onError) : ctx.schema[SCALAR];
  let scalar;
  try {
    const res = tag.resolve(value, (msg) => onError(tagToken != null ? tagToken : token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar(res) ? res : new Scalar(res);
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    onError(tagToken != null ? tagToken : token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range;
  scalar.source = value;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag.format)
    scalar.format = tag.format;
  if (comment)
    scalar.comment = comment;
  return scalar;
}
function findScalarTagByName(schema4, value, tagName, tagToken, onError) {
  var _a;
  if (tagName === "!")
    return schema4[SCALAR];
  const matchWithTest = [];
  for (const tag of schema4.tags) {
    if (!tag.collection && tag.tag === tagName) {
      if (tag.default && tag.test)
        matchWithTest.push(tag);
      else
        return tag;
    }
  }
  for (const tag of matchWithTest)
    if ((_a = tag.test) == null ? void 0 : _a.test(value))
      return tag;
  const kt = schema4.knownTags[tagName];
  if (kt && !kt.collection) {
    schema4.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema4[SCALAR];
}
function findScalarTagByTest({ directives, schema: schema4 }, value, token, onError) {
  var _a;
  const tag = schema4.tags.find((tag2) => {
    var _a2;
    return tag2.default && ((_a2 = tag2.test) == null ? void 0 : _a2.test(value));
  }) || schema4[SCALAR];
  if (schema4.compat) {
    const compat = (_a = schema4.compat.find((tag2) => {
      var _a2;
      return tag2.default && ((_a2 = tag2.test) == null ? void 0 : _a2.test(value));
    })) != null ? _a : schema4[SCALAR];
    if (tag.tag !== compat.tag) {
      const ts = directives.tagString(tag.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag;
}

// node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js
function emptyScalarPosition(offset, before, pos) {
  if (before) {
    if (pos === null)
      pos = before.length;
    for (let i4 = pos - 1; i4 >= 0; --i4) {
      let st = before[i4];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset -= st.source.length;
          continue;
      }
      st = before[++i4];
      while ((st == null ? void 0 : st.type) === "space") {
        offset += st.source.length;
        st = before[++i4];
      }
      break;
    }
  }
  return offset;
}

// node_modules/yaml/browser/dist/compose/compose-node.js
var CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
  const { spaceBefore, comment, anchor, tag } = props;
  let node;
  let isSrcToken = true;
  switch (token.type) {
    case "alias":
      node = composeAlias(ctx, token, onError);
      if (anchor || tag)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node = composeScalar(ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node = composeCollection(CN, ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    default: {
      const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
      onError(token, "UNEXPECTED_TOKEN", message);
      node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    if (token.type === "scalar" && token.source === "")
      node.comment = comment;
    else
      node.commentBefore = comment;
  }
  if (ctx.options.keepSourceTokens && isSrcToken)
    node.srcToken = token;
  return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset, before, pos),
    indent: -1,
    source: ""
  };
  const node = composeScalar(ctx, token, tag, onError);
  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment)
    node.comment = comment;
  return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias.source.endsWith(":"))
    onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, options.strict, onError);
  alias.range = [offset, valueEnd, re.offset];
  if (re.comment)
    alias.comment = re.comment;
  return alias;
}

// node_modules/yaml/browser/dist/compose/compose-doc.js
function composeDoc(options, directives, { offset, start, value, end }, onError) {
  const opts = Object.assign({ _directives: directives }, options);
  const doc = new Document2(void 0, opts);
  const ctx = {
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value != null ? value : end == null ? void 0 : end[0],
    offset,
    onError,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd(end, contentEnd, false, onError);
  if (re.comment)
    doc.comment = re.comment;
  doc.range = [offset, contentEnd, re.offset];
  return doc;
}

// node_modules/yaml/browser/dist/compose/composer.js
function getErrorPos(src) {
  if (typeof src === "number")
    return [src, src + 1];
  if (Array.isArray(src))
    return src.length === 2 ? src : [src[0], src[1]];
  const { offset, source } = src;
  return [offset, offset + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  var _a;
  let comment = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i4 = 0; i4 < prelude.length; ++i4) {
    const source = prelude[i4];
    switch (source[0]) {
      case "#":
        comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (((_a = prelude[i4 + 1]) == null ? void 0 : _a[0]) !== "#")
          i4 += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment, afterEmptyLine };
}
var Composer = class {
  constructor(options = {}) {
    this.doc = null;
    this.atDirectives = false;
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
    this.onError = (source, code, message, warning) => {
      const pos = getErrorPos(source);
      if (warning)
        this.warnings.push(new YAMLWarning(pos, code, message));
      else
        this.errors.push(new YAMLParseError(pos, code, message));
    };
    this.directives = new Directives({ version: options.version || "1.2" });
    this.options = options;
  }
  decorate(doc, afterDoc) {
    const { comment, afterEmptyLine } = parsePrelude(this.prelude);
    if (comment) {
      const dc = doc.contents;
      if (afterDoc) {
        doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
      } else if (afterEmptyLine || doc.directives.docStart || !dc) {
        doc.commentBefore = comment;
      } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
        let it = dc.items[0];
        if (isPair(it))
          it = it.key;
        const cb = it.commentBefore;
        it.commentBefore = cb ? `${comment}
${cb}` : comment;
      } else {
        const cb = dc.commentBefore;
        dc.commentBefore = cb ? `${comment}
${cb}` : comment;
      }
    }
    if (afterDoc) {
      Array.prototype.push.apply(doc.errors, this.errors);
      Array.prototype.push.apply(doc.warnings, this.warnings);
    } else {
      doc.errors = this.errors;
      doc.warnings = this.warnings;
    }
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
  }
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  *compose(tokens, forceDoc = false, endOffset = -1) {
    for (const token of tokens)
      yield* this.next(token);
    yield* this.end(forceDoc, endOffset);
  }
  *next(token) {
    switch (token.type) {
      case "directive":
        this.directives.add(token.source, (offset, message, warning) => {
          const pos = getErrorPos(token);
          pos[0] += offset;
          this.onError(pos, "BAD_DIRECTIVE", message, warning);
        });
        this.prelude.push(token.source);
        this.atDirectives = true;
        break;
      case "document": {
        const doc = composeDoc(this.options, this.directives, token, this.onError);
        if (this.atDirectives && !doc.directives.docStart)
          this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
        this.decorate(doc, false);
        if (this.doc)
          yield this.doc;
        this.doc = doc;
        this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(token.source);
        break;
      case "error": {
        const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
        const error = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
        if (this.atDirectives || !this.doc)
          this.errors.push(error);
        else
          this.doc.errors.push(error);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const msg = "Unexpected doc-end without preceding document";
          this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
          break;
        }
        this.doc.directives.docEnd = true;
        const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
        this.decorate(this.doc, true);
        if (end.comment) {
          const dc = this.doc.comment;
          this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
        }
        this.doc.range[2] = end.offset;
        break;
      }
      default:
        this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
    }
  }
  *end(forceDoc = false, endOffset = -1) {
    if (this.doc) {
      this.decorate(this.doc, true);
      yield this.doc;
      this.doc = null;
    } else if (forceDoc) {
      const opts = Object.assign({ _directives: this.directives }, this.options);
      const doc = new Document2(void 0, opts);
      if (this.atDirectives)
        this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
      doc.range = [0, endOffset, endOffset];
      this.decorate(doc, false);
      yield doc;
    }
  }
};

// node_modules/yaml/browser/dist/parse/cst-visit.js
var BREAK2 = Symbol("break visit");
var SKIP2 = Symbol("skip children");
var REMOVE2 = Symbol("remove item");
function visit2(cst, visitor) {
  if ("type" in cst && cst.type === "document")
    cst = { start: cst.start, value: cst.value };
  _visit(Object.freeze([]), cst, visitor);
}
visit2.BREAK = BREAK2;
visit2.SKIP = SKIP2;
visit2.REMOVE = REMOVE2;
visit2.itemAtPath = (cst, path) => {
  let item = cst;
  for (const [field, index] of path) {
    const tok = item == null ? void 0 : item[field];
    if (tok && "items" in tok) {
      item = tok.items[index];
    } else
      return void 0;
  }
  return item;
};
visit2.parentCollection = (cst, path) => {
  const parent = visit2.itemAtPath(cst, path.slice(0, -1));
  const field = path[path.length - 1][0];
  const coll = parent == null ? void 0 : parent[field];
  if (coll && "items" in coll)
    return coll;
  throw new Error("Parent collection not found");
};
function _visit(path, item, visitor) {
  let ctrl = visitor(item, path);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i4 = 0; i4 < token.items.length; ++i4) {
        const ci = _visit(Object.freeze(path.concat([[field, i4]])), token.items[i4], visitor);
        if (typeof ci === "number")
          i4 = ci - 1;
        else if (ci === BREAK2)
          return BREAK2;
        else if (ci === REMOVE2) {
          token.items.splice(i4, 1);
          i4 -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
}

// node_modules/yaml/browser/dist/parse/cst.js
var BOM = "\uFEFF";
var DOCUMENT = "";
var FLOW_END = "";
var SCALAR2 = "";
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR2:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}

// node_modules/yaml/browser/dist/parse/lexer.js
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var hexDigits = "0123456789ABCDEFabcdef".split("");
var tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split("");
var invalidFlowScalarChars = ",[]{}".split("");
var invalidAnchorChars = " ,[]{}\n\r	".split("");
var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
var Lexer = class {
  constructor() {
    this.atEnd = false;
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    this.buffer = "";
    this.flowKey = false;
    this.flowLevel = 0;
    this.indentNext = 0;
    this.indentValue = 0;
    this.lineEndPos = null;
    this.next = null;
    this.pos = 0;
  }
  *lex(source, incomplete = false) {
    var _a;
    if (source) {
      this.buffer = this.buffer ? this.buffer + source : source;
      this.lineEndPos = null;
    }
    this.atEnd = !incomplete;
    let next = (_a = this.next) != null ? _a : "stream";
    while (next && (incomplete || this.hasChars(1)))
      next = yield* this.parseNext(next);
  }
  atLineEnd() {
    let i4 = this.pos;
    let ch = this.buffer[i4];
    while (ch === " " || ch === "	")
      ch = this.buffer[++i4];
    if (!ch || ch === "#" || ch === "\n")
      return true;
    if (ch === "\r")
      return this.buffer[i4 + 1] === "\n";
    return false;
  }
  charAt(n6) {
    return this.buffer[this.pos + n6];
  }
  continueScalar(offset) {
    let ch = this.buffer[offset];
    if (this.indentNext > 0) {
      let indent = 0;
      while (ch === " ")
        ch = this.buffer[++indent + offset];
      if (ch === "\r") {
        const next = this.buffer[indent + offset + 1];
        if (next === "\n" || !next && !this.atEnd)
          return offset + indent + 1;
      }
      return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
    }
    if (ch === "-" || ch === ".") {
      const dt = this.buffer.substr(offset, 3);
      if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
        return -1;
    }
    return offset;
  }
  getLine() {
    let end = this.lineEndPos;
    if (typeof end !== "number" || end !== -1 && end < this.pos) {
      end = this.buffer.indexOf("\n", this.pos);
      this.lineEndPos = end;
    }
    if (end === -1)
      return this.atEnd ? this.buffer.substring(this.pos) : null;
    if (this.buffer[end - 1] === "\r")
      end -= 1;
    return this.buffer.substring(this.pos, end);
  }
  hasChars(n6) {
    return this.pos + n6 <= this.buffer.length;
  }
  setNext(state) {
    this.buffer = this.buffer.substring(this.pos);
    this.pos = 0;
    this.lineEndPos = null;
    this.next = state;
    return null;
  }
  peek(n6) {
    return this.buffer.substr(this.pos, n6);
  }
  *parseNext(next) {
    switch (next) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let line = this.getLine();
    if (line === null)
      return this.setNext("stream");
    if (line[0] === BOM) {
      yield* this.pushCount(1);
      line = line.substring(1);
    }
    if (line[0] === "%") {
      let dirEnd = line.length;
      const cs = line.indexOf("#");
      if (cs !== -1) {
        const ch = line[cs - 1];
        if (ch === " " || ch === "	")
          dirEnd = cs - 1;
      }
      while (true) {
        const ch = line[dirEnd - 1];
        if (ch === " " || ch === "	")
          dirEnd -= 1;
        else
          break;
      }
      const n6 = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
      yield* this.pushCount(line.length - n6);
      this.pushNewline();
      return "stream";
    }
    if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(true);
      yield* this.pushCount(line.length - sp);
      yield* this.pushNewline();
      return "stream";
    }
    yield DOCUMENT;
    return yield* this.parseLineStart();
  }
  *parseLineStart() {
    const ch = this.charAt(0);
    if (!ch && !this.atEnd)
      return this.setNext("line-start");
    if (ch === "-" || ch === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const s5 = this.peek(3);
      if (s5 === "---" && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        this.indentValue = 0;
        this.indentNext = 0;
        return "doc";
      } else if (s5 === "..." && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        return "stream";
      }
    }
    this.indentValue = yield* this.pushSpaces(false);
    if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
      this.indentNext = this.indentValue;
    return yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [ch0, ch1] = this.peek(2);
    if (!ch1 && !this.atEnd)
      return this.setNext("block-start");
    if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
      const n6 = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      this.indentNext = this.indentValue + 1;
      this.indentValue += n6;
      return yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const line = this.getLine();
    if (line === null)
      return this.setNext("doc");
    let n6 = yield* this.pushIndicators();
    switch (line[n6]) {
      case "#":
        yield* this.pushCount(line.length - n6);
      case void 0:
        yield* this.pushNewline();
        return yield* this.parseLineStart();
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel = 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        return "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        n6 += yield* this.parseBlockScalarHeader();
        n6 += yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - n6);
        yield* this.pushNewline();
        return yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let nl, sp;
    let indent = -1;
    do {
      nl = yield* this.pushNewline();
      if (nl > 0) {
        sp = yield* this.pushSpaces(false);
        this.indentValue = indent = sp;
      } else {
        sp = 0;
      }
      sp += yield* this.pushSpaces(true);
    } while (nl + sp > 0);
    const line = this.getLine();
    if (line === null)
      return this.setNext("flow");
    if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
      const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
      if (!atFlowEndMarker) {
        this.flowLevel = 0;
        yield FLOW_END;
        return yield* this.parseLineStart();
      }
    }
    let n6 = 0;
    while (line[n6] === ",") {
      n6 += yield* this.pushCount(1);
      n6 += yield* this.pushSpaces(true);
      this.flowKey = false;
    }
    n6 += yield* this.pushIndicators();
    switch (line[n6]) {
      case void 0:
        return "flow";
      case "#":
        yield* this.pushCount(line.length - n6);
        return "flow";
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel += 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        this.flowKey = true;
        this.flowLevel -= 1;
        return this.flowLevel ? "flow" : "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "flow";
      case '"':
      case "'":
        this.flowKey = true;
        return yield* this.parseQuotedScalar();
      case ":": {
        const next = this.charAt(1);
        if (this.flowKey || isEmpty(next) || next === ",") {
          this.flowKey = false;
          yield* this.pushCount(1);
          yield* this.pushSpaces(true);
          return "flow";
        }
      }
      default:
        this.flowKey = false;
        return yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const quote = this.charAt(0);
    let end = this.buffer.indexOf(quote, this.pos + 1);
    if (quote === "'") {
      while (end !== -1 && this.buffer[end + 1] === "'")
        end = this.buffer.indexOf("'", end + 2);
    } else {
      while (end !== -1) {
        let n6 = 0;
        while (this.buffer[end - 1 - n6] === "\\")
          n6 += 1;
        if (n6 % 2 === 0)
          break;
        end = this.buffer.indexOf('"', end + 1);
      }
    }
    const qb = this.buffer.substring(0, end);
    let nl = qb.indexOf("\n", this.pos);
    if (nl !== -1) {
      while (nl !== -1) {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = qb.indexOf("\n", cs);
      }
      if (nl !== -1) {
        end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
      }
    }
    if (end === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      end = this.buffer.length;
    }
    yield* this.pushToIndex(end + 1, false);
    return this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    let i4 = this.pos;
    while (true) {
      const ch = this.buffer[++i4];
      if (ch === "+")
        this.blockScalarKeep = true;
      else if (ch > "0" && ch <= "9")
        this.blockScalarIndent = Number(ch) - 1;
      else if (ch !== "-")
        break;
    }
    return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
  }
  *parseBlockScalar() {
    let nl = this.pos - 1;
    let indent = 0;
    let ch;
    loop:
      for (let i4 = this.pos; ch = this.buffer[i4]; ++i4) {
        switch (ch) {
          case " ":
            indent += 1;
            break;
          case "\n":
            nl = i4;
            indent = 0;
            break;
          case "\r": {
            const next = this.buffer[i4 + 1];
            if (!next && !this.atEnd)
              return this.setNext("block-scalar");
            if (next === "\n")
              break;
          }
          default:
            break loop;
        }
      }
    if (!ch && !this.atEnd)
      return this.setNext("block-scalar");
    if (indent >= this.indentNext) {
      if (this.blockScalarIndent === -1)
        this.indentNext = indent;
      else
        this.indentNext += this.blockScalarIndent;
      do {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = this.buffer.indexOf("\n", cs);
      } while (nl !== -1);
      if (nl === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        nl = this.buffer.length;
      }
    }
    if (!this.blockScalarKeep) {
      do {
        let i4 = nl - 1;
        let ch2 = this.buffer[i4];
        if (ch2 === "\r")
          ch2 = this.buffer[--i4];
        const lastChar = i4;
        while (ch2 === " " || ch2 === "	")
          ch2 = this.buffer[--i4];
        if (ch2 === "\n" && i4 >= this.pos && i4 + 1 + indent > lastChar)
          nl = i4;
        else
          break;
      } while (true);
    }
    yield SCALAR2;
    yield* this.pushToIndex(nl + 1, true);
    return yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const inFlow = this.flowLevel > 0;
    let end = this.pos - 1;
    let i4 = this.pos - 1;
    let ch;
    while (ch = this.buffer[++i4]) {
      if (ch === ":") {
        const next = this.buffer[i4 + 1];
        if (isEmpty(next) || inFlow && next === ",")
          break;
        end = i4;
      } else if (isEmpty(ch)) {
        let next = this.buffer[i4 + 1];
        if (ch === "\r") {
          if (next === "\n") {
            i4 += 1;
            ch = "\n";
            next = this.buffer[i4 + 1];
          } else
            end = i4;
        }
        if (next === "#" || inFlow && invalidFlowScalarChars.includes(next))
          break;
        if (ch === "\n") {
          const cs = this.continueScalar(i4 + 1);
          if (cs === -1)
            break;
          i4 = Math.max(i4, cs - 2);
        }
      } else {
        if (inFlow && invalidFlowScalarChars.includes(ch))
          break;
        end = i4;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("plain-scalar");
    yield SCALAR2;
    yield* this.pushToIndex(end + 1, true);
    return inFlow ? "flow" : "doc";
  }
  *pushCount(n6) {
    if (n6 > 0) {
      yield this.buffer.substr(this.pos, n6);
      this.pos += n6;
      return n6;
    }
    return 0;
  }
  *pushToIndex(i4, allowEmpty) {
    const s5 = this.buffer.slice(this.pos, i4);
    if (s5) {
      yield s5;
      this.pos += s5.length;
      return s5.length;
    } else if (allowEmpty)
      yield "";
    return 0;
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "-":
      case "?":
      case ":": {
        const inFlow = this.flowLevel > 0;
        const ch1 = this.charAt(1);
        if (isEmpty(ch1) || inFlow && invalidFlowScalarChars.includes(ch1)) {
          if (!inFlow)
            this.indentNext = this.indentValue + 1;
          else if (this.flowKey)
            this.flowKey = false;
          return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        }
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let i4 = this.pos + 2;
      let ch = this.buffer[i4];
      while (!isEmpty(ch) && ch !== ">")
        ch = this.buffer[++i4];
      return yield* this.pushToIndex(ch === ">" ? i4 + 1 : i4, false);
    } else {
      let i4 = this.pos + 1;
      let ch = this.buffer[i4];
      while (ch) {
        if (tagChars.includes(ch))
          ch = this.buffer[++i4];
        else if (ch === "%" && hexDigits.includes(this.buffer[i4 + 1]) && hexDigits.includes(this.buffer[i4 + 2])) {
          ch = this.buffer[i4 += 3];
        } else
          break;
      }
      return yield* this.pushToIndex(i4, false);
    }
  }
  *pushNewline() {
    const ch = this.buffer[this.pos];
    if (ch === "\n")
      return yield* this.pushCount(1);
    else if (ch === "\r" && this.charAt(1) === "\n")
      return yield* this.pushCount(2);
    else
      return 0;
  }
  *pushSpaces(allowTabs) {
    let i4 = this.pos - 1;
    let ch;
    do {
      ch = this.buffer[++i4];
    } while (ch === " " || allowTabs && ch === "	");
    const n6 = i4 - this.pos;
    if (n6 > 0) {
      yield this.buffer.substr(this.pos, n6);
      this.pos = i4;
    }
    return n6;
  }
  *pushUntil(test) {
    let i4 = this.pos;
    let ch = this.buffer[i4];
    while (!test(ch))
      ch = this.buffer[++i4];
    return yield* this.pushToIndex(i4, false);
  }
};

// node_modules/yaml/browser/dist/parse/line-counter.js
var LineCounter = class {
  constructor() {
    this.lineStarts = [];
    this.addNewLine = (offset) => this.lineStarts.push(offset);
    this.linePos = (offset) => {
      let low = 0;
      let high = this.lineStarts.length;
      while (low < high) {
        const mid = low + high >> 1;
        if (this.lineStarts[mid] < offset)
          low = mid + 1;
        else
          high = mid;
      }
      if (this.lineStarts[low] === offset)
        return { line: low + 1, col: 1 };
      if (low === 0)
        return { line: 0, col: offset };
      const start = this.lineStarts[low - 1];
      return { line: low, col: offset - start + 1 };
    };
  }
};

// node_modules/yaml/browser/dist/parse/parser.js
function includesToken(list, type) {
  for (let i4 = 0; i4 < list.length; ++i4)
    if (list[i4].type === type)
      return true;
  return false;
}
function findNonEmptyIndex(list) {
  for (let i4 = 0; i4 < list.length; ++i4) {
    switch (list[i4].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i4;
    }
  }
  return -1;
}
function isFlowToken(token) {
  switch (token == null ? void 0 : token.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  var _a;
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return (_a = it.sep) != null ? _a : it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  var _a;
  if (prev.length === 0)
    return [];
  let i4 = prev.length;
  loop:
    while (--i4 >= 0) {
      switch (prev[i4].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break loop;
      }
    }
  while (((_a = prev[++i4]) == null ? void 0 : _a.type) === "space") {
  }
  return prev.splice(i4, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
var Parser = class {
  constructor(onNewLine) {
    this.atNewLine = true;
    this.atScalar = false;
    this.indent = 0;
    this.offset = 0;
    this.onKeyLine = false;
    this.stack = [];
    this.source = "";
    this.type = "";
    this.lexer = new Lexer();
    this.onNewLine = onNewLine;
  }
  *parse(source, incomplete = false) {
    if (this.onNewLine && this.offset === 0)
      this.onNewLine(0);
    for (const lexeme of this.lexer.lex(source, incomplete))
      yield* this.next(lexeme);
    if (!incomplete)
      yield* this.end();
  }
  *next(source) {
    this.source = source;
    if (this.atScalar) {
      this.atScalar = false;
      yield* this.step();
      this.offset += source.length;
      return;
    }
    const type = tokenType(source);
    if (!type) {
      const message = `Not a YAML token: ${source}`;
      yield* this.pop({ type: "error", offset: this.offset, message, source });
      this.offset += source.length;
    } else if (type === "scalar") {
      this.atNewLine = false;
      this.atScalar = true;
      this.type = "scalar";
    } else {
      this.type = type;
      yield* this.step();
      switch (type) {
        case "newline":
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine)
            this.onNewLine(this.offset + source.length);
          break;
        case "space":
          if (this.atNewLine && source[0] === " ")
            this.indent += source.length;
          break;
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
          if (this.atNewLine)
            this.indent += source.length;
          break;
        case "doc-mode":
        case "flow-error-end":
          return;
        default:
          this.atNewLine = false;
      }
      this.offset += source.length;
    }
  }
  *end() {
    while (this.stack.length > 0)
      yield* this.pop();
  }
  get sourceToken() {
    const st = {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
    return st;
  }
  *step() {
    const top = this.peek(1);
    if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
      while (this.stack.length > 0)
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!top)
      return yield* this.stream();
    switch (top.type) {
      case "document":
        return yield* this.document(top);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(top);
      case "block-scalar":
        return yield* this.blockScalar(top);
      case "block-map":
        return yield* this.blockMap(top);
      case "block-seq":
        return yield* this.blockSequence(top);
      case "flow-collection":
        return yield* this.flowCollection(top);
      case "doc-end":
        return yield* this.documentEnd(top);
    }
    yield* this.pop();
  }
  peek(n6) {
    return this.stack[this.stack.length - n6];
  }
  *pop(error) {
    const token = error != null ? error : this.stack.pop();
    if (!token) {
      const message = "Tried to pop an empty stack";
      yield { type: "error", offset: this.offset, source: "", message };
    } else if (this.stack.length === 0) {
      yield token;
    } else {
      const top = this.peek(1);
      if (token.type === "block-scalar") {
        token.indent = "indent" in top ? top.indent : 0;
      } else if (token.type === "flow-collection" && top.type === "document") {
        token.indent = 0;
      }
      if (token.type === "flow-collection")
        fixFlowSeqItems(token);
      switch (top.type) {
        case "document":
          top.value = token;
          break;
        case "block-scalar":
          top.props.push(token);
          break;
        case "block-map": {
          const it = top.items[top.items.length - 1];
          if (it.value) {
            top.items.push({ start: [], key: token, sep: [] });
            this.onKeyLine = true;
            return;
          } else if (it.sep) {
            it.value = token;
          } else {
            Object.assign(it, { key: token, sep: [] });
            this.onKeyLine = !includesToken(it.start, "explicit-key-ind");
            return;
          }
          break;
        }
        case "block-seq": {
          const it = top.items[top.items.length - 1];
          if (it.value)
            top.items.push({ start: [], value: token });
          else
            it.value = token;
          break;
        }
        case "flow-collection": {
          const it = top.items[top.items.length - 1];
          if (!it || it.value)
            top.items.push({ start: [], key: token, sep: [] });
          else if (it.sep)
            it.value = token;
          else
            Object.assign(it, { key: token, sep: [] });
          return;
        }
        default:
          yield* this.pop();
          yield* this.pop(token);
      }
      if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
        const last = token.items[token.items.length - 1];
        if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
          if (top.type === "document")
            top.end = last.start;
          else
            top.items.push({ start: last.start });
          token.items.splice(-1, 1);
        }
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const doc = {
          type: "document",
          offset: this.offset,
          start: []
        };
        if (this.type === "doc-start")
          doc.start.push(this.sourceToken);
        this.stack.push(doc);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(doc) {
    if (doc.value)
      return yield* this.lineEnd(doc);
    switch (this.type) {
      case "doc-start": {
        if (findNonEmptyIndex(doc.start) !== -1) {
          yield* this.pop();
          yield* this.step();
        } else
          doc.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        doc.start.push(this.sourceToken);
        return;
    }
    const bv = this.startBlockValue(doc);
    if (bv)
      this.stack.push(bv);
    else {
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML document`,
        source: this.source
      };
    }
  }
  *scalar(scalar) {
    if (this.type === "map-value-ind") {
      const prev = getPrevProps(this.peek(2));
      const start = getFirstKeyStartProps(prev);
      let sep;
      if (scalar.end) {
        sep = scalar.end;
        sep.push(this.sourceToken);
        delete scalar.end;
      } else
        sep = [this.sourceToken];
      const map2 = {
        type: "block-map",
        offset: scalar.offset,
        indent: scalar.indent,
        items: [{ start, key: scalar, sep }]
      };
      this.onKeyLine = true;
      this.stack[this.stack.length - 1] = map2;
    } else
      yield* this.lineEnd(scalar);
  }
  *blockScalar(scalar) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        scalar.props.push(this.sourceToken);
        return;
      case "scalar":
        scalar.source = this.source;
        this.atNewLine = true;
        this.indent = 0;
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        yield* this.pop();
        break;
      default:
        yield* this.pop();
        yield* this.step();
    }
  }
  *blockMap(map2) {
    var _a;
    const it = map2.items[map2.items.length - 1];
    switch (this.type) {
      case "newline":
        this.onKeyLine = false;
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last == null ? void 0 : last.type) === "comment")
            end == null ? void 0 : end.push(this.sourceToken);
          else
            map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          it.start.push(this.sourceToken);
        }
        return;
      case "space":
      case "comment":
        if (it.value) {
          map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          if (this.atIndentedComment(it.start, map2.indent)) {
            const prev = map2.items[map2.items.length - 2];
            const end = (_a = prev == null ? void 0 : prev.value) == null ? void 0 : _a.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              map2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= map2.indent) {
      const atNextItem = !this.onKeyLine && this.indent === map2.indent && it.sep;
      let start = [];
      if (atNextItem && it.sep && !it.value) {
        const nl = [];
        for (let i4 = 0; i4 < it.sep.length; ++i4) {
          const st = it.sep[i4];
          switch (st.type) {
            case "newline":
              nl.push(i4);
              break;
            case "space":
              break;
            case "comment":
              if (st.indent > map2.indent)
                nl.length = 0;
              break;
            default:
              nl.length = 0;
          }
        }
        if (nl.length >= 2)
          start = it.sep.splice(nl[1]);
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map2.items.push({ start });
            this.onKeyLine = true;
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "explicit-key-ind":
          if (!it.sep && !includesToken(it.start, "explicit-key-ind")) {
            it.start.push(this.sourceToken);
          } else if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map2.items.push({ start });
          } else {
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            });
          }
          this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (includesToken(it.start, "explicit-key-ind")) {
            if (!it.sep) {
              if (includesToken(it.start, "newline")) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else {
                const start2 = getFirstKeyStartProps(it.start);
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                });
              }
            } else if (it.value) {
              map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start, key: null, sep: [this.sourceToken] }]
              });
            } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
              const start2 = getFirstKeyStartProps(it.start);
              const key = it.key;
              const sep = it.sep;
              sep.push(this.sourceToken);
              delete it.key, delete it.sep;
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: start2, key, sep }]
              });
            } else if (start.length > 0) {
              it.sep = it.sep.concat(start, this.sourceToken);
            } else {
              it.sep.push(this.sourceToken);
            }
          } else {
            if (!it.sep) {
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            } else if (it.value || atNextItem) {
              map2.items.push({ start, key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [], key: null, sep: [this.sourceToken] }]
              });
            } else {
              it.sep.push(this.sourceToken);
            }
          }
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (atNextItem || it.value) {
            map2.items.push({ start, key: fs, sep: [] });
            this.onKeyLine = true;
          } else if (it.sep) {
            this.stack.push(fs);
          } else {
            Object.assign(it, { key: fs, sep: [] });
            this.onKeyLine = true;
          }
          return;
        }
        default: {
          const bv = this.startBlockValue(map2);
          if (bv) {
            if (atNextItem && bv.type !== "block-seq" && includesToken(it.start, "explicit-key-ind")) {
              map2.items.push({ start });
            }
            this.stack.push(bv);
            return;
          }
        }
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *blockSequence(seq2) {
    var _a;
    const it = seq2.items[seq2.items.length - 1];
    switch (this.type) {
      case "newline":
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last == null ? void 0 : last.type) === "comment")
            end == null ? void 0 : end.push(this.sourceToken);
          else
            seq2.items.push({ start: [this.sourceToken] });
        } else
          it.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it.value)
          seq2.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(it.start, seq2.indent)) {
            const prev = seq2.items[seq2.items.length - 2];
            const end = (_a = prev == null ? void 0 : prev.value) == null ? void 0 : _a.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              seq2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (it.value || this.indent <= seq2.indent)
          break;
        it.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== seq2.indent)
          break;
        if (it.value || includesToken(it.start, "seq-item-ind"))
          seq2.items.push({ start: [this.sourceToken] });
        else
          it.start.push(this.sourceToken);
        return;
    }
    if (this.indent > seq2.indent) {
      const bv = this.startBlockValue(seq2);
      if (bv) {
        this.stack.push(bv);
        return;
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *flowCollection(fc) {
    const it = fc.items[fc.items.length - 1];
    if (this.type === "flow-error-end") {
      let top;
      do {
        yield* this.pop();
        top = this.peek(1);
      } while (top && top.type === "flow-collection");
    } else if (fc.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          if (!it || it.sep)
            fc.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          if (!it || it.value)
            fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            Object.assign(it, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          if (!it || it.value)
            fc.items.push({ start: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (!it || it.value)
            fc.items.push({ start: [], key: fs, sep: [] });
          else if (it.sep)
            this.stack.push(fs);
          else
            Object.assign(it, { key: fs, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          fc.end.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(fc);
      if (bv)
        this.stack.push(bv);
      else {
        yield* this.pop();
        yield* this.step();
      }
    } else {
      const parent = this.peek(2);
      if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
        yield* this.pop();
        yield* this.step();
      } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        fixFlowSeqItems(fc);
        const sep = fc.end.splice(1, fc.end.length);
        sep.push(this.sourceToken);
        const map2 = {
          type: "block-map",
          offset: fc.offset,
          indent: fc.indent,
          items: [{ start, key: fc, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map2;
      } else {
        yield* this.lineEnd(fc);
      }
    }
  }
  flowScalar(type) {
    if (this.onNewLine) {
      let nl = this.source.indexOf("\n") + 1;
      while (nl !== 0) {
        this.onNewLine(this.offset + nl);
        nl = this.source.indexOf("\n", nl) + 1;
      }
    }
    return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(parent) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        start.push(this.sourceToken);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(start, indent) {
    if (this.type !== "comment")
      return false;
    if (this.indent <= indent)
      return false;
    return start.every((st) => st.type === "newline" || st.type === "space");
  }
  *documentEnd(docEnd) {
    if (this.type !== "doc-mode") {
      if (docEnd.end)
        docEnd.end.push(this.sourceToken);
      else
        docEnd.end = [this.sourceToken];
      if (this.type === "newline")
        yield* this.pop();
    }
  }
  *lineEnd(token) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop();
        yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      case "space":
      case "comment":
      default:
        if (token.end)
          token.end.push(this.sourceToken);
        else
          token.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
    }
  }
};

// node_modules/yaml/browser/dist/public-api.js
function parseOptions(options) {
  const prettyErrors = options.prettyErrors !== false;
  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseDocument(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser(lineCounter == null ? void 0 : lineCounter.addNewLine);
  const composer = new Composer(options);
  let doc = null;
  for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source, lineCounter));
    doc.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc;
}
function parse2(src, reviver, options) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options === void 0 && reviver && typeof reviver === "object") {
    options = reviver;
  }
  const doc = parseDocument(src, options);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options));
}

// node_modules/tslib/modules/index.js
var import_tslib = __toESM(require_tslib(), 1);
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn
} = import_tslib.default;

// node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i4) {
      return i4 + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = function() {
  function Subscription3(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription3.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                _a.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e7) {
          errors = e7 instanceof UnsubscriptionError ? e7.errors : [e7];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription3.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription3) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription3.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription3.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription3.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription3.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription3) {
      teardown._removeParent(this);
    }
  };
  Subscription3.EMPTY = function() {
    var empty = new Subscription3();
    empty.closed = true;
    return empty;
  }();
  return Subscription3;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/rxjs/dist/esm5/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop() {
}

// node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// node_modules/rxjs/dist/esm5/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

// node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x2) {
  return x2;
}

// node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}

// node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x2) {
        return value = x2;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return this;
  };
  return Action2;
}(Subscription);

// node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
var intervalProvider = {
  setInterval: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay);
    }
    this.pending = true;
    this.delay = delay;
    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (delay != null && this.delay === delay && this.pending === false) {
      return id;
    }
    intervalProvider.clearInterval(id);
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e7) {
      errored = true;
      errorValue = e7 ? e7 : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id = _a.id, scheduler = _a.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);

// node_modules/rxjs/dist/esm5/internal/Scheduler.js
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay, state) {
    if (delay === void 0) {
      delay = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    _this._scheduled = void 0;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/async.js
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async = asyncScheduler;

// node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction(value.schedule);
}

// node_modules/rxjs/dist/esm5/internal/util/isDate.js
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}

// node_modules/rxjs/dist/esm5/internal/observable/timer.js
function timer(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n6 = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n6++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/interval.js
function interval(period, scheduler) {
  if (period === void 0) {
    period = 0;
  }
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  if (period < 0) {
    period = 0;
  }
  return timer(period, period, scheduler);
}

// src/main.ts
var AppleRemindersPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.elementRegister = {};
  }
  message(msg, disappearIn) {
    if (disappearIn) {
      this.statusBar.setText(msg);
      setTimeout(() => {
        this.statusBar.setText("\u{1F34E}");
      }, disappearIn);
    } else
      this.statusBar.setText(msg);
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.statusBar = this.addStatusBarItem();
      this.statusBar.setText("Loading Apple Reminders...");
      this.addSettingTab(new SampleSettingTab(this.app, this));
      RemindersDataService.setLogger((x2, timeout) => this.message(x2, timeout));
      RemindersDataService.setSettings(this.settings);
      this.registerMarkdownCodeBlockProcessor("apple-reminders", (src, el, ctx) => {
        var _a, _b;
        const spec = parse2(src.trim());
        if (!spec["list"]) {
          new import_obsidian4.Notice("You cannot have an apple-reminders block without a list name!", 3e3);
          el.innerHTML = `
					<pre>Please add list name to continue</pre>
				`;
          return;
        }
        let lE = new ListElement(spec);
        let fileName = (_b = (_a = ctx.sourcePath.split("\\").last()) == null ? void 0 : _a.split("/").last()) == null ? void 0 : _b.trim().split(".").first();
        let x2 = interval(RemindersDataService.getSettings().autoRefreshTime * 1e4).subscribe(() => {
          RemindersDataService.fetchData(spec, fileName).then(([listData, reminders]) => {
            lE.reminders = reminders;
            lE.listMeta = listData;
          });
        });
        this.elementRegister[src.trim()] = {
          list: lE,
          spec,
          sub: x2
        };
        RemindersDataService.fetchData(spec, fileName).then(([listData, reminders]) => {
          lE.listMeta = listData;
          lE.reminders = reminders;
        });
        el.appendChild(lE);
      });
    });
  }
  onunload() {
    Object.keys(this.elementRegister).forEach((key) => {
      this.elementRegister[key].sub.unsubscribe();
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2J1ZmZlcnMvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL25vZGUtb3Nhc2NyaXB0L2xpYi9vc2EtcGFyc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy9ub2RlLW9zYXNjcmlwdC9saWIvb3NhLXZhcmdlbi5qcyIsICJub2RlX21vZHVsZXMvbm9kZS1vc2FzY3JpcHQvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvdXRpbHMvcGF0dGVybi50cyIsICJub2RlX21vZHVsZXMvZGF5anMvZGF5anMubWluLmpzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY2FsY3VsYXRpb24veWVhcnMudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvZGF5anMvcGx1Z2luL3F1YXJ0ZXJPZlllYXIuanMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy91dGlscy9kYXlqcy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL3RpbWV6b25lLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvcmVzdWx0cy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9wYXJzZXJzL0Fic3RyYWN0UGFyc2VyV2l0aFdvcmRCb3VuZGFyeS50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZW4vcGFyc2Vycy9FTlRpbWVVbml0V2l0aGluRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOTW9udGhOYW1lTGl0dGxlRW5kaWFuUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOTW9udGhOYW1lTWlkZGxlRW5kaWFuUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOTW9udGhOYW1lUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOQ2FzdWFsWWVhck1vbnRoRGF5UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOU2xhc2hNb250aEZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9wYXJzZXJzL0Fic3RyYWN0VGltZUV4cHJlc3Npb25QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3BhcnNlcnMvRU5UaW1lRXhwcmVzc2lvblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL3V0aWxzL3RpbWV1bml0cy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZW4vcGFyc2Vycy9FTlRpbWVVbml0QWdvRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOVGltZVVuaXRMYXRlckZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9hYnN0cmFjdFJlZmluZXJzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3JlZmluZXJzL0Fic3RyYWN0TWVyZ2VEYXRlUmFuZ2VSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9yZWZpbmVycy9FTk1lcmdlRGF0ZVJhbmdlUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NhbGN1bGF0aW9uL21lcmdpbmdDYWxjdWxhdGlvbi50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9yZWZpbmVycy9BYnN0cmFjdE1lcmdlRGF0ZVRpbWVSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9yZWZpbmVycy9FTk1lcmdlRGF0ZVRpbWVSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3JlZmluZXJzL0V4dHJhY3RUaW1lem9uZUFiYnJSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3JlZmluZXJzL0V4dHJhY3RUaW1lem9uZU9mZnNldFJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9jb21tb24vcmVmaW5lcnMvT3ZlcmxhcFJlbW92YWxSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3JlZmluZXJzL0ZvcndhcmREYXRlUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9yZWZpbmVycy9Vbmxpa2VseUZvcm1hdEZpbHRlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9wYXJzZXJzL0lTT0Zvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9yZWZpbmVycy9NZXJnZVdlZWtkYXlDb21wb25lbnRSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29uZmlndXJhdGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9jb21tb24vY2FzdWFsUmVmZXJlbmNlcy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZW4vcGFyc2Vycy9FTkNhc3VhbERhdGVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3BhcnNlcnMvRU5DYXN1YWxUaW1lUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL2NhbGN1bGF0aW9uL3dlZWtkYXlzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOV2Vla2RheVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZW4vcGFyc2Vycy9FTlJlbGF0aXZlRGF0ZUZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2Nocm9uby50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9wYXJzZXJzL1NsYXNoRGF0ZUZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZW4vcGFyc2Vycy9FTlRpbWVVbml0Q2FzdWFsUmVsYXRpdmVGb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3JlZmluZXJzL0VOTWVyZ2VSZWxhdGl2ZURhdGVSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9pbmRleC50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZGUvcGFyc2Vycy9ERVRpbWVFeHByZXNzaW9uUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9kZS9jb25zdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2RlL3BhcnNlcnMvREVXZWVrZGF5UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9kZS9wYXJzZXJzL0RFU3BlY2lmaWNUaW1lRXhwcmVzc2lvblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZGUvcmVmaW5lcnMvREVNZXJnZURhdGVSYW5nZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2RlL3JlZmluZXJzL0RFTWVyZ2VEYXRlVGltZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2RlL3BhcnNlcnMvREVDYXN1YWxUaW1lUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9kZS9wYXJzZXJzL0RFQ2FzdWFsRGF0ZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZGUvcGFyc2Vycy9ERU1vbnRoTmFtZUxpdHRsZUVuZGlhblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZGUvcGFyc2Vycy9ERVRpbWVVbml0UmVsYXRpdmVGb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2RlL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9mci9wYXJzZXJzL0ZSQ2FzdWFsRGF0ZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZnIvcGFyc2Vycy9GUkNhc3VhbFRpbWVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2ZyL3BhcnNlcnMvRlJUaW1lRXhwcmVzc2lvblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZnIvcmVmaW5lcnMvRlJNZXJnZURhdGVUaW1lUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZnIvcmVmaW5lcnMvRlJNZXJnZURhdGVSYW5nZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2ZyL2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZnIvcGFyc2Vycy9GUldlZWtkYXlQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2ZyL3BhcnNlcnMvRlJTcGVjaWZpY1RpbWVFeHByZXNzaW9uUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9mci9wYXJzZXJzL0ZSTW9udGhOYW1lTGl0dGxlRW5kaWFuUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9mci9wYXJzZXJzL0ZSVGltZVVuaXRBZ29Gb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2ZyL3BhcnNlcnMvRlJUaW1lVW5pdFdpdGhpbkZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZnIvcGFyc2Vycy9GUlRpbWVVbml0UmVsYXRpdmVGb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2ZyL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9qYS9jb25zdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2phL3BhcnNlcnMvSlBTdGFuZGFyZFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvamEvcmVmaW5lcnMvSlBNZXJnZURhdGVSYW5nZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2phL3BhcnNlcnMvSlBDYXN1YWxEYXRlUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9qYS9pbmRleC50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcHQvY29uc3RhbnRzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9wdC9wYXJzZXJzL1BUV2Vla2RheVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcHQvcGFyc2Vycy9QVFRpbWVFeHByZXNzaW9uUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9wdC9yZWZpbmVycy9QVE1lcmdlRGF0ZVRpbWVSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9wdC9yZWZpbmVycy9QVE1lcmdlRGF0ZVJhbmdlUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcHQvcGFyc2Vycy9QVE1vbnRoTmFtZUxpdHRsZUVuZGlhblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcHQvcGFyc2Vycy9QVENhc3VhbERhdGVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3B0L3BhcnNlcnMvUFRDYXN1YWxUaW1lUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9wdC9pbmRleC50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcmVmaW5lcnMvTkxNZXJnZURhdGVSYW5nZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3JlZmluZXJzL05MTWVyZ2VEYXRlVGltZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3BhcnNlcnMvTkxDYXN1YWxEYXRlUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9wYXJzZXJzL05MQ2FzdWFsVGltZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvY29uc3RhbnRzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9wYXJzZXJzL05MVGltZVVuaXRXaXRoaW5Gb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3BhcnNlcnMvTkxXZWVrZGF5UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9wYXJzZXJzL05MTW9udGhOYW1lTWlkZGxlRW5kaWFuUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9wYXJzZXJzL05MTW9udGhOYW1lUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9wYXJzZXJzL05MU2xhc2hNb250aEZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTFRpbWVFeHByZXNzaW9uUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9wYXJzZXJzL05MQ2FzdWFsWWVhck1vbnRoRGF5UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9wYXJzZXJzL05MQ2FzdWFsRGF0ZVRpbWVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3BhcnNlcnMvTkxUaW1lVW5pdENhc3VhbFJlbGF0aXZlRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9wYXJzZXJzL05MUmVsYXRpdmVEYXRlRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9wYXJzZXJzL05MVGltZVVuaXRBZ29Gb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3BhcnNlcnMvTkxUaW1lVW5pdExhdGVyRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9pbmRleC50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFudC9wYXJzZXJzL1pISGFudENhc3VhbERhdGVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnQvY29uc3RhbnRzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW50L3BhcnNlcnMvWkhIYW50RGF0ZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFudC9wYXJzZXJzL1pISGFudERlYWRsaW5lRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW50L3BhcnNlcnMvWkhIYW50UmVsYXRpb25XZWVrZGF5UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW50L3BhcnNlcnMvWkhIYW50VGltZUV4cHJlc3Npb25QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnQvcGFyc2Vycy9aSEhhbnRXZWVrZGF5UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW50L3JlZmluZXJzL1pISGFudE1lcmdlRGF0ZVJhbmdlUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFudC9yZWZpbmVycy9aSEhhbnRNZXJnZURhdGVUaW1lUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFudC9pbmRleC50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFucy9wYXJzZXJzL1pISGFuc0Nhc3VhbERhdGVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnMvY29uc3RhbnRzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW5zL3BhcnNlcnMvWkhIYW5zRGF0ZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFucy9wYXJzZXJzL1pISGFuc0RlYWRsaW5lRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW5zL3BhcnNlcnMvWkhIYW5zUmVsYXRpb25XZWVrZGF5UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW5zL3BhcnNlcnMvWkhIYW5zVGltZUV4cHJlc3Npb25QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnMvcGFyc2Vycy9aSEhhbnNXZWVrZGF5UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW5zL3JlZmluZXJzL1pISGFuc01lcmdlRGF0ZVJhbmdlUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFucy9yZWZpbmVycy9aSEhhbnNNZXJnZURhdGVUaW1lUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFucy9pbmRleC50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3J1L2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvcGFyc2Vycy9SVVRpbWVVbml0V2l0aGluRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ydS9wYXJzZXJzL1JVTW9udGhOYW1lTGl0dGxlRW5kaWFuUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ydS9wYXJzZXJzL1JVTW9udGhOYW1lUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ydS9wYXJzZXJzL1JVVGltZUV4cHJlc3Npb25QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3J1L3BhcnNlcnMvUlVUaW1lVW5pdEFnb0Zvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvcmVmaW5lcnMvUlVNZXJnZURhdGVSYW5nZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3J1L3JlZmluZXJzL1JVTWVyZ2VEYXRlVGltZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3J1L3BhcnNlcnMvUlVDYXN1YWxEYXRlUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ydS9wYXJzZXJzL1JVQ2FzdWFsVGltZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvcGFyc2Vycy9SVVdlZWtkYXlQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3J1L3BhcnNlcnMvUlVSZWxhdGl2ZURhdGVGb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3J1L3BhcnNlcnMvUlVUaW1lVW5pdENhc3VhbFJlbGF0aXZlRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ydS9pbmRleC50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5qcyIsICJzcmMvbWFpbi50cyIsICJub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L3NyYy9jc3MtdGFnLnRzIiwgIm5vZGVfbW9kdWxlcy9AbGl0L3JlYWN0aXZlLWVsZW1lbnQvc3JjL3JlYWN0aXZlLWVsZW1lbnQudHMiLCAibm9kZV9tb2R1bGVzL2xpdC1odG1sL3NyYy9saXQtaHRtbC50cyIsICJub2RlX21vZHVsZXMvbGl0LWVsZW1lbnQvc3JjL2xpdC1lbGVtZW50LnRzIiwgIm5vZGVfbW9kdWxlcy9AbGl0L3JlYWN0aXZlLWVsZW1lbnQvc3JjL2RlY29yYXRvcnMvY3VzdG9tLWVsZW1lbnQudHMiLCAibm9kZV9tb2R1bGVzL0BsaXQvcmVhY3RpdmUtZWxlbWVudC9zcmMvZGVjb3JhdG9ycy9wcm9wZXJ0eS50cyIsICJub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L3NyYy9kZWNvcmF0b3JzL3F1ZXJ5LWFzc2lnbmVkLWVsZW1lbnRzLnRzIiwgInNyYy9kYXRhL2FwcGxlLWludGVncmF0aW9uLnRzIiwgInNyYy91aS9zZXR0aW5ncy50cyIsICJzcmMvZGF0YS91dGlsaXRpZXMudHMiLCAic3JjL2RhdGEvY29uc3RhbnRzLnRzIiwgInNyYy9kYXRhL3JlbWluZGVycy1kYXRhLnNlcnZpY2UudHMiLCAic3JjL3VpL2xvYWRpbmctYmFyLmVsZW1lbnQudHMiLCAic3JjL3VpL3JlbWluZGVyLmVsZW1lbnQudHMiLCAic3JjL3VpL2xpc3QuZWxlbWVudC50cyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvTm9kZS5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvdmlzaXQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2RvYy9kaXJlY3RpdmVzLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9kb2MvYW5jaG9ycy5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvQWxpYXMuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L25vZGVzL3RvSlMuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L25vZGVzL1NjYWxhci5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvZG9jL2NyZWF0ZU5vZGUuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L25vZGVzL0NvbGxlY3Rpb24uanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3N0cmluZ2lmeS9zdHJpbmdpZnlDb21tZW50LmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvZm9sZEZsb3dMaW5lcy5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeVN0cmluZy5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeS5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeVBhaXIuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2xvZy5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvYWRkUGFpclRvSlNNYXAuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L25vZGVzL1BhaXIuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3N0cmluZ2lmeS9zdHJpbmdpZnlDb2xsZWN0aW9uLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9ZQU1MTWFwLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvY29tbW9uL21hcC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvWUFNTFNlcS5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvbW1vbi9zZXEuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9jb21tb24vc3RyaW5nLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvY29tbW9uL251bGwuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9jb3JlL2Jvb2wuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3N0cmluZ2lmeS9zdHJpbmdpZnlOdW1iZXIuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9jb3JlL2Zsb2F0LmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvY29yZS9pbnQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9jb3JlL3NjaGVtYS5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2pzb24vc2NoZW1hLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEveWFtbC0xLjEvYmluYXJ5LmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEveWFtbC0xLjEvcGFpcnMuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9vbWFwLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEveWFtbC0xLjEvYm9vbC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL3lhbWwtMS4xL2Zsb2F0LmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEveWFtbC0xLjEvaW50LmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEveWFtbC0xLjEvc2V0LmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEveWFtbC0xLjEvdGltZXN0YW1wLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEveWFtbC0xLjEvc2NoZW1hLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvdGFncy5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL1NjaGVtYS5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeURvY3VtZW50LmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9kb2MvYXBwbHlSZXZpdmVyLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9kb2MvRG9jdW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2Vycm9ycy5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvY29tcG9zZS9yZXNvbHZlLXByb3BzLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3V0aWwtY29udGFpbnMtbmV3bGluZS5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvY29tcG9zZS91dGlsLWZsb3ctaW5kZW50LWNoZWNrLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3V0aWwtbWFwLWluY2x1ZGVzLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3Jlc29sdmUtYmxvY2stbWFwLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3Jlc29sdmUtYmxvY2stc2VxLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3Jlc29sdmUtZW5kLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3Jlc29sdmUtZmxvdy1jb2xsZWN0aW9uLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL2NvbXBvc2UtY29sbGVjdGlvbi5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvY29tcG9zZS9yZXNvbHZlLWJsb2NrLXNjYWxhci5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvY29tcG9zZS9yZXNvbHZlLWZsb3ctc2NhbGFyLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL2NvbXBvc2Utc2NhbGFyLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3V0aWwtZW1wdHktc2NhbGFyLXBvc2l0aW9uLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL2NvbXBvc2Utbm9kZS5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvY29tcG9zZS9jb21wb3NlLWRvYy5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvY29tcG9zZS9jb21wb3Nlci5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvcGFyc2UvY3N0LXZpc2l0LmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9wYXJzZS9jc3QuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3BhcnNlL2xleGVyLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9wYXJzZS9saW5lLWNvdW50ZXIuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3BhcnNlL3BhcnNlci5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvcHVibGljLWFwaS5qcyIsICJub2RlX21vZHVsZXMvdHNsaWIvbW9kdWxlcy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvcnhqcy9zcmMvaW50ZXJuYWwvdXRpbC9pc0Z1bmN0aW9uLnRzIiwgIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC91dGlsL2NyZWF0ZUVycm9yQ2xhc3MudHMiLCAibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvci50cyIsICJub2RlX21vZHVsZXMvcnhqcy9zcmMvaW50ZXJuYWwvdXRpbC9hcnJSZW1vdmUudHMiLCAibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL1N1YnNjcmlwdGlvbi50cyIsICJub2RlX21vZHVsZXMvcnhqcy9zcmMvaW50ZXJuYWwvY29uZmlnLnRzIiwgIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9zY2hlZHVsZXIvdGltZW91dFByb3ZpZGVyLnRzIiwgIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC91dGlsL3JlcG9ydFVuaGFuZGxlZEVycm9yLnRzIiwgIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC91dGlsL25vb3AudHMiLCAibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL05vdGlmaWNhdGlvbkZhY3Rvcmllcy50cyIsICJub2RlX21vZHVsZXMvcnhqcy9zcmMvaW50ZXJuYWwvdXRpbC9lcnJvckNvbnRleHQudHMiLCAibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL1N1YnNjcmliZXIudHMiLCAibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL3N5bWJvbC9vYnNlcnZhYmxlLnRzIiwgIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC91dGlsL2lkZW50aXR5LnRzIiwgIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC91dGlsL3BpcGUudHMiLCAibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL09ic2VydmFibGUudHMiLCAibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL3NjaGVkdWxlci9kYXRlVGltZXN0YW1wUHJvdmlkZXIudHMiLCAibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL3NjaGVkdWxlci9BY3Rpb24udHMiLCAibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL3NjaGVkdWxlci9pbnRlcnZhbFByb3ZpZGVyLnRzIiwgIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9zY2hlZHVsZXIvQXN5bmNBY3Rpb24udHMiLCAibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL1NjaGVkdWxlci50cyIsICJub2RlX21vZHVsZXMvcnhqcy9zcmMvaW50ZXJuYWwvc2NoZWR1bGVyL0FzeW5jU2NoZWR1bGVyLnRzIiwgIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9zY2hlZHVsZXIvYXN5bmMudHMiLCAibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL3V0aWwvaXNTY2hlZHVsZXIudHMiLCAibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL3V0aWwvaXNEYXRlLnRzIiwgIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vYnNlcnZhYmxlL3RpbWVyLnRzIiwgIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vYnNlcnZhYmxlL2ludGVydmFsLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJtb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcnM7XG5cbmZ1bmN0aW9uIEJ1ZmZlcnMgKGJ1ZnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVycykpIHJldHVybiBuZXcgQnVmZmVycyhidWZzKTtcbiAgICB0aGlzLmJ1ZmZlcnMgPSBidWZzIHx8IFtdO1xuICAgIHRoaXMubGVuZ3RoID0gdGhpcy5idWZmZXJzLnJlZHVjZShmdW5jdGlvbiAoc2l6ZSwgYnVmKSB7XG4gICAgICAgIHJldHVybiBzaXplICsgYnVmLmxlbmd0aFxuICAgIH0sIDApO1xufVxuXG5CdWZmZXJzLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGFyZ3VtZW50c1tpXSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RyaWVkIHRvIHB1c2ggYSBub24tYnVmZmVyJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGJ1ZiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgdGhpcy5idWZmZXJzLnB1c2goYnVmKTtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xufTtcblxuQnVmZmVycy5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhcmd1bWVudHNbaV0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUcmllZCB0byB1bnNoaWZ0IGEgbm9uLWJ1ZmZlcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBidWYgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHRoaXMuYnVmZmVycy51bnNoaWZ0KGJ1Zik7XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGJ1Zi5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbn07XG5cbkJ1ZmZlcnMucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoZHN0LCBkU3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gdGhpcy5zbGljZShzdGFydCwgZW5kKS5jb3B5KGRzdCwgZFN0YXJ0LCAwLCBlbmQgLSBzdGFydCk7XG59O1xuXG5CdWZmZXJzLnByb3RvdHlwZS5zcGxpY2UgPSBmdW5jdGlvbiAoaSwgaG93TWFueSkge1xuICAgIHZhciBidWZmZXJzID0gdGhpcy5idWZmZXJzO1xuICAgIHZhciBpbmRleCA9IGkgPj0gMCA/IGkgOiB0aGlzLmxlbmd0aCAtIGk7XG4gICAgdmFyIHJlcHMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgXG4gICAgaWYgKGhvd01hbnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBob3dNYW55ID0gdGhpcy5sZW5ndGggLSBpbmRleDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaG93TWFueSA+IHRoaXMubGVuZ3RoIC0gaW5kZXgpIHtcbiAgICAgICAgaG93TWFueSA9IHRoaXMubGVuZ3RoIC0gaW5kZXg7XG4gICAgfVxuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmxlbmd0aCArPSByZXBzW2ldLmxlbmd0aDtcbiAgICB9XG4gICAgXG4gICAgdmFyIHJlbW92ZWQgPSBuZXcgQnVmZmVycygpO1xuICAgIHZhciBieXRlcyA9IDA7XG4gICAgXG4gICAgdmFyIHN0YXJ0Qnl0ZXMgPSAwO1xuICAgIGZvciAoXG4gICAgICAgIHZhciBpaSA9IDA7XG4gICAgICAgIGlpIDwgYnVmZmVycy5sZW5ndGggJiYgc3RhcnRCeXRlcyArIGJ1ZmZlcnNbaWldLmxlbmd0aCA8IGluZGV4O1xuICAgICAgICBpaSArK1xuICAgICkgeyBzdGFydEJ5dGVzICs9IGJ1ZmZlcnNbaWldLmxlbmd0aCB9XG4gICAgXG4gICAgaWYgKGluZGV4IC0gc3RhcnRCeXRlcyA+IDApIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gaW5kZXggLSBzdGFydEJ5dGVzO1xuICAgICAgICBcbiAgICAgICAgaWYgKHN0YXJ0ICsgaG93TWFueSA8IGJ1ZmZlcnNbaWldLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKGJ1ZmZlcnNbaWldLnNsaWNlKHN0YXJ0LCBzdGFydCArIGhvd01hbnkpKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIG9yaWcgPSBidWZmZXJzW2lpXTtcbiAgICAgICAgICAgIC8vdmFyIGJ1ZiA9IG5ldyBCdWZmZXIob3JpZy5sZW5ndGggLSBob3dNYW55KTtcbiAgICAgICAgICAgIHZhciBidWYwID0gbmV3IEJ1ZmZlcihzdGFydCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXJ0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBidWYwW2ldID0gb3JpZ1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGJ1ZjEgPSBuZXcgQnVmZmVyKG9yaWcubGVuZ3RoIC0gc3RhcnQgLSBob3dNYW55KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydCArIGhvd01hbnk7IGkgPCBvcmlnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnVmMVsgaSAtIGhvd01hbnkgLSBzdGFydCBdID0gb3JpZ1tpXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAocmVwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcHNfID0gcmVwcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHJlcHNfLnVuc2hpZnQoYnVmMCk7XG4gICAgICAgICAgICAgICAgcmVwc18ucHVzaChidWYxKTtcbiAgICAgICAgICAgICAgICBidWZmZXJzLnNwbGljZS5hcHBseShidWZmZXJzLCBbIGlpLCAxIF0uY29uY2F0KHJlcHNfKSk7XG4gICAgICAgICAgICAgICAgaWkgKz0gcmVwc18ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJlcHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcnMuc3BsaWNlKGlpLCAxLCBidWYwLCBidWYxKTtcbiAgICAgICAgICAgICAgICAvL2J1ZmZlcnNbaWldID0gYnVmO1xuICAgICAgICAgICAgICAgIGlpICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVkLnB1c2goYnVmZmVyc1tpaV0uc2xpY2Uoc3RhcnQpKTtcbiAgICAgICAgICAgIGJ1ZmZlcnNbaWldID0gYnVmZmVyc1tpaV0uc2xpY2UoMCwgc3RhcnQpO1xuICAgICAgICAgICAgaWkgKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKHJlcHMubGVuZ3RoID4gMCkge1xuICAgICAgICBidWZmZXJzLnNwbGljZS5hcHBseShidWZmZXJzLCBbIGlpLCAwIF0uY29uY2F0KHJlcHMpKTtcbiAgICAgICAgaWkgKz0gcmVwcy5sZW5ndGg7XG4gICAgfVxuICAgIFxuICAgIHdoaWxlIChyZW1vdmVkLmxlbmd0aCA8IGhvd01hbnkpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IGJ1ZmZlcnNbaWldO1xuICAgICAgICB2YXIgbGVuID0gYnVmLmxlbmd0aDtcbiAgICAgICAgdmFyIHRha2UgPSBNYXRoLm1pbihsZW4sIGhvd01hbnkgLSByZW1vdmVkLmxlbmd0aCk7XG4gICAgICAgIFxuICAgICAgICBpZiAodGFrZSA9PT0gbGVuKSB7XG4gICAgICAgICAgICByZW1vdmVkLnB1c2goYnVmKTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuc3BsaWNlKGlpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZWQucHVzaChidWYuc2xpY2UoMCwgdGFrZSkpO1xuICAgICAgICAgICAgYnVmZmVyc1tpaV0gPSBidWZmZXJzW2lpXS5zbGljZSh0YWtlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB0aGlzLmxlbmd0aCAtPSByZW1vdmVkLmxlbmd0aDtcbiAgICBcbiAgICByZXR1cm4gcmVtb3ZlZDtcbn07XG4gXG5CdWZmZXJzLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChpLCBqKSB7XG4gICAgdmFyIGJ1ZmZlcnMgPSB0aGlzLmJ1ZmZlcnM7XG4gICAgaWYgKGogPT09IHVuZGVmaW5lZCkgaiA9IHRoaXMubGVuZ3RoO1xuICAgIGlmIChpID09PSB1bmRlZmluZWQpIGkgPSAwO1xuICAgIFxuICAgIGlmIChqID4gdGhpcy5sZW5ndGgpIGogPSB0aGlzLmxlbmd0aDtcbiAgICBcbiAgICB2YXIgc3RhcnRCeXRlcyA9IDA7XG4gICAgZm9yIChcbiAgICAgICAgdmFyIHNpID0gMDtcbiAgICAgICAgc2kgPCBidWZmZXJzLmxlbmd0aCAmJiBzdGFydEJ5dGVzICsgYnVmZmVyc1tzaV0ubGVuZ3RoIDw9IGk7XG4gICAgICAgIHNpICsrXG4gICAgKSB7IHN0YXJ0Qnl0ZXMgKz0gYnVmZmVyc1tzaV0ubGVuZ3RoIH1cbiAgICBcbiAgICB2YXIgdGFyZ2V0ID0gbmV3IEJ1ZmZlcihqIC0gaSk7XG4gICAgXG4gICAgdmFyIHRpID0gMDtcbiAgICBmb3IgKHZhciBpaSA9IHNpOyB0aSA8IGogLSBpICYmIGlpIDwgYnVmZmVycy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgdmFyIGxlbiA9IGJ1ZmZlcnNbaWldLmxlbmd0aDtcbiAgICAgICAgXG4gICAgICAgIHZhciBzdGFydCA9IHRpID09PSAwID8gaSAtIHN0YXJ0Qnl0ZXMgOiAwO1xuICAgICAgICB2YXIgZW5kID0gdGkgKyBsZW4gPj0gaiAtIGlcbiAgICAgICAgICAgID8gTWF0aC5taW4oc3RhcnQgKyAoaiAtIGkpIC0gdGksIGxlbilcbiAgICAgICAgICAgIDogbGVuXG4gICAgICAgIDtcbiAgICAgICAgXG4gICAgICAgIGJ1ZmZlcnNbaWldLmNvcHkodGFyZ2V0LCB0aSwgc3RhcnQsIGVuZCk7XG4gICAgICAgIHRpICs9IGVuZCAtIHN0YXJ0O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuQnVmZmVycy5wcm90b3R5cGUucG9zID0gZnVuY3Rpb24gKGkpIHtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgICB2YXIgbCA9IGksIGJpID0gMCwgYnUgPSBudWxsO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgYnUgPSB0aGlzLmJ1ZmZlcnNbYmldO1xuICAgICAgICBpZiAobCA8IGJ1Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHtidWY6IGJpLCBvZmZzZXQ6IGx9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCAtPSBidS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgYmkrKztcbiAgICB9XG59O1xuXG5CdWZmZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGkpIHtcbiAgICB2YXIgcG9zID0gdGhpcy5wb3MoaSk7XG5cbiAgICByZXR1cm4gdGhpcy5idWZmZXJzW3Bvcy5idWZdLmdldChwb3Mub2Zmc2V0KTtcbn07XG5cbkJ1ZmZlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoaSwgYikge1xuICAgIHZhciBwb3MgPSB0aGlzLnBvcyhpKTtcblxuICAgIHJldHVybiB0aGlzLmJ1ZmZlcnNbcG9zLmJ1Zl0uc2V0KHBvcy5vZmZzZXQsIGIpO1xufTtcblxuQnVmZmVycy5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIChuZWVkbGUsIG9mZnNldCkge1xuICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgbmVlZGxlKSB7XG4gICAgICAgIG5lZWRsZSA9IG5ldyBCdWZmZXIobmVlZGxlKTtcbiAgICB9IGVsc2UgaWYgKG5lZWRsZSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAvLyBhbHJlYWR5IGEgYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUgZm9yIGEgc2VhcmNoIHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmICghbmVlZGxlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICB2YXIgaSA9IDAsIGogPSAwLCBtYXRjaCA9IDAsIG1zdGFydCwgcG9zID0gMDtcblxuICAgIC8vIHN0YXJ0IHNlYXJjaCBmcm9tIGEgcGFydGljdWxhciBwb2ludCBpbiB0aGUgdmlydHVhbCBidWZmZXJcbiAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5wb3Mob2Zmc2V0KTtcbiAgICAgICAgaSA9IHAuYnVmO1xuICAgICAgICBqID0gcC5vZmZzZXQ7XG4gICAgICAgIHBvcyA9IG9mZnNldDtcbiAgICB9XG5cbiAgICAvLyBmb3IgZWFjaCBjaGFyYWN0ZXIgaW4gdmlydHVhbCBidWZmZXJcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIHdoaWxlIChqID49IHRoaXMuYnVmZmVyc1tpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgaSsrO1xuXG4gICAgICAgICAgICBpZiAoaSA+PSB0aGlzLmJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gc2VhcmNoIHN0cmluZyBub3QgZm91bmRcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hhciA9IHRoaXMuYnVmZmVyc1tpXVtqXTtcblxuICAgICAgICBpZiAoY2hhciA9PSBuZWVkbGVbbWF0Y2hdKSB7XG4gICAgICAgICAgICAvLyBrZWVwIHRyYWNrIHdoZXJlIG1hdGNoIHN0YXJ0ZWRcbiAgICAgICAgICAgIGlmIChtYXRjaCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgbXN0YXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgICAgICAgICBwb3M6IHBvc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRjaCsrO1xuICAgICAgICAgICAgaWYgKG1hdGNoID09IG5lZWRsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBmdWxsIG1hdGNoXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1zdGFydC5wb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2ggIT0gMCkge1xuICAgICAgICAgICAgLy8gYSBwYXJ0aWFsIG1hdGNoIGVuZGVkLCBnbyBiYWNrIHRvIG1hdGNoIHN0YXJ0aW5nIHBvc2l0aW9uXG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgY29udGludWUgdGhlIHNlYXJjaCBhdCB0aGUgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIGkgPSBtc3RhcnQuaTtcbiAgICAgICAgICAgIGogPSBtc3RhcnQuajtcbiAgICAgICAgICAgIHBvcyA9IG1zdGFydC5wb3M7XG4gICAgICAgICAgICBtYXRjaCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBqKys7XG4gICAgICAgIHBvcysrO1xuICAgIH1cbn07XG5cbkJ1ZmZlcnMucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2xpY2UoKTtcbn1cblxuQnVmZmVycy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlKHN0YXJ0LCBlbmQpLnRvU3RyaW5nKGVuY29kaW5nKTtcbn1cbiIsICIvKlxuICogR2VuZXJhdGVkIGJ5IFBFRy5qcyAwLjEwLjAuXG4gKlxuICogaHR0cDovL3BlZ2pzLm9yZy9cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gcGVnJHN1YmNsYXNzKGNoaWxkLCBwYXJlbnQpIHtcbiAgZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9XG4gIGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTtcbn1cblxuZnVuY3Rpb24gcGVnJFN5bnRheEVycm9yKG1lc3NhZ2UsIGV4cGVjdGVkLCBmb3VuZCwgbG9jYXRpb24pIHtcbiAgdGhpcy5tZXNzYWdlICA9IG1lc3NhZ2U7XG4gIHRoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgdGhpcy5mb3VuZCAgICA9IGZvdW5kO1xuICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gIHRoaXMubmFtZSAgICAgPSBcIlN5bnRheEVycm9yXCI7XG5cbiAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgcGVnJFN5bnRheEVycm9yKTtcbiAgfVxufVxuXG5wZWckc3ViY2xhc3MocGVnJFN5bnRheEVycm9yLCBFcnJvcik7XG5cbnBlZyRTeW50YXhFcnJvci5idWlsZE1lc3NhZ2UgPSBmdW5jdGlvbihleHBlY3RlZCwgZm91bmQpIHtcbiAgdmFyIERFU0NSSUJFX0VYUEVDVEFUSU9OX0ZOUyA9IHtcbiAgICAgICAgbGl0ZXJhbDogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gXCJcXFwiXCIgKyBsaXRlcmFsRXNjYXBlKGV4cGVjdGF0aW9uLnRleHQpICsgXCJcXFwiXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCJjbGFzc1wiOiBmdW5jdGlvbihleHBlY3RhdGlvbikge1xuICAgICAgICAgIHZhciBlc2NhcGVkUGFydHMgPSBcIlwiLFxuICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cGVjdGF0aW9uLnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBlc2NhcGVkUGFydHMgKz0gZXhwZWN0YXRpb24ucGFydHNbaV0gaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgICAgICA/IGNsYXNzRXNjYXBlKGV4cGVjdGF0aW9uLnBhcnRzW2ldWzBdKSArIFwiLVwiICsgY2xhc3NFc2NhcGUoZXhwZWN0YXRpb24ucGFydHNbaV1bMV0pXG4gICAgICAgICAgICAgIDogY2xhc3NFc2NhcGUoZXhwZWN0YXRpb24ucGFydHNbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBcIltcIiArIChleHBlY3RhdGlvbi5pbnZlcnRlZCA/IFwiXlwiIDogXCJcIikgKyBlc2NhcGVkUGFydHMgKyBcIl1cIjtcbiAgICAgICAgfSxcblxuICAgICAgICBhbnk6IGZ1bmN0aW9uKGV4cGVjdGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYW55IGNoYXJhY3RlclwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVuZDogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gXCJlbmQgb2YgaW5wdXRcIjtcbiAgICAgICAgfSxcblxuICAgICAgICBvdGhlcjogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gZXhwZWN0YXRpb24uZGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgZnVuY3Rpb24gaGV4KGNoKSB7XG4gICAgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBsaXRlcmFsRXNjYXBlKHMpIHtcbiAgICByZXR1cm4gc1xuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJylcbiAgICAgIC5yZXBsYWNlKC9cIi9nLCAgJ1xcXFxcIicpXG4gICAgICAucmVwbGFjZSgvXFwwL2csICdcXFxcMCcpXG4gICAgICAucmVwbGFjZSgvXFx0L2csICdcXFxcdCcpXG4gICAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpXG4gICAgICAucmVwbGFjZSgvXFxyL2csICdcXFxccicpXG4gICAgICAucmVwbGFjZSgvW1xceDAwLVxceDBGXS9nLCAgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx4MCcgKyBoZXgoY2gpOyB9KVxuICAgICAgLnJlcGxhY2UoL1tcXHgxMC1cXHgxRlxceDdGLVxceDlGXS9nLCBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx4JyAgKyBoZXgoY2gpOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsYXNzRXNjYXBlKHMpIHtcbiAgICByZXR1cm4gc1xuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJylcbiAgICAgIC5yZXBsYWNlKC9cXF0vZywgJ1xcXFxdJylcbiAgICAgIC5yZXBsYWNlKC9cXF4vZywgJ1xcXFxeJylcbiAgICAgIC5yZXBsYWNlKC8tL2csICAnXFxcXC0nKVxuICAgICAgLnJlcGxhY2UoL1xcMC9nLCAnXFxcXDAnKVxuICAgICAgLnJlcGxhY2UoL1xcdC9nLCAnXFxcXHQnKVxuICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKVxuICAgICAgLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKVxuICAgICAgLnJlcGxhY2UoL1tcXHgwMC1cXHgwRl0vZywgICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceDAnICsgaGV4KGNoKTsgfSlcbiAgICAgIC5yZXBsYWNlKC9bXFx4MTAtXFx4MUZcXHg3Ri1cXHg5Rl0vZywgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceCcgICsgaGV4KGNoKTsgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXNjcmliZUV4cGVjdGF0aW9uKGV4cGVjdGF0aW9uKSB7XG4gICAgcmV0dXJuIERFU0NSSUJFX0VYUEVDVEFUSU9OX0ZOU1tleHBlY3RhdGlvbi50eXBlXShleHBlY3RhdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBkZXNjcmliZUV4cGVjdGVkKGV4cGVjdGVkKSB7XG4gICAgdmFyIGRlc2NyaXB0aW9ucyA9IG5ldyBBcnJheShleHBlY3RlZC5sZW5ndGgpLFxuICAgICAgICBpLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGV4cGVjdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXNjcmlwdGlvbnNbaV0gPSBkZXNjcmliZUV4cGVjdGF0aW9uKGV4cGVjdGVkW2ldKTtcbiAgICB9XG5cbiAgICBkZXNjcmlwdGlvbnMuc29ydCgpO1xuXG4gICAgaWYgKGRlc2NyaXB0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGkgPSAxLCBqID0gMTsgaSA8IGRlc2NyaXB0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZGVzY3JpcHRpb25zW2kgLSAxXSAhPT0gZGVzY3JpcHRpb25zW2ldKSB7XG4gICAgICAgICAgZGVzY3JpcHRpb25zW2pdID0gZGVzY3JpcHRpb25zW2ldO1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVzY3JpcHRpb25zLmxlbmd0aCA9IGo7XG4gICAgfVxuXG4gICAgc3dpdGNoIChkZXNjcmlwdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbnNbMF07XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uc1swXSArIFwiIG9yIFwiICsgZGVzY3JpcHRpb25zWzFdO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb25zLnNsaWNlKDAsIC0xKS5qb2luKFwiLCBcIilcbiAgICAgICAgICArIFwiLCBvciBcIlxuICAgICAgICAgICsgZGVzY3JpcHRpb25zW2Rlc2NyaXB0aW9ucy5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXNjcmliZUZvdW5kKGZvdW5kKSB7XG4gICAgcmV0dXJuIGZvdW5kID8gXCJcXFwiXCIgKyBsaXRlcmFsRXNjYXBlKGZvdW5kKSArIFwiXFxcIlwiIDogXCJlbmQgb2YgaW5wdXRcIjtcbiAgfVxuXG4gIHJldHVybiBcIkV4cGVjdGVkIFwiICsgZGVzY3JpYmVFeHBlY3RlZChleHBlY3RlZCkgKyBcIiBidXQgXCIgKyBkZXNjcmliZUZvdW5kKGZvdW5kKSArIFwiIGZvdW5kLlwiO1xufTtcblxuZnVuY3Rpb24gcGVnJHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge307XG5cbiAgdmFyIHBlZyRGQUlMRUQgPSB7fSxcblxuICAgICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9ucyA9IHsgb3Nhc2NyaXB0OiBwZWckcGFyc2Vvc2FzY3JpcHQgfSxcbiAgICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbiAgPSBwZWckcGFyc2Vvc2FzY3JpcHQsXG5cbiAgICAgIHBlZyRjMCA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfSxcbiAgICAgIHBlZyRjMSA9IFwie1wiLFxuICAgICAgcGVnJGMyID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIntcIiwgZmFsc2UpLFxuICAgICAgcGVnJGMzID0gXCJ9XCIsXG4gICAgICBwZWckYzQgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwifVwiLCBmYWxzZSksXG4gICAgICBwZWckYzUgPSBcIjpcIixcbiAgICAgIHBlZyRjNiA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCI6XCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjNyA9IFwiLFwiLFxuICAgICAgcGVnJGM4ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIixcIiwgZmFsc2UpLFxuICAgICAgcGVnJGM5ID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJ3aGl0ZXNwYWNlXCIpLFxuICAgICAgcGVnJGMxMCA9IC9eWyBcXHRcXG5cXHJdLyxcbiAgICAgIHBlZyRjMTEgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbXCIgXCIsIFwiXFx0XCIsIFwiXFxuXCIsIFwiXFxyXCJdLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgcGVnJGMxMiA9IFwiZmFsc2VcIixcbiAgICAgIHBlZyRjMTMgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiZmFsc2VcIiwgZmFsc2UpLFxuICAgICAgcGVnJGMxNCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICBwZWckYzE1ID0gXCJ0cnVlXCIsXG4gICAgICBwZWckYzE2ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInRydWVcIiwgZmFsc2UpLFxuICAgICAgcGVnJGMxNyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgIH0sXG4gICAgICBwZWckYzE4ID0gcGVnJGFueUV4cGVjdGF0aW9uKCksXG4gICAgICBwZWckYzE5ID0gZnVuY3Rpb24oY2hhcnMpIHsgcmV0dXJuIChjaGFycy5sZW5ndGggPiAwKSA/IGNoYXJzLmpvaW4oJycpIDogbnVsbDsgfSxcbiAgICAgIHBlZyRjMjAgPSBmdW5jdGlvbihmaXJzdCwgbSkgeyByZXR1cm4gbTsgfSxcbiAgICAgIHBlZyRjMjEgPSBmdW5jdGlvbihmaXJzdCwgcmVzdCkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge30sIGk7XG5cbiAgICAgICAgICAgICAgcmVzdWx0W2ZpcnN0Lm5hbWVdID0gZmlyc3QudmFsdWU7XG5cbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbcmVzdFtpXS5uYW1lXSA9IHJlc3RbaV0udmFsdWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcbiAgICAgIHBlZyRjMjIgPSBmdW5jdGlvbihtZW1iZXJzKSB7IHJldHVybiBtZW1iZXJzICE9PSBudWxsID8gbWVtYmVyczoge307IH0sXG4gICAgICBwZWckYzIzID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICAgIH0sXG4gICAgICBwZWckYzI0ID0gL15bIGEtejAtOVxcLV0vaSxcbiAgICAgIHBlZyRjMjUgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbXCIgXCIsIFtcImFcIiwgXCJ6XCJdLCBbXCIwXCIsIFwiOVwiXSwgXCItXCJdLCBmYWxzZSwgdHJ1ZSksXG4gICAgICBwZWckYzI2ID0gZnVuY3Rpb24oY2hhcnMpIHsgcmV0dXJuIGNoYXJzLmpvaW4oXCJcIikudHJpbSgpOyB9LFxuICAgICAgcGVnJGMyNyA9IGZ1bmN0aW9uKGZpcnN0LCB2KSB7IHJldHVybiB2OyB9LFxuICAgICAgcGVnJGMyOCA9IGZ1bmN0aW9uKGZpcnN0LCByZXN0KSB7IHJldHVybiBbZmlyc3RdLmNvbmNhdChyZXN0KTsgfSxcbiAgICAgIHBlZyRjMjkgPSBmdW5jdGlvbih2YWx1ZXMpIHsgcmV0dXJuIHZhbHVlcyAhPT0gbnVsbCA/IHZhbHVlcyA6IFtdOyB9LFxuICAgICAgcGVnJGMzMCA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwibnVtYmVyXCIpLFxuICAgICAgcGVnJGMzMSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcGFyc2VGbG9hdCh0ZXh0KCkpOyB9LFxuICAgICAgcGVnJGMzMiA9IFwiLlwiLFxuICAgICAgcGVnJGMzMyA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIuXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjMzQgPSAvXlsxLTldLyxcbiAgICAgIHBlZyRjMzUgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiMVwiLCBcIjlcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgcGVnJGMzNiA9IC9eW2VFXS8sXG4gICAgICBwZWckYzM3ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wiZVwiLCBcIkVcIl0sIGZhbHNlLCBmYWxzZSksXG4gICAgICBwZWckYzM4ID0gXCItXCIsXG4gICAgICBwZWckYzM5ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIi1cIiwgZmFsc2UpLFxuICAgICAgcGVnJGM0MCA9IFwiK1wiLFxuICAgICAgcGVnJGM0MSA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIrXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjNDIgPSBcIjBcIixcbiAgICAgIHBlZyRjNDMgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiMFwiLCBmYWxzZSksXG4gICAgICBwZWckYzQ0ID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJzdHJpbmdcIiksXG4gICAgICBwZWckYzQ1ID0gZnVuY3Rpb24oY2hhcnMpIHsgcmV0dXJuIGNoYXJzLmpvaW4oXCJcIik7IH0sXG4gICAgICBwZWckYzQ2ID0gXCJcXG5cIixcbiAgICAgIHBlZyRjNDcgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiXFxuXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjNDggPSBcIlxcdFwiLFxuICAgICAgcGVnJGM0OSA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJcXHRcIiwgZmFsc2UpLFxuICAgICAgcGVnJGM1MCA9IFwiXFxcIlwiLFxuICAgICAgcGVnJGM1MSA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJcXFwiXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjNTIgPSBcIlxcXFxcIixcbiAgICAgIHBlZyRjNTMgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiXFxcXFwiLCBmYWxzZSksXG4gICAgICBwZWckYzU0ID0gXCIvXCIsXG4gICAgICBwZWckYzU1ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIi9cIiwgZmFsc2UpLFxuICAgICAgcGVnJGM1NiA9IFwiYlwiLFxuICAgICAgcGVnJGM1NyA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJiXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjNTggPSBmdW5jdGlvbigpIHsgcmV0dXJuIFwiXFxiXCI7IH0sXG4gICAgICBwZWckYzU5ID0gXCJmXCIsXG4gICAgICBwZWckYzYwID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImZcIiwgZmFsc2UpLFxuICAgICAgcGVnJGM2MSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJcXGZcIjsgfSxcbiAgICAgIHBlZyRjNjIgPSBcIm5cIixcbiAgICAgIHBlZyRjNjMgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiblwiLCBmYWxzZSksXG4gICAgICBwZWckYzY0ID0gZnVuY3Rpb24oKSB7IHJldHVybiBcIlxcblwiOyB9LFxuICAgICAgcGVnJGM2NSA9IFwiclwiLFxuICAgICAgcGVnJGM2NiA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJyXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjNjcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIFwiXFxyXCI7IH0sXG4gICAgICBwZWckYzY4ID0gXCJ0XCIsXG4gICAgICBwZWckYzY5ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInRcIiwgZmFsc2UpLFxuICAgICAgcGVnJGM3MCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJcXHRcIjsgfSxcbiAgICAgIHBlZyRjNzEgPSBcInVcIixcbiAgICAgIHBlZyRjNzIgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidVwiLCBmYWxzZSksXG4gICAgICBwZWckYzczID0gZnVuY3Rpb24oZGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoZGlnaXRzLCAxNikpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgcGVnJGM3NCA9IGZ1bmN0aW9uKHNlcXVlbmNlKSB7IHJldHVybiBzZXF1ZW5jZTsgfSxcbiAgICAgIHBlZyRjNzUgPSAvXlteXFwwLVxceDFGXCJcXFxcXS8sXG4gICAgICBwZWckYzc2ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcIlxcMFwiLCBcIlxceDFGXCJdLCBcIlxcXCJcIiwgXCJcXFxcXCJdLCB0cnVlLCBmYWxzZSksXG4gICAgICBwZWckYzc3ID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJ1bnF1b3RlZCBzdHJpbmdcIiksXG4gICAgICBwZWckYzc4ID0gZnVuY3Rpb24oZmlyc3RfY2hhciwgY2hhcnMpIHsgcmV0dXJuIGZpcnN0X2NoYXIrY2hhcnMuam9pbihcIlwiKTsgfSxcbiAgICAgIHBlZyRjNzkgPSAvXlthLXogXS8sXG4gICAgICBwZWckYzgwID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcImFcIiwgXCJ6XCJdLCBcIiBcIl0sIGZhbHNlLCBmYWxzZSksXG4gICAgICBwZWckYzgxID0gL15bXix9XS8sXG4gICAgICBwZWckYzgyID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wiLFwiLCBcIn1cIl0sIHRydWUsIGZhbHNlKSxcbiAgICAgIHBlZyRjODMgPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcImRhdGVcIiksXG4gICAgICBwZWckYzg0ID0gXCJkYXRlXCIsXG4gICAgICBwZWckYzg1ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImRhdGVcIiwgZmFsc2UpLFxuICAgICAgcGVnJGM4NiA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgdmFyIGRhdGVPYmplY3QgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgICAgcmV0dXJuICFpc05hTihkYXRlT2JqZWN0LmdldFRpbWUoKSkgPyBkYXRlT2JqZWN0IDogZGF0ZTtcbiAgICAgICB9LFxuICAgICAgcGVnJGM4NyA9IC9eWzAtOV0vLFxuICAgICAgcGVnJGM4OCA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCIwXCIsIFwiOVwiXV0sIGZhbHNlLCBmYWxzZSksXG4gICAgICBwZWckYzg5ID0gL15bMC05YS1mXS9pLFxuICAgICAgcGVnJGM5MCA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCIwXCIsIFwiOVwiXSwgW1wiYVwiLCBcImZcIl1dLCBmYWxzZSwgdHJ1ZSksXG5cbiAgICAgIHBlZyRjdXJyUG9zICAgICAgICAgID0gMCxcbiAgICAgIHBlZyRzYXZlZFBvcyAgICAgICAgID0gMCxcbiAgICAgIHBlZyRwb3NEZXRhaWxzQ2FjaGUgID0gW3sgbGluZTogMSwgY29sdW1uOiAxIH1dLFxuICAgICAgcGVnJG1heEZhaWxQb3MgICAgICAgPSAwLFxuICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCAgPSBbXSxcbiAgICAgIHBlZyRzaWxlbnRGYWlscyAgICAgID0gMCxcblxuICAgICAgcGVnJHJlc3VsdDtcblxuICBpZiAoXCJzdGFydFJ1bGVcIiBpbiBvcHRpb25zKSB7XG4gICAgaWYgKCEob3B0aW9ucy5zdGFydFJ1bGUgaW4gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHN0YXJ0IHBhcnNpbmcgZnJvbSBydWxlIFxcXCJcIiArIG9wdGlvbnMuc3RhcnRSdWxlICsgXCJcXFwiLlwiKTtcbiAgICB9XG5cbiAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb24gPSBwZWckc3RhcnRSdWxlRnVuY3Rpb25zW29wdGlvbnMuc3RhcnRSdWxlXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRleHQoKSB7XG4gICAgcmV0dXJuIGlucHV0LnN1YnN0cmluZyhwZWckc2F2ZWRQb3MsIHBlZyRjdXJyUG9zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvY2F0aW9uKCkge1xuICAgIHJldHVybiBwZWckY29tcHV0ZUxvY2F0aW9uKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXhwZWN0ZWQoZGVzY3JpcHRpb24sIGxvY2F0aW9uKSB7XG4gICAgbG9jYXRpb24gPSBsb2NhdGlvbiAhPT0gdm9pZCAwID8gbG9jYXRpb24gOiBwZWckY29tcHV0ZUxvY2F0aW9uKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpXG5cbiAgICB0aHJvdyBwZWckYnVpbGRTdHJ1Y3R1cmVkRXJyb3IoXG4gICAgICBbcGVnJG90aGVyRXhwZWN0YXRpb24oZGVzY3JpcHRpb24pXSxcbiAgICAgIGlucHV0LnN1YnN0cmluZyhwZWckc2F2ZWRQb3MsIHBlZyRjdXJyUG9zKSxcbiAgICAgIGxvY2F0aW9uXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UsIGxvY2F0aW9uKSB7XG4gICAgbG9jYXRpb24gPSBsb2NhdGlvbiAhPT0gdm9pZCAwID8gbG9jYXRpb24gOiBwZWckY29tcHV0ZUxvY2F0aW9uKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpXG5cbiAgICB0aHJvdyBwZWckYnVpbGRTaW1wbGVFcnJvcihtZXNzYWdlLCBsb2NhdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKHRleHQsIGlnbm9yZUNhc2UpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImxpdGVyYWxcIiwgdGV4dDogdGV4dCwgaWdub3JlQ2FzZTogaWdub3JlQ2FzZSB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGNsYXNzRXhwZWN0YXRpb24ocGFydHMsIGludmVydGVkLCBpZ25vcmVDYXNlKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJjbGFzc1wiLCBwYXJ0czogcGFydHMsIGludmVydGVkOiBpbnZlcnRlZCwgaWdub3JlQ2FzZTogaWdub3JlQ2FzZSB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGFueUV4cGVjdGF0aW9uKCkge1xuICAgIHJldHVybiB7IHR5cGU6IFwiYW55XCIgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRlbmRFeHBlY3RhdGlvbigpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImVuZFwiIH07XG4gIH1cblxuICBmdW5jdGlvbiBwZWckb3RoZXJFeHBlY3RhdGlvbihkZXNjcmlwdGlvbikge1xuICAgIHJldHVybiB7IHR5cGU6IFwib3RoZXJcIiwgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uIH07XG4gIH1cblxuICBmdW5jdGlvbiBwZWckY29tcHV0ZVBvc0RldGFpbHMocG9zKSB7XG4gICAgdmFyIGRldGFpbHMgPSBwZWckcG9zRGV0YWlsc0NhY2hlW3Bvc10sIHA7XG5cbiAgICBpZiAoZGV0YWlscykge1xuICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHAgPSBwb3MgLSAxO1xuICAgICAgd2hpbGUgKCFwZWckcG9zRGV0YWlsc0NhY2hlW3BdKSB7XG4gICAgICAgIHAtLTtcbiAgICAgIH1cblxuICAgICAgZGV0YWlscyA9IHBlZyRwb3NEZXRhaWxzQ2FjaGVbcF07XG4gICAgICBkZXRhaWxzID0ge1xuICAgICAgICBsaW5lOiAgIGRldGFpbHMubGluZSxcbiAgICAgICAgY29sdW1uOiBkZXRhaWxzLmNvbHVtblxuICAgICAgfTtcblxuICAgICAgd2hpbGUgKHAgPCBwb3MpIHtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocCkgPT09IDEwKSB7XG4gICAgICAgICAgZGV0YWlscy5saW5lKys7XG4gICAgICAgICAgZGV0YWlscy5jb2x1bW4gPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRldGFpbHMuY29sdW1uKys7XG4gICAgICAgIH1cblxuICAgICAgICBwKys7XG4gICAgICB9XG5cbiAgICAgIHBlZyRwb3NEZXRhaWxzQ2FjaGVbcG9zXSA9IGRldGFpbHM7XG4gICAgICByZXR1cm4gZGV0YWlscztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwZWckY29tcHV0ZUxvY2F0aW9uKHN0YXJ0UG9zLCBlbmRQb3MpIHtcbiAgICB2YXIgc3RhcnRQb3NEZXRhaWxzID0gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHN0YXJ0UG9zKSxcbiAgICAgICAgZW5kUG9zRGV0YWlscyAgID0gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKGVuZFBvcyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHtcbiAgICAgICAgb2Zmc2V0OiBzdGFydFBvcyxcbiAgICAgICAgbGluZTogICBzdGFydFBvc0RldGFpbHMubGluZSxcbiAgICAgICAgY29sdW1uOiBzdGFydFBvc0RldGFpbHMuY29sdW1uXG4gICAgICB9LFxuICAgICAgZW5kOiB7XG4gICAgICAgIG9mZnNldDogZW5kUG9zLFxuICAgICAgICBsaW5lOiAgIGVuZFBvc0RldGFpbHMubGluZSxcbiAgICAgICAgY29sdW1uOiBlbmRQb3NEZXRhaWxzLmNvbHVtblxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwZWckZmFpbChleHBlY3RlZCkge1xuICAgIGlmIChwZWckY3VyclBvcyA8IHBlZyRtYXhGYWlsUG9zKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKHBlZyRjdXJyUG9zID4gcGVnJG1heEZhaWxQb3MpIHtcbiAgICAgIHBlZyRtYXhGYWlsUG9zID0gcGVnJGN1cnJQb3M7XG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkID0gW107XG4gICAgfVxuXG4gICAgcGVnJG1heEZhaWxFeHBlY3RlZC5wdXNoKGV4cGVjdGVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRidWlsZFNpbXBsZUVycm9yKG1lc3NhZ2UsIGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBwZWckU3ludGF4RXJyb3IobWVzc2FnZSwgbnVsbCwgbnVsbCwgbG9jYXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGJ1aWxkU3RydWN0dXJlZEVycm9yKGV4cGVjdGVkLCBmb3VuZCwgbG9jYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IHBlZyRTeW50YXhFcnJvcihcbiAgICAgIHBlZyRTeW50YXhFcnJvci5idWlsZE1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kKSxcbiAgICAgIGV4cGVjdGVkLFxuICAgICAgZm91bmQsXG4gICAgICBsb2NhdGlvblxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2Vvc2FzY3JpcHQoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZXdzKCk7XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZXZhbHVlKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczMgPSBwZWckcGFyc2V3cygpO1xuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjMChzMik7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWJlZ2luX29iamVjdCgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNld3MoKTtcbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTIzKSB7XG4gICAgICAgIHMyID0gcGVnJGMxO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMik7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMyA9IHBlZyRwYXJzZXdzKCk7XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMxID0gW3MxLCBzMiwgczNdO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VlbmRfb2JqZWN0KCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2V3cygpO1xuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMjUpIHtcbiAgICAgICAgczIgPSBwZWckYzM7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzID0gcGVnJHBhcnNld3MoKTtcbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEgPSBbczEsIHMyLCBzM107XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZW5hbWVfc2VwYXJhdG9yKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2V3cygpO1xuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA1OCkge1xuICAgICAgICBzMiA9IHBlZyRjNTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczMgPSBwZWckcGFyc2V3cygpO1xuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMSA9IFtzMSwgczIsIHMzXTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNldmFsdWVfc2VwYXJhdG9yKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2V3cygpO1xuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NCkge1xuICAgICAgICBzMiA9IHBlZyRjNztcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzgpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczMgPSBwZWckcGFyc2V3cygpO1xuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMSA9IFtzMSwgczIsIHMzXTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNld3MoKSB7XG4gICAgdmFyIHMwLCBzMTtcblxuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIHMwID0gW107XG4gICAgaWYgKHBlZyRjMTAudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgczEgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzExKTsgfVxuICAgIH1cbiAgICB3aGlsZSAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwLnB1c2goczEpO1xuICAgICAgaWYgKHBlZyRjMTAudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMSk7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjOSk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2V2YWx1ZSgpIHtcbiAgICB2YXIgczA7XG5cbiAgICBzMCA9IHBlZyRwYXJzZWZhbHNlKCk7XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMCA9IHBlZyRwYXJzZXRydWUoKTtcbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMCA9IHBlZyRwYXJzZW9iamVjdCgpO1xuICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMCA9IHBlZyRwYXJzZWFycmF5KCk7XG4gICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMCA9IHBlZyRwYXJzZW51bWJlcigpO1xuICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHMwID0gcGVnJHBhcnNlc3RyaW5nKCk7XG4gICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJHBhcnNlZGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckcGFyc2V1bnF1b3RlZF9zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRwYXJzZXJhdygpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWZhbHNlKCkge1xuICAgIHZhciBzMCwgczE7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDUpID09PSBwZWckYzEyKSB7XG4gICAgICBzMSA9IHBlZyRjMTI7XG4gICAgICBwZWckY3VyclBvcyArPSA1O1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTMpOyB9XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICBzMSA9IHBlZyRjMTQoKTtcbiAgICB9XG4gICAgczAgPSBzMTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXRydWUoKSB7XG4gICAgdmFyIHMwLCBzMTtcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNCkgPT09IHBlZyRjMTUpIHtcbiAgICAgIHMxID0gcGVnJGMxNTtcbiAgICAgIHBlZyRjdXJyUG9zICs9IDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxNik7IH1cbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgIHMxID0gcGVnJGMxNygpO1xuICAgIH1cbiAgICBzMCA9IHMxO1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlcmF3KCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2V3cygpO1xuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBbXTtcbiAgICAgIGlmIChpbnB1dC5sZW5ndGggPiBwZWckY3VyclBvcykge1xuICAgICAgICBzMyA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxOCk7IH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IHBlZyRjdXJyUG9zKSB7XG4gICAgICAgICAgczMgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxOCk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzID0gcGVnJHBhcnNld3MoKTtcbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzE5KHMyKTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlb2JqZWN0KCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNiwgczc7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlYmVnaW5fb2JqZWN0KCk7XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRjdXJyUG9zO1xuICAgICAgczMgPSBwZWckcGFyc2VtZW1iZXIoKTtcbiAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzNCA9IFtdO1xuICAgICAgICBzNSA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzNiA9IHBlZyRwYXJzZXZhbHVlX3NlcGFyYXRvcigpO1xuICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNyA9IHBlZyRwYXJzZW1lbWJlcigpO1xuICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczU7XG4gICAgICAgICAgICBzNiA9IHBlZyRjMjAoczMsIHM3KTtcbiAgICAgICAgICAgIHM1ID0gczY7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczU7XG4gICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczU7XG4gICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM0LnB1c2goczUpO1xuICAgICAgICAgIHM1ID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgczYgPSBwZWckcGFyc2V2YWx1ZV9zZXBhcmF0b3IoKTtcbiAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM3ID0gcGVnJHBhcnNlbWVtYmVyKCk7XG4gICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczU7XG4gICAgICAgICAgICAgIHM2ID0gcGVnJGMyMChzMywgczcpO1xuICAgICAgICAgICAgICBzNSA9IHM2O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzNTtcbiAgICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHM1O1xuICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMjtcbiAgICAgICAgICBzMyA9IHBlZyRjMjEoczMsIHM0KTtcbiAgICAgICAgICBzMiA9IHMzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczI7XG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMyO1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzID0gcGVnJHBhcnNlZW5kX29iamVjdCgpO1xuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjMjIoczIpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VtZW1iZXIoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZWtleSgpO1xuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2VuYW1lX3NlcGFyYXRvcigpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzID0gcGVnJHBhcnNldmFsdWUoKTtcbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzIzKHMxLCBzMyk7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWtleSgpIHtcbiAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBbXTtcbiAgICBpZiAocGVnJGMyNC50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjUpOyB9XG4gICAgfVxuICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICBpZiAocGVnJGMyNC50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyNSk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICBzMSA9IHBlZyRjMjYoczEpO1xuICAgIH1cbiAgICBzMCA9IHMxO1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlYXJyYXkoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNztcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2ViZWdpbl9vYmplY3QoKTtcbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMyA9IHBlZyRwYXJzZXZhbHVlKCk7XG4gICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczQgPSBbXTtcbiAgICAgICAgczUgPSBwZWckY3VyclBvcztcbiAgICAgICAgczYgPSBwZWckcGFyc2V2YWx1ZV9zZXBhcmF0b3IoKTtcbiAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczcgPSBwZWckcGFyc2V2YWx1ZSgpO1xuICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczU7XG4gICAgICAgICAgICBzNiA9IHBlZyRjMjcoczMsIHM3KTtcbiAgICAgICAgICAgIHM1ID0gczY7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczU7XG4gICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczU7XG4gICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM0LnB1c2goczUpO1xuICAgICAgICAgIHM1ID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgczYgPSBwZWckcGFyc2V2YWx1ZV9zZXBhcmF0b3IoKTtcbiAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM3ID0gcGVnJHBhcnNldmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzNTtcbiAgICAgICAgICAgICAgczYgPSBwZWckYzI3KHMzLCBzNyk7XG4gICAgICAgICAgICAgIHM1ID0gczY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHM1O1xuICAgICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczU7XG4gICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMyO1xuICAgICAgICAgIHMzID0gcGVnJGMyOChzMywgczQpO1xuICAgICAgICAgIHMyID0gczM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMjtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczI7XG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczMgPSBwZWckcGFyc2VlbmRfb2JqZWN0KCk7XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGMyOShzMik7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZW51bWJlcigpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0O1xuXG4gICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZW1pbnVzKCk7XG4gICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2VpbnQoKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMyA9IHBlZyRwYXJzZWZyYWMoKTtcbiAgICAgICAgaWYgKHMzID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM0ID0gcGVnJHBhcnNlZXhwKCk7XG4gICAgICAgICAgaWYgKHM0ID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICBzMSA9IHBlZyRjMzEoKTtcbiAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzMwKTsgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWRlY2ltYWxfcG9pbnQoKSB7XG4gICAgdmFyIHMwO1xuXG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0Nikge1xuICAgICAgczAgPSBwZWckYzMyO1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzMzKTsgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWRpZ2l0MV85KCkge1xuICAgIHZhciBzMDtcblxuICAgIGlmIChwZWckYzM0LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMwID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzNSk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VlKCkge1xuICAgIHZhciBzMDtcblxuICAgIGlmIChwZWckYzM2LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMwID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzNyk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VleHAoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNDtcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2VlKCk7XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZW1pbnVzKCk7XG4gICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2VwbHVzKCk7XG4gICAgICB9XG4gICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzID0gW107XG4gICAgICAgIHM0ID0gcGVnJHBhcnNlRElHSVQoKTtcbiAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgd2hpbGUgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMy5wdXNoKHM0KTtcbiAgICAgICAgICAgIHM0ID0gcGVnJHBhcnNlRElHSVQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMxID0gW3MxLCBzMiwgczNdO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VmcmFjKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2VkZWNpbWFsX3BvaW50KCk7XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IFtdO1xuICAgICAgczMgPSBwZWckcGFyc2VESUdJVCgpO1xuICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlRElHSVQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxID0gW3MxLCBzMl07XG4gICAgICAgIHMwID0gczE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlaW50KCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgIHMwID0gcGVnJHBhcnNlemVybygpO1xuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlZGlnaXQxXzkoKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IFtdO1xuICAgICAgICBzMyA9IHBlZyRwYXJzZURJR0lUKCk7XG4gICAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlRElHSVQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMSA9IFtzMSwgczJdO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VtaW51cygpIHtcbiAgICB2YXIgczA7XG5cbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ1KSB7XG4gICAgICBzMCA9IHBlZyRjMzg7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzkpOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlcGx1cygpIHtcbiAgICB2YXIgczA7XG5cbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQzKSB7XG4gICAgICBzMCA9IHBlZyRjNDA7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDEpOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlemVybygpIHtcbiAgICB2YXIgczA7XG5cbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ4KSB7XG4gICAgICBzMCA9IHBlZyRjNDI7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDMpOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlc3RyaW5nKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2VxdW90YXRpb25fbWFyaygpO1xuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBbXTtcbiAgICAgIHMzID0gcGVnJHBhcnNlY2hhcigpO1xuICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICBzMyA9IHBlZyRwYXJzZWNoYXIoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMyA9IHBlZyRwYXJzZXF1b3RhdGlvbl9tYXJrKCk7XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGM0NShzMik7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0NCk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VjaGFyKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNiwgczcsIHM4LCBzOTtcblxuICAgIHMwID0gcGVnJHBhcnNldW5lc2NhcGVkKCk7XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDEwKSB7XG4gICAgICAgIHMwID0gcGVnJGM0NjtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQ3KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOSkge1xuICAgICAgICAgIHMwID0gcGVnJGM0ODtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDkpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICBzMSA9IHBlZyRwYXJzZWVzY2FwZSgpO1xuICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzNCkge1xuICAgICAgICAgICAgICBzMiA9IHBlZyRjNTA7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1MSk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkyKSB7XG4gICAgICAgICAgICAgICAgczIgPSBwZWckYzUyO1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1Myk7IH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ3KSB7XG4gICAgICAgICAgICAgICAgICBzMiA9IHBlZyRjNTQ7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTUpOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgczIgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTgpIHtcbiAgICAgICAgICAgICAgICAgICAgczMgPSBwZWckYzU2O1xuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTcpOyB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczI7XG4gICAgICAgICAgICAgICAgICAgIHMzID0gcGVnJGM1OCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgczIgPSBzMztcbiAgICAgICAgICAgICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBzMiA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDEwMikge1xuICAgICAgICAgICAgICAgICAgICAgIHMzID0gcGVnJGM1OTtcbiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjApOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczI7XG4gICAgICAgICAgICAgICAgICAgICAgczMgPSBwZWckYzYxKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgczIgPSBzMztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgczIgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDExMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgczMgPSBwZWckYzYyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYzKTsgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMyO1xuICAgICAgICAgICAgICAgICAgICAgICAgczMgPSBwZWckYzY0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHMyID0gczM7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMiA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMTQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczMgPSBwZWckYzY1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjYpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHMzID0gcGVnJGM2NygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgczIgPSBzMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMiA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDExNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMzID0gcGVnJGM2ODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjkpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczMgPSBwZWckYzcwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgczIgPSBzMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczIgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDExNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczMgPSBwZWckYzcxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzcyKTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM0ID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzNSA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VIRVhESUcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzNyA9IHBlZyRwYXJzZUhFWERJRygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzOCA9IHBlZyRwYXJzZUhFWERJRygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzOCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczkgPSBwZWckcGFyc2VIRVhESUcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzOSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzNiA9IFtzNiwgczcsIHM4LCBzOV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM1ID0gczY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHM1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHM1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczQgPSBpbnB1dC5zdWJzdHJpbmcoczQsIHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM0ID0gczU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMzID0gcGVnJGM3MyhzNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMyID0gczM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICAgIHMxID0gcGVnJGM3NChzMik7XG4gICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlZXNjYXBlKCkge1xuICAgIHZhciBzMDtcblxuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTIpIHtcbiAgICAgIHMwID0gcGVnJGM1MjtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1Myk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VxdW90YXRpb25fbWFyaygpIHtcbiAgICB2YXIgczA7XG5cbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM0KSB7XG4gICAgICBzMCA9IHBlZyRjNTA7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTEpOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNldW5lc2NhcGVkKCkge1xuICAgIHZhciBzMDtcblxuICAgIGlmIChwZWckYzc1LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMwID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM3Nik7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2V1bnF1b3RlZF9zdHJpbmcoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZWZpcnN0X3VucXVvdGVkX2NoYXIoKTtcbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gW107XG4gICAgICBzMyA9IHBlZyRwYXJzZXVucXVvdGVkX2NoYXIoKTtcbiAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgczMgPSBwZWckcGFyc2V1bnF1b3RlZF9jaGFyKCk7XG4gICAgICB9XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGM3OChzMSwgczIpO1xuICAgICAgICBzMCA9IHMxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM3Nyk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VmaXJzdF91bnF1b3RlZF9jaGFyKCkge1xuICAgIHZhciBzMDtcblxuICAgIGlmIChwZWckYzc5LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMwID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4MCk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2V1bnF1b3RlZF9jaGFyKCkge1xuICAgIHZhciBzMDtcblxuICAgIGlmIChwZWckYzgxLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMwID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4Mik7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VkYXRlKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNCkgPT09IHBlZyRjODQpIHtcbiAgICAgIHMxID0gcGVnJGM4NDtcbiAgICAgIHBlZyRjdXJyUG9zICs9IDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4NSk7IH1cbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZXdzKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczMgPSBwZWckcGFyc2VzdHJpbmcoKTtcbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzg2KHMzKTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzgzKTsgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZURJR0lUKCkge1xuICAgIHZhciBzMDtcblxuICAgIGlmIChwZWckYzg3LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMwID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4OCk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VIRVhESUcoKSB7XG4gICAgdmFyIHMwO1xuXG4gICAgaWYgKHBlZyRjODkudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgczAgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzkwKTsgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIHBlZyRyZXN1bHQgPSBwZWckc3RhcnRSdWxlRnVuY3Rpb24oKTtcblxuICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHBlZyRyZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIHBlZyRmYWlsKHBlZyRlbmRFeHBlY3RhdGlvbigpKTtcbiAgICB9XG5cbiAgICB0aHJvdyBwZWckYnVpbGRTdHJ1Y3R1cmVkRXJyb3IoXG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkLFxuICAgICAgcGVnJG1heEZhaWxQb3MgPCBpbnB1dC5sZW5ndGggPyBpbnB1dC5jaGFyQXQocGVnJG1heEZhaWxQb3MpIDogbnVsbCxcbiAgICAgIHBlZyRtYXhGYWlsUG9zIDwgaW5wdXQubGVuZ3RoXG4gICAgICAgID8gcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckbWF4RmFpbFBvcywgcGVnJG1heEZhaWxQb3MgKyAxKVxuICAgICAgICA6IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJG1heEZhaWxQb3MsIHBlZyRtYXhGYWlsUG9zKVxuICAgICk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFN5bnRheEVycm9yOiBwZWckU3ludGF4RXJyb3IsXG4gIHBhcnNlOiAgICAgICBwZWckcGFyc2Vcbn07XG4iLCAiXG4vKipcbiAqIFNlcmlhbGl6ZSBhIGphdmFzY3JpcHQgb2JqZWN0IHRvIEFwcGxlU2NyaXB0XG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZU9iamVjdCh2YWx1ZSkge1xuXHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gJyc7XG5cdH1cblx0dmFyIHJlc3VsdDtcblx0dmFyIHR5cGVPZiA9IHR5cGVvZiB2YWx1ZTtcblxuXHRpZiAodHlwZU9mID09PSAnb2JqZWN0JyAmJiAodmFsdWUgIT09IG51bGwpKSB7XG5cdFx0cmVzdWx0ID0gJ3snO1xuXHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0dmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoYXJyYXlWYWx1ZSwgaSkge1xuXHRcdFx0XHRpZiAoaSAhPT0gMCkge1xuXHRcdFx0XHRcdHJlc3VsdCArPSAnLCc7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVzdWx0ICs9IHNlcmlhbGl6ZU9iamVjdChhcnJheVZhbHVlKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBpKSB7XG5cdFx0XHRcdGlmIChpICE9PSAwKSB7XG5cdFx0XHRcdFx0cmVzdWx0ICs9ICcsJztcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXN1bHQgKz0ga2V5ICsgJzonICsgc2VyaWFsaXplT2JqZWN0KHZhbHVlW2tleV0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmVzdWx0ICs9ICd9Jztcblx0fSBlbHNlIGlmICh0eXBlT2YgPT09ICdzdHJpbmcnKSB7XG5cdFx0cmVzdWx0ID0gJ1wiJyArIHZhbHVlICsgJ1wiJztcblx0fSBlbHNlIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0cmVzdWx0ID0gJ251bGwnO1xuXHR9XG5cblx0cmV0dXJuIHJlc3VsdCB8fCB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdHNlcmlhbGl6ZU9iamVjdDogc2VyaWFsaXplT2JqZWN0LFxuICAvLyBHZW5lcmF0ZSBhcHBsZSBzY3JpcHQgZnJvbSBqYXZhc2NyaXB0IG9iamVjdFxuXHRnZW5lcmF0ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuXHRcdHZhciBhU2NyaXB0ID0gJyc7XG5cblx0XHRPYmplY3Qua2V5cyhvYmplY3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0YVNjcmlwdCArPSAnc2V0ICcgKyBrZXkgKyAnIHRvICcgKyBzZXJpYWxpemVPYmplY3Qob2JqZWN0W2tleV0pICsgJ1xcbic7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gYVNjcmlwdDtcblx0fVxufTtcbiIsICJ2YXIgc3Bhd24gPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuc3Bhd247XG52YXIgZGlybmFtZSA9IHJlcXVpcmUoJ3BhdGgnKS5kaXJuYW1lO1xudmFyIHJlYWRGaWxlU3luYyA9IHJlcXVpcmUoJ2ZzJykucmVhZEZpbGVTeW5jO1xuXG52YXIgQnVmZmVycyA9IHJlcXVpcmUoJ2J1ZmZlcnMnKTtcblxudmFyIHBhcnNlID0gcmVxdWlyZSgnLi9vc2EtcGFyc2VyJykucGFyc2U7XG52YXIgdmFyR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9vc2EtdmFyZ2VuJykuZ2VuZXJhdGU7XG5cbnZhciBidWZmZXJTdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG5cdHZhciBidWZmZXIgPSBuZXcgQnVmZmVycygpO1xuXHRzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcblx0XHRidWZmZXIucHVzaChjaHVuayk7XG5cdH0pO1xuXHRyZXR1cm4gYnVmZmVyO1xufTtcblxudmFyIGV4ZWN1dGUgPSBmdW5jdGlvbiAocGF0aCwgc2NyaXB0LCB2YXJzLCBjYikge1xuXHRpZiAoY2IgPT09IHVuZGVmaW5lZCkge1xuXHRcdGNiID0gdmFycztcblx0fVxuXHR2YXIgb3B0cztcblx0aWYgKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJykge1xuXHRcdG9wdHMgPSB7fTtcblx0fSBlbHNlIHtcblx0XHRvcHRzID0ge2N3ZDogZGlybmFtZShwYXRoKX07XG5cdH1cblxuXHR2YXIgY3AgPSBzcGF3bignb3Nhc2NyaXB0JywgWyctc3MnLCAnLSddLCBvcHRzKTtcblxuXHR2YXIgb3V0QnVmZmVyID0gYnVmZmVyU3RyZWFtKGNwLnN0ZG91dCk7XG5cdHZhciBlcnJCdWZmZXIgPSBidWZmZXJTdHJlYW0oY3Auc3RkZXJyKTtcblxuXHRjcC5vbignY2xvc2UnLCBmdW5jdGlvbiAoY29kZSkge1xuXHRcdHZhciBlcnJvcjtcblx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0aWYgKGNvZGUpIHtcblx0XHRcdGVycm9yID0gbmV3IEVycm9yKGVyckJ1ZmZlci50b1N0cmluZygpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVzdWx0ID0gcGFyc2Uob3V0QnVmZmVyLnRvU3RyaW5nKCkpO1xuXHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdGVycm9yID0gZXJyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChjYikge1xuXHRcdFx0Y2IoZXJyb3IsIHJlc3VsdCwgb3V0QnVmZmVyKTtcblx0XHR9XG5cdH0pO1xuXG5cdGlmICghc2NyaXB0KSB7XG5cdFx0c2NyaXB0ID0gcmVhZEZpbGVTeW5jKHBhdGgpO1xuXHR9XG5cblx0aWYgKHZhcnMpIHtcblx0XHRzY3JpcHQgPSB2YXJHZW5lcmF0b3IodmFycykgKyAnXFxuJyArIHNjcmlwdDtcblx0fVxuXG5cdGNwLnN0ZGluLndyaXRlKHNjcmlwdCk7XG5cdGNwLnN0ZGluLmVuZCgpO1xuXG5cdHJldHVybiBjcDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRleGVjdXRlOiBmdW5jdGlvbiAoc2NyaXB0LCB2YXJzLCBjYikge1xuXHRcdHJldHVybiBleGVjdXRlKHVuZGVmaW5lZCwgc2NyaXB0LCB2YXJzLCBjYik7XG5cdH0sXG5cdGV4ZWN1dGVGaWxlOiBmdW5jdGlvbiAocGF0aCwgdmFycywgY2IpIHtcblx0XHRyZXR1cm4gZXhlY3V0ZShwYXRoLCB1bmRlZmluZWQsIHZhcnMsIGNiKTtcblx0fVxufTtcbiIsIG51bGwsICIhZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShlKToodD1cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOnR8fHNlbGYpLmRheWpzPWUoKX0odGhpcywoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgdD0xZTMsZT02ZTQsbj0zNmU1LHI9XCJtaWxsaXNlY29uZFwiLGk9XCJzZWNvbmRcIixzPVwibWludXRlXCIsdT1cImhvdXJcIixhPVwiZGF5XCIsbz1cIndlZWtcIixmPVwibW9udGhcIixoPVwicXVhcnRlclwiLGM9XCJ5ZWFyXCIsZD1cImRhdGVcIiwkPVwiSW52YWxpZCBEYXRlXCIsbD0vXihcXGR7NH0pWy0vXT8oXFxkezEsMn0pP1stL10/KFxcZHswLDJ9KVtUdFxcc10qKFxcZHsxLDJ9KT86PyhcXGR7MSwyfSk/Oj8oXFxkezEsMn0pP1suOl0/KFxcZCspPyQvLHk9L1xcWyhbXlxcXV0rKV18WXsxLDR9fE17MSw0fXxEezEsMn18ZHsxLDR9fEh7MSwyfXxoezEsMn18YXxBfG17MSwyfXxzezEsMn18WnsxLDJ9fFNTUy9nLE09e25hbWU6XCJlblwiLHdlZWtkYXlzOlwiU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXlcIi5zcGxpdChcIl9cIiksbW9udGhzOlwiSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlclwiLnNwbGl0KFwiX1wiKX0sbT1mdW5jdGlvbih0LGUsbil7dmFyIHI9U3RyaW5nKHQpO3JldHVybiFyfHxyLmxlbmd0aD49ZT90OlwiXCIrQXJyYXkoZSsxLXIubGVuZ3RoKS5qb2luKG4pK3R9LGc9e3M6bSx6OmZ1bmN0aW9uKHQpe3ZhciBlPS10LnV0Y09mZnNldCgpLG49TWF0aC5hYnMoZSkscj1NYXRoLmZsb29yKG4vNjApLGk9biU2MDtyZXR1cm4oZTw9MD9cIitcIjpcIi1cIikrbShyLDIsXCIwXCIpK1wiOlwiK20oaSwyLFwiMFwiKX0sbTpmdW5jdGlvbiB0KGUsbil7aWYoZS5kYXRlKCk8bi5kYXRlKCkpcmV0dXJuLXQobixlKTt2YXIgcj0xMioobi55ZWFyKCktZS55ZWFyKCkpKyhuLm1vbnRoKCktZS5tb250aCgpKSxpPWUuY2xvbmUoKS5hZGQocixmKSxzPW4taTwwLHU9ZS5jbG9uZSgpLmFkZChyKyhzPy0xOjEpLGYpO3JldHVybisoLShyKyhuLWkpLyhzP2ktdTp1LWkpKXx8MCl9LGE6ZnVuY3Rpb24odCl7cmV0dXJuIHQ8MD9NYXRoLmNlaWwodCl8fDA6TWF0aC5mbG9vcih0KX0scDpmdW5jdGlvbih0KXtyZXR1cm57TTpmLHk6Yyx3Om8sZDphLEQ6ZCxoOnUsbTpzLHM6aSxtczpyLFE6aH1bdF18fFN0cmluZyh0fHxcIlwiKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL3MkLyxcIlwiKX0sdTpmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dH19LHY9XCJlblwiLEQ9e307RFt2XT1NO3ZhciBwPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgX30sUz1mdW5jdGlvbiB0KGUsbixyKXt2YXIgaTtpZighZSlyZXR1cm4gdjtpZihcInN0cmluZ1wiPT10eXBlb2YgZSl7dmFyIHM9ZS50b0xvd2VyQ2FzZSgpO0Rbc10mJihpPXMpLG4mJihEW3NdPW4saT1zKTt2YXIgdT1lLnNwbGl0KFwiLVwiKTtpZighaSYmdS5sZW5ndGg+MSlyZXR1cm4gdCh1WzBdKX1lbHNle3ZhciBhPWUubmFtZTtEW2FdPWUsaT1hfXJldHVybiFyJiZpJiYodj1pKSxpfHwhciYmdn0sdz1mdW5jdGlvbih0LGUpe2lmKHAodCkpcmV0dXJuIHQuY2xvbmUoKTt2YXIgbj1cIm9iamVjdFwiPT10eXBlb2YgZT9lOnt9O3JldHVybiBuLmRhdGU9dCxuLmFyZ3M9YXJndW1lbnRzLG5ldyBfKG4pfSxPPWc7Ty5sPVMsTy5pPXAsTy53PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHcodCx7bG9jYWxlOmUuJEwsdXRjOmUuJHUseDplLiR4LCRvZmZzZXQ6ZS4kb2Zmc2V0fSl9O3ZhciBfPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gTSh0KXt0aGlzLiRMPVModC5sb2NhbGUsbnVsbCwhMCksdGhpcy5wYXJzZSh0KX12YXIgbT1NLnByb3RvdHlwZTtyZXR1cm4gbS5wYXJzZT1mdW5jdGlvbih0KXt0aGlzLiRkPWZ1bmN0aW9uKHQpe3ZhciBlPXQuZGF0ZSxuPXQudXRjO2lmKG51bGw9PT1lKXJldHVybiBuZXcgRGF0ZShOYU4pO2lmKE8udShlKSlyZXR1cm4gbmV3IERhdGU7aWYoZSBpbnN0YW5jZW9mIERhdGUpcmV0dXJuIG5ldyBEYXRlKGUpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlJiYhL1okL2kudGVzdChlKSl7dmFyIHI9ZS5tYXRjaChsKTtpZihyKXt2YXIgaT1yWzJdLTF8fDAscz0ocls3XXx8XCIwXCIpLnN1YnN0cmluZygwLDMpO3JldHVybiBuP25ldyBEYXRlKERhdGUuVVRDKHJbMV0saSxyWzNdfHwxLHJbNF18fDAscls1XXx8MCxyWzZdfHwwLHMpKTpuZXcgRGF0ZShyWzFdLGksclszXXx8MSxyWzRdfHwwLHJbNV18fDAscls2XXx8MCxzKX19cmV0dXJuIG5ldyBEYXRlKGUpfSh0KSx0aGlzLiR4PXQueHx8e30sdGhpcy5pbml0KCl9LG0uaW5pdD1mdW5jdGlvbigpe3ZhciB0PXRoaXMuJGQ7dGhpcy4keT10LmdldEZ1bGxZZWFyKCksdGhpcy4kTT10LmdldE1vbnRoKCksdGhpcy4kRD10LmdldERhdGUoKSx0aGlzLiRXPXQuZ2V0RGF5KCksdGhpcy4kSD10LmdldEhvdXJzKCksdGhpcy4kbT10LmdldE1pbnV0ZXMoKSx0aGlzLiRzPXQuZ2V0U2Vjb25kcygpLHRoaXMuJG1zPXQuZ2V0TWlsbGlzZWNvbmRzKCl9LG0uJHV0aWxzPWZ1bmN0aW9uKCl7cmV0dXJuIE99LG0uaXNWYWxpZD1mdW5jdGlvbigpe3JldHVybiEodGhpcy4kZC50b1N0cmluZygpPT09JCl9LG0uaXNTYW1lPWZ1bmN0aW9uKHQsZSl7dmFyIG49dyh0KTtyZXR1cm4gdGhpcy5zdGFydE9mKGUpPD1uJiZuPD10aGlzLmVuZE9mKGUpfSxtLmlzQWZ0ZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdyh0KTx0aGlzLnN0YXJ0T2YoZSl9LG0uaXNCZWZvcmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmRPZihlKTx3KHQpfSxtLiRnPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gTy51KHQpP3RoaXNbZV06dGhpcy5zZXQobix0KX0sbS51bml4PWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkvMWUzKX0sbS52YWx1ZU9mPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGQuZ2V0VGltZSgpfSxtLnN0YXJ0T2Y9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLHI9ISFPLnUoZSl8fGUsaD1PLnAodCksJD1mdW5jdGlvbih0LGUpe3ZhciBpPU8udyhuLiR1P0RhdGUuVVRDKG4uJHksZSx0KTpuZXcgRGF0ZShuLiR5LGUsdCksbik7cmV0dXJuIHI/aTppLmVuZE9mKGEpfSxsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIE8udyhuLnRvRGF0ZSgpW3RdLmFwcGx5KG4udG9EYXRlKFwic1wiKSwocj9bMCwwLDAsMF06WzIzLDU5LDU5LDk5OV0pLnNsaWNlKGUpKSxuKX0seT10aGlzLiRXLE09dGhpcy4kTSxtPXRoaXMuJEQsZz1cInNldFwiKyh0aGlzLiR1P1wiVVRDXCI6XCJcIik7c3dpdGNoKGgpe2Nhc2UgYzpyZXR1cm4gcj8kKDEsMCk6JCgzMSwxMSk7Y2FzZSBmOnJldHVybiByPyQoMSxNKTokKDAsTSsxKTtjYXNlIG86dmFyIHY9dGhpcy4kbG9jYWxlKCkud2Vla1N0YXJ0fHwwLEQ9KHk8dj95Kzc6eSktdjtyZXR1cm4gJChyP20tRDptKyg2LUQpLE0pO2Nhc2UgYTpjYXNlIGQ6cmV0dXJuIGwoZytcIkhvdXJzXCIsMCk7Y2FzZSB1OnJldHVybiBsKGcrXCJNaW51dGVzXCIsMSk7Y2FzZSBzOnJldHVybiBsKGcrXCJTZWNvbmRzXCIsMik7Y2FzZSBpOnJldHVybiBsKGcrXCJNaWxsaXNlY29uZHNcIiwzKTtkZWZhdWx0OnJldHVybiB0aGlzLmNsb25lKCl9fSxtLmVuZE9mPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnN0YXJ0T2YodCwhMSl9LG0uJHNldD1mdW5jdGlvbih0LGUpe3ZhciBuLG89Ty5wKHQpLGg9XCJzZXRcIisodGhpcy4kdT9cIlVUQ1wiOlwiXCIpLCQ9KG49e30sblthXT1oK1wiRGF0ZVwiLG5bZF09aCtcIkRhdGVcIixuW2ZdPWgrXCJNb250aFwiLG5bY109aCtcIkZ1bGxZZWFyXCIsblt1XT1oK1wiSG91cnNcIixuW3NdPWgrXCJNaW51dGVzXCIsbltpXT1oK1wiU2Vjb25kc1wiLG5bcl09aCtcIk1pbGxpc2Vjb25kc1wiLG4pW29dLGw9bz09PWE/dGhpcy4kRCsoZS10aGlzLiRXKTplO2lmKG89PT1mfHxvPT09Yyl7dmFyIHk9dGhpcy5jbG9uZSgpLnNldChkLDEpO3kuJGRbJF0obCkseS5pbml0KCksdGhpcy4kZD15LnNldChkLE1hdGgubWluKHRoaXMuJEQseS5kYXlzSW5Nb250aCgpKSkuJGR9ZWxzZSAkJiZ0aGlzLiRkWyRdKGwpO3JldHVybiB0aGlzLmluaXQoKSx0aGlzfSxtLnNldD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmNsb25lKCkuJHNldCh0LGUpfSxtLmdldD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpc1tPLnAodCldKCl9LG0uYWRkPWZ1bmN0aW9uKHIsaCl7dmFyIGQsJD10aGlzO3I9TnVtYmVyKHIpO3ZhciBsPU8ucChoKSx5PWZ1bmN0aW9uKHQpe3ZhciBlPXcoJCk7cmV0dXJuIE8udyhlLmRhdGUoZS5kYXRlKCkrTWF0aC5yb3VuZCh0KnIpKSwkKX07aWYobD09PWYpcmV0dXJuIHRoaXMuc2V0KGYsdGhpcy4kTStyKTtpZihsPT09YylyZXR1cm4gdGhpcy5zZXQoYyx0aGlzLiR5K3IpO2lmKGw9PT1hKXJldHVybiB5KDEpO2lmKGw9PT1vKXJldHVybiB5KDcpO3ZhciBNPShkPXt9LGRbc109ZSxkW3VdPW4sZFtpXT10LGQpW2xdfHwxLG09dGhpcy4kZC5nZXRUaW1lKCkrcipNO3JldHVybiBPLncobSx0aGlzKX0sbS5zdWJ0cmFjdD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFkZCgtMSp0LGUpfSxtLmZvcm1hdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLG49dGhpcy4kbG9jYWxlKCk7aWYoIXRoaXMuaXNWYWxpZCgpKXJldHVybiBuLmludmFsaWREYXRlfHwkO3ZhciByPXR8fFwiWVlZWS1NTS1ERFRISDptbTpzc1pcIixpPU8ueih0aGlzKSxzPXRoaXMuJEgsdT10aGlzLiRtLGE9dGhpcy4kTSxvPW4ud2Vla2RheXMsZj1uLm1vbnRocyxoPWZ1bmN0aW9uKHQsbixpLHMpe3JldHVybiB0JiYodFtuXXx8dChlLHIpKXx8aVtuXS5zbGljZSgwLHMpfSxjPWZ1bmN0aW9uKHQpe3JldHVybiBPLnMocyUxMnx8MTIsdCxcIjBcIil9LGQ9bi5tZXJpZGllbXx8ZnVuY3Rpb24odCxlLG4pe3ZhciByPXQ8MTI/XCJBTVwiOlwiUE1cIjtyZXR1cm4gbj9yLnRvTG93ZXJDYXNlKCk6cn0sbD17WVk6U3RyaW5nKHRoaXMuJHkpLnNsaWNlKC0yKSxZWVlZOnRoaXMuJHksTTphKzEsTU06Ty5zKGErMSwyLFwiMFwiKSxNTU06aChuLm1vbnRoc1Nob3J0LGEsZiwzKSxNTU1NOmgoZixhKSxEOnRoaXMuJEQsREQ6Ty5zKHRoaXMuJEQsMixcIjBcIiksZDpTdHJpbmcodGhpcy4kVyksZGQ6aChuLndlZWtkYXlzTWluLHRoaXMuJFcsbywyKSxkZGQ6aChuLndlZWtkYXlzU2hvcnQsdGhpcy4kVyxvLDMpLGRkZGQ6b1t0aGlzLiRXXSxIOlN0cmluZyhzKSxISDpPLnMocywyLFwiMFwiKSxoOmMoMSksaGg6YygyKSxhOmQocyx1LCEwKSxBOmQocyx1LCExKSxtOlN0cmluZyh1KSxtbTpPLnModSwyLFwiMFwiKSxzOlN0cmluZyh0aGlzLiRzKSxzczpPLnModGhpcy4kcywyLFwiMFwiKSxTU1M6Ty5zKHRoaXMuJG1zLDMsXCIwXCIpLFo6aX07cmV0dXJuIHIucmVwbGFjZSh5LChmdW5jdGlvbih0LGUpe3JldHVybiBlfHxsW3RdfHxpLnJlcGxhY2UoXCI6XCIsXCJcIil9KSl9LG0udXRjT2Zmc2V0PWZ1bmN0aW9uKCl7cmV0dXJuIDE1Ki1NYXRoLnJvdW5kKHRoaXMuJGQuZ2V0VGltZXpvbmVPZmZzZXQoKS8xNSl9LG0uZGlmZj1mdW5jdGlvbihyLGQsJCl7dmFyIGwseT1PLnAoZCksTT13KHIpLG09KE0udXRjT2Zmc2V0KCktdGhpcy51dGNPZmZzZXQoKSkqZSxnPXRoaXMtTSx2PU8ubSh0aGlzLE0pO3JldHVybiB2PShsPXt9LGxbY109di8xMixsW2ZdPXYsbFtoXT12LzMsbFtvXT0oZy1tKS82MDQ4ZTUsbFthXT0oZy1tKS84NjRlNSxsW3VdPWcvbixsW3NdPWcvZSxsW2ldPWcvdCxsKVt5XXx8ZywkP3Y6Ty5hKHYpfSxtLmRheXNJbk1vbnRoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5kT2YoZikuJER9LG0uJGxvY2FsZT1mdW5jdGlvbigpe3JldHVybiBEW3RoaXMuJExdfSxtLmxvY2FsZT1mdW5jdGlvbih0LGUpe2lmKCF0KXJldHVybiB0aGlzLiRMO3ZhciBuPXRoaXMuY2xvbmUoKSxyPVModCxlLCEwKTtyZXR1cm4gciYmKG4uJEw9ciksbn0sbS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBPLncodGhpcy4kZCx0aGlzKX0sbS50b0RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkpfSxtLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzVmFsaWQoKT90aGlzLnRvSVNPU3RyaW5nKCk6bnVsbH0sbS50b0lTT1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRkLnRvSVNPU3RyaW5nKCl9LG0udG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZC50b1VUQ1N0cmluZygpfSxNfSgpLFQ9Xy5wcm90b3R5cGU7cmV0dXJuIHcucHJvdG90eXBlPVQsW1tcIiRtc1wiLHJdLFtcIiRzXCIsaV0sW1wiJG1cIixzXSxbXCIkSFwiLHVdLFtcIiRXXCIsYV0sW1wiJE1cIixmXSxbXCIkeVwiLGNdLFtcIiREXCIsZF1dLmZvckVhY2goKGZ1bmN0aW9uKHQpe1RbdFsxXV09ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuJGcoZSx0WzBdLHRbMV0pfX0pKSx3LmV4dGVuZD1mdW5jdGlvbih0LGUpe3JldHVybiB0LiRpfHwodChlLF8sdyksdC4kaT0hMCksd30sdy5sb2NhbGU9Uyx3LmlzRGF5anM9cCx3LnVuaXg9ZnVuY3Rpb24odCl7cmV0dXJuIHcoMWUzKnQpfSx3LmVuPURbdl0sdy5Mcz1ELHcucD17fSx3fSkpOyIsIG51bGwsIG51bGwsICIhZnVuY3Rpb24odCxuKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1uKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShuKToodD1cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOnR8fHNlbGYpLmRheWpzX3BsdWdpbl9xdWFydGVyT2ZZZWFyPW4oKX0odGhpcywoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgdD1cIm1vbnRoXCIsbj1cInF1YXJ0ZXJcIjtyZXR1cm4gZnVuY3Rpb24oZSxpKXt2YXIgcj1pLnByb3RvdHlwZTtyLnF1YXJ0ZXI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuJHV0aWxzKCkudSh0KT9NYXRoLmNlaWwoKHRoaXMubW9udGgoKSsxKS8zKTp0aGlzLm1vbnRoKHRoaXMubW9udGgoKSUzKzMqKHQtMSkpfTt2YXIgcz1yLmFkZDtyLmFkZD1mdW5jdGlvbihlLGkpe3JldHVybiBlPU51bWJlcihlKSx0aGlzLiR1dGlscygpLnAoaSk9PT1uP3RoaXMuYWRkKDMqZSx0KTpzLmJpbmQodGhpcykoZSxpKX07dmFyIHU9ci5zdGFydE9mO3Iuc3RhcnRPZj1mdW5jdGlvbihlLGkpe3ZhciByPXRoaXMuJHV0aWxzKCkscz0hIXIudShpKXx8aTtpZihyLnAoZSk9PT1uKXt2YXIgbz10aGlzLnF1YXJ0ZXIoKS0xO3JldHVybiBzP3RoaXMubW9udGgoMypvKS5zdGFydE9mKHQpLnN0YXJ0T2YoXCJkYXlcIik6dGhpcy5tb250aCgzKm8rMikuZW5kT2YodCkuZW5kT2YoXCJkYXlcIil9cmV0dXJuIHUuYmluZCh0aGlzKShlLGkpfX19KSk7IiwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgZ2xvYmFsLCBkZWZpbmUsIFN5c3RlbSwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG52YXIgX19leHRlbmRzO1xyXG52YXIgX19hc3NpZ247XHJcbnZhciBfX3Jlc3Q7XHJcbnZhciBfX2RlY29yYXRlO1xyXG52YXIgX19wYXJhbTtcclxudmFyIF9fbWV0YWRhdGE7XHJcbnZhciBfX2F3YWl0ZXI7XHJcbnZhciBfX2dlbmVyYXRvcjtcclxudmFyIF9fZXhwb3J0U3RhcjtcclxudmFyIF9fdmFsdWVzO1xyXG52YXIgX19yZWFkO1xyXG52YXIgX19zcHJlYWQ7XHJcbnZhciBfX3NwcmVhZEFycmF5cztcclxudmFyIF9fc3ByZWFkQXJyYXk7XHJcbnZhciBfX2F3YWl0O1xyXG52YXIgX19hc3luY0dlbmVyYXRvcjtcclxudmFyIF9fYXN5bmNEZWxlZ2F0b3I7XHJcbnZhciBfX2FzeW5jVmFsdWVzO1xyXG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3Q7XHJcbnZhciBfX2ltcG9ydFN0YXI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQ7XHJcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0O1xyXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldDtcclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRJbjtcclxudmFyIF9fY3JlYXRlQmluZGluZztcclxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICB2YXIgcm9vdCA9IHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0eXBlb2YgdGhpcyA9PT0gXCJvYmplY3RcIiA/IHRoaXMgOiB7fTtcclxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShcInRzbGliXCIsIFtcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChleHBvcnRzKSB7IGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIoZXhwb3J0cykpKTsgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIobW9kdWxlLmV4cG9ydHMpKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMsIHByZXZpb3VzKSB7XHJcbiAgICAgICAgaWYgKGV4cG9ydHMgIT09IHJvb3QpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpZCwgdikgeyByZXR1cm4gZXhwb3J0c1tpZF0gPSBwcmV2aW91cyA/IHByZXZpb3VzKGlkLCB2KSA6IHY7IH07XHJcbiAgICB9XHJcbn0pXHJcbihmdW5jdGlvbiAoZXhwb3J0ZXIpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcblxyXG4gICAgX19yZXN0ID0gZnVuY3Rpb24gKHMsIGUpIHtcclxuICAgICAgICB2YXIgdCA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgICAgICB0W3BdID0gc1twXTtcclxuICAgICAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2RlY29yYXRlID0gZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICAgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxuICAgIH07XHJcblxyXG4gICAgX19wYXJhbSA9IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19tZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXdhaXRlciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2dlbmVyYXRvciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICAgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgICAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZXhwb3J0U3RhciA9IGZ1bmN0aW9uKG0sIG8pIHtcclxuICAgICAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcclxuICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xyXG4gICAgICAgICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xyXG4gICAgfSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgICAgIG9bazJdID0gbVtrXTtcclxuICAgIH0pO1xyXG5cclxuICAgIF9fdmFsdWVzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3JlYWQgPSBmdW5jdGlvbiAobywgbikge1xyXG4gICAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgICAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xyXG4gICAgX19zcHJlYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xyXG4gICAgX19zcHJlYWRBcnJheXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3NwcmVhZEFycmF5ID0gZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICAgICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hd2FpdCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNHZW5lcmF0b3IgPSBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jRGVsZWdhdG9yID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICB2YXIgaSwgcDtcclxuICAgICAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY1ZhbHVlcyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX21ha2VUZW1wbGF0ZU9iamVjdCA9IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICAgICAgcmV0dXJuIGNvb2tlZDtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxuICAgIH0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxuICAgIH07XHJcblxyXG4gICAgX19pbXBvcnRTdGFyID0gZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9faW1wb3J0RGVmYXVsdCA9IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgICAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxuICAgIH07XHJcblxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgICAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICAgICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxuICAgIH07XHJcblxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICAgICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgICAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4gPSBmdW5jdGlvbiAoc3RhdGUsIHJlY2VpdmVyKSB7XHJcbiAgICAgICAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgPT09IHN0YXRlIDogc3RhdGUuaGFzKHJlY2VpdmVyKTtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0ZXIoXCJfX2V4dGVuZHNcIiwgX19leHRlbmRzKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3NpZ25cIiwgX19hc3NpZ24pO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3Jlc3RcIiwgX19yZXN0KTtcclxuICAgIGV4cG9ydGVyKFwiX19kZWNvcmF0ZVwiLCBfX2RlY29yYXRlKTtcclxuICAgIGV4cG9ydGVyKFwiX19wYXJhbVwiLCBfX3BhcmFtKTtcclxuICAgIGV4cG9ydGVyKFwiX19tZXRhZGF0YVwiLCBfX21ldGFkYXRhKTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdGVyXCIsIF9fYXdhaXRlcik7XHJcbiAgICBleHBvcnRlcihcIl9fZ2VuZXJhdG9yXCIsIF9fZ2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19leHBvcnRTdGFyXCIsIF9fZXhwb3J0U3Rhcik7XHJcbiAgICBleHBvcnRlcihcIl9fY3JlYXRlQmluZGluZ1wiLCBfX2NyZWF0ZUJpbmRpbmcpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3ZhbHVlc1wiLCBfX3ZhbHVlcyk7XHJcbiAgICBleHBvcnRlcihcIl9fcmVhZFwiLCBfX3JlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3NwcmVhZFwiLCBfX3NwcmVhZCk7XHJcbiAgICBleHBvcnRlcihcIl9fc3ByZWFkQXJyYXlzXCIsIF9fc3ByZWFkQXJyYXlzKTtcclxuICAgIGV4cG9ydGVyKFwiX19zcHJlYWRBcnJheVwiLCBfX3NwcmVhZEFycmF5KTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdFwiLCBfX2F3YWl0KTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0dlbmVyYXRvclwiLCBfX2FzeW5jR2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0RlbGVnYXRvclwiLCBfX2FzeW5jRGVsZWdhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY1ZhbHVlc1wiLCBfX2FzeW5jVmFsdWVzKTtcclxuICAgIGV4cG9ydGVyKFwiX19tYWtlVGVtcGxhdGVPYmplY3RcIiwgX19tYWtlVGVtcGxhdGVPYmplY3QpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2ltcG9ydFN0YXJcIiwgX19pbXBvcnRTdGFyKTtcclxuICAgIGV4cG9ydGVyKFwiX19pbXBvcnREZWZhdWx0XCIsIF9faW1wb3J0RGVmYXVsdCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRHZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRTZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZFNldCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRJblwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4pO1xyXG59KTtcclxuIiwgImltcG9ydCB7IE5vdGljZSwgUGx1Z2luIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgTGlzdEVsZW1lbnQgfSBmcm9tICcuL3VpL2xpc3QuZWxlbWVudCc7XG5pbXBvcnQgeyBSZW1pbmRlcnNEYXRhU2VydmljZSB9IGZyb20gXCIuL2RhdGEvcmVtaW5kZXJzLWRhdGEuc2VydmljZVwiO1xuaW1wb3J0IHsgcGFyc2UgfSBmcm9tICd5YW1sJztcbmltcG9ydCB7IGludGVydmFsLCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEFwcGxlUmVtaW5kZXJzUGx1Z2luU2V0dGluZ3MsIFNhbXBsZVNldHRpbmdUYWIsIERFRkFVTFRfU0VUVElOR1MgfSBmcm9tICcuL3VpL3NldHRpbmdzJztcbmltcG9ydCB7IEFwcGxlUmVtaW5kZXJTcGVjIH0gZnJvbSAnLi9tb2RlbHMvc2hhcmVkLm1vZGVscyc7XG5cblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcHBsZVJlbWluZGVyc1BsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG5cdHNldHRpbmdzOiBBcHBsZVJlbWluZGVyc1BsdWdpblNldHRpbmdzO1xuXG5cdGVsZW1lbnRSZWdpc3RlcjogeyBba2V5OiBzdHJpbmddOiB7IGxpc3Q6IExpc3RFbGVtZW50OyBzdWI6IFN1YnNjcmlwdGlvbjsgc3BlYzogQXBwbGVSZW1pbmRlclNwZWMgfSB9ID0ge307XG5cblx0c3RhdHVzQmFyOiBIVE1MRWxlbWVudDtcblxuXHRtZXNzYWdlKG1zZzogc3RyaW5nLCBkaXNhcHBlYXJJbj86IG51bWJlcikge1xuXHRcdGlmIChkaXNhcHBlYXJJbikge1xuXHRcdFx0dGhpcy5zdGF0dXNCYXIuc2V0VGV4dChtc2cpXG5cdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0dGhpcy5zdGF0dXNCYXIuc2V0VGV4dChcIlx1RDgzQ1x1REY0RVwiKVxuXHRcdFx0fSwgZGlzYXBwZWFySW4pO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0XHR0aGlzLnN0YXR1c0Jhci5zZXRUZXh0KG1zZylcblx0fVxuXG5cblx0YXN5bmMgb25sb2FkKCkge1xuXHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cblx0XHQvLyBUT0RPOiBDcmVhdGUgUmVtaW5kZXJzIHZpZXcgb24gc2lkZSBwYW5lbCB3aGVuIGNsaWNraW5nIHJpYmJvbiBpY29uXG5cdFx0Ly8gY29uc3QgcmliYm9uSWNvbkVsID0gdGhpcy5hZGRSaWJib25JY29uKCdkaWNlJywgJ1NhbXBsZSBQbHVnaW4nLCAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XG5cdFx0Ly8gQ2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBpY29uLlxuXHRcdC8vIG5ldyBOb3RpY2UoJ1RoaXMgaXMgYSBub3RpY2UhJyk7XG5cdFx0Ly8gfSk7XG5cblx0XHQvLyBUaGlzIGFkZHMgYSBzdGF0dXMgYmFyIGl0ZW0gdG8gdGhlIGJvdHRvbSBvZiB0aGUgYXBwLiBEb2VzIG5vdCB3b3JrIG9uIG1vYmlsZSBhcHBzLlxuXHRcdHRoaXMuc3RhdHVzQmFyID0gdGhpcy5hZGRTdGF0dXNCYXJJdGVtKCk7XG5cdFx0dGhpcy5zdGF0dXNCYXIuc2V0VGV4dCgnTG9hZGluZyBBcHBsZSBSZW1pbmRlcnMuLi4nKTtcblxuXHRcdHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgU2FtcGxlU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xuXG5cdFx0UmVtaW5kZXJzRGF0YVNlcnZpY2Uuc2V0TG9nZ2VyKCh4LCB0aW1lb3V0PzogbnVtYmVyKSA9PiB0aGlzLm1lc3NhZ2UoeCwgdGltZW91dCkpXG5cdFx0UmVtaW5kZXJzRGF0YVNlcnZpY2Uuc2V0U2V0dGluZ3ModGhpcy5zZXR0aW5ncyk7XG5cblx0XHR0aGlzLnJlZ2lzdGVyTWFya2Rvd25Db2RlQmxvY2tQcm9jZXNzb3IoJ2FwcGxlLXJlbWluZGVycycsIChzcmMsIGVsLCBjdHgpID0+IHtcblx0XHRcdGNvbnN0IHNwZWMgPSBwYXJzZShzcmMudHJpbSgpKTtcblx0XHRcdGlmKCFzcGVjW1wibGlzdFwiXSkge1xuXHRcdFx0XHRuZXcgTm90aWNlKFwiWW91IGNhbm5vdCBoYXZlIGFuIGFwcGxlLXJlbWluZGVycyBibG9jayB3aXRob3V0IGEgbGlzdCBuYW1lIVwiLCAzMDAwKTtcblx0XHRcdFx0ZWwuaW5uZXJIVE1MID0gYFxuXHRcdFx0XHRcdDxwcmU+UGxlYXNlIGFkZCBsaXN0IG5hbWUgdG8gY29udGludWU8L3ByZT5cblx0XHRcdFx0YDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0bGV0IGxFID0gbmV3IExpc3RFbGVtZW50KHNwZWMpO1xuXHRcdFx0bGV0IGZpbGVOYW1lID0gY3R4LnNvdXJjZVBhdGguc3BsaXQoXCJcXFxcXCIpLmxhc3QoKT8uc3BsaXQoXCIvXCIpLmxhc3QoKT8udHJpbSgpLnNwbGl0KFwiLlwiKS5maXJzdCgpO1xuXG5cdFx0XHRsZXQgeCA9IGludGVydmFsKFJlbWluZGVyc0RhdGFTZXJ2aWNlLmdldFNldHRpbmdzKCkuYXV0b1JlZnJlc2hUaW1lICogMTAwMDApLnN1YnNjcmliZSgoKSA9PiB7XG5cdFx0XHRcdFJlbWluZGVyc0RhdGFTZXJ2aWNlLmZldGNoRGF0YShzcGVjLCBmaWxlTmFtZSkudGhlbihcblx0XHRcdFx0XHQoW2xpc3REYXRhLCByZW1pbmRlcnNdKSA9PiB7XG5cdFx0XHRcdFx0XHRsRS5yZW1pbmRlcnMgPSByZW1pbmRlcnM7XG5cdFx0XHRcdFx0XHRsRS5saXN0TWV0YSA9IGxpc3REYXRhO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0KVxuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuZWxlbWVudFJlZ2lzdGVyW3NyYy50cmltKCldID0ge1xuXHRcdFx0XHRsaXN0OiBsRSxcblx0XHRcdFx0c3BlYzogc3BlYyxcblx0XHRcdFx0c3ViOiB4XG5cdFx0XHR9XG5cblx0XHRcdFJlbWluZGVyc0RhdGFTZXJ2aWNlLmZldGNoRGF0YShzcGVjLCBmaWxlTmFtZSkudGhlbigoW2xpc3REYXRhLCByZW1pbmRlcnNdKSA9PiB7XG5cdFx0XHRcdGxFLmxpc3RNZXRhID0gbGlzdERhdGE7XG5cdFx0XHRcdGxFLnJlbWluZGVycyA9IHJlbWluZGVycztcblx0XHRcdH0pXG5cblx0XHRcdGVsLmFwcGVuZENoaWxkKGxFKTtcblx0XHR9KVxuXHR9XG5cblx0b251bmxvYWQoKSB7XG5cdFx0T2JqZWN0LmtleXModGhpcy5lbGVtZW50UmVnaXN0ZXIpLmZvckVhY2goa2V5ID0+IHtcblx0XHRcdHRoaXMuZWxlbWVudFJlZ2lzdGVyW2tleV0uc3ViLnVuc3Vic2NyaWJlKCk7XG5cdFx0fSlcblx0fVxuXG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcblx0XHR0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcblx0fVxuXG5cdGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xuXHR9XG59XG5cblxuIiwgIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuXG5jb25zdCBOT0RFX01PREUgPSBmYWxzZTtcbmNvbnN0IGdsb2JhbCA9IE5PREVfTU9ERSA/IGdsb2JhbFRoaXMgOiB3aW5kb3c7XG5cbi8qKlxuICogV2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIHN1cHBvcnRzIGBhZG9wdGVkU3R5bGVTaGVldHNgLlxuICovXG5leHBvcnQgY29uc3Qgc3VwcG9ydHNBZG9wdGluZ1N0eWxlU2hlZXRzID1cbiAgZ2xvYmFsLlNoYWRvd1Jvb3QgJiZcbiAgKGdsb2JhbC5TaGFkeUNTUyA9PT0gdW5kZWZpbmVkIHx8IGdsb2JhbC5TaGFkeUNTUy5uYXRpdmVTaGFkb3cpICYmXG4gICdhZG9wdGVkU3R5bGVTaGVldHMnIGluIERvY3VtZW50LnByb3RvdHlwZSAmJlxuICAncmVwbGFjZScgaW4gQ1NTU3R5bGVTaGVldC5wcm90b3R5cGU7XG5cbi8qKlxuICogQSBDU1NSZXN1bHQgb3IgbmF0aXZlIENTU1N0eWxlU2hlZXQuXG4gKlxuICogSW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGNvbnN0cnVjdGlibGUgQ1NTIHN0eWxlIHNoZWV0cywgQ1NTU3R5bGVTaGVldFxuICogb2JqZWN0IGNhbiBiZSB1c2VkIGZvciBzdHlsaW5nIGFsb25nIHNpZGUgQ1NTUmVzdWx0IGZyb20gdGhlIGBjc3NgXG4gKiB0ZW1wbGF0ZSB0YWcuXG4gKi9cbmV4cG9ydCB0eXBlIENTU1Jlc3VsdE9yTmF0aXZlID0gQ1NTUmVzdWx0IHwgQ1NTU3R5bGVTaGVldDtcblxuZXhwb3J0IHR5cGUgQ1NTUmVzdWx0QXJyYXkgPSBBcnJheTxDU1NSZXN1bHRPck5hdGl2ZSB8IENTU1Jlc3VsdEFycmF5PjtcblxuLyoqXG4gKiBBIHNpbmdsZSBDU1NSZXN1bHQsIENTU1N0eWxlU2hlZXQsIG9yIGFuIGFycmF5IG9yIG5lc3RlZCBhcnJheXMgb2YgdGhvc2UuXG4gKi9cbmV4cG9ydCB0eXBlIENTU1Jlc3VsdEdyb3VwID0gQ1NTUmVzdWx0T3JOYXRpdmUgfCBDU1NSZXN1bHRBcnJheTtcblxuY29uc3QgY29uc3RydWN0aW9uVG9rZW4gPSBTeW1ib2woKTtcblxuY29uc3QgY3NzVGFnQ2FjaGUgPSBuZXcgV2Vha01hcDxUZW1wbGF0ZVN0cmluZ3NBcnJheSwgQ1NTU3R5bGVTaGVldD4oKTtcblxuLyoqXG4gKiBBIGNvbnRhaW5lciBmb3IgYSBzdHJpbmcgb2YgQ1NTIHRleHQsIHRoYXQgbWF5IGJlIHVzZWQgdG8gY3JlYXRlIGEgQ1NTU3R5bGVTaGVldC5cbiAqXG4gKiBDU1NSZXN1bHQgaXMgdGhlIHJldHVybiB2YWx1ZSBvZiBgY3NzYC10YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbHMgYW5kXG4gKiBgdW5zYWZlQ1NTKClgLiBJbiBvcmRlciB0byBlbnN1cmUgdGhhdCBDU1NSZXN1bHRzIGFyZSBvbmx5IGNyZWF0ZWQgdmlhIHRoZVxuICogYGNzc2AgdGFnIGFuZCBgdW5zYWZlQ1NTKClgLCBDU1NSZXN1bHQgY2Fubm90IGJlIGNvbnN0cnVjdGVkIGRpcmVjdGx5LlxuICovXG5leHBvcnQgY2xhc3MgQ1NTUmVzdWx0IHtcbiAgLy8gVGhpcyBwcm9wZXJ0eSBuZWVkcyB0byByZW1haW4gdW5taW5pZmllZC5cbiAgWydfJGNzc1Jlc3VsdCQnXSA9IHRydWU7XG4gIHJlYWRvbmx5IGNzc1RleHQ6IHN0cmluZztcbiAgcHJpdmF0ZSBfc3R5bGVTaGVldD86IENTU1N0eWxlU2hlZXQ7XG4gIHByaXZhdGUgX3N0cmluZ3M6IFRlbXBsYXRlU3RyaW5nc0FycmF5IHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoXG4gICAgY3NzVGV4dDogc3RyaW5nLFxuICAgIHN0cmluZ3M6IFRlbXBsYXRlU3RyaW5nc0FycmF5IHwgdW5kZWZpbmVkLFxuICAgIHNhZmVUb2tlbjogc3ltYm9sXG4gICkge1xuICAgIGlmIChzYWZlVG9rZW4gIT09IGNvbnN0cnVjdGlvblRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDU1NSZXN1bHQgaXMgbm90IGNvbnN0cnVjdGFibGUuIFVzZSBgdW5zYWZlQ1NTYCBvciBgY3NzYCBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuY3NzVGV4dCA9IGNzc1RleHQ7XG4gICAgdGhpcy5fc3RyaW5ncyA9IHN0cmluZ3M7XG4gIH1cblxuICAvLyBUaGlzIGlzIGEgZ2V0dGVyIHNvIHRoYXQgaXQncyBsYXp5LiBJbiBwcmFjdGljZSwgdGhpcyBtZWFucyBzdHlsZXNoZWV0c1xuICAvLyBhcmUgbm90IGNyZWF0ZWQgdW50aWwgdGhlIGZpcnN0IGVsZW1lbnQgaW5zdGFuY2UgaXMgbWFkZS5cbiAgZ2V0IHN0eWxlU2hlZXQoKTogQ1NTU3R5bGVTaGVldCB8IHVuZGVmaW5lZCB7XG4gICAgLy8gSWYgYHN1cHBvcnRzQWRvcHRpbmdTdHlsZVNoZWV0c2AgaXMgdHJ1ZSB0aGVuIHdlIGFzc3VtZSBDU1NTdHlsZVNoZWV0IGlzXG4gICAgLy8gY29uc3RydWN0YWJsZS5cbiAgICBsZXQgc3R5bGVTaGVldCA9IHRoaXMuX3N0eWxlU2hlZXQ7XG4gICAgY29uc3Qgc3RyaW5ncyA9IHRoaXMuX3N0cmluZ3M7XG4gICAgaWYgKHN1cHBvcnRzQWRvcHRpbmdTdHlsZVNoZWV0cyAmJiBzdHlsZVNoZWV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGNhY2hlYWJsZSA9IHN0cmluZ3MgIT09IHVuZGVmaW5lZCAmJiBzdHJpbmdzLmxlbmd0aCA9PT0gMTtcbiAgICAgIGlmIChjYWNoZWFibGUpIHtcbiAgICAgICAgc3R5bGVTaGVldCA9IGNzc1RhZ0NhY2hlLmdldChzdHJpbmdzKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZVNoZWV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgKHRoaXMuX3N0eWxlU2hlZXQgPSBzdHlsZVNoZWV0ID0gbmV3IENTU1N0eWxlU2hlZXQoKSkucmVwbGFjZVN5bmMoXG4gICAgICAgICAgdGhpcy5jc3NUZXh0XG4gICAgICAgICk7XG4gICAgICAgIGlmIChjYWNoZWFibGUpIHtcbiAgICAgICAgICBjc3NUYWdDYWNoZS5zZXQoc3RyaW5ncywgc3R5bGVTaGVldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlU2hlZXQ7XG4gIH1cblxuICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmNzc1RleHQ7XG4gIH1cbn1cblxudHlwZSBDb25zdHJ1Y3RhYmxlQ1NTUmVzdWx0ID0gQ1NTUmVzdWx0ICYge1xuICBuZXcgKFxuICAgIGNzc1RleHQ6IHN0cmluZyxcbiAgICBzdHJpbmdzOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSB8IHVuZGVmaW5lZCxcbiAgICBzYWZlVG9rZW46IHN5bWJvbFxuICApOiBDU1NSZXN1bHQ7XG59O1xuXG5jb25zdCB0ZXh0RnJvbUNTU1Jlc3VsdCA9ICh2YWx1ZTogQ1NTUmVzdWx0R3JvdXAgfCBudW1iZXIpID0+IHtcbiAgLy8gVGhpcyBwcm9wZXJ0eSBuZWVkcyB0byByZW1haW4gdW5taW5pZmllZC5cbiAgaWYgKCh2YWx1ZSBhcyBDU1NSZXN1bHQpWydfJGNzc1Jlc3VsdCQnXSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiAodmFsdWUgYXMgQ1NTUmVzdWx0KS5jc3NUZXh0O1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFZhbHVlIHBhc3NlZCB0byAnY3NzJyBmdW5jdGlvbiBtdXN0IGJlIGEgJ2NzcycgZnVuY3Rpb24gcmVzdWx0OiBgICtcbiAgICAgICAgYCR7dmFsdWV9LiBVc2UgJ3Vuc2FmZUNTUycgdG8gcGFzcyBub24tbGl0ZXJhbCB2YWx1ZXMsIGJ1dCB0YWtlIGNhcmUgYCArXG4gICAgICAgIGB0byBlbnN1cmUgcGFnZSBzZWN1cml0eS5gXG4gICAgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcmFwIGEgdmFsdWUgZm9yIGludGVycG9sYXRpb24gaW4gYSB7QGxpbmtjb2RlIGNzc30gdGFnZ2VkIHRlbXBsYXRlIGxpdGVyYWwuXG4gKlxuICogVGhpcyBpcyB1bnNhZmUgYmVjYXVzZSB1bnRydXN0ZWQgQ1NTIHRleHQgY2FuIGJlIHVzZWQgdG8gcGhvbmUgaG9tZVxuICogb3IgZXhmaWx0cmF0ZSBkYXRhIHRvIGFuIGF0dGFja2VyIGNvbnRyb2xsZWQgc2l0ZS4gVGFrZSBjYXJlIHRvIG9ubHkgdXNlXG4gKiB0aGlzIHdpdGggdHJ1c3RlZCBpbnB1dC5cbiAqL1xuZXhwb3J0IGNvbnN0IHVuc2FmZUNTUyA9ICh2YWx1ZTogdW5rbm93bikgPT5cbiAgbmV3IChDU1NSZXN1bHQgYXMgQ29uc3RydWN0YWJsZUNTU1Jlc3VsdCkoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogU3RyaW5nKHZhbHVlKSxcbiAgICB1bmRlZmluZWQsXG4gICAgY29uc3RydWN0aW9uVG9rZW5cbiAgKTtcblxuLyoqXG4gKiBBIHRlbXBsYXRlIGxpdGVyYWwgdGFnIHdoaWNoIGNhbiBiZSB1c2VkIHdpdGggTGl0RWxlbWVudCdzXG4gKiB7QGxpbmtjb2RlIExpdEVsZW1lbnQuc3R5bGVzfSBwcm9wZXJ0eSB0byBzZXQgZWxlbWVudCBzdHlsZXMuXG4gKlxuICogRm9yIHNlY3VyaXR5IHJlYXNvbnMsIG9ubHkgbGl0ZXJhbCBzdHJpbmcgdmFsdWVzIGFuZCBudW1iZXIgbWF5IGJlIHVzZWQgaW5cbiAqIGVtYmVkZGVkIGV4cHJlc3Npb25zLiBUbyBpbmNvcnBvcmF0ZSBub24tbGl0ZXJhbCB2YWx1ZXMge0BsaW5rY29kZSB1bnNhZmVDU1N9XG4gKiBtYXkgYmUgdXNlZCBpbnNpZGUgYW4gZXhwcmVzc2lvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGNzcyA9IChcbiAgc3RyaW5nczogVGVtcGxhdGVTdHJpbmdzQXJyYXksXG4gIC4uLnZhbHVlczogKENTU1Jlc3VsdEdyb3VwIHwgbnVtYmVyKVtdXG4pOiBDU1NSZXN1bHQgPT4ge1xuICBjb25zdCBjc3NUZXh0ID1cbiAgICBzdHJpbmdzLmxlbmd0aCA9PT0gMVxuICAgICAgPyBzdHJpbmdzWzBdXG4gICAgICA6IHZhbHVlcy5yZWR1Y2UoXG4gICAgICAgICAgKGFjYywgdiwgaWR4KSA9PiBhY2MgKyB0ZXh0RnJvbUNTU1Jlc3VsdCh2KSArIHN0cmluZ3NbaWR4ICsgMV0sXG4gICAgICAgICAgc3RyaW5nc1swXVxuICAgICAgICApO1xuICByZXR1cm4gbmV3IChDU1NSZXN1bHQgYXMgQ29uc3RydWN0YWJsZUNTU1Jlc3VsdCkoXG4gICAgY3NzVGV4dCxcbiAgICBzdHJpbmdzLFxuICAgIGNvbnN0cnVjdGlvblRva2VuXG4gICk7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIGdpdmVuIHN0eWxlcyB0byBhIGBzaGFkb3dSb290YC4gV2hlbiBTaGFkb3cgRE9NIGlzXG4gKiBhdmFpbGFibGUgYnV0IGBhZG9wdGVkU3R5bGVTaGVldHNgIGlzIG5vdCwgc3R5bGVzIGFyZSBhcHBlbmRlZCB0byB0aGVcbiAqIGBzaGFkb3dSb290YCB0byBbbWltaWMgc3BlYyBiZWhhdmlvcl0oaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9jb25zdHJ1Y3Qtc3R5bGVzaGVldHMvI3VzaW5nLWNvbnN0cnVjdGVkLXN0eWxlc2hlZXRzKS5cbiAqIE5vdGUsIHdoZW4gc2hpbW1pbmcgaXMgdXNlZCwgYW55IHN0eWxlcyB0aGF0IGFyZSBzdWJzZXF1ZW50bHkgcGxhY2VkIGludG9cbiAqIHRoZSBzaGFkb3dSb290IHNob3VsZCBiZSBwbGFjZWQgKmJlZm9yZSogYW55IHNoaW1tZWQgYWRvcHRlZCBzdHlsZXMuIFRoaXNcbiAqIHdpbGwgbWF0Y2ggc3BlYyBiZWhhdmlvciB0aGF0IGdpdmVzIGFkb3B0ZWQgc2hlZXRzIHByZWNlZGVuY2Ugb3ZlciBzdHlsZXMgaW5cbiAqIHNoYWRvd1Jvb3QuXG4gKi9cbmV4cG9ydCBjb25zdCBhZG9wdFN0eWxlcyA9IChcbiAgcmVuZGVyUm9vdDogU2hhZG93Um9vdCxcbiAgc3R5bGVzOiBBcnJheTxDU1NSZXN1bHRPck5hdGl2ZT5cbikgPT4ge1xuICBpZiAoc3VwcG9ydHNBZG9wdGluZ1N0eWxlU2hlZXRzKSB7XG4gICAgKHJlbmRlclJvb3QgYXMgU2hhZG93Um9vdCkuYWRvcHRlZFN0eWxlU2hlZXRzID0gc3R5bGVzLm1hcCgocykgPT5cbiAgICAgIHMgaW5zdGFuY2VvZiBDU1NTdHlsZVNoZWV0ID8gcyA6IHMuc3R5bGVTaGVldCFcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgY29uc3Qgbm9uY2UgPSAoZ2xvYmFsIGFzIGFueSlbJ2xpdE5vbmNlJ107XG4gICAgICBpZiAobm9uY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgbm9uY2UpO1xuICAgICAgfVxuICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSAocyBhcyBDU1NSZXN1bHQpLmNzc1RleHQ7XG4gICAgICByZW5kZXJSb290LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9KTtcbiAgfVxufTtcblxuY29uc3QgY3NzUmVzdWx0RnJvbVN0eWxlU2hlZXQgPSAoc2hlZXQ6IENTU1N0eWxlU2hlZXQpID0+IHtcbiAgbGV0IGNzc1RleHQgPSAnJztcbiAgZm9yIChjb25zdCBydWxlIG9mIHNoZWV0LmNzc1J1bGVzKSB7XG4gICAgY3NzVGV4dCArPSBydWxlLmNzc1RleHQ7XG4gIH1cbiAgcmV0dXJuIHVuc2FmZUNTUyhjc3NUZXh0KTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRDb21wYXRpYmxlU3R5bGUgPVxuICBzdXBwb3J0c0Fkb3B0aW5nU3R5bGVTaGVldHMgfHxcbiAgKE5PREVfTU9ERSAmJiBnbG9iYWwuQ1NTU3R5bGVTaGVldCA9PT0gdW5kZWZpbmVkKVxuICAgID8gKHM6IENTU1Jlc3VsdE9yTmF0aXZlKSA9PiBzXG4gICAgOiAoczogQ1NTUmVzdWx0T3JOYXRpdmUpID0+XG4gICAgICAgIHMgaW5zdGFuY2VvZiBDU1NTdHlsZVNoZWV0ID8gY3NzUmVzdWx0RnJvbVN0eWxlU2hlZXQocykgOiBzO1xuIiwgIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuXG4vKipcbiAqIFVzZSB0aGlzIG1vZHVsZSBpZiB5b3Ugd2FudCB0byBjcmVhdGUgeW91ciBvd24gYmFzZSBjbGFzcyBleHRlbmRpbmdcbiAqIHtAbGluayBSZWFjdGl2ZUVsZW1lbnR9LlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cblxuaW1wb3J0IHtcbiAgZ2V0Q29tcGF0aWJsZVN0eWxlLFxuICBhZG9wdFN0eWxlcyxcbiAgQ1NTUmVzdWx0R3JvdXAsXG4gIENTU1Jlc3VsdE9yTmF0aXZlLFxufSBmcm9tICcuL2Nzcy10YWcuanMnO1xuaW1wb3J0IHR5cGUge1xuICBSZWFjdGl2ZUNvbnRyb2xsZXIsXG4gIFJlYWN0aXZlQ29udHJvbGxlckhvc3QsXG59IGZyb20gJy4vcmVhY3RpdmUtY29udHJvbGxlci5qcyc7XG5cbmV4cG9ydCAqIGZyb20gJy4vY3NzLXRhZy5qcyc7XG5leHBvcnQgdHlwZSB7XG4gIFJlYWN0aXZlQ29udHJvbGxlcixcbiAgUmVhY3RpdmVDb250cm9sbGVySG9zdCxcbn0gZnJvbSAnLi9yZWFjdGl2ZS1jb250cm9sbGVyLmpzJztcblxuY29uc3QgTk9ERV9NT0RFID0gZmFsc2U7XG5jb25zdCBnbG9iYWwgPSBOT0RFX01PREUgPyBnbG9iYWxUaGlzIDogd2luZG93O1xuXG5pZiAoTk9ERV9NT0RFKSB7XG4gIGdsb2JhbC5jdXN0b21FbGVtZW50cyA/Pz0ge1xuICAgIGRlZmluZSgpIHt9LFxuICB9IGFzIHVua25vd24gYXMgQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5O1xufVxuXG5jb25zdCBERVZfTU9ERSA9IHRydWU7XG5cbmxldCByZXF1ZXN0VXBkYXRlVGhlbmFibGU6IChuYW1lOiBzdHJpbmcpID0+IHtcbiAgdGhlbjogKFxuICAgIG9uZnVsZmlsbGVkPzogKHZhbHVlOiBib29sZWFuKSA9PiB2b2lkLFxuICAgIF9vbnJlamVjdGVkPzogKCkgPT4gdm9pZFxuICApID0+IHZvaWQ7XG59O1xuXG5sZXQgaXNzdWVXYXJuaW5nOiAoY29kZTogc3RyaW5nLCB3YXJuaW5nOiBzdHJpbmcpID0+IHZvaWQ7XG5cbmNvbnN0IHRydXN0ZWRUeXBlcyA9IChnbG9iYWwgYXMgdW5rbm93biBhcyB7dHJ1c3RlZFR5cGVzPzoge2VtcHR5U2NyaXB0OiAnJ319KVxuICAudHJ1c3RlZFR5cGVzO1xuXG4vLyBUZW1wb3Jhcnkgd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9jcmJ1Zy5jb20vOTkzMjY4XG4vLyBDdXJyZW50bHksIGFueSBhdHRyaWJ1dGUgc3RhcnRpbmcgd2l0aCBcIm9uXCIgaXMgY29uc2lkZXJlZCB0byBiZSBhXG4vLyBUcnVzdGVkU2NyaXB0IHNvdXJjZS4gU3VjaCBib29sZWFuIGF0dHJpYnV0ZXMgbXVzdCBiZSBzZXQgdG8gdGhlIGVxdWl2YWxlbnRcbi8vIHRydXN0ZWQgZW1wdHlTY3JpcHQgdmFsdWUuXG5jb25zdCBlbXB0eVN0cmluZ0ZvckJvb2xlYW5BdHRyaWJ1dGUgPSB0cnVzdGVkVHlwZXNcbiAgPyAodHJ1c3RlZFR5cGVzLmVtcHR5U2NyaXB0IGFzIHVua25vd24gYXMgJycpXG4gIDogJyc7XG5cbmNvbnN0IHBvbHlmaWxsU3VwcG9ydCA9IERFVl9NT0RFXG4gID8gZ2xvYmFsLnJlYWN0aXZlRWxlbWVudFBvbHlmaWxsU3VwcG9ydERldk1vZGVcbiAgOiBnbG9iYWwucmVhY3RpdmVFbGVtZW50UG9seWZpbGxTdXBwb3J0O1xuXG5pZiAoREVWX01PREUpIHtcbiAgLy8gRW5zdXJlIHdhcm5pbmdzIGFyZSBpc3N1ZWQgb25seSAxeCwgZXZlbiBpZiBtdWx0aXBsZSB2ZXJzaW9ucyBvZiBMaXRcbiAgLy8gYXJlIGxvYWRlZC5cbiAgY29uc3QgaXNzdWVkV2FybmluZ3M6IFNldDxzdHJpbmcgfCB1bmRlZmluZWQ+ID0gKGdsb2JhbC5saXRJc3N1ZWRXYXJuaW5ncyA/Pz1cbiAgICBuZXcgU2V0KCkpO1xuXG4gIC8vIElzc3VlIGEgd2FybmluZywgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5LlxuICBpc3N1ZVdhcm5pbmcgPSAoY29kZTogc3RyaW5nLCB3YXJuaW5nOiBzdHJpbmcpID0+IHtcbiAgICB3YXJuaW5nICs9IGAgU2VlIGh0dHBzOi8vbGl0LmRldi9tc2cvJHtjb2RlfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gO1xuICAgIGlmICghaXNzdWVkV2FybmluZ3MuaGFzKHdhcm5pbmcpKSB7XG4gICAgICBjb25zb2xlLndhcm4od2FybmluZyk7XG4gICAgICBpc3N1ZWRXYXJuaW5ncy5hZGQod2FybmluZyk7XG4gICAgfVxuICB9O1xuXG4gIGlzc3VlV2FybmluZyhcbiAgICAnZGV2LW1vZGUnLFxuICAgIGBMaXQgaXMgaW4gZGV2IG1vZGUuIE5vdCByZWNvbW1lbmRlZCBmb3IgcHJvZHVjdGlvbiFgXG4gICk7XG5cbiAgLy8gSXNzdWUgcG9seWZpbGwgc3VwcG9ydCB3YXJuaW5nLlxuICBpZiAoZ2xvYmFsLlNoYWR5RE9NPy5pblVzZSAmJiBwb2x5ZmlsbFN1cHBvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIGlzc3VlV2FybmluZyhcbiAgICAgICdwb2x5ZmlsbC1zdXBwb3J0LW1pc3NpbmcnLFxuICAgICAgYFNoYWRvdyBET00gaXMgYmVpbmcgcG9seWZpbGxlZCB2aWEgXFxgU2hhZHlET01cXGAgYnV0IGAgK1xuICAgICAgICBgdGhlIFxcYHBvbHlmaWxsLXN1cHBvcnRcXGAgbW9kdWxlIGhhcyBub3QgYmVlbiBsb2FkZWQuYFxuICAgICk7XG4gIH1cblxuICByZXF1ZXN0VXBkYXRlVGhlbmFibGUgPSAobmFtZSkgPT4gKHtcbiAgICB0aGVuOiAoXG4gICAgICBvbmZ1bGZpbGxlZD86ICh2YWx1ZTogYm9vbGVhbikgPT4gdm9pZCxcbiAgICAgIF9vbnJlamVjdGVkPzogKCkgPT4gdm9pZFxuICAgICkgPT4ge1xuICAgICAgaXNzdWVXYXJuaW5nKFxuICAgICAgICAncmVxdWVzdC11cGRhdGUtcHJvbWlzZScsXG4gICAgICAgIGBUaGUgXFxgcmVxdWVzdFVwZGF0ZVxcYCBtZXRob2Qgc2hvdWxkIG5vIGxvbmdlciByZXR1cm4gYSBQcm9taXNlIGJ1dCBgICtcbiAgICAgICAgICBgZG9lcyBzbyBvbiBcXGAke25hbWV9XFxgLiBVc2UgXFxgdXBkYXRlQ29tcGxldGVcXGAgaW5zdGVhZC5gXG4gICAgICApO1xuICAgICAgaWYgKG9uZnVsZmlsbGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb25mdWxmaWxsZWQoZmFsc2UpO1xuICAgICAgfVxuICAgIH0sXG4gIH0pO1xufVxuXG4vKipcbiAqIENvbnRhaW5zIHR5cGVzIHRoYXQgYXJlIHBhcnQgb2YgdGhlIHVuc3RhYmxlIGRlYnVnIEFQSS5cbiAqXG4gKiBFdmVyeXRoaW5nIGluIHRoaXMgQVBJIGlzIG5vdCBzdGFibGUgYW5kIG1heSBjaGFuZ2Ugb3IgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLFxuICogZXZlbiBvbiBwYXRjaCByZWxlYXNlcy5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1uYW1lc3BhY2VcbmV4cG9ydCBuYW1lc3BhY2UgUmVhY3RpdmVVbnN0YWJsZSB7XG4gIC8qKlxuICAgKiBXaGVuIExpdCBpcyBydW5uaW5nIGluIGRldiBtb2RlIGFuZCBgd2luZG93LmVtaXRMaXREZWJ1Z0xvZ0V2ZW50c2AgaXMgdHJ1ZSxcbiAgICogd2Ugd2lsbCBlbWl0ICdsaXQtZGVidWcnIGV2ZW50cyB0byB3aW5kb3csIHdpdGggbGl2ZSBkZXRhaWxzIGFib3V0IHRoZSB1cGRhdGUgYW5kIHJlbmRlclxuICAgKiBsaWZlY3ljbGUuIFRoZXNlIGNhbiBiZSB1c2VmdWwgZm9yIHdyaXRpbmcgZGVidWcgdG9vbGluZyBhbmQgdmlzdWFsaXphdGlvbnMuXG4gICAqXG4gICAqIFBsZWFzZSBiZSBhd2FyZSB0aGF0IHJ1bm5pbmcgd2l0aCB3aW5kb3cuZW1pdExpdERlYnVnTG9nRXZlbnRzIGhhcyBwZXJmb3JtYW5jZSBvdmVyaGVhZCxcbiAgICogbWFraW5nIGNlcnRhaW4gb3BlcmF0aW9ucyB0aGF0IGFyZSBub3JtYWxseSB2ZXJ5IGNoZWFwIChsaWtlIGEgbm8tb3AgcmVuZGVyKSBtdWNoIHNsb3dlcixcbiAgICogYmVjYXVzZSB3ZSBtdXN0IGNvcHkgZGF0YSBhbmQgZGlzcGF0Y2ggZXZlbnRzLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1uYW1lc3BhY2VcbiAgZXhwb3J0IG5hbWVzcGFjZSBEZWJ1Z0xvZyB7XG4gICAgZXhwb3J0IHR5cGUgRW50cnkgPSBVcGRhdGU7XG4gICAgZXhwb3J0IGludGVyZmFjZSBVcGRhdGUge1xuICAgICAga2luZDogJ3VwZGF0ZSc7XG4gICAgfVxuICB9XG59XG5cbmludGVyZmFjZSBEZWJ1Z0xvZ2dpbmdXaW5kb3cge1xuICAvLyBFdmVuIGluIGRldiBtb2RlLCB3ZSBnZW5lcmFsbHkgZG9uJ3Qgd2FudCB0byBlbWl0IHRoZXNlIGV2ZW50cywgYXMgdGhhdCdzXG4gIC8vIGFub3RoZXIgbGV2ZWwgb2YgY29zdCwgc28gb25seSBlbWl0IHRoZW0gd2hlbiBERVZfTU9ERSBpcyB0cnVlIF9hbmRfIHdoZW5cbiAgLy8gd2luZG93LmVtaXRMaXREZWJ1Z0V2ZW50cyBpcyB0cnVlLlxuICBlbWl0TGl0RGVidWdMb2dFdmVudHM/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFVzZWZ1bCBmb3IgdmlzdWFsaXppbmcgYW5kIGxvZ2dpbmcgaW5zaWdodHMgaW50byB3aGF0IHRoZSBMaXQgdGVtcGxhdGUgc3lzdGVtIGlzIGRvaW5nLlxuICpcbiAqIENvbXBpbGVkIG91dCBvZiBwcm9kIG1vZGUgYnVpbGRzLlxuICovXG5jb25zdCBkZWJ1Z0xvZ0V2ZW50ID0gREVWX01PREVcbiAgPyAoZXZlbnQ6IFJlYWN0aXZlVW5zdGFibGUuRGVidWdMb2cuRW50cnkpID0+IHtcbiAgICAgIGNvbnN0IHNob3VsZEVtaXQgPSAoZ2xvYmFsIGFzIHVua25vd24gYXMgRGVidWdMb2dnaW5nV2luZG93KVxuICAgICAgICAuZW1pdExpdERlYnVnTG9nRXZlbnRzO1xuICAgICAgaWYgKCFzaG91bGRFbWl0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGdsb2JhbC5kaXNwYXRjaEV2ZW50KFxuICAgICAgICBuZXcgQ3VzdG9tRXZlbnQ8UmVhY3RpdmVVbnN0YWJsZS5EZWJ1Z0xvZy5FbnRyeT4oJ2xpdC1kZWJ1ZycsIHtcbiAgICAgICAgICBkZXRhaWw6IGV2ZW50LFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIDogdW5kZWZpbmVkO1xuXG4vKlxuICogV2hlbiB1c2luZyBDbG9zdXJlIENvbXBpbGVyLCBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KHByb3BlcnR5LCBvYmplY3QpIGlzXG4gKiByZXBsYWNlZCBhdCBjb21waWxlIHRpbWUgYnkgdGhlIG11bmdlZCBuYW1lIGZvciBvYmplY3RbcHJvcGVydHldLiBXZSBjYW5ub3RcbiAqIGFsaWFzIHRoaXMgZnVuY3Rpb24sIHNvIHdlIGhhdmUgdG8gdXNlIGEgc21hbGwgc2hpbSB0aGF0IGhhcyB0aGUgc2FtZVxuICogYmVoYXZpb3Igd2hlbiBub3QgY29tcGlsaW5nLlxuICovXG4vKkBfX0lOTElORV9fKi9cbmNvbnN0IEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkgPSA8UCBleHRlbmRzIFByb3BlcnR5S2V5PihcbiAgcHJvcDogUCxcbiAgX29iajogdW5rbm93blxuKTogUCA9PiBwcm9wO1xuXG4vKipcbiAqIENvbnZlcnRzIHByb3BlcnR5IHZhbHVlcyB0byBhbmQgZnJvbSBhdHRyaWJ1dGUgdmFsdWVzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXhBdHRyaWJ1dGVDb252ZXJ0ZXI8VHlwZSA9IHVua25vd24sIFR5cGVIaW50ID0gdW5rbm93bj4ge1xuICAvKipcbiAgICogQ2FsbGVkIHRvIGNvbnZlcnQgYW4gYXR0cmlidXRlIHZhbHVlIHRvIGEgcHJvcGVydHlcbiAgICogdmFsdWUuXG4gICAqL1xuICBmcm9tQXR0cmlidXRlPyh2YWx1ZTogc3RyaW5nIHwgbnVsbCwgdHlwZT86IFR5cGVIaW50KTogVHlwZTtcblxuICAvKipcbiAgICogQ2FsbGVkIHRvIGNvbnZlcnQgYSBwcm9wZXJ0eSB2YWx1ZSB0byBhbiBhdHRyaWJ1dGVcbiAgICogdmFsdWUuXG4gICAqXG4gICAqIEl0IHJldHVybnMgdW5rbm93biBpbnN0ZWFkIG9mIHN0cmluZywgdG8gYmUgY29tcGF0aWJsZSB3aXRoXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL3RydXN0ZWQtdHlwZXMgKGFuZCBzaW1pbGFyIGVmZm9ydHMpLlxuICAgKi9cbiAgdG9BdHRyaWJ1dGU/KHZhbHVlOiBUeXBlLCB0eXBlPzogVHlwZUhpbnQpOiB1bmtub3duO1xufVxuXG50eXBlIEF0dHJpYnV0ZUNvbnZlcnRlcjxUeXBlID0gdW5rbm93biwgVHlwZUhpbnQgPSB1bmtub3duPiA9XG4gIHwgQ29tcGxleEF0dHJpYnV0ZUNvbnZlcnRlcjxUeXBlPlxuICB8ICgodmFsdWU6IHN0cmluZyB8IG51bGwsIHR5cGU/OiBUeXBlSGludCkgPT4gVHlwZSk7XG5cbi8qKlxuICogRGVmaW5lcyBvcHRpb25zIGZvciBhIHByb3BlcnR5IGFjY2Vzc29yLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb3BlcnR5RGVjbGFyYXRpb248VHlwZSA9IHVua25vd24sIFR5cGVIaW50ID0gdW5rbm93bj4ge1xuICAvKipcbiAgICogV2hlbiBzZXQgdG8gYHRydWVgLCBpbmRpY2F0ZXMgdGhlIHByb3BlcnR5IGlzIGludGVybmFsIHByaXZhdGUgc3RhdGUuIFRoZVxuICAgKiBwcm9wZXJ0eSBzaG91bGQgbm90IGJlIHNldCBieSB1c2Vycy4gV2hlbiB1c2luZyBUeXBlU2NyaXB0LCB0aGlzIHByb3BlcnR5XG4gICAqIHNob3VsZCBiZSBtYXJrZWQgYXMgYHByaXZhdGVgIG9yIGBwcm90ZWN0ZWRgLCBhbmQgaXQgaXMgYWxzbyBhIGNvbW1vblxuICAgKiBwcmFjdGljZSB0byB1c2UgYSBsZWFkaW5nIGBfYCBpbiB0aGUgbmFtZS4gVGhlIHByb3BlcnR5IGlzIG5vdCBhZGRlZCB0b1xuICAgKiBgb2JzZXJ2ZWRBdHRyaWJ1dGVzYC5cbiAgICovXG4gIHJlYWRvbmx5IHN0YXRlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSW5kaWNhdGVzIGhvdyBhbmQgd2hldGhlciB0aGUgcHJvcGVydHkgYmVjb21lcyBhbiBvYnNlcnZlZCBhdHRyaWJ1dGUuXG4gICAqIElmIHRoZSB2YWx1ZSBpcyBgZmFsc2VgLCB0aGUgcHJvcGVydHkgaXMgbm90IGFkZGVkIHRvIGBvYnNlcnZlZEF0dHJpYnV0ZXNgLlxuICAgKiBJZiB0cnVlIG9yIGFic2VudCwgdGhlIGxvd2VyY2FzZWQgcHJvcGVydHkgbmFtZSBpcyBvYnNlcnZlZCAoZS5nLiBgZm9vQmFyYFxuICAgKiBiZWNvbWVzIGBmb29iYXJgKS4gSWYgYSBzdHJpbmcsIHRoZSBzdHJpbmcgdmFsdWUgaXMgb2JzZXJ2ZWQgKGUuZ1xuICAgKiBgYXR0cmlidXRlOiAnZm9vLWJhcidgKS5cbiAgICovXG4gIHJlYWRvbmx5IGF0dHJpYnV0ZT86IGJvb2xlYW4gfCBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGUgdHlwZSBvZiB0aGUgcHJvcGVydHkuIFRoaXMgaXMgdXNlZCBvbmx5IGFzIGEgaGludCBmb3IgdGhlXG4gICAqIGBjb252ZXJ0ZXJgIHRvIGRldGVybWluZSBob3cgdG8gY29udmVydCB0aGUgYXR0cmlidXRlXG4gICAqIHRvL2Zyb20gYSBwcm9wZXJ0eS5cbiAgICovXG4gIHJlYWRvbmx5IHR5cGU/OiBUeXBlSGludDtcblxuICAvKipcbiAgICogSW5kaWNhdGVzIGhvdyB0byBjb252ZXJ0IHRoZSBhdHRyaWJ1dGUgdG8vZnJvbSBhIHByb3BlcnR5LiBJZiB0aGlzIHZhbHVlXG4gICAqIGlzIGEgZnVuY3Rpb24sIGl0IGlzIHVzZWQgdG8gY29udmVydCB0aGUgYXR0cmlidXRlIHZhbHVlIGEgdGhlIHByb3BlcnR5XG4gICAqIHZhbHVlLiBJZiBpdCdzIGFuIG9iamVjdCwgaXQgY2FuIGhhdmUga2V5cyBmb3IgYGZyb21BdHRyaWJ1dGVgIGFuZFxuICAgKiBgdG9BdHRyaWJ1dGVgLiBJZiBubyBgdG9BdHRyaWJ1dGVgIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIGFuZFxuICAgKiBgcmVmbGVjdGAgaXMgc2V0IHRvIGB0cnVlYCwgdGhlIHByb3BlcnR5IHZhbHVlIGlzIHNldCBkaXJlY3RseSB0byB0aGVcbiAgICogYXR0cmlidXRlLiBBIGRlZmF1bHQgYGNvbnZlcnRlcmAgaXMgdXNlZCBpZiBub25lIGlzIHByb3ZpZGVkOyBpdCBzdXBwb3J0c1xuICAgKiBgQm9vbGVhbmAsIGBTdHJpbmdgLCBgTnVtYmVyYCwgYE9iamVjdGAsIGFuZCBgQXJyYXlgLiBOb3RlLFxuICAgKiB3aGVuIGEgcHJvcGVydHkgY2hhbmdlcyBhbmQgdGhlIGNvbnZlcnRlciBpcyB1c2VkIHRvIHVwZGF0ZSB0aGUgYXR0cmlidXRlLFxuICAgKiB0aGUgcHJvcGVydHkgaXMgbmV2ZXIgdXBkYXRlZCBhZ2FpbiBhcyBhIHJlc3VsdCBvZiB0aGUgYXR0cmlidXRlIGNoYW5naW5nLFxuICAgKiBhbmQgdmljZSB2ZXJzYS5cbiAgICovXG4gIHJlYWRvbmx5IGNvbnZlcnRlcj86IEF0dHJpYnV0ZUNvbnZlcnRlcjxUeXBlLCBUeXBlSGludD47XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgcHJvcGVydHkgc2hvdWxkIHJlZmxlY3QgdG8gYW4gYXR0cmlidXRlLlxuICAgKiBJZiBgdHJ1ZWAsIHdoZW4gdGhlIHByb3BlcnR5IGlzIHNldCwgdGhlIGF0dHJpYnV0ZSBpcyBzZXQgdXNpbmcgdGhlXG4gICAqIGF0dHJpYnV0ZSBuYW1lIGRldGVybWluZWQgYWNjb3JkaW5nIHRvIHRoZSBydWxlcyBmb3IgdGhlIGBhdHRyaWJ1dGVgXG4gICAqIHByb3BlcnR5IG9wdGlvbiBhbmQgdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBjb252ZXJ0ZWQgdXNpbmcgdGhlIHJ1bGVzXG4gICAqIGZyb20gdGhlIGBjb252ZXJ0ZXJgIHByb3BlcnR5IG9wdGlvbi5cbiAgICovXG4gIHJlYWRvbmx5IHJlZmxlY3Q/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgaW5kaWNhdGVzIGlmIGEgcHJvcGVydHkgc2hvdWxkIGJlIGNvbnNpZGVyZWQgY2hhbmdlZCB3aGVuXG4gICAqIGl0IGlzIHNldC4gVGhlIGZ1bmN0aW9uIHNob3VsZCB0YWtlIHRoZSBgbmV3VmFsdWVgIGFuZCBgb2xkVmFsdWVgIGFuZFxuICAgKiByZXR1cm4gYHRydWVgIGlmIGFuIHVwZGF0ZSBzaG91bGQgYmUgcmVxdWVzdGVkLlxuICAgKi9cbiAgaGFzQ2hhbmdlZD8odmFsdWU6IFR5cGUsIG9sZFZhbHVlOiBUeXBlKTogYm9vbGVhbjtcblxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgYW4gYWNjZXNzb3Igd2lsbCBiZSBjcmVhdGVkIGZvciB0aGlzIHByb3BlcnR5LiBCeVxuICAgKiBkZWZhdWx0LCBhbiBhY2Nlc3NvciB3aWxsIGJlIGdlbmVyYXRlZCBmb3IgdGhpcyBwcm9wZXJ0eSB0aGF0IHJlcXVlc3RzIGFuXG4gICAqIHVwZGF0ZSB3aGVuIHNldC4gSWYgdGhpcyBmbGFnIGlzIGB0cnVlYCwgbm8gYWNjZXNzb3Igd2lsbCBiZSBjcmVhdGVkLCBhbmRcbiAgICogaXQgd2lsbCBiZSB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRvIGNhbGxcbiAgICogYHRoaXMucmVxdWVzdFVwZGF0ZShwcm9wZXJ0eU5hbWUsIG9sZFZhbHVlKWAgdG8gcmVxdWVzdCBhbiB1cGRhdGUgd2hlblxuICAgKiB0aGUgcHJvcGVydHkgY2hhbmdlcy5cbiAgICovXG4gIHJlYWRvbmx5IG5vQWNjZXNzb3I/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIE1hcCBvZiBwcm9wZXJ0aWVzIHRvIFByb3BlcnR5RGVjbGFyYXRpb24gb3B0aW9ucy4gRm9yIGVhY2ggcHJvcGVydHkgYW5cbiAqIGFjY2Vzc29yIGlzIG1hZGUsIGFuZCB0aGUgcHJvcGVydHkgaXMgcHJvY2Vzc2VkIGFjY29yZGluZyB0byB0aGVcbiAqIFByb3BlcnR5RGVjbGFyYXRpb24gb3B0aW9ucy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm9wZXJ0eURlY2xhcmF0aW9ucyB7XG4gIHJlYWRvbmx5IFtrZXk6IHN0cmluZ106IFByb3BlcnR5RGVjbGFyYXRpb247XG59XG5cbnR5cGUgUHJvcGVydHlEZWNsYXJhdGlvbk1hcCA9IE1hcDxQcm9wZXJ0eUtleSwgUHJvcGVydHlEZWNsYXJhdGlvbj47XG5cbnR5cGUgQXR0cmlidXRlTWFwID0gTWFwPHN0cmluZywgUHJvcGVydHlLZXk+O1xuXG4vKipcbiAqIEEgTWFwIG9mIHByb3BlcnR5IGtleXMgdG8gdmFsdWVzLlxuICpcbiAqIFRha2VzIGFuIG9wdGlvbmFsIHR5cGUgcGFyYW1ldGVyIFQsIHdoaWNoIHdoZW4gc3BlY2lmaWVkIGFzIGEgbm9uLWFueSxcbiAqIG5vbi11bmtub3duIHR5cGUsIHdpbGwgbWFrZSB0aGUgTWFwIG1vcmUgc3Ryb25nbHktdHlwZWQsIGFzc29jaWF0aW5nIHRoZSBtYXBcbiAqIGtleXMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nIHZhbHVlIHR5cGUgb24gVC5cbiAqXG4gKiBVc2UgYFByb3BlcnR5VmFsdWVzPHRoaXM+YCB3aGVuIG92ZXJyaWRpbmcgUmVhY3RpdmVFbGVtZW50LnVwZGF0ZSgpIGFuZFxuICogb3RoZXIgbGlmZWN5Y2xlIG1ldGhvZHMgaW4gb3JkZXIgdG8gZ2V0IHN0cm9uZ2VyIHR5cGUtY2hlY2tpbmcgb24ga2V5c1xuICogYW5kIHZhbHVlcy5cbiAqL1xuLy8gVGhpcyB0eXBlIGlzIGNvbmRpdGlvbmFsIHNvIHRoYXQgaWYgdGhlIHBhcmFtZXRlciBUIGlzIG5vdCBzcGVjaWZpZWQsIG9yXG4vLyBpcyBgYW55YCwgdGhlIHR5cGUgd2lsbCBpbmNsdWRlIGBNYXA8UHJvcGVydHlLZXksIHVua25vd24+YC4gU2luY2UgVCBpcyBub3Rcbi8vIGdpdmVuIGluIHRoZSB1c2VzIG9mIFByb3BlcnR5VmFsdWVzIGluIHRoaXMgZmlsZSwgYWxsIHVzZXMgaGVyZSBmYWxsYmFjayB0b1xuLy8gbWVhbmluZyBgTWFwPFByb3BlcnR5S2V5LCB1bmtub3duPmAsIGJ1dCBpZiBhIGRldmVsb3BlciB1c2VzXG4vLyBgUHJvcGVydHlWYWx1ZXM8dGhpcz5gIChvciBhbnkgb3RoZXIgdmFsdWUgZm9yIFQpIHRoZXkgd2lsbCBnZXQgYVxuLy8gc3Ryb25nbHktdHlwZWQgTWFwIHR5cGUuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IHR5cGUgUHJvcGVydHlWYWx1ZXM8VCA9IGFueT4gPSBUIGV4dGVuZHMgb2JqZWN0XG4gID8gUHJvcGVydHlWYWx1ZU1hcDxUPlxuICA6IE1hcDxQcm9wZXJ0eUtleSwgdW5rbm93bj47XG5cbi8qKlxuICogRG8gbm90IHVzZSwgaW5zdGVhZCBwcmVmZXIge0BsaW5rY29kZSBQcm9wZXJ0eVZhbHVlc30uXG4gKi9cbi8vIFRoaXMgdHlwZSBtdXN0IGJlIGV4cG9ydGVkIHN1Y2ggdGhhdCBKYXZhU2NyaXB0IGdlbmVyYXRlZCBieSB0aGUgR29vZ2xlXG4vLyBDbG9zdXJlIENvbXBpbGVyIGNhbiBpbXBvcnQgYSB0eXBlIHJlZmVyZW5jZS5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcGVydHlWYWx1ZU1hcDxUPiBleHRlbmRzIE1hcDxQcm9wZXJ0eUtleSwgdW5rbm93bj4ge1xuICBnZXQ8SyBleHRlbmRzIGtleW9mIFQ+KGs6IEspOiBUW0tdO1xuICBzZXQ8SyBleHRlbmRzIGtleW9mIFQ+KGtleTogSywgdmFsdWU6IFRbS10pOiB0aGlzO1xuICBoYXM8SyBleHRlbmRzIGtleW9mIFQ+KGs6IEspOiBib29sZWFuO1xuICBkZWxldGU8SyBleHRlbmRzIGtleW9mIFQ+KGs6IEspOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgZGVmYXVsdENvbnZlcnRlcjogQ29tcGxleEF0dHJpYnV0ZUNvbnZlcnRlciA9IHtcbiAgdG9BdHRyaWJ1dGUodmFsdWU6IHVua25vd24sIHR5cGU/OiB1bmtub3duKTogdW5rbm93biB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEJvb2xlYW46XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPyBlbXB0eVN0cmluZ0ZvckJvb2xlYW5BdHRyaWJ1dGUgOiBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgY2FzZSBBcnJheTpcbiAgICAgICAgLy8gaWYgdGhlIHZhbHVlIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYCBwYXNzIHRoaXMgdGhyb3VnaFxuICAgICAgICAvLyB0byBhbGxvdyByZW1vdmluZy9ubyBjaGFuZ2UgYmVoYXZpb3IuXG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT0gbnVsbCA/IHZhbHVlIDogSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuXG4gIGZyb21BdHRyaWJ1dGUodmFsdWU6IHN0cmluZyB8IG51bGwsIHR5cGU/OiB1bmtub3duKSB7XG4gICAgbGV0IGZyb21WYWx1ZTogdW5rbm93biA9IHZhbHVlO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgICBmcm9tVmFsdWUgPSB2YWx1ZSAhPT0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgZnJvbVZhbHVlID0gdmFsdWUgPT09IG51bGwgPyBudWxsIDogTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE9iamVjdDpcbiAgICAgIGNhc2UgQXJyYXk6XG4gICAgICAgIC8vIERvICpub3QqIGdlbmVyYXRlIGV4Y2VwdGlvbiB3aGVuIGludmFsaWQgSlNPTiBpcyBzZXQgYXMgZWxlbWVudHNcbiAgICAgICAgLy8gZG9uJ3Qgbm9ybWFsbHkgY29tcGxhaW4gb24gYmVpbmcgbWlzLWNvbmZpZ3VyZWQuXG4gICAgICAgIC8vIFRPRE8oc29ydmVsbCk6IERvIGdlbmVyYXRlIGV4Y2VwdGlvbiBpbiAqZGV2IG1vZGUqLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEFzc2VydCB0byBhZGhlcmUgdG8gQmF6ZWwncyBcIm11c3QgdHlwZSBhc3NlcnQgSlNPTiBwYXJzZVwiIHJ1bGUuXG4gICAgICAgICAgZnJvbVZhbHVlID0gSlNPTi5wYXJzZSh2YWx1ZSEpIGFzIHVua25vd247XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBmcm9tVmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbVZhbHVlO1xuICB9LFxufTtcblxuZXhwb3J0IGludGVyZmFjZSBIYXNDaGFuZ2VkIHtcbiAgKHZhbHVlOiB1bmtub3duLCBvbGQ6IHVua25vd24pOiBib29sZWFuO1xufVxuXG4vKipcbiAqIENoYW5nZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGRpZmZlcmVudCBmcm9tIGBvbGRWYWx1ZWAuXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGFzIHRoZSBkZWZhdWx0IGZvciBhIHByb3BlcnR5J3MgYGhhc0NoYW5nZWRgIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgY29uc3Qgbm90RXF1YWw6IEhhc0NoYW5nZWQgPSAodmFsdWU6IHVua25vd24sIG9sZDogdW5rbm93bik6IGJvb2xlYW4gPT4ge1xuICAvLyBUaGlzIGVuc3VyZXMgKG9sZD09TmFOLCB2YWx1ZT09TmFOKSBhbHdheXMgcmV0dXJucyBmYWxzZVxuICByZXR1cm4gb2xkICE9PSB2YWx1ZSAmJiAob2xkID09PSBvbGQgfHwgdmFsdWUgPT09IHZhbHVlKTtcbn07XG5cbmNvbnN0IGRlZmF1bHRQcm9wZXJ0eURlY2xhcmF0aW9uOiBQcm9wZXJ0eURlY2xhcmF0aW9uID0ge1xuICBhdHRyaWJ1dGU6IHRydWUsXG4gIHR5cGU6IFN0cmluZyxcbiAgY29udmVydGVyOiBkZWZhdWx0Q29udmVydGVyLFxuICByZWZsZWN0OiBmYWxzZSxcbiAgaGFzQ2hhbmdlZDogbm90RXF1YWwsXG59O1xuXG4vKipcbiAqIFRoZSBDbG9zdXJlIEpTIENvbXBpbGVyIGRvZXNuJ3QgY3VycmVudGx5IGhhdmUgZ29vZCBzdXBwb3J0IGZvciBzdGF0aWNcbiAqIHByb3BlcnR5IHNlbWFudGljcyB3aGVyZSBcInRoaXNcIiBpcyBkeW5hbWljIChlLmcuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtY29tcGlsZXIvaXNzdWVzLzMxNzcgYW5kIG90aGVycykgc28gd2UgdXNlXG4gKiB0aGlzIGhhY2sgdG8gYnlwYXNzIGFueSByZXdyaXRpbmcgYnkgdGhlIGNvbXBpbGVyLlxuICovXG5jb25zdCBmaW5hbGl6ZWQgPSAnZmluYWxpemVkJztcblxuLyoqXG4gKiBBIHN0cmluZyByZXByZXNlbnRpbmcgb25lIG9mIHRoZSBzdXBwb3J0ZWQgZGV2IG1vZGUgd2FybmluZyBjYXRlZ29yaWVzLlxuICovXG5leHBvcnQgdHlwZSBXYXJuaW5nS2luZCA9ICdjaGFuZ2UtaW4tdXBkYXRlJyB8ICdtaWdyYXRpb24nO1xuXG5leHBvcnQgdHlwZSBJbml0aWFsaXplciA9IChlbGVtZW50OiBSZWFjdGl2ZUVsZW1lbnQpID0+IHZvaWQ7XG5cbmNvbnN0IGh0bWxFbGVtZW50U2hpbU5lZWRlZCA9IE5PREVfTU9ERSAmJiBnbG9iYWwuSFRNTEVsZW1lbnQgPT09IHVuZGVmaW5lZDtcbmlmIChodG1sRWxlbWVudFNoaW1OZWVkZWQpIHtcbiAgZ2xvYmFsLkhUTUxFbGVtZW50ID0gY2xhc3MgSFRNTEVsZW1lbnQge30gYXMgdW5rbm93biBhcyB0eXBlb2YgSFRNTEVsZW1lbnQ7XG59XG5cbi8qKlxuICogQmFzZSBlbGVtZW50IGNsYXNzIHdoaWNoIG1hbmFnZXMgZWxlbWVudCBwcm9wZXJ0aWVzIGFuZCBhdHRyaWJ1dGVzLiBXaGVuXG4gKiBwcm9wZXJ0aWVzIGNoYW5nZSwgdGhlIGB1cGRhdGVgIG1ldGhvZCBpcyBhc3luY2hyb25vdXNseSBjYWxsZWQuIFRoaXMgbWV0aG9kXG4gKiBzaG91bGQgYmUgc3VwcGxpZWQgYnkgc3ViY2xhc3NlcnMgdG8gcmVuZGVyIHVwZGF0ZXMgYXMgZGVzaXJlZC5cbiAqIEBub0luaGVyaXREb2NcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJlYWN0aXZlRWxlbWVudFxuICBleHRlbmRzIEhUTUxFbGVtZW50XG4gIGltcGxlbWVudHMgUmVhY3RpdmVDb250cm9sbGVySG9zdFxue1xuICAvLyBOb3RlOiB0aGVzZSBhcmUgcGF0Y2hlZCBpbiBvbmx5IGluIERFVl9NT0RFLlxuICAvKipcbiAgICogUmVhZCBvciBzZXQgYWxsIHRoZSBlbmFibGVkIHdhcm5pbmcgY2F0ZWdvcmllcyBmb3IgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogVGhpcyBwcm9wZXJ0eSBpcyBvbmx5IHVzZWQgaW4gZGV2ZWxvcG1lbnQgYnVpbGRzLlxuICAgKlxuICAgKiBAbm9jb2xsYXBzZVxuICAgKiBAY2F0ZWdvcnkgZGV2LW1vZGVcbiAgICovXG4gIHN0YXRpYyBlbmFibGVkV2FybmluZ3M/OiBXYXJuaW5nS2luZFtdO1xuXG4gIC8qKlxuICAgKiBFbmFibGUgdGhlIGdpdmVuIHdhcm5pbmcgY2F0ZWdvcnkgZm9yIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIG9ubHkgZXhpc3RzIGluIGRldmVsb3BtZW50IGJ1aWxkcywgc28gaXQgc2hvdWxkIGJlIGFjY2Vzc2VkXG4gICAqIHdpdGggYSBndWFyZCBsaWtlOlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiAvLyBFbmFibGUgZm9yIGFsbCBSZWFjdGl2ZUVsZW1lbnQgc3ViY2xhc3Nlc1xuICAgKiBSZWFjdGl2ZUVsZW1lbnQuZW5hYmxlV2FybmluZz8uKCdtaWdyYXRpb24nKTtcbiAgICpcbiAgICogLy8gRW5hYmxlIGZvciBvbmx5IE15RWxlbWVudCBhbmQgc3ViY2xhc3Nlc1xuICAgKiBNeUVsZW1lbnQuZW5hYmxlV2FybmluZz8uKCdtaWdyYXRpb24nKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBub2NvbGxhcHNlXG4gICAqIEBjYXRlZ29yeSBkZXYtbW9kZVxuICAgKi9cbiAgc3RhdGljIGVuYWJsZVdhcm5pbmc/OiAod2FybmluZ0tpbmQ6IFdhcm5pbmdLaW5kKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBEaXNhYmxlIHRoZSBnaXZlbiB3YXJuaW5nIGNhdGVnb3J5IGZvciB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBvbmx5IGV4aXN0cyBpbiBkZXZlbG9wbWVudCBidWlsZHMsIHNvIGl0IHNob3VsZCBiZSBhY2Nlc3NlZFxuICAgKiB3aXRoIGEgZ3VhcmQgbGlrZTpcbiAgICpcbiAgICogYGBgdHNcbiAgICogLy8gRGlzYWJsZSBmb3IgYWxsIFJlYWN0aXZlRWxlbWVudCBzdWJjbGFzc2VzXG4gICAqIFJlYWN0aXZlRWxlbWVudC5kaXNhYmxlV2FybmluZz8uKCdtaWdyYXRpb24nKTtcbiAgICpcbiAgICogLy8gRGlzYWJsZSBmb3Igb25seSBNeUVsZW1lbnQgYW5kIHN1YmNsYXNzZXNcbiAgICogTXlFbGVtZW50LmRpc2FibGVXYXJuaW5nPy4oJ21pZ3JhdGlvbicpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQG5vY29sbGFwc2VcbiAgICogQGNhdGVnb3J5IGRldi1tb2RlXG4gICAqL1xuICBzdGF0aWMgZGlzYWJsZVdhcm5pbmc/OiAod2FybmluZ0tpbmQ6IFdhcm5pbmdLaW5kKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGluaXRpYWxpemVyIGZ1bmN0aW9uIHRvIHRoZSBjbGFzcyB0aGF0IGlzIGNhbGxlZCBkdXJpbmcgaW5zdGFuY2VcbiAgICogY29uc3RydWN0aW9uLlxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBmb3IgY29kZSB0aGF0IHJ1bnMgYWdhaW5zdCBhIGBSZWFjdGl2ZUVsZW1lbnRgXG4gICAqIHN1YmNsYXNzLCBzdWNoIGFzIGEgZGVjb3JhdG9yLCB0aGF0IG5lZWRzIHRvIGRvIHdvcmsgZm9yIGVhY2hcbiAgICogaW5zdGFuY2UsIHN1Y2ggYXMgc2V0dGluZyB1cCBhIGBSZWFjdGl2ZUNvbnRyb2xsZXJgLlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBteURlY29yYXRvciA9ICh0YXJnZXQ6IHR5cGVvZiBSZWFjdGl2ZUVsZW1lbnQsIGtleTogc3RyaW5nKSA9PiB7XG4gICAqICAgdGFyZ2V0LmFkZEluaXRpYWxpemVyKChpbnN0YW5jZTogUmVhY3RpdmVFbGVtZW50KSA9PiB7XG4gICAqICAgICAvLyBUaGlzIGlzIHJ1biBkdXJpbmcgY29uc3RydWN0aW9uIG9mIHRoZSBlbGVtZW50XG4gICAqICAgICBuZXcgTXlDb250cm9sbGVyKGluc3RhbmNlKTtcbiAgICogICB9KTtcbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogRGVjb3JhdGluZyBhIGZpZWxkIHdpbGwgdGhlbiBjYXVzZSBlYWNoIGluc3RhbmNlIHRvIHJ1biBhbiBpbml0aWFsaXplclxuICAgKiB0aGF0IGFkZHMgYSBjb250cm9sbGVyOlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBjbGFzcyBNeUVsZW1lbnQgZXh0ZW5kcyBMaXRFbGVtZW50IHtcbiAgICogICBAbXlEZWNvcmF0b3IgZm9vO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBJbml0aWFsaXplcnMgYXJlIHN0b3JlZCBwZXItY29uc3RydWN0b3IuIEFkZGluZyBhbiBpbml0aWFsaXplciB0byBhXG4gICAqIHN1YmNsYXNzIGRvZXMgbm90IGFkZCBpdCB0byBhIHN1cGVyY2xhc3MuIFNpbmNlIGluaXRpYWxpemVycyBhcmUgcnVuIGluXG4gICAqIGNvbnN0cnVjdG9ycywgaW5pdGlhbGl6ZXJzIHdpbGwgcnVuIGluIG9yZGVyIG9mIHRoZSBjbGFzcyBoaWVyYXJjaHksXG4gICAqIHN0YXJ0aW5nIHdpdGggc3VwZXJjbGFzc2VzIGFuZCBwcm9ncmVzc2luZyB0byB0aGUgaW5zdGFuY2UncyBjbGFzcy5cbiAgICpcbiAgICogQG5vY29sbGFwc2VcbiAgICovXG4gIHN0YXRpYyBhZGRJbml0aWFsaXplcihpbml0aWFsaXplcjogSW5pdGlhbGl6ZXIpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplcnMgPz89IFtdO1xuICAgIHRoaXMuX2luaXRpYWxpemVycy5wdXNoKGluaXRpYWxpemVyKTtcbiAgfVxuXG4gIHN0YXRpYyBfaW5pdGlhbGl6ZXJzPzogSW5pdGlhbGl6ZXJbXTtcblxuICAvKlxuICAgKiBEdWUgdG8gY2xvc3VyZSBjb21waWxlciBFUzYgY29tcGlsYXRpb24gYnVncywgQG5vY29sbGFwc2UgaXMgcmVxdWlyZWQgb25cbiAgICogYWxsIHN0YXRpYyBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIHdpdGggaW5pdGlhbGl6ZXJzLiAgUmVmZXJlbmNlOlxuICAgKiAtIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1jb21waWxlci9pc3N1ZXMvMTc3NlxuICAgKi9cblxuICAvKipcbiAgICogTWFwcyBhdHRyaWJ1dGUgbmFtZXMgdG8gcHJvcGVydGllczsgZm9yIGV4YW1wbGUgYGZvb2JhcmAgYXR0cmlidXRlIHRvXG4gICAqIGBmb29CYXJgIHByb3BlcnR5LiBDcmVhdGVkIGxhemlseSBvbiB1c2VyIHN1YmNsYXNzZXMgd2hlbiBmaW5hbGl6aW5nIHRoZVxuICAgKiBjbGFzcy5cbiAgICogQG5vY29sbGFwc2VcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIF9fYXR0cmlidXRlVG9Qcm9wZXJ0eU1hcDogQXR0cmlidXRlTWFwO1xuXG4gIC8qKlxuICAgKiBNYXJrcyBjbGFzcyBhcyBoYXZpbmcgZmluaXNoZWQgY3JlYXRpbmcgcHJvcGVydGllcy5cbiAgICovXG4gIHByb3RlY3RlZCBzdGF0aWMgW2ZpbmFsaXplZF0gPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBNZW1vaXplZCBsaXN0IG9mIGFsbCBlbGVtZW50IHByb3BlcnRpZXMsIGluY2x1ZGluZyBhbnkgc3VwZXJjbGFzcyBwcm9wZXJ0aWVzLlxuICAgKiBDcmVhdGVkIGxhemlseSBvbiB1c2VyIHN1YmNsYXNzZXMgd2hlbiBmaW5hbGl6aW5nIHRoZSBjbGFzcy5cbiAgICogQG5vY29sbGFwc2VcbiAgICogQGNhdGVnb3J5IHByb3BlcnRpZXNcbiAgICovXG4gIHN0YXRpYyBlbGVtZW50UHJvcGVydGllczogUHJvcGVydHlEZWNsYXJhdGlvbk1hcCA9IG5ldyBNYXAoKTtcblxuICAvKipcbiAgICogVXNlci1zdXBwbGllZCBvYmplY3QgdGhhdCBtYXBzIHByb3BlcnR5IG5hbWVzIHRvIGBQcm9wZXJ0eURlY2xhcmF0aW9uYFxuICAgKiBvYmplY3RzIGNvbnRhaW5pbmcgb3B0aW9ucyBmb3IgY29uZmlndXJpbmcgcmVhY3RpdmUgcHJvcGVydGllcy4gV2hlblxuICAgKiBhIHJlYWN0aXZlIHByb3BlcnR5IGlzIHNldCB0aGUgZWxlbWVudCB3aWxsIHVwZGF0ZSBhbmQgcmVuZGVyLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0IHByb3BlcnRpZXMgYXJlIHB1YmxpYyBmaWVsZHMsIGFuZCBhcyBzdWNoLCB0aGV5IHNob3VsZCBiZVxuICAgKiBjb25zaWRlcmVkIGFzIHByaW1hcmlseSBzZXR0YWJsZSBieSBlbGVtZW50IHVzZXJzLCBlaXRoZXIgdmlhIGF0dHJpYnV0ZSBvclxuICAgKiB0aGUgcHJvcGVydHkgaXRzZWxmLlxuICAgKlxuICAgKiBHZW5lcmFsbHksIHByb3BlcnRpZXMgdGhhdCBhcmUgY2hhbmdlZCBieSB0aGUgZWxlbWVudCBzaG91bGQgYmUgcHJpdmF0ZSBvclxuICAgKiBwcm90ZWN0ZWQgZmllbGRzIGFuZCBzaG91bGQgdXNlIHRoZSBgc3RhdGU6IHRydWVgIG9wdGlvbi4gUHJvcGVydGllc1xuICAgKiBtYXJrZWQgYXMgYHN0YXRlYCBkbyBub3QgcmVmbGVjdCBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIGF0dHJpYnV0ZVxuICAgKlxuICAgKiBIb3dldmVyLCBzb21ldGltZXMgZWxlbWVudCBjb2RlIGRvZXMgbmVlZCB0byBzZXQgYSBwdWJsaWMgcHJvcGVydHkuIFRoaXNcbiAgICogc2hvdWxkIHR5cGljYWxseSBvbmx5IGJlIGRvbmUgaW4gcmVzcG9uc2UgdG8gdXNlciBpbnRlcmFjdGlvbiwgYW5kIGFuIGV2ZW50XG4gICAqIHNob3VsZCBiZSBmaXJlZCBpbmZvcm1pbmcgdGhlIHVzZXI7IGZvciBleGFtcGxlLCBhIGNoZWNrYm94IHNldHMgaXRzXG4gICAqIGBjaGVja2VkYCBwcm9wZXJ0eSB3aGVuIGNsaWNrZWQgYW5kIGZpcmVzIGEgYGNoYW5nZWRgIGV2ZW50LiBNdXRhdGluZ1xuICAgKiBwdWJsaWMgcHJvcGVydGllcyBzaG91bGQgdHlwaWNhbGx5IG5vdCBiZSBkb25lIGZvciBub24tcHJpbWl0aXZlIChvYmplY3Qgb3JcbiAgICogYXJyYXkpIHByb3BlcnRpZXMuIEluIG90aGVyIGNhc2VzIHdoZW4gYW4gZWxlbWVudCBuZWVkcyB0byBtYW5hZ2Ugc3RhdGUsIGFcbiAgICogcHJpdmF0ZSBwcm9wZXJ0eSBzZXQgd2l0aCB0aGUgYHN0YXRlOiB0cnVlYCBvcHRpb24gc2hvdWxkIGJlIHVzZWQuIFdoZW5cbiAgICogbmVlZGVkLCBzdGF0ZSBwcm9wZXJ0aWVzIGNhbiBiZSBpbml0aWFsaXplZCB2aWEgcHVibGljIHByb3BlcnRpZXMgdG9cbiAgICogZmFjaWxpdGF0ZSBjb21wbGV4IGludGVyYWN0aW9ucy5cbiAgICogQG5vY29sbGFwc2VcbiAgICogQGNhdGVnb3J5IHByb3BlcnRpZXNcbiAgICovXG4gIHN0YXRpYyBwcm9wZXJ0aWVzOiBQcm9wZXJ0eURlY2xhcmF0aW9ucztcblxuICAvKipcbiAgICogTWVtb2l6ZWQgbGlzdCBvZiBhbGwgZWxlbWVudCBzdHlsZXMuXG4gICAqIENyZWF0ZWQgbGF6aWx5IG9uIHVzZXIgc3ViY2xhc3NlcyB3aGVuIGZpbmFsaXppbmcgdGhlIGNsYXNzLlxuICAgKiBAbm9jb2xsYXBzZVxuICAgKiBAY2F0ZWdvcnkgc3R5bGVzXG4gICAqL1xuICBzdGF0aWMgZWxlbWVudFN0eWxlczogQXJyYXk8Q1NTUmVzdWx0T3JOYXRpdmU+ID0gW107XG5cbiAgLyoqXG4gICAqIEFycmF5IG9mIHN0eWxlcyB0byBhcHBseSB0byB0aGUgZWxlbWVudC4gVGhlIHN0eWxlcyBzaG91bGQgYmUgZGVmaW5lZFxuICAgKiB1c2luZyB0aGUge0BsaW5rY29kZSBjc3N9IHRhZyBmdW5jdGlvbiwgdmlhIGNvbnN0cnVjdGlibGUgc3R5bGVzaGVldHMsIG9yXG4gICAqIGltcG9ydGVkIGZyb20gbmF0aXZlIENTUyBtb2R1bGUgc2NyaXB0cy5cbiAgICpcbiAgICogTm90ZSBvbiBDb250ZW50IFNlY3VyaXR5IFBvbGljeTpcbiAgICpcbiAgICogRWxlbWVudCBzdHlsZXMgYXJlIGltcGxlbWVudGVkIHdpdGggYDxzdHlsZT5gIHRhZ3Mgd2hlbiB0aGUgYnJvd3NlciBkb2Vzbid0XG4gICAqIHN1cHBvcnQgYWRvcHRlZCBTdHlsZVNoZWV0cy4gVG8gdXNlIHN1Y2ggYDxzdHlsZT5gIHRhZ3Mgd2l0aCB0aGUgc3R5bGUtc3JjXG4gICAqIENTUCBkaXJlY3RpdmUsIHRoZSBzdHlsZS1zcmMgdmFsdWUgbXVzdCBlaXRoZXIgaW5jbHVkZSAndW5zYWZlLWlubGluZScgb3JcbiAgICogJ25vbmNlLTxiYXNlNjQtdmFsdWU+JyB3aXRoIDxiYXNlNjQtdmFsdWU+IHJlcGxhY2VkIGJlIGEgc2VydmVyLWdlbmVyYXRlZFxuICAgKiBub25jZS5cbiAgICpcbiAgICogVG8gcHJvdmlkZSBhIG5vbmNlIHRvIHVzZSBvbiBnZW5lcmF0ZWQgPHN0eWxlPiBlbGVtZW50cywgc2V0XG4gICAqIGB3aW5kb3cubGl0Tm9uY2VgIHRvIGEgc2VydmVyLWdlbmVyYXRlZCBub25jZSBpbiB5b3VyIHBhZ2UncyBIVE1MLCBiZWZvcmVcbiAgICogbG9hZGluZyBhcHBsaWNhdGlvbiBjb2RlOlxuICAgKlxuICAgKiBgYGBodG1sXG4gICAqIDxzY3JpcHQ+XG4gICAqICAgLy8gR2VuZXJhdGVkIGFuZCB1bmlxdWUgcGVyIHJlcXVlc3Q6XG4gICAqICAgd2luZG93LmxpdE5vbmNlID0gJ2ExYjJjM2Q0JztcbiAgICogPC9zY3JpcHQ+XG4gICAqIGBgYFxuICAgKiBAbm9jb2xsYXBzZVxuICAgKiBAY2F0ZWdvcnkgc3R5bGVzXG4gICAqL1xuICBzdGF0aWMgc3R5bGVzPzogQ1NTUmVzdWx0R3JvdXA7XG5cbiAgLyoqXG4gICAqIFRoZSBzZXQgb2YgcHJvcGVydGllcyBkZWZpbmVkIGJ5IHRoaXMgY2xhc3MgdGhhdCBjYXVzZWQgYW4gYWNjZXNzb3IgdG8gYmVcbiAgICogYWRkZWQgZHVyaW5nIGBjcmVhdGVQcm9wZXJ0eWAuXG4gICAqIEBub2NvbGxhcHNlXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBfX3JlYWN0aXZlUHJvcGVydHlLZXlzPzogU2V0PFByb3BlcnR5S2V5PjtcblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgYXR0cmlidXRlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSByZWdpc3RlcmVkIHByb3BlcnRpZXMuXG4gICAqIEBub2NvbGxhcHNlXG4gICAqIEBjYXRlZ29yeSBhdHRyaWJ1dGVzXG4gICAqL1xuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICAvLyBub3RlOiBwaWdneSBiYWNraW5nIG9uIHRoaXMgdG8gZW5zdXJlIHdlJ3JlIGZpbmFsaXplZC5cbiAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgY29uc3QgYXR0cmlidXRlczogc3RyaW5nW10gPSBbXTtcbiAgICAvLyBVc2UgZm9yRWFjaCBzbyB0aGlzIHdvcmtzIGV2ZW4gaWYgZm9yL29mIGxvb3BzIGFyZSBjb21waWxlZCB0byBmb3IgbG9vcHNcbiAgICAvLyBleHBlY3RpbmcgYXJyYXlzXG4gICAgdGhpcy5lbGVtZW50UHJvcGVydGllcy5mb3JFYWNoKCh2LCBwKSA9PiB7XG4gICAgICBjb25zdCBhdHRyID0gdGhpcy5fX2F0dHJpYnV0ZU5hbWVGb3JQcm9wZXJ0eShwLCB2KTtcbiAgICAgIGlmIChhdHRyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fX2F0dHJpYnV0ZVRvUHJvcGVydHlNYXAuc2V0KGF0dHIsIHApO1xuICAgICAgICBhdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHByb3BlcnR5IGFjY2Vzc29yIG9uIHRoZSBlbGVtZW50IHByb3RvdHlwZSBpZiBvbmUgZG9lcyBub3QgZXhpc3RcbiAgICogYW5kIHN0b3JlcyBhIHtAbGlua2NvZGUgUHJvcGVydHlEZWNsYXJhdGlvbn0gZm9yIHRoZSBwcm9wZXJ0eSB3aXRoIHRoZVxuICAgKiBnaXZlbiBvcHRpb25zLiBUaGUgcHJvcGVydHkgc2V0dGVyIGNhbGxzIHRoZSBwcm9wZXJ0eSdzIGBoYXNDaGFuZ2VkYFxuICAgKiBwcm9wZXJ0eSBvcHRpb24gb3IgdXNlcyBhIHN0cmljdCBpZGVudGl0eSBjaGVjayB0byBkZXRlcm1pbmUgd2hldGhlciBvciBub3RcbiAgICogdG8gcmVxdWVzdCBhbiB1cGRhdGUuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIG1heSBiZSBvdmVycmlkZGVuIHRvIGN1c3RvbWl6ZSBwcm9wZXJ0aWVzOyBob3dldmVyLFxuICAgKiB3aGVuIGRvaW5nIHNvLCBpdCdzIGltcG9ydGFudCB0byBjYWxsIGBzdXBlci5jcmVhdGVQcm9wZXJ0eWAgdG8gZW5zdXJlXG4gICAqIHRoZSBwcm9wZXJ0eSBpcyBzZXR1cCBjb3JyZWN0bHkuIFRoaXMgbWV0aG9kIGNhbGxzXG4gICAqIGBnZXRQcm9wZXJ0eURlc2NyaXB0b3JgIGludGVybmFsbHkgdG8gZ2V0IGEgZGVzY3JpcHRvciB0byBpbnN0YWxsLlxuICAgKiBUbyBjdXN0b21pemUgd2hhdCBwcm9wZXJ0aWVzIGRvIHdoZW4gdGhleSBhcmUgZ2V0IG9yIHNldCwgb3ZlcnJpZGVcbiAgICogYGdldFByb3BlcnR5RGVzY3JpcHRvcmAuIFRvIGN1c3RvbWl6ZSB0aGUgb3B0aW9ucyBmb3IgYSBwcm9wZXJ0eSxcbiAgICogaW1wbGVtZW50IGBjcmVhdGVQcm9wZXJ0eWAgbGlrZSB0aGlzOlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBzdGF0aWMgY3JlYXRlUHJvcGVydHkobmFtZSwgb3B0aW9ucykge1xuICAgKiAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHtteU9wdGlvbjogdHJ1ZX0pO1xuICAgKiAgIHN1cGVyLmNyZWF0ZVByb3BlcnR5KG5hbWUsIG9wdGlvbnMpO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBAbm9jb2xsYXBzZVxuICAgKiBAY2F0ZWdvcnkgcHJvcGVydGllc1xuICAgKi9cbiAgc3RhdGljIGNyZWF0ZVByb3BlcnR5KFxuICAgIG5hbWU6IFByb3BlcnR5S2V5LFxuICAgIG9wdGlvbnM6IFByb3BlcnR5RGVjbGFyYXRpb24gPSBkZWZhdWx0UHJvcGVydHlEZWNsYXJhdGlvblxuICApIHtcbiAgICAvLyBpZiB0aGlzIGlzIGEgc3RhdGUgcHJvcGVydHksIGZvcmNlIHRoZSBhdHRyaWJ1dGUgdG8gZmFsc2UuXG4gICAgaWYgKG9wdGlvbnMuc3RhdGUpIHtcbiAgICAgIC8vIENhc3QgYXMgYW55IHNpbmNlIHRoaXMgaXMgcmVhZG9ubHkuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgKG9wdGlvbnMgYXMgYW55KS5hdHRyaWJ1dGUgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gTm90ZSwgc2luY2UgdGhpcyBjYW4gYmUgY2FsbGVkIGJ5IHRoZSBgQHByb3BlcnR5YCBkZWNvcmF0b3Igd2hpY2hcbiAgICAvLyBpcyBjYWxsZWQgYmVmb3JlIGBmaW5hbGl6ZWAsIHdlIGVuc3VyZSBmaW5hbGl6YXRpb24gaGFzIGJlZW4ga2lja2VkIG9mZi5cbiAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgdGhpcy5lbGVtZW50UHJvcGVydGllcy5zZXQobmFtZSwgb3B0aW9ucyk7XG4gICAgLy8gRG8gbm90IGdlbmVyYXRlIGFuIGFjY2Vzc29yIGlmIHRoZSBwcm90b3R5cGUgYWxyZWFkeSBoYXMgb25lLCBzaW5jZVxuICAgIC8vIGl0IHdvdWxkIGJlIGxvc3Qgb3RoZXJ3aXNlIGFuZCB0aGF0IHdvdWxkIG5ldmVyIGJlIHRoZSB1c2VyJ3MgaW50ZW50aW9uO1xuICAgIC8vIEluc3RlYWQsIHdlIGV4cGVjdCB1c2VycyB0byBjYWxsIGByZXF1ZXN0VXBkYXRlYCB0aGVtc2VsdmVzIGZyb21cbiAgICAvLyB1c2VyLWRlZmluZWQgYWNjZXNzb3JzLiBOb3RlIHRoYXQgaWYgdGhlIHN1cGVyIGhhcyBhbiBhY2Nlc3NvciB3ZSB3aWxsXG4gICAgLy8gc3RpbGwgb3ZlcndyaXRlIGl0XG4gICAgaWYgKCFvcHRpb25zLm5vQWNjZXNzb3IgJiYgIXRoaXMucHJvdG90eXBlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb25zdCBrZXkgPSB0eXBlb2YgbmFtZSA9PT0gJ3N5bWJvbCcgPyBTeW1ib2woKSA6IGBfXyR7bmFtZX1gO1xuICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMuZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG5hbWUsIGtleSwgb3B0aW9ucyk7XG4gICAgICBpZiAoZGVzY3JpcHRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZGVzY3JpcHRvcik7XG4gICAgICAgIGlmIChERVZfTU9ERSkge1xuICAgICAgICAgIC8vIElmIHRoaXMgY2xhc3MgZG9lc24ndCBoYXZlIGl0cyBvd24gc2V0LCBjcmVhdGUgb25lIGFuZCBpbml0aWFsaXplXG4gICAgICAgICAgLy8gd2l0aCB0aGUgdmFsdWVzIGluIHRoZSBzZXQgZnJvbSB0aGUgbmVhcmVzdCBhbmNlc3RvciBjbGFzcywgaWYgYW55LlxuICAgICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eSgnX19yZWFjdGl2ZVByb3BlcnR5S2V5cycpKSB7XG4gICAgICAgICAgICB0aGlzLl9fcmVhY3RpdmVQcm9wZXJ0eUtleXMgPSBuZXcgU2V0KFxuICAgICAgICAgICAgICB0aGlzLl9fcmVhY3RpdmVQcm9wZXJ0eUtleXMgPz8gW11cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX19yZWFjdGl2ZVByb3BlcnR5S2V5cyEuYWRkKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIGJlIGRlZmluZWQgb24gdGhlIGdpdmVuIG5hbWVkIHByb3BlcnR5LlxuICAgKiBJZiBubyBkZXNjcmlwdG9yIGlzIHJldHVybmVkLCB0aGUgcHJvcGVydHkgd2lsbCBub3QgYmVjb21lIGFuIGFjY2Vzc29yLlxuICAgKiBGb3IgZXhhbXBsZSxcbiAgICpcbiAgICogYGBgdHNcbiAgICogY2xhc3MgTXlFbGVtZW50IGV4dGVuZHMgTGl0RWxlbWVudCB7XG4gICAqICAgc3RhdGljIGdldFByb3BlcnR5RGVzY3JpcHRvcihuYW1lLCBrZXksIG9wdGlvbnMpIHtcbiAgICogICAgIGNvbnN0IGRlZmF1bHREZXNjcmlwdG9yID1cbiAgICogICAgICAgICBzdXBlci5nZXRQcm9wZXJ0eURlc2NyaXB0b3IobmFtZSwga2V5LCBvcHRpb25zKTtcbiAgICogICAgIGNvbnN0IHNldHRlciA9IGRlZmF1bHREZXNjcmlwdG9yLnNldDtcbiAgICogICAgIHJldHVybiB7XG4gICAqICAgICAgIGdldDogZGVmYXVsdERlc2NyaXB0b3IuZ2V0LFxuICAgKiAgICAgICBzZXQodmFsdWUpIHtcbiAgICogICAgICAgICBzZXR0ZXIuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAqICAgICAgICAgLy8gY3VzdG9tIGFjdGlvbi5cbiAgICogICAgICAgfSxcbiAgICogICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBAbm9jb2xsYXBzZVxuICAgKiBAY2F0ZWdvcnkgcHJvcGVydGllc1xuICAgKi9cbiAgcHJvdGVjdGVkIHN0YXRpYyBnZXRQcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgbmFtZTogUHJvcGVydHlLZXksXG4gICAga2V5OiBzdHJpbmcgfCBzeW1ib2wsXG4gICAgb3B0aW9uczogUHJvcGVydHlEZWNsYXJhdGlvblxuICApOiBQcm9wZXJ0eURlc2NyaXB0b3IgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgZ2V0KCk6IGFueSB7XG4gICAgICAgIHJldHVybiAodGhpcyBhcyB7W2tleTogc3RyaW5nXTogdW5rbm93bn0pW2tleSBhcyBzdHJpbmddO1xuICAgICAgfSxcbiAgICAgIHNldCh0aGlzOiBSZWFjdGl2ZUVsZW1lbnQsIHZhbHVlOiB1bmtub3duKSB7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gKHRoaXMgYXMge30gYXMge1trZXk6IHN0cmluZ106IHVua25vd259KVtcbiAgICAgICAgICBuYW1lIGFzIHN0cmluZ1xuICAgICAgICBdO1xuICAgICAgICAodGhpcyBhcyB7fSBhcyB7W2tleTogc3RyaW5nXTogdW5rbm93bn0pW2tleSBhcyBzdHJpbmddID0gdmFsdWU7XG4gICAgICAgICh0aGlzIGFzIHVua25vd24gYXMgUmVhY3RpdmVFbGVtZW50KS5yZXF1ZXN0VXBkYXRlKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBvcHRpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAqIFRoZXNlIG9wdGlvbnMgYXJlIGRlZmluZWQgd2l0aCBhIGBQcm9wZXJ0eURlY2xhcmF0aW9uYCB2aWEgdGhlIGBwcm9wZXJ0aWVzYFxuICAgKiBvYmplY3Qgb3IgdGhlIGBAcHJvcGVydHlgIGRlY29yYXRvciBhbmQgYXJlIHJlZ2lzdGVyZWQgaW5cbiAgICogYGNyZWF0ZVByb3BlcnR5KC4uLilgLlxuICAgKlxuICAgKiBOb3RlLCB0aGlzIG1ldGhvZCBzaG91bGQgYmUgY29uc2lkZXJlZCBcImZpbmFsXCIgYW5kIG5vdCBvdmVycmlkZGVuLiBUb1xuICAgKiBjdXN0b21pemUgdGhlIG9wdGlvbnMgZm9yIGEgZ2l2ZW4gcHJvcGVydHksIG92ZXJyaWRlXG4gICAqIHtAbGlua2NvZGUgY3JlYXRlUHJvcGVydHl9LlxuICAgKlxuICAgKiBAbm9jb2xsYXBzZVxuICAgKiBAZmluYWxcbiAgICogQGNhdGVnb3J5IHByb3BlcnRpZXNcbiAgICovXG4gIHN0YXRpYyBnZXRQcm9wZXJ0eU9wdGlvbnMobmFtZTogUHJvcGVydHlLZXkpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50UHJvcGVydGllcy5nZXQobmFtZSkgfHwgZGVmYXVsdFByb3BlcnR5RGVjbGFyYXRpb247XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBwcm9wZXJ0eSBhY2Nlc3NvcnMgZm9yIHJlZ2lzdGVyZWQgcHJvcGVydGllcywgc2V0cyB1cCBlbGVtZW50XG4gICAqIHN0eWxpbmcsIGFuZCBlbnN1cmVzIGFueSBzdXBlcmNsYXNzZXMgYXJlIGFsc28gZmluYWxpemVkLiBSZXR1cm5zIHRydWUgaWZcbiAgICogdGhlIGVsZW1lbnQgd2FzIGZpbmFsaXplZC5cbiAgICogQG5vY29sbGFwc2VcbiAgICovXG4gIHByb3RlY3RlZCBzdGF0aWMgZmluYWxpemUoKSB7XG4gICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoZmluYWxpemVkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzW2ZpbmFsaXplZF0gPSB0cnVlO1xuICAgIC8vIGZpbmFsaXplIGFueSBzdXBlcmNsYXNzZXNcbiAgICBjb25zdCBzdXBlckN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykgYXMgdHlwZW9mIFJlYWN0aXZlRWxlbWVudDtcbiAgICBzdXBlckN0b3IuZmluYWxpemUoKTtcbiAgICB0aGlzLmVsZW1lbnRQcm9wZXJ0aWVzID0gbmV3IE1hcChzdXBlckN0b3IuZWxlbWVudFByb3BlcnRpZXMpO1xuICAgIC8vIGluaXRpYWxpemUgTWFwIHBvcHVsYXRlZCBpbiBvYnNlcnZlZEF0dHJpYnV0ZXNcbiAgICB0aGlzLl9fYXR0cmlidXRlVG9Qcm9wZXJ0eU1hcCA9IG5ldyBNYXAoKTtcbiAgICAvLyBtYWtlIGFueSBwcm9wZXJ0aWVzXG4gICAgLy8gTm90ZSwgb25seSBwcm9jZXNzIFwib3duXCIgcHJvcGVydGllcyBzaW5jZSB0aGlzIGVsZW1lbnQgd2lsbCBpbmhlcml0XG4gICAgLy8gYW55IHByb3BlcnRpZXMgZGVmaW5lZCBvbiB0aGUgc3VwZXJDbGFzcywgYW5kIGZpbmFsaXphdGlvbiBlbnN1cmVzXG4gICAgLy8gdGhlIGVudGlyZSBwcm90b3R5cGUgY2hhaW4gaXMgZmluYWxpemVkLlxuICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ3Byb3BlcnRpZXMnLCB0aGlzKSkpIHtcbiAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgICAgLy8gc3VwcG9ydCBzeW1ib2xzIGluIHByb3BlcnRpZXMgKElFMTEgZG9lcyBub3Qgc3VwcG9ydCB0aGlzKVxuICAgICAgY29uc3QgcHJvcEtleXMgPSBbXG4gICAgICAgIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BzKSxcbiAgICAgICAgLi4uT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhwcm9wcyksXG4gICAgICBdO1xuICAgICAgLy8gVGhpcyBmb3Ivb2YgaXMgb2sgYmVjYXVzZSBwcm9wS2V5cyBpcyBhbiBhcnJheVxuICAgICAgZm9yIChjb25zdCBwIG9mIHByb3BLZXlzKSB7XG4gICAgICAgIC8vIG5vdGUsIHVzZSBvZiBgYW55YCBpcyBkdWUgdG8gVHlwZVNjcmlwdCBsYWNrIG9mIHN1cHBvcnQgZm9yIHN5bWJvbCBpblxuICAgICAgICAvLyBpbmRleCB0eXBlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB0aGlzLmNyZWF0ZVByb3BlcnR5KHAsIChwcm9wcyBhcyBhbnkpW3BdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5lbGVtZW50U3R5bGVzID0gdGhpcy5maW5hbGl6ZVN0eWxlcyh0aGlzLnN0eWxlcyk7XG4gICAgLy8gREVWIG1vZGUgd2FybmluZ3NcbiAgICBpZiAoREVWX01PREUpIHtcbiAgICAgIGNvbnN0IHdhcm5SZW1vdmVkT3JSZW5hbWVkID0gKG5hbWU6IHN0cmluZywgcmVuYW1lZCA9IGZhbHNlKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIGlzc3VlV2FybmluZyhcbiAgICAgICAgICAgIHJlbmFtZWQgPyAncmVuYW1lZC1hcGknIDogJ3JlbW92ZWQtYXBpJyxcbiAgICAgICAgICAgIGBcXGAke25hbWV9XFxgIGlzIGltcGxlbWVudGVkIG9uIGNsYXNzICR7dGhpcy5uYW1lfS4gSXQgYCArXG4gICAgICAgICAgICAgIGBoYXMgYmVlbiAke3JlbmFtZWQgPyAncmVuYW1lZCcgOiAncmVtb3ZlZCd9IGAgK1xuICAgICAgICAgICAgICBgaW4gdGhpcyB2ZXJzaW9uIG9mIExpdEVsZW1lbnQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB3YXJuUmVtb3ZlZE9yUmVuYW1lZCgnaW5pdGlhbGl6ZScpO1xuICAgICAgd2FyblJlbW92ZWRPclJlbmFtZWQoJ3JlcXVlc3RVcGRhdGVJbnRlcm5hbCcpO1xuICAgICAgd2FyblJlbW92ZWRPclJlbmFtZWQoJ19nZXRVcGRhdGVDb21wbGV0ZScsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcHRpb25zIHVzZWQgd2hlbiBjYWxsaW5nIGBhdHRhY2hTaGFkb3dgLiBTZXQgdGhpcyBwcm9wZXJ0eSB0byBjdXN0b21pemVcbiAgICogdGhlIG9wdGlvbnMgZm9yIHRoZSBzaGFkb3dSb290OyBmb3IgZXhhbXBsZSwgdG8gY3JlYXRlIGEgY2xvc2VkXG4gICAqIHNoYWRvd1Jvb3Q6IGB7bW9kZTogJ2Nsb3NlZCd9YC5cbiAgICpcbiAgICogTm90ZSwgdGhlc2Ugb3B0aW9ucyBhcmUgdXNlZCBpbiBgY3JlYXRlUmVuZGVyUm9vdGAuIElmIHRoaXMgbWV0aG9kXG4gICAqIGlzIGN1c3RvbWl6ZWQsIG9wdGlvbnMgc2hvdWxkIGJlIHJlc3BlY3RlZCBpZiBwb3NzaWJsZS5cbiAgICogQG5vY29sbGFwc2VcbiAgICogQGNhdGVnb3J5IHJlbmRlcmluZ1xuICAgKi9cbiAgc3RhdGljIHNoYWRvd1Jvb3RPcHRpb25zOiBTaGFkb3dSb290SW5pdCA9IHttb2RlOiAnb3Blbid9O1xuXG4gIC8qKlxuICAgKiBUYWtlcyB0aGUgc3R5bGVzIHRoZSB1c2VyIHN1cHBsaWVkIHZpYSB0aGUgYHN0YXRpYyBzdHlsZXNgIHByb3BlcnR5IGFuZFxuICAgKiByZXR1cm5zIHRoZSBhcnJheSBvZiBzdHlsZXMgdG8gYXBwbHkgdG8gdGhlIGVsZW1lbnQuXG4gICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGludGVncmF0ZSBpbnRvIGEgc3R5bGUgbWFuYWdlbWVudCBzeXN0ZW0uXG4gICAqXG4gICAqIFN0eWxlcyBhcmUgZGVkdXBsaWNhdGVkIHByZXNlcnZpbmcgdGhlIF9sYXN0XyBpbnN0YW5jZSBpbiB0aGUgbGlzdC4gVGhpc1xuICAgKiBpcyBhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiB0byBhdm9pZCBkdXBsaWNhdGVkIHN0eWxlcyB0aGF0IGNhbiBvY2N1clxuICAgKiBlc3BlY2lhbGx5IHdoZW4gY29tcG9zaW5nIHZpYSBzdWJjbGFzc2luZy4gVGhlIGxhc3QgaXRlbSBpcyBrZXB0IHRvIHRyeVxuICAgKiB0byBwcmVzZXJ2ZSB0aGUgY2FzY2FkZSBvcmRlciB3aXRoIHRoZSBhc3N1bXB0aW9uIHRoYXQgaXQncyBtb3N0IGltcG9ydGFudFxuICAgKiB0aGF0IGxhc3QgYWRkZWQgc3R5bGVzIG92ZXJyaWRlIHByZXZpb3VzIHN0eWxlcy5cbiAgICpcbiAgICogQG5vY29sbGFwc2VcbiAgICogQGNhdGVnb3J5IHN0eWxlc1xuICAgKi9cbiAgcHJvdGVjdGVkIHN0YXRpYyBmaW5hbGl6ZVN0eWxlcyhcbiAgICBzdHlsZXM/OiBDU1NSZXN1bHRHcm91cFxuICApOiBBcnJheTxDU1NSZXN1bHRPck5hdGl2ZT4ge1xuICAgIGNvbnN0IGVsZW1lbnRTdHlsZXMgPSBbXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZXMpKSB7XG4gICAgICAvLyBEZWR1cGUgdGhlIGZsYXR0ZW5lZCBhcnJheSBpbiByZXZlcnNlIG9yZGVyIHRvIHByZXNlcnZlIHRoZSBsYXN0IGl0ZW1zLlxuICAgICAgLy8gQ2FzdGluZyB0byBBcnJheTx1bmtub3duPiB3b3JrcyBhcm91bmQgVFMgZXJyb3IgdGhhdFxuICAgICAgLy8gYXBwZWFycyB0byBjb21lIGZyb20gdHJ5aW5nIHRvIGZsYXR0ZW4gYSB0eXBlIENTU1Jlc3VsdEFycmF5LlxuICAgICAgY29uc3Qgc2V0ID0gbmV3IFNldCgoc3R5bGVzIGFzIEFycmF5PHVua25vd24+KS5mbGF0KEluZmluaXR5KS5yZXZlcnNlKCkpO1xuICAgICAgLy8gVGhlbiBwcmVzZXJ2ZSBvcmlnaW5hbCBvcmRlciBieSBhZGRpbmcgdGhlIHNldCBpdGVtcyBpbiByZXZlcnNlIG9yZGVyLlxuICAgICAgZm9yIChjb25zdCBzIG9mIHNldCkge1xuICAgICAgICBlbGVtZW50U3R5bGVzLnVuc2hpZnQoZ2V0Q29tcGF0aWJsZVN0eWxlKHMgYXMgQ1NTUmVzdWx0T3JOYXRpdmUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN0eWxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbGVtZW50U3R5bGVzLnB1c2goZ2V0Q29tcGF0aWJsZVN0eWxlKHN0eWxlcykpO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudFN0eWxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBOb2RlIG9yIFNoYWRvd1Jvb3QgaW50byB3aGljaCBlbGVtZW50IERPTSBzaG91bGQgYmUgcmVuZGVyZWQuIERlZmF1bHRzXG4gICAqIHRvIGFuIG9wZW4gc2hhZG93Um9vdC5cbiAgICogQGNhdGVnb3J5IHJlbmRlcmluZ1xuICAgKi9cbiAgcmVhZG9ubHkgcmVuZGVyUm9vdCE6IEhUTUxFbGVtZW50IHwgU2hhZG93Um9vdDtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJvcGVydHkgbmFtZSBmb3IgdGhlIGdpdmVuIGF0dHJpYnV0ZSBgbmFtZWAuXG4gICAqIEBub2NvbGxhcHNlXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBfX2F0dHJpYnV0ZU5hbWVGb3JQcm9wZXJ0eShcbiAgICBuYW1lOiBQcm9wZXJ0eUtleSxcbiAgICBvcHRpb25zOiBQcm9wZXJ0eURlY2xhcmF0aW9uXG4gICkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG9wdGlvbnMuYXR0cmlidXRlO1xuICAgIHJldHVybiBhdHRyaWJ1dGUgPT09IGZhbHNlXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiB0eXBlb2YgYXR0cmlidXRlID09PSAnc3RyaW5nJ1xuICAgICAgPyBhdHRyaWJ1dGVcbiAgICAgIDogdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnXG4gICAgICA/IG5hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIH1cblxuICBwcml2YXRlIF9faW5zdGFuY2VQcm9wZXJ0aWVzPzogUHJvcGVydHlWYWx1ZXMgPSBuZXcgTWFwKCk7XG4gIC8vIEluaXRpYWxpemUgdG8gYW4gdW5yZXNvbHZlZCBQcm9taXNlIHNvIHdlIGNhbiBtYWtlIHN1cmUgdGhlIGVsZW1lbnQgaGFzXG4gIC8vIGNvbm5lY3RlZCBiZWZvcmUgZmlyc3QgdXBkYXRlLlxuICBwcml2YXRlIF9fdXBkYXRlUHJvbWlzZSE6IFByb21pc2U8Ym9vbGVhbj47XG5cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlcmUgaXMgYSBwZW5kaW5nIHVwZGF0ZSBhcyBhIHJlc3VsdCBvZiBjYWxsaW5nIGByZXF1ZXN0VXBkYXRlKClgLlxuICAgKiBTaG91bGQgb25seSBiZSByZWFkLlxuICAgKiBAY2F0ZWdvcnkgdXBkYXRlc1xuICAgKi9cbiAgaXNVcGRhdGVQZW5kaW5nID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIElzIHNldCB0byBgdHJ1ZWAgYWZ0ZXIgdGhlIGZpcnN0IHVwZGF0ZS4gVGhlIGVsZW1lbnQgY29kZSBjYW5ub3QgYXNzdW1lXG4gICAqIHRoYXQgYHJlbmRlclJvb3RgIGV4aXN0cyBiZWZvcmUgdGhlIGVsZW1lbnQgYGhhc1VwZGF0ZWRgLlxuICAgKiBAY2F0ZWdvcnkgdXBkYXRlc1xuICAgKi9cbiAgaGFzVXBkYXRlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBNYXAgd2l0aCBrZXlzIGZvciBhbnkgcHJvcGVydGllcyB0aGF0IGhhdmUgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdFxuICAgKiB1cGRhdGUgY3ljbGUgd2l0aCBwcmV2aW91cyB2YWx1ZXMuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgXyRjaGFuZ2VkUHJvcGVydGllcyE6IFByb3BlcnR5VmFsdWVzO1xuXG4gIC8qKlxuICAgKiBNYXAgd2l0aCBrZXlzIG9mIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgcmVmbGVjdGVkIHdoZW4gdXBkYXRlZC5cbiAgICovXG4gIHByaXZhdGUgX19yZWZsZWN0aW5nUHJvcGVydGllcz86IE1hcDxQcm9wZXJ0eUtleSwgUHJvcGVydHlEZWNsYXJhdGlvbj47XG5cbiAgLyoqXG4gICAqIE5hbWUgb2YgY3VycmVudGx5IHJlZmxlY3RpbmcgcHJvcGVydHlcbiAgICovXG4gIHByaXZhdGUgX19yZWZsZWN0aW5nUHJvcGVydHk6IFByb3BlcnR5S2V5IHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldCBvZiBjb250cm9sbGVycy5cbiAgICovXG4gIHByaXZhdGUgX19jb250cm9sbGVycz86IFJlYWN0aXZlQ29udHJvbGxlcltdO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIG9ubHkgb3ZlcnJpZGUgcG9pbnQgZm9yIGN1c3RvbWl6aW5nIHdvcmsgZG9uZSB3aGVuIGVsZW1lbnRzXG4gICAqIGFyZSBjb25zdHJ1Y3RlZC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLl9fdXBkYXRlUHJvbWlzZSA9IG5ldyBQcm9taXNlPGJvb2xlYW4+KFxuICAgICAgKHJlcykgPT4gKHRoaXMuZW5hYmxlVXBkYXRpbmcgPSByZXMpXG4gICAgKTtcbiAgICB0aGlzLl8kY2hhbmdlZFByb3BlcnRpZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fX3NhdmVJbnN0YW5jZVByb3BlcnRpZXMoKTtcbiAgICAvLyBlbnN1cmVzIGZpcnN0IHVwZGF0ZSB3aWxsIGJlIGNhdWdodCBieSBhbiBlYXJseSBhY2Nlc3Mgb2ZcbiAgICAvLyBgdXBkYXRlQ29tcGxldGVgXG4gICAgdGhpcy5yZXF1ZXN0VXBkYXRlKCk7XG4gICAgKHRoaXMuY29uc3RydWN0b3IgYXMgdHlwZW9mIFJlYWN0aXZlRWxlbWVudCkuX2luaXRpYWxpemVycz8uZm9yRWFjaCgoaSkgPT5cbiAgICAgIGkodGhpcylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGBSZWFjdGl2ZUNvbnRyb2xsZXJgIHRvIHBhcnRpY2lwYXRlIGluIHRoZSBlbGVtZW50J3MgcmVhY3RpdmVcbiAgICogdXBkYXRlIGN5Y2xlLiBUaGUgZWxlbWVudCBhdXRvbWF0aWNhbGx5IGNhbGxzIGludG8gYW55IHJlZ2lzdGVyZWRcbiAgICogY29udHJvbGxlcnMgZHVyaW5nIGl0cyBsaWZlY3ljbGUgY2FsbGJhY2tzLlxuICAgKlxuICAgKiBJZiB0aGUgZWxlbWVudCBpcyBjb25uZWN0ZWQgd2hlbiBgYWRkQ29udHJvbGxlcigpYCBpcyBjYWxsZWQsIHRoZVxuICAgKiBjb250cm9sbGVyJ3MgYGhvc3RDb25uZWN0ZWQoKWAgY2FsbGJhY2sgd2lsbCBiZSBpbW1lZGlhdGVseSBjYWxsZWQuXG4gICAqIEBjYXRlZ29yeSBjb250cm9sbGVyc1xuICAgKi9cbiAgYWRkQ29udHJvbGxlcihjb250cm9sbGVyOiBSZWFjdGl2ZUNvbnRyb2xsZXIpIHtcbiAgICAodGhpcy5fX2NvbnRyb2xsZXJzID8/PSBbXSkucHVzaChjb250cm9sbGVyKTtcbiAgICAvLyBJZiBhIGNvbnRyb2xsZXIgaXMgYWRkZWQgYWZ0ZXIgdGhlIGVsZW1lbnQgaGFzIGJlZW4gY29ubmVjdGVkLFxuICAgIC8vIGNhbGwgaG9zdENvbm5lY3RlZC4gTm90ZSwgcmUtdXNpbmcgZXhpc3RlbmNlIG9mIGByZW5kZXJSb290YCBoZXJlXG4gICAgLy8gKHdoaWNoIGlzIHNldCBpbiBjb25uZWN0ZWRDYWxsYmFjaykgdG8gYXZvaWQgdGhlIG5lZWQgdG8gdHJhY2sgYVxuICAgIC8vIGZpcnN0IGNvbm5lY3RlZCBzdGF0ZS5cbiAgICBpZiAodGhpcy5yZW5kZXJSb290ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgY29udHJvbGxlci5ob3N0Q29ubmVjdGVkPy4oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGBSZWFjdGl2ZUNvbnRyb2xsZXJgIGZyb20gdGhlIGVsZW1lbnQuXG4gICAqIEBjYXRlZ29yeSBjb250cm9sbGVyc1xuICAgKi9cbiAgcmVtb3ZlQ29udHJvbGxlcihjb250cm9sbGVyOiBSZWFjdGl2ZUNvbnRyb2xsZXIpIHtcbiAgICAvLyBOb3RlLCBpZiB0aGUgaW5kZXhPZiBpcyAtMSwgdGhlID4+PiB3aWxsIGZsaXAgdGhlIHNpZ24gd2hpY2ggbWFrZXMgdGhlXG4gICAgLy8gc3BsaWNlIGRvIG5vdGhpbmcuXG4gICAgdGhpcy5fX2NvbnRyb2xsZXJzPy5zcGxpY2UodGhpcy5fX2NvbnRyb2xsZXJzLmluZGV4T2YoY29udHJvbGxlcikgPj4+IDAsIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpeGVzIGFueSBwcm9wZXJ0aWVzIHNldCBvbiB0aGUgaW5zdGFuY2UgYmVmb3JlIHVwZ3JhZGUgdGltZS5cbiAgICogT3RoZXJ3aXNlIHRoZXNlIHdvdWxkIHNoYWRvdyB0aGUgYWNjZXNzb3IgYW5kIGJyZWFrIHRoZXNlIHByb3BlcnRpZXMuXG4gICAqIFRoZSBwcm9wZXJ0aWVzIGFyZSBzdG9yZWQgaW4gYSBNYXAgd2hpY2ggaXMgcGxheWVkIGJhY2sgYWZ0ZXIgdGhlXG4gICAqIGNvbnN0cnVjdG9yIHJ1bnMuIE5vdGUsIG9uIHZlcnkgb2xkIHZlcnNpb25zIG9mIFNhZmFyaSAoPD05KSBvciBDaHJvbWVcbiAgICogKDw9NDEpLCBwcm9wZXJ0aWVzIGNyZWF0ZWQgZm9yIG5hdGl2ZSBwbGF0Zm9ybSBwcm9wZXJ0aWVzIGxpa2UgKGBpZGAgb3JcbiAgICogYG5hbWVgKSBtYXkgbm90IGhhdmUgZGVmYXVsdCB2YWx1ZXMgc2V0IGluIHRoZSBlbGVtZW50IGNvbnN0cnVjdG9yLiBPblxuICAgKiB0aGVzZSBicm93c2VycyBuYXRpdmUgcHJvcGVydGllcyBhcHBlYXIgb24gaW5zdGFuY2VzIGFuZCB0aGVyZWZvcmUgdGhlaXJcbiAgICogZGVmYXVsdCB2YWx1ZSB3aWxsIG92ZXJ3cml0ZSBhbnkgZWxlbWVudCBkZWZhdWx0IChlLmcuIGlmIHRoZSBlbGVtZW50IHNldHNcbiAgICogdGhpcy5pZCA9ICdpZCcgaW4gdGhlIGNvbnN0cnVjdG9yLCB0aGUgJ2lkJyB3aWxsIGJlY29tZSAnJyBzaW5jZSB0aGlzIGlzXG4gICAqIHRoZSBuYXRpdmUgcGxhdGZvcm0gZGVmYXVsdCkuXG4gICAqL1xuICBwcml2YXRlIF9fc2F2ZUluc3RhbmNlUHJvcGVydGllcygpIHtcbiAgICAvLyBVc2UgZm9yRWFjaCBzbyB0aGlzIHdvcmtzIGV2ZW4gaWYgZm9yL29mIGxvb3BzIGFyZSBjb21waWxlZCB0byBmb3IgbG9vcHNcbiAgICAvLyBleHBlY3RpbmcgYXJyYXlzXG4gICAgKHRoaXMuY29uc3RydWN0b3IgYXMgdHlwZW9mIFJlYWN0aXZlRWxlbWVudCkuZWxlbWVudFByb3BlcnRpZXMuZm9yRWFjaChcbiAgICAgIChfdiwgcCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgIHRoaXMuX19pbnN0YW5jZVByb3BlcnRpZXMhLnNldChwLCB0aGlzW3AgYXMga2V5b2YgdGhpc10pO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzW3AgYXMga2V5b2YgdGhpc107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5vZGUgaW50byB3aGljaCB0aGUgZWxlbWVudCBzaG91bGQgcmVuZGVyIGFuZCBieSBkZWZhdWx0XG4gICAqIGNyZWF0ZXMgYW5kIHJldHVybnMgYW4gb3BlbiBzaGFkb3dSb290LiBJbXBsZW1lbnQgdG8gY3VzdG9taXplIHdoZXJlIHRoZVxuICAgKiBlbGVtZW50J3MgRE9NIGlzIHJlbmRlcmVkLiBGb3IgZXhhbXBsZSwgdG8gcmVuZGVyIGludG8gdGhlIGVsZW1lbnQnc1xuICAgKiBjaGlsZE5vZGVzLCByZXR1cm4gYHRoaXNgLlxuICAgKlxuICAgKiBAcmV0dXJuIFJldHVybnMgYSBub2RlIGludG8gd2hpY2ggdG8gcmVuZGVyLlxuICAgKiBAY2F0ZWdvcnkgcmVuZGVyaW5nXG4gICAqL1xuICBwcm90ZWN0ZWQgY3JlYXRlUmVuZGVyUm9vdCgpOiBFbGVtZW50IHwgU2hhZG93Um9vdCB7XG4gICAgY29uc3QgcmVuZGVyUm9vdCA9XG4gICAgICB0aGlzLnNoYWRvd1Jvb3QgPz9cbiAgICAgIHRoaXMuYXR0YWNoU2hhZG93KFxuICAgICAgICAodGhpcy5jb25zdHJ1Y3RvciBhcyB0eXBlb2YgUmVhY3RpdmVFbGVtZW50KS5zaGFkb3dSb290T3B0aW9uc1xuICAgICAgKTtcbiAgICBhZG9wdFN0eWxlcyhcbiAgICAgIHJlbmRlclJvb3QsXG4gICAgICAodGhpcy5jb25zdHJ1Y3RvciBhcyB0eXBlb2YgUmVhY3RpdmVFbGVtZW50KS5lbGVtZW50U3R5bGVzXG4gICAgKTtcbiAgICByZXR1cm4gcmVuZGVyUm9vdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBmaXJzdCBjb25uZWN0aW9uLCBjcmVhdGVzIHRoZSBlbGVtZW50J3MgcmVuZGVyUm9vdCwgc2V0cyB1cFxuICAgKiBlbGVtZW50IHN0eWxpbmcsIGFuZCBlbmFibGVzIHVwZGF0aW5nLlxuICAgKiBAY2F0ZWdvcnkgbGlmZWN5Y2xlXG4gICAqL1xuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAvLyBjcmVhdGUgcmVuZGVyUm9vdCBiZWZvcmUgZmlyc3QgdXBkYXRlLlxuICAgIGlmICh0aGlzLnJlbmRlclJvb3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgKFxuICAgICAgICB0aGlzIGFzIHtcbiAgICAgICAgICByZW5kZXJSb290OiBFbGVtZW50IHwgRG9jdW1lbnRGcmFnbWVudDtcbiAgICAgICAgfVxuICAgICAgKS5yZW5kZXJSb290ID0gdGhpcy5jcmVhdGVSZW5kZXJSb290KCk7XG4gICAgfVxuICAgIHRoaXMuZW5hYmxlVXBkYXRpbmcodHJ1ZSk7XG4gICAgdGhpcy5fX2NvbnRyb2xsZXJzPy5mb3JFYWNoKChjKSA9PiBjLmhvc3RDb25uZWN0ZWQ/LigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RlLCB0aGlzIG1ldGhvZCBzaG91bGQgYmUgY29uc2lkZXJlZCBmaW5hbCBhbmQgbm90IG92ZXJyaWRkZW4uIEl0IGlzXG4gICAqIG92ZXJyaWRkZW4gb24gdGhlIGVsZW1lbnQgaW5zdGFuY2Ugd2l0aCBhIGZ1bmN0aW9uIHRoYXQgdHJpZ2dlcnMgdGhlIGZpcnN0XG4gICAqIHVwZGF0ZS5cbiAgICogQGNhdGVnb3J5IHVwZGF0ZXNcbiAgICovXG4gIHByb3RlY3RlZCBlbmFibGVVcGRhdGluZyhfcmVxdWVzdGVkVXBkYXRlOiBib29sZWFuKSB7fVxuXG4gIC8qKlxuICAgKiBBbGxvd3MgZm9yIGBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpYCBpbiBleHRlbnNpb25zIHdoaWxlXG4gICAqIHJlc2VydmluZyB0aGUgcG9zc2liaWxpdHkgb2YgbWFraW5nIG5vbi1icmVha2luZyBmZWF0dXJlIGFkZGl0aW9uc1xuICAgKiB3aGVuIGRpc2Nvbm5lY3RpbmcgYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLlxuICAgKiBAY2F0ZWdvcnkgbGlmZWN5Y2xlXG4gICAqL1xuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9fY29udHJvbGxlcnM/LmZvckVhY2goKGMpID0+IGMuaG9zdERpc2Nvbm5lY3RlZD8uKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN5bmNocm9uaXplcyBwcm9wZXJ0eSB2YWx1ZXMgd2hlbiBhdHRyaWJ1dGVzIGNoYW5nZS5cbiAgICpcbiAgICogU3BlY2lmaWNhbGx5LCB3aGVuIGFuIGF0dHJpYnV0ZSBpcyBzZXQsIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IGlzIHNldC5cbiAgICogWW91IHNob3VsZCByYXJlbHkgbmVlZCB0byBpbXBsZW1lbnQgdGhpcyBjYWxsYmFjay4gSWYgdGhpcyBtZXRob2QgaXNcbiAgICogb3ZlcnJpZGRlbiwgYHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBfb2xkLCB2YWx1ZSlgIG11c3QgYmVcbiAgICogY2FsbGVkLlxuICAgKlxuICAgKiBTZWUgW3VzaW5nIHRoZSBsaWZlY3ljbGUgY2FsbGJhY2tzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9XZWJfQ29tcG9uZW50cy9Vc2luZ19jdXN0b21fZWxlbWVudHMjdXNpbmdfdGhlX2xpZmVjeWNsZV9jYWxsYmFja3MpXG4gICAqIG9uIE1ETiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AuXG4gICAqIEBjYXRlZ29yeSBhdHRyaWJ1dGVzXG4gICAqL1xuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soXG4gICAgbmFtZTogc3RyaW5nLFxuICAgIF9vbGQ6IHN0cmluZyB8IG51bGwsXG4gICAgdmFsdWU6IHN0cmluZyB8IG51bGxcbiAgKSB7XG4gICAgdGhpcy5fJGF0dHJpYnV0ZVRvUHJvcGVydHkobmFtZSwgdmFsdWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBfX3Byb3BlcnR5VG9BdHRyaWJ1dGUoXG4gICAgbmFtZTogUHJvcGVydHlLZXksXG4gICAgdmFsdWU6IHVua25vd24sXG4gICAgb3B0aW9uczogUHJvcGVydHlEZWNsYXJhdGlvbiA9IGRlZmF1bHRQcm9wZXJ0eURlY2xhcmF0aW9uXG4gICkge1xuICAgIGNvbnN0IGF0dHIgPSAoXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yIGFzIHR5cGVvZiBSZWFjdGl2ZUVsZW1lbnRcbiAgICApLl9fYXR0cmlidXRlTmFtZUZvclByb3BlcnR5KG5hbWUsIG9wdGlvbnMpO1xuICAgIGlmIChhdHRyICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZWZsZWN0ID09PSB0cnVlKSB7XG4gICAgICBjb25zdCBjb252ZXJ0ZXIgPVxuICAgICAgICAob3B0aW9ucy5jb252ZXJ0ZXIgYXMgQ29tcGxleEF0dHJpYnV0ZUNvbnZlcnRlcik/LnRvQXR0cmlidXRlICE9PVxuICAgICAgICB1bmRlZmluZWRcbiAgICAgICAgICA/IChvcHRpb25zLmNvbnZlcnRlciBhcyBDb21wbGV4QXR0cmlidXRlQ29udmVydGVyKVxuICAgICAgICAgIDogZGVmYXVsdENvbnZlcnRlcjtcbiAgICAgIGNvbnN0IGF0dHJWYWx1ZSA9IGNvbnZlcnRlci50b0F0dHJpYnV0ZSEodmFsdWUsIG9wdGlvbnMudHlwZSk7XG4gICAgICBpZiAoXG4gICAgICAgIERFVl9NT0RFICYmXG4gICAgICAgICh0aGlzLmNvbnN0cnVjdG9yIGFzIHR5cGVvZiBSZWFjdGl2ZUVsZW1lbnQpLmVuYWJsZWRXYXJuaW5ncyEuaW5kZXhPZihcbiAgICAgICAgICAnbWlncmF0aW9uJ1xuICAgICAgICApID49IDAgJiZcbiAgICAgICAgYXR0clZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgICkge1xuICAgICAgICBpc3N1ZVdhcm5pbmcoXG4gICAgICAgICAgJ3VuZGVmaW5lZC1hdHRyaWJ1dGUtdmFsdWUnLFxuICAgICAgICAgIGBUaGUgYXR0cmlidXRlIHZhbHVlIGZvciB0aGUgJHtuYW1lIGFzIHN0cmluZ30gcHJvcGVydHkgaXMgYCArXG4gICAgICAgICAgICBgdW5kZWZpbmVkIG9uIGVsZW1lbnQgJHt0aGlzLmxvY2FsTmFtZX0uIFRoZSBhdHRyaWJ1dGUgd2lsbCBiZSBgICtcbiAgICAgICAgICAgIGByZW1vdmVkLCBidXQgaW4gdGhlIHByZXZpb3VzIHZlcnNpb24gb2YgXFxgUmVhY3RpdmVFbGVtZW50XFxgLCBgICtcbiAgICAgICAgICAgIGB0aGUgYXR0cmlidXRlIHdvdWxkIG5vdCBoYXZlIGNoYW5nZWQuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLy8gVHJhY2sgaWYgdGhlIHByb3BlcnR5IGlzIGJlaW5nIHJlZmxlY3RlZCB0byBhdm9pZFxuICAgICAgLy8gc2V0dGluZyB0aGUgcHJvcGVydHkgYWdhaW4gdmlhIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgLiBOb3RlOlxuICAgICAgLy8gMS4gdGhpcyB0YWtlcyBhZHZhbnRhZ2Ugb2YgdGhlIGZhY3QgdGhhdCB0aGUgY2FsbGJhY2sgaXMgc3luY2hyb25vdXMuXG4gICAgICAvLyAyLiB3aWxsIGJlaGF2ZSBpbmNvcnJlY3RseSBpZiBtdWx0aXBsZSBhdHRyaWJ1dGVzIGFyZSBpbiB0aGUgcmVhY3Rpb25cbiAgICAgIC8vIHN0YWNrIGF0IHRpbWUgb2YgY2FsbGluZy4gSG93ZXZlciwgc2luY2Ugd2UgcHJvY2VzcyBhdHRyaWJ1dGVzXG4gICAgICAvLyBpbiBgdXBkYXRlYCB0aGlzIHNob3VsZCBub3QgYmUgcG9zc2libGUgKG9yIGFuIGV4dHJlbWUgY29ybmVyIGNhc2VcbiAgICAgIC8vIHRoYXQgd2UnZCBsaWtlIHRvIGRpc2NvdmVyKS5cbiAgICAgIC8vIG1hcmsgc3RhdGUgcmVmbGVjdGluZ1xuICAgICAgdGhpcy5fX3JlZmxlY3RpbmdQcm9wZXJ0eSA9IG5hbWU7XG4gICAgICBpZiAoYXR0clZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyVmFsdWUgYXMgc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIC8vIG1hcmsgc3RhdGUgbm90IHJlZmxlY3RpbmdcbiAgICAgIHRoaXMuX19yZWZsZWN0aW5nUHJvcGVydHkgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgXyRhdHRyaWJ1dGVUb1Byb3BlcnR5KG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IG51bGwpIHtcbiAgICBjb25zdCBjdG9yID0gdGhpcy5jb25zdHJ1Y3RvciBhcyB0eXBlb2YgUmVhY3RpdmVFbGVtZW50O1xuICAgIC8vIE5vdGUsIGhpbnQgdGhpcyBhcyBhbiBgQXR0cmlidXRlTWFwYCBzbyBjbG9zdXJlIGNsZWFybHkgdW5kZXJzdGFuZHNcbiAgICAvLyB0aGUgdHlwZTsgaXQgaGFzIGlzc3VlcyB3aXRoIHRyYWNraW5nIHR5cGVzIHRocm91Z2ggc3RhdGljc1xuICAgIGNvbnN0IHByb3BOYW1lID0gKGN0b3IuX19hdHRyaWJ1dGVUb1Byb3BlcnR5TWFwIGFzIEF0dHJpYnV0ZU1hcCkuZ2V0KG5hbWUpO1xuICAgIC8vIFVzZSB0cmFja2luZyBpbmZvIHRvIGF2b2lkIHJlZmxlY3RpbmcgYSBwcm9wZXJ0eSB2YWx1ZSB0byBhbiBhdHRyaWJ1dGVcbiAgICAvLyBpZiBpdCB3YXMganVzdCBzZXQgYmVjYXVzZSB0aGUgYXR0cmlidXRlIGNoYW5nZWQuXG4gICAgaWYgKHByb3BOYW1lICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fX3JlZmxlY3RpbmdQcm9wZXJ0eSAhPT0gcHJvcE5hbWUpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBjdG9yLmdldFByb3BlcnR5T3B0aW9ucyhwcm9wTmFtZSk7XG4gICAgICBjb25zdCBjb252ZXJ0ZXIgPVxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5jb252ZXJ0ZXIgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICA/IHtmcm9tQXR0cmlidXRlOiBvcHRpb25zLmNvbnZlcnRlcn1cbiAgICAgICAgICA6IG9wdGlvbnMuY29udmVydGVyPy5mcm9tQXR0cmlidXRlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IG9wdGlvbnMuY29udmVydGVyXG4gICAgICAgICAgOiBkZWZhdWx0Q29udmVydGVyO1xuICAgICAgLy8gbWFyayBzdGF0ZSByZWZsZWN0aW5nXG4gICAgICB0aGlzLl9fcmVmbGVjdGluZ1Byb3BlcnR5ID0gcHJvcE5hbWU7XG4gICAgICB0aGlzW3Byb3BOYW1lIGFzIGtleW9mIHRoaXNdID0gY29udmVydGVyLmZyb21BdHRyaWJ1dGUhKFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb3B0aW9ucy50eXBlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICApIGFzIGFueTtcbiAgICAgIC8vIG1hcmsgc3RhdGUgbm90IHJlZmxlY3RpbmdcbiAgICAgIHRoaXMuX19yZWZsZWN0aW5nUHJvcGVydHkgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0cyBhbiB1cGRhdGUgd2hpY2ggaXMgcHJvY2Vzc2VkIGFzeW5jaHJvbm91c2x5LiBUaGlzIHNob3VsZCBiZSBjYWxsZWRcbiAgICogd2hlbiBhbiBlbGVtZW50IHNob3VsZCB1cGRhdGUgYmFzZWQgb24gc29tZSBzdGF0ZSBub3QgdHJpZ2dlcmVkIGJ5IHNldHRpbmdcbiAgICogYSByZWFjdGl2ZSBwcm9wZXJ0eS4gSW4gdGhpcyBjYXNlLCBwYXNzIG5vIGFyZ3VtZW50cy4gSXQgc2hvdWxkIGFsc28gYmVcbiAgICogY2FsbGVkIHdoZW4gbWFudWFsbHkgaW1wbGVtZW50aW5nIGEgcHJvcGVydHkgc2V0dGVyLiBJbiB0aGlzIGNhc2UsIHBhc3MgdGhlXG4gICAqIHByb3BlcnR5IGBuYW1lYCBhbmQgYG9sZFZhbHVlYCB0byBlbnN1cmUgdGhhdCBhbnkgY29uZmlndXJlZCBwcm9wZXJ0eVxuICAgKiBvcHRpb25zIGFyZSBob25vcmVkLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBuYW1lIG9mIHJlcXVlc3RpbmcgcHJvcGVydHlcbiAgICogQHBhcmFtIG9sZFZhbHVlIG9sZCB2YWx1ZSBvZiByZXF1ZXN0aW5nIHByb3BlcnR5XG4gICAqIEBwYXJhbSBvcHRpb25zIHByb3BlcnR5IG9wdGlvbnMgdG8gdXNlIGluc3RlYWQgb2YgdGhlIHByZXZpb3VzbHlcbiAgICogICAgIGNvbmZpZ3VyZWQgb3B0aW9uc1xuICAgKiBAY2F0ZWdvcnkgdXBkYXRlc1xuICAgKi9cbiAgcmVxdWVzdFVwZGF0ZShcbiAgICBuYW1lPzogUHJvcGVydHlLZXksXG4gICAgb2xkVmFsdWU/OiB1bmtub3duLFxuICAgIG9wdGlvbnM/OiBQcm9wZXJ0eURlY2xhcmF0aW9uXG4gICk6IHZvaWQge1xuICAgIGxldCBzaG91bGRSZXF1ZXN0VXBkYXRlID0gdHJ1ZTtcbiAgICAvLyBJZiB3ZSBoYXZlIGEgcHJvcGVydHkga2V5LCBwZXJmb3JtIHByb3BlcnR5IHVwZGF0ZSBzdGVwcy5cbiAgICBpZiAobmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zID1cbiAgICAgICAgb3B0aW9ucyB8fFxuICAgICAgICAodGhpcy5jb25zdHJ1Y3RvciBhcyB0eXBlb2YgUmVhY3RpdmVFbGVtZW50KS5nZXRQcm9wZXJ0eU9wdGlvbnMobmFtZSk7XG4gICAgICBjb25zdCBoYXNDaGFuZ2VkID0gb3B0aW9ucy5oYXNDaGFuZ2VkIHx8IG5vdEVxdWFsO1xuICAgICAgaWYgKGhhc0NoYW5nZWQodGhpc1tuYW1lIGFzIGtleW9mIHRoaXNdLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl8kY2hhbmdlZFByb3BlcnRpZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgdGhpcy5fJGNoYW5nZWRQcm9wZXJ0aWVzLnNldChuYW1lLCBvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRvIHJlZmxlY3RpbmcgcHJvcGVydGllcyBzZXQuXG4gICAgICAgIC8vIE5vdGUsIGl0J3MgaW1wb3J0YW50IHRoYXQgZXZlcnkgY2hhbmdlIGhhcyBhIGNoYW5jZSB0byBhZGQgdGhlXG4gICAgICAgIC8vIHByb3BlcnR5IHRvIGBfcmVmbGVjdGluZ1Byb3BlcnRpZXNgLiBUaGlzIGVuc3VyZXMgc2V0dGluZ1xuICAgICAgICAvLyBhdHRyaWJ1dGUgKyBwcm9wZXJ0eSByZWZsZWN0cyBjb3JyZWN0bHkuXG4gICAgICAgIGlmIChvcHRpb25zLnJlZmxlY3QgPT09IHRydWUgJiYgdGhpcy5fX3JlZmxlY3RpbmdQcm9wZXJ0eSAhPT0gbmFtZSkge1xuICAgICAgICAgIGlmICh0aGlzLl9fcmVmbGVjdGluZ1Byb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fX3JlZmxlY3RpbmdQcm9wZXJ0aWVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9fcmVmbGVjdGluZ1Byb3BlcnRpZXMuc2V0KG5hbWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBYm9ydCB0aGUgcmVxdWVzdCBpZiB0aGUgcHJvcGVydHkgc2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIGNoYW5nZWQuXG4gICAgICAgIHNob3VsZFJlcXVlc3RVcGRhdGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzVXBkYXRlUGVuZGluZyAmJiBzaG91bGRSZXF1ZXN0VXBkYXRlKSB7XG4gICAgICB0aGlzLl9fdXBkYXRlUHJvbWlzZSA9IHRoaXMuX19lbnF1ZXVlVXBkYXRlKCk7XG4gICAgfVxuICAgIC8vIE5vdGUsIHNpbmNlIHRoaXMgbm8gbG9uZ2VyIHJldHVybnMgYSBwcm9taXNlLCBpbiBkZXYgbW9kZSB3ZSByZXR1cm4gYVxuICAgIC8vIHRoZW5hYmxlIHdoaWNoIHdhcm5zIGlmIGl0J3MgY2FsbGVkLlxuICAgIHJldHVybiBERVZfTU9ERVxuICAgICAgPyAocmVxdWVzdFVwZGF0ZVRoZW5hYmxlKHRoaXMubG9jYWxOYW1lKSBhcyB1bmtub3duIGFzIHZvaWQpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoZSBlbGVtZW50IHRvIGFzeW5jaHJvbm91c2x5IHVwZGF0ZS5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX19lbnF1ZXVlVXBkYXRlKCkge1xuICAgIHRoaXMuaXNVcGRhdGVQZW5kaW5nID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgLy8gRW5zdXJlIGFueSBwcmV2aW91cyB1cGRhdGUgaGFzIHJlc29sdmVkIGJlZm9yZSB1cGRhdGluZy5cbiAgICAgIC8vIFRoaXMgYGF3YWl0YCBhbHNvIGVuc3VyZXMgdGhhdCBwcm9wZXJ0eSBjaGFuZ2VzIGFyZSBiYXRjaGVkLlxuICAgICAgYXdhaXQgdGhpcy5fX3VwZGF0ZVByb21pc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gUmVmaXJlIGFueSBwcmV2aW91cyBlcnJvcnMgYXN5bmMgc28gdGhleSBkbyBub3QgZGlzcnVwdCB0aGUgdXBkYXRlXG4gICAgICAvLyBjeWNsZS4gRXJyb3JzIGFyZSByZWZpcmVkIHNvIGRldmVsb3BlcnMgaGF2ZSBhIGNoYW5jZSB0byBvYnNlcnZlXG4gICAgICAvLyB0aGVtLCBhbmQgdGhpcyBjYW4gYmUgZG9uZSBieSBpbXBsZW1lbnRpbmdcbiAgICAgIC8vIGB3aW5kb3cub251bmhhbmRsZWRyZWplY3Rpb25gLlxuICAgICAgUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc2NoZWR1bGVVcGRhdGUoKTtcbiAgICAvLyBJZiBgc2NoZWR1bGVVcGRhdGVgIHJldHVybnMgYSBQcm9taXNlLCB3ZSBhd2FpdCBpdC4gVGhpcyBpcyBkb25lIHRvXG4gICAgLy8gZW5hYmxlIGNvb3JkaW5hdGluZyB1cGRhdGVzIHdpdGggYSBzY2hlZHVsZXIuIE5vdGUsIHRoZSByZXN1bHQgaXNcbiAgICAvLyBjaGVja2VkIHRvIGF2b2lkIGRlbGF5aW5nIGFuIGFkZGl0aW9uYWwgbWljcm90YXNrIHVubGVzcyB3ZSBuZWVkIHRvLlxuICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgYXdhaXQgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gIXRoaXMuaXNVcGRhdGVQZW5kaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlcyBhbiBlbGVtZW50IHVwZGF0ZS4gWW91IGNhbiBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlXG4gICAqIHRpbWluZyBvZiB1cGRhdGVzIGJ5IHJldHVybmluZyBhIFByb21pc2UuIFRoZSB1cGRhdGUgd2lsbCBhd2FpdCB0aGVcbiAgICogcmV0dXJuZWQgUHJvbWlzZSwgYW5kIHlvdSBzaG91bGQgcmVzb2x2ZSB0aGUgUHJvbWlzZSB0byBhbGxvdyB0aGUgdXBkYXRlXG4gICAqIHRvIHByb2NlZWQuIElmIHRoaXMgbWV0aG9kIGlzIG92ZXJyaWRkZW4sIGBzdXBlci5zY2hlZHVsZVVwZGF0ZSgpYFxuICAgKiBtdXN0IGJlIGNhbGxlZC5cbiAgICpcbiAgICogRm9yIGluc3RhbmNlLCB0byBzY2hlZHVsZSB1cGRhdGVzIHRvIG9jY3VyIGp1c3QgYmVmb3JlIHRoZSBuZXh0IGZyYW1lOlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBvdmVycmlkZSBwcm90ZWN0ZWQgYXN5bmMgc2NoZWR1bGVVcGRhdGUoKTogUHJvbWlzZTx1bmtub3duPiB7XG4gICAqICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiByZXNvbHZlKCkpKTtcbiAgICogICBzdXBlci5zY2hlZHVsZVVwZGF0ZSgpO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKiBAY2F0ZWdvcnkgdXBkYXRlc1xuICAgKi9cbiAgcHJvdGVjdGVkIHNjaGVkdWxlVXBkYXRlKCk6IHZvaWQgfCBQcm9taXNlPHVua25vd24+IHtcbiAgICByZXR1cm4gdGhpcy5wZXJmb3JtVXBkYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYW4gZWxlbWVudCB1cGRhdGUuIE5vdGUsIGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZHVyaW5nIHRoZVxuICAgKiB1cGRhdGUsIGBmaXJzdFVwZGF0ZWRgIGFuZCBgdXBkYXRlZGAgd2lsbCBub3QgYmUgY2FsbGVkLlxuICAgKlxuICAgKiBDYWxsIGBwZXJmb3JtVXBkYXRlKClgIHRvIGltbWVkaWF0ZWx5IHByb2Nlc3MgYSBwZW5kaW5nIHVwZGF0ZS4gVGhpcyBzaG91bGRcbiAgICogZ2VuZXJhbGx5IG5vdCBiZSBuZWVkZWQsIGJ1dCBpdCBjYW4gYmUgZG9uZSBpbiByYXJlIGNhc2VzIHdoZW4geW91IG5lZWQgdG9cbiAgICogdXBkYXRlIHN5bmNocm9ub3VzbHkuXG4gICAqXG4gICAqIE5vdGU6IFRvIGVuc3VyZSBgcGVyZm9ybVVwZGF0ZSgpYCBzeW5jaHJvbm91c2x5IGNvbXBsZXRlcyBhIHBlbmRpbmcgdXBkYXRlLFxuICAgKiBpdCBzaG91bGQgbm90IGJlIG92ZXJyaWRkZW4uIEluIExpdEVsZW1lbnQgMi54IGl0IHdhcyBzdWdnZXN0ZWQgdG8gb3ZlcnJpZGVcbiAgICogYHBlcmZvcm1VcGRhdGUoKWAgdG8gYWxzbyBjdXN0b21pemluZyB1cGRhdGUgc2NoZWR1bGluZy4gSW5zdGVhZCwgeW91IHNob3VsZCBub3dcbiAgICogb3ZlcnJpZGUgYHNjaGVkdWxlVXBkYXRlKClgLiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBMaXRFbGVtZW50IDIueCxcbiAgICogc2NoZWR1bGluZyB1cGRhdGVzIHZpYSBgcGVyZm9ybVVwZGF0ZSgpYCBjb250aW51ZXMgdG8gd29yaywgYnV0IHdpbGwgbWFrZVxuICAgKiBhbHNvIGNhbGxpbmcgYHBlcmZvcm1VcGRhdGUoKWAgdG8gc3luY2hyb25vdXNseSBwcm9jZXNzIHVwZGF0ZXMgZGlmZmljdWx0LlxuICAgKlxuICAgKiBAY2F0ZWdvcnkgdXBkYXRlc1xuICAgKi9cbiAgcHJvdGVjdGVkIHBlcmZvcm1VcGRhdGUoKTogdm9pZCB8IFByb21pc2U8dW5rbm93bj4ge1xuICAgIC8vIEFib3J0IGFueSB1cGRhdGUgaWYgb25lIGlzIG5vdCBwZW5kaW5nIHdoZW4gdGhpcyBpcyBjYWxsZWQuXG4gICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIGBwZXJmb3JtVXBkYXRlYCBpcyBjYWxsZWQgZWFybHkgdG8gXCJmbHVzaFwiXG4gICAgLy8gdGhlIHVwZGF0ZS5cbiAgICBpZiAoIXRoaXMuaXNVcGRhdGVQZW5kaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlYnVnTG9nRXZlbnQ/Lih7a2luZDogJ3VwZGF0ZSd9KTtcbiAgICAvLyBjcmVhdGUgcmVuZGVyUm9vdCBiZWZvcmUgZmlyc3QgdXBkYXRlLlxuICAgIGlmICghdGhpcy5oYXNVcGRhdGVkKSB7XG4gICAgICAvLyBQcm9kdWNlIHdhcm5pbmcgaWYgYW55IGNsYXNzIHByb3BlcnRpZXMgYXJlIHNoYWRvd2VkIGJ5IGNsYXNzIGZpZWxkc1xuICAgICAgaWYgKERFVl9NT0RFKSB7XG4gICAgICAgIGNvbnN0IHNoYWRvd2VkUHJvcGVydGllczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgKFxuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IgYXMgdHlwZW9mIFJlYWN0aXZlRWxlbWVudFxuICAgICAgICApLl9fcmVhY3RpdmVQcm9wZXJ0eUtleXM/LmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShwKSAmJiAhdGhpcy5fX2luc3RhbmNlUHJvcGVydGllcz8uaGFzKHApKSB7XG4gICAgICAgICAgICBzaGFkb3dlZFByb3BlcnRpZXMucHVzaChwIGFzIHN0cmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNoYWRvd2VkUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIG9uIGVsZW1lbnQgJHt0aGlzLmxvY2FsTmFtZX0gd2lsbCBub3QgYCArXG4gICAgICAgICAgICAgIGB0cmlnZ2VyIHVwZGF0ZXMgYXMgZXhwZWN0ZWQgYmVjYXVzZSB0aGV5IGFyZSBzZXQgdXNpbmcgY2xhc3MgYCArXG4gICAgICAgICAgICAgIGBmaWVsZHM6ICR7c2hhZG93ZWRQcm9wZXJ0aWVzLmpvaW4oJywgJyl9LiBgICtcbiAgICAgICAgICAgICAgYE5hdGl2ZSBjbGFzcyBmaWVsZHMgYW5kIHNvbWUgY29tcGlsZWQgb3V0cHV0IHdpbGwgb3ZlcndyaXRlIGAgK1xuICAgICAgICAgICAgICBgYWNjZXNzb3JzIHVzZWQgZm9yIGRldGVjdGluZyBjaGFuZ2VzLiBTZWUgYCArXG4gICAgICAgICAgICAgIGBodHRwczovL2xpdC5kZXYvbXNnL2NsYXNzLWZpZWxkLXNoYWRvd2luZyBgICtcbiAgICAgICAgICAgICAgYGZvciBtb3JlIGluZm9ybWF0aW9uLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE1peGluIGluc3RhbmNlIHByb3BlcnRpZXMgb25jZSwgaWYgdGhleSBleGlzdC5cbiAgICBpZiAodGhpcy5fX2luc3RhbmNlUHJvcGVydGllcykge1xuICAgICAgLy8gVXNlIGZvckVhY2ggc28gdGhpcyB3b3JrcyBldmVuIGlmIGZvci9vZiBsb29wcyBhcmUgY29tcGlsZWQgdG8gZm9yIGxvb3BzXG4gICAgICAvLyBleHBlY3RpbmcgYXJyYXlzXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgdGhpcy5fX2luc3RhbmNlUHJvcGVydGllcyEuZm9yRWFjaCgodiwgcCkgPT4gKCh0aGlzIGFzIGFueSlbcF0gPSB2KSk7XG4gICAgICB0aGlzLl9faW5zdGFuY2VQcm9wZXJ0aWVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgc2hvdWxkVXBkYXRlID0gZmFsc2U7XG4gICAgY29uc3QgY2hhbmdlZFByb3BlcnRpZXMgPSB0aGlzLl8kY2hhbmdlZFByb3BlcnRpZXM7XG4gICAgdHJ5IHtcbiAgICAgIHNob3VsZFVwZGF0ZSA9IHRoaXMuc2hvdWxkVXBkYXRlKGNoYW5nZWRQcm9wZXJ0aWVzKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgdGhpcy53aWxsVXBkYXRlKGNoYW5nZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgdGhpcy5fX2NvbnRyb2xsZXJzPy5mb3JFYWNoKChjKSA9PiBjLmhvc3RVcGRhdGU/LigpKTtcbiAgICAgICAgdGhpcy51cGRhdGUoY2hhbmdlZFByb3BlcnRpZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX21hcmtVcGRhdGVkKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gUHJldmVudCBgZmlyc3RVcGRhdGVkYCBhbmQgYHVwZGF0ZWRgIGZyb20gcnVubmluZyB3aGVuIHRoZXJlJ3MgYW5cbiAgICAgIC8vIHVwZGF0ZSBleGNlcHRpb24uXG4gICAgICBzaG91bGRVcGRhdGUgPSBmYWxzZTtcbiAgICAgIC8vIEVuc3VyZSBlbGVtZW50IGNhbiBhY2NlcHQgYWRkaXRpb25hbCB1cGRhdGVzIGFmdGVyIGFuIGV4Y2VwdGlvbi5cbiAgICAgIHRoaXMuX19tYXJrVXBkYXRlZCgpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgLy8gVGhlIHVwZGF0ZSBpcyBubyBsb25nZXIgY29uc2lkZXJlZCBwZW5kaW5nIGFuZCBmdXJ0aGVyIHVwZGF0ZXMgYXJlIG5vdyBhbGxvd2VkLlxuICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgIHRoaXMuXyRkaWRVcGRhdGUoY2hhbmdlZFByb3BlcnRpZXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGJlZm9yZSBgdXBkYXRlKClgIHRvIGNvbXB1dGUgdmFsdWVzIG5lZWRlZCBkdXJpbmcgdGhlIHVwZGF0ZS5cbiAgICpcbiAgICogSW1wbGVtZW50IGB3aWxsVXBkYXRlYCB0byBjb21wdXRlIHByb3BlcnR5IHZhbHVlcyB0aGF0IGRlcGVuZCBvbiBvdGhlclxuICAgKiBwcm9wZXJ0aWVzIGFuZCBhcmUgdXNlZCBpbiB0aGUgcmVzdCBvZiB0aGUgdXBkYXRlIHByb2Nlc3MuXG4gICAqXG4gICAqIGBgYHRzXG4gICAqIHdpbGxVcGRhdGUoY2hhbmdlZFByb3BlcnRpZXMpIHtcbiAgICogICAvLyBvbmx5IG5lZWQgdG8gY2hlY2sgY2hhbmdlZCBwcm9wZXJ0aWVzIGZvciBhbiBleHBlbnNpdmUgY29tcHV0YXRpb24uXG4gICAqICAgaWYgKGNoYW5nZWRQcm9wZXJ0aWVzLmhhcygnZmlyc3ROYW1lJykgfHwgY2hhbmdlZFByb3BlcnRpZXMuaGFzKCdsYXN0TmFtZScpKSB7XG4gICAqICAgICB0aGlzLnNoYSA9IGNvbXB1dGVTSEEoYCR7dGhpcy5maXJzdE5hbWV9ICR7dGhpcy5sYXN0TmFtZX1gKTtcbiAgICogICB9XG4gICAqIH1cbiAgICpcbiAgICogcmVuZGVyKCkge1xuICAgKiAgIHJldHVybiBodG1sYFNIQTogJHt0aGlzLnNoYX1gO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBAY2F0ZWdvcnkgdXBkYXRlc1xuICAgKi9cbiAgcHJvdGVjdGVkIHdpbGxVcGRhdGUoX2NoYW5nZWRQcm9wZXJ0aWVzOiBQcm9wZXJ0eVZhbHVlcyk6IHZvaWQge31cblxuICAvLyBOb3RlLCB0aGlzIGlzIGFuIG92ZXJyaWRlIHBvaW50IGZvciBwb2x5ZmlsbC1zdXBwb3J0LlxuICAvLyBAaW50ZXJuYWxcbiAgXyRkaWRVcGRhdGUoY2hhbmdlZFByb3BlcnRpZXM6IFByb3BlcnR5VmFsdWVzKSB7XG4gICAgdGhpcy5fX2NvbnRyb2xsZXJzPy5mb3JFYWNoKChjKSA9PiBjLmhvc3RVcGRhdGVkPy4oKSk7XG4gICAgaWYgKCF0aGlzLmhhc1VwZGF0ZWQpIHtcbiAgICAgIHRoaXMuaGFzVXBkYXRlZCA9IHRydWU7XG4gICAgICB0aGlzLmZpcnN0VXBkYXRlZChjaGFuZ2VkUHJvcGVydGllcyk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlZChjaGFuZ2VkUHJvcGVydGllcyk7XG4gICAgaWYgKFxuICAgICAgREVWX01PREUgJiZcbiAgICAgIHRoaXMuaXNVcGRhdGVQZW5kaW5nICYmXG4gICAgICAodGhpcy5jb25zdHJ1Y3RvciBhcyB0eXBlb2YgUmVhY3RpdmVFbGVtZW50KS5lbmFibGVkV2FybmluZ3MhLmluZGV4T2YoXG4gICAgICAgICdjaGFuZ2UtaW4tdXBkYXRlJ1xuICAgICAgKSA+PSAwXG4gICAgKSB7XG4gICAgICBpc3N1ZVdhcm5pbmcoXG4gICAgICAgICdjaGFuZ2UtaW4tdXBkYXRlJyxcbiAgICAgICAgYEVsZW1lbnQgJHt0aGlzLmxvY2FsTmFtZX0gc2NoZWR1bGVkIGFuIHVwZGF0ZSBgICtcbiAgICAgICAgICBgKGdlbmVyYWxseSBiZWNhdXNlIGEgcHJvcGVydHkgd2FzIHNldCkgYCArXG4gICAgICAgICAgYGFmdGVyIGFuIHVwZGF0ZSBjb21wbGV0ZWQsIGNhdXNpbmcgYSBuZXcgdXBkYXRlIHRvIGJlIHNjaGVkdWxlZC4gYCArXG4gICAgICAgICAgYFRoaXMgaXMgaW5lZmZpY2llbnQgYW5kIHNob3VsZCBiZSBhdm9pZGVkIHVubGVzcyB0aGUgbmV4dCB1cGRhdGUgYCArXG4gICAgICAgICAgYGNhbiBvbmx5IGJlIHNjaGVkdWxlZCBhcyBhIHNpZGUgZWZmZWN0IG9mIHRoZSBwcmV2aW91cyB1cGRhdGUuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9fbWFya1VwZGF0ZWQoKSB7XG4gICAgdGhpcy5fJGNoYW5nZWRQcm9wZXJ0aWVzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuaXNVcGRhdGVQZW5kaW5nID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBlbGVtZW50IGhhcyBjb21wbGV0ZWQgdXBkYXRpbmcuXG4gICAqIFRoZSBQcm9taXNlIHZhbHVlIGlzIGEgYm9vbGVhbiB0aGF0IGlzIGB0cnVlYCBpZiB0aGUgZWxlbWVudCBjb21wbGV0ZWQgdGhlXG4gICAqIHVwZGF0ZSB3aXRob3V0IHRyaWdnZXJpbmcgYW5vdGhlciB1cGRhdGUuIFRoZSBQcm9taXNlIHJlc3VsdCBpcyBgZmFsc2VgIGlmXG4gICAqIGEgcHJvcGVydHkgd2FzIHNldCBpbnNpZGUgYHVwZGF0ZWQoKWAuIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBhblxuICAgKiBleGNlcHRpb24gd2FzIHRocm93biBkdXJpbmcgdGhlIHVwZGF0ZS5cbiAgICpcbiAgICogVG8gYXdhaXQgYWRkaXRpb25hbCBhc3luY2hyb25vdXMgd29yaywgb3ZlcnJpZGUgdGhlIGBnZXRVcGRhdGVDb21wbGV0ZWBcbiAgICogbWV0aG9kLiBGb3IgZXhhbXBsZSwgaXQgaXMgc29tZXRpbWVzIHVzZWZ1bCB0byBhd2FpdCBhIHJlbmRlcmVkIGVsZW1lbnRcbiAgICogYmVmb3JlIGZ1bGZpbGxpbmcgdGhpcyBQcm9taXNlLiBUbyBkbyB0aGlzLCBmaXJzdCBhd2FpdFxuICAgKiBgc3VwZXIuZ2V0VXBkYXRlQ29tcGxldGUoKWAsIHRoZW4gYW55IHN1YnNlcXVlbnQgc3RhdGUuXG4gICAqXG4gICAqIEByZXR1cm4gQSBwcm9taXNlIG9mIGEgYm9vbGVhbiB0aGF0IHJlc29sdmVzIHRvIHRydWUgaWYgdGhlIHVwZGF0ZSBjb21wbGV0ZWRcbiAgICogICAgIHdpdGhvdXQgdHJpZ2dlcmluZyBhbm90aGVyIHVwZGF0ZS5cbiAgICogQGNhdGVnb3J5IHVwZGF0ZXNcbiAgICovXG4gIGdldCB1cGRhdGVDb21wbGV0ZSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5nZXRVcGRhdGVDb21wbGV0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHBvaW50IGZvciB0aGUgYHVwZGF0ZUNvbXBsZXRlYCBwcm9taXNlLlxuICAgKlxuICAgKiBJdCBpcyBub3Qgc2FmZSB0byBvdmVycmlkZSB0aGUgYHVwZGF0ZUNvbXBsZXRlYCBnZXR0ZXIgZGlyZWN0bHkgZHVlIHRvIGFcbiAgICogbGltaXRhdGlvbiBpbiBUeXBlU2NyaXB0IHdoaWNoIG1lYW5zIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBjYWxsIGFcbiAgICogc3VwZXJjbGFzcyBnZXR0ZXIgKGUuZy4gYHN1cGVyLnVwZGF0ZUNvbXBsZXRlLnRoZW4oLi4uKWApIHdoZW4gdGhlIHRhcmdldFxuICAgKiBsYW5ndWFnZSBpcyBFUzUgKGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzM4KS5cbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW4gaW5zdGVhZC4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqIGBgYHRzXG4gICAqIGNsYXNzIE15RWxlbWVudCBleHRlbmRzIExpdEVsZW1lbnQge1xuICAgKiAgIG92ZXJyaWRlIGFzeW5jIGdldFVwZGF0ZUNvbXBsZXRlKCkge1xuICAgKiAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3VwZXIuZ2V0VXBkYXRlQ29tcGxldGUoKTtcbiAgICogICAgIGF3YWl0IHRoaXMuX215Q2hpbGQudXBkYXRlQ29tcGxldGU7XG4gICAqICAgICByZXR1cm4gcmVzdWx0O1xuICAgKiAgIH1cbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybiBBIHByb21pc2Ugb2YgYSBib29sZWFuIHRoYXQgcmVzb2x2ZXMgdG8gdHJ1ZSBpZiB0aGUgdXBkYXRlIGNvbXBsZXRlZFxuICAgKiAgICAgd2l0aG91dCB0cmlnZ2VyaW5nIGFub3RoZXIgdXBkYXRlLlxuICAgKiBAY2F0ZWdvcnkgdXBkYXRlc1xuICAgKi9cbiAgcHJvdGVjdGVkIGdldFVwZGF0ZUNvbXBsZXRlKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLl9fdXBkYXRlUHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb250cm9scyB3aGV0aGVyIG9yIG5vdCBgdXBkYXRlKClgIHNob3VsZCBiZSBjYWxsZWQgd2hlbiB0aGUgZWxlbWVudCByZXF1ZXN0c1xuICAgKiBhbiB1cGRhdGUuIEJ5IGRlZmF1bHQsIHRoaXMgbWV0aG9kIGFsd2F5cyByZXR1cm5zIGB0cnVlYCwgYnV0IHRoaXMgY2FuIGJlXG4gICAqIGN1c3RvbWl6ZWQgdG8gY29udHJvbCB3aGVuIHRvIHVwZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIF9jaGFuZ2VkUHJvcGVydGllcyBNYXAgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzIHdpdGggb2xkIHZhbHVlc1xuICAgKiBAY2F0ZWdvcnkgdXBkYXRlc1xuICAgKi9cbiAgcHJvdGVjdGVkIHNob3VsZFVwZGF0ZShfY2hhbmdlZFByb3BlcnRpZXM6IFByb3BlcnR5VmFsdWVzKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZWxlbWVudC4gVGhpcyBtZXRob2QgcmVmbGVjdHMgcHJvcGVydHkgdmFsdWVzIHRvIGF0dHJpYnV0ZXMuXG4gICAqIEl0IGNhbiBiZSBvdmVycmlkZGVuIHRvIHJlbmRlciBhbmQga2VlcCB1cGRhdGVkIGVsZW1lbnQgRE9NLlxuICAgKiBTZXR0aW5nIHByb3BlcnRpZXMgaW5zaWRlIHRoaXMgbWV0aG9kIHdpbGwgKm5vdCogdHJpZ2dlclxuICAgKiBhbm90aGVyIHVwZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIF9jaGFuZ2VkUHJvcGVydGllcyBNYXAgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzIHdpdGggb2xkIHZhbHVlc1xuICAgKiBAY2F0ZWdvcnkgdXBkYXRlc1xuICAgKi9cbiAgcHJvdGVjdGVkIHVwZGF0ZShfY2hhbmdlZFByb3BlcnRpZXM6IFByb3BlcnR5VmFsdWVzKSB7XG4gICAgaWYgKHRoaXMuX19yZWZsZWN0aW5nUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBVc2UgZm9yRWFjaCBzbyB0aGlzIHdvcmtzIGV2ZW4gaWYgZm9yL29mIGxvb3BzIGFyZSBjb21waWxlZCB0byBmb3JcbiAgICAgIC8vIGxvb3BzIGV4cGVjdGluZyBhcnJheXNcbiAgICAgIHRoaXMuX19yZWZsZWN0aW5nUHJvcGVydGllcy5mb3JFYWNoKCh2LCBrKSA9PlxuICAgICAgICB0aGlzLl9fcHJvcGVydHlUb0F0dHJpYnV0ZShrLCB0aGlzW2sgYXMga2V5b2YgdGhpc10sIHYpXG4gICAgICApO1xuICAgICAgdGhpcy5fX3JlZmxlY3RpbmdQcm9wZXJ0aWVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLl9fbWFya1VwZGF0ZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW5ldmVyIHRoZSBlbGVtZW50IGlzIHVwZGF0ZWQuIEltcGxlbWVudCB0byBwZXJmb3JtXG4gICAqIHBvc3QtdXBkYXRpbmcgdGFza3MgdmlhIERPTSBBUElzLCBmb3IgZXhhbXBsZSwgZm9jdXNpbmcgYW4gZWxlbWVudC5cbiAgICpcbiAgICogU2V0dGluZyBwcm9wZXJ0aWVzIGluc2lkZSB0aGlzIG1ldGhvZCB3aWxsIHRyaWdnZXIgdGhlIGVsZW1lbnQgdG8gdXBkYXRlXG4gICAqIGFnYWluIGFmdGVyIHRoaXMgdXBkYXRlIGN5Y2xlIGNvbXBsZXRlcy5cbiAgICpcbiAgICogQHBhcmFtIF9jaGFuZ2VkUHJvcGVydGllcyBNYXAgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzIHdpdGggb2xkIHZhbHVlc1xuICAgKiBAY2F0ZWdvcnkgdXBkYXRlc1xuICAgKi9cbiAgcHJvdGVjdGVkIHVwZGF0ZWQoX2NoYW5nZWRQcm9wZXJ0aWVzOiBQcm9wZXJ0eVZhbHVlcykge31cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBlbGVtZW50IGlzIGZpcnN0IHVwZGF0ZWQuIEltcGxlbWVudCB0byBwZXJmb3JtIG9uZSB0aW1lXG4gICAqIHdvcmsgb24gdGhlIGVsZW1lbnQgYWZ0ZXIgdXBkYXRlLlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBmaXJzdFVwZGF0ZWQoKSB7XG4gICAqICAgdGhpcy5yZW5kZXJSb290LmdldEVsZW1lbnRCeUlkKCdteS10ZXh0LWFyZWEnKS5mb2N1cygpO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBTZXR0aW5nIHByb3BlcnRpZXMgaW5zaWRlIHRoaXMgbWV0aG9kIHdpbGwgdHJpZ2dlciB0aGUgZWxlbWVudCB0byB1cGRhdGVcbiAgICogYWdhaW4gYWZ0ZXIgdGhpcyB1cGRhdGUgY3ljbGUgY29tcGxldGVzLlxuICAgKlxuICAgKiBAcGFyYW0gX2NoYW5nZWRQcm9wZXJ0aWVzIE1hcCBvZiBjaGFuZ2VkIHByb3BlcnRpZXMgd2l0aCBvbGQgdmFsdWVzXG4gICAqIEBjYXRlZ29yeSB1cGRhdGVzXG4gICAqL1xuICBwcm90ZWN0ZWQgZmlyc3RVcGRhdGVkKF9jaGFuZ2VkUHJvcGVydGllczogUHJvcGVydHlWYWx1ZXMpIHt9XG59XG5cbmlmIChodG1sRWxlbWVudFNoaW1OZWVkZWQpIHtcbiAgZGVsZXRlIChnbG9iYWwgYXMgUGFydGlhbDx0eXBlb2YgZ2xvYmFsPikuSFRNTEVsZW1lbnQ7XG59XG5cbi8vIEFwcGx5IHBvbHlmaWxscyBpZiBhdmFpbGFibGVcbnBvbHlmaWxsU3VwcG9ydD8uKHtSZWFjdGl2ZUVsZW1lbnR9KTtcblxuLy8gRGV2IG1vZGUgd2FybmluZ3MuLi5cbmlmIChERVZfTU9ERSkge1xuICAvLyBEZWZhdWx0IHdhcm5pbmcgc2V0LlxuICBSZWFjdGl2ZUVsZW1lbnQuZW5hYmxlZFdhcm5pbmdzID0gWydjaGFuZ2UtaW4tdXBkYXRlJ107XG4gIGNvbnN0IGVuc3VyZU93bldhcm5pbmdzID0gZnVuY3Rpb24gKGN0b3I6IHR5cGVvZiBSZWFjdGl2ZUVsZW1lbnQpIHtcbiAgICBpZiAoXG4gICAgICAhY3Rvci5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdlbmFibGVkV2FybmluZ3MnLCBjdG9yKSlcbiAgICApIHtcbiAgICAgIGN0b3IuZW5hYmxlZFdhcm5pbmdzID0gY3Rvci5lbmFibGVkV2FybmluZ3MhLnNsaWNlKCk7XG4gICAgfVxuICB9O1xuICBSZWFjdGl2ZUVsZW1lbnQuZW5hYmxlV2FybmluZyA9IGZ1bmN0aW9uIChcbiAgICB0aGlzOiB0eXBlb2YgUmVhY3RpdmVFbGVtZW50LFxuICAgIHdhcm5pbmc6IFdhcm5pbmdLaW5kXG4gICkge1xuICAgIGVuc3VyZU93bldhcm5pbmdzKHRoaXMpO1xuICAgIGlmICh0aGlzLmVuYWJsZWRXYXJuaW5ncyEuaW5kZXhPZih3YXJuaW5nKSA8IDApIHtcbiAgICAgIHRoaXMuZW5hYmxlZFdhcm5pbmdzIS5wdXNoKHdhcm5pbmcpO1xuICAgIH1cbiAgfTtcbiAgUmVhY3RpdmVFbGVtZW50LmRpc2FibGVXYXJuaW5nID0gZnVuY3Rpb24gKFxuICAgIHRoaXM6IHR5cGVvZiBSZWFjdGl2ZUVsZW1lbnQsXG4gICAgd2FybmluZzogV2FybmluZ0tpbmRcbiAgKSB7XG4gICAgZW5zdXJlT3duV2FybmluZ3ModGhpcyk7XG4gICAgY29uc3QgaSA9IHRoaXMuZW5hYmxlZFdhcm5pbmdzIS5pbmRleE9mKHdhcm5pbmcpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRoaXMuZW5hYmxlZFdhcm5pbmdzIS5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBJTVBPUlRBTlQ6IGRvIG5vdCBjaGFuZ2UgdGhlIHByb3BlcnR5IG5hbWUgb3IgdGhlIGFzc2lnbm1lbnQgZXhwcmVzc2lvbi5cbi8vIFRoaXMgbGluZSB3aWxsIGJlIHVzZWQgaW4gcmVnZXhlcyB0byBzZWFyY2ggZm9yIFJlYWN0aXZlRWxlbWVudCB1c2FnZS5cbihnbG9iYWwucmVhY3RpdmVFbGVtZW50VmVyc2lvbnMgPz89IFtdKS5wdXNoKCcxLjQuMScpO1xuaWYgKERFVl9NT0RFICYmIGdsb2JhbC5yZWFjdGl2ZUVsZW1lbnRWZXJzaW9ucy5sZW5ndGggPiAxKSB7XG4gIGlzc3VlV2FybmluZyEoXG4gICAgJ211bHRpcGxlLXZlcnNpb25zJyxcbiAgICBgTXVsdGlwbGUgdmVyc2lvbnMgb2YgTGl0IGxvYWRlZC4gTG9hZGluZyBtdWx0aXBsZSB2ZXJzaW9ucyBgICtcbiAgICAgIGBpcyBub3QgcmVjb21tZW5kZWQuYFxuICApO1xufVxuIiwgIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuXG4vLyBJTVBPUlRBTlQ6IHRoZXNlIGltcG9ydHMgbXVzdCBiZSB0eXBlLW9ubHlcbmltcG9ydCB0eXBlIHtEaXJlY3RpdmUsIERpcmVjdGl2ZVJlc3VsdCwgUGFydEluZm99IGZyb20gJy4vZGlyZWN0aXZlLmpzJztcblxuY29uc3QgREVWX01PREUgPSB0cnVlO1xuY29uc3QgRU5BQkxFX0VYVFJBX1NFQ1VSSVRZX0hPT0tTID0gdHJ1ZTtcbmNvbnN0IEVOQUJMRV9TSEFEWURPTV9OT1BBVENIID0gdHJ1ZTtcbmNvbnN0IE5PREVfTU9ERSA9IGZhbHNlO1xuLy8gVXNlIHdpbmRvdyBmb3IgYnJvd3NlciBidWlsZHMgYmVjYXVzZSBJRTExIGRvZXNuJ3QgaGF2ZSBnbG9iYWxUaGlzLlxuY29uc3QgZ2xvYmFsID0gTk9ERV9NT0RFID8gZ2xvYmFsVGhpcyA6IHdpbmRvdztcblxuLyoqXG4gKiBDb250YWlucyB0eXBlcyB0aGF0IGFyZSBwYXJ0IG9mIHRoZSB1bnN0YWJsZSBkZWJ1ZyBBUEkuXG4gKlxuICogRXZlcnl0aGluZyBpbiB0aGlzIEFQSSBpcyBub3Qgc3RhYmxlIGFuZCBtYXkgY2hhbmdlIG9yIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZSxcbiAqIGV2ZW4gb24gcGF0Y2ggcmVsZWFzZXMuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbmFtZXNwYWNlXG5leHBvcnQgbmFtZXNwYWNlIExpdFVuc3RhYmxlIHtcbiAgLyoqXG4gICAqIFdoZW4gTGl0IGlzIHJ1bm5pbmcgaW4gZGV2IG1vZGUgYW5kIGB3aW5kb3cuZW1pdExpdERlYnVnTG9nRXZlbnRzYCBpcyB0cnVlLFxuICAgKiB3ZSB3aWxsIGVtaXQgJ2xpdC1kZWJ1ZycgZXZlbnRzIHRvIHdpbmRvdywgd2l0aCBsaXZlIGRldGFpbHMgYWJvdXQgdGhlIHVwZGF0ZSBhbmQgcmVuZGVyXG4gICAqIGxpZmVjeWNsZS4gVGhlc2UgY2FuIGJlIHVzZWZ1bCBmb3Igd3JpdGluZyBkZWJ1ZyB0b29saW5nIGFuZCB2aXN1YWxpemF0aW9ucy5cbiAgICpcbiAgICogUGxlYXNlIGJlIGF3YXJlIHRoYXQgcnVubmluZyB3aXRoIHdpbmRvdy5lbWl0TGl0RGVidWdMb2dFdmVudHMgaGFzIHBlcmZvcm1hbmNlIG92ZXJoZWFkLFxuICAgKiBtYWtpbmcgY2VydGFpbiBvcGVyYXRpb25zIHRoYXQgYXJlIG5vcm1hbGx5IHZlcnkgY2hlYXAgKGxpa2UgYSBuby1vcCByZW5kZXIpIG11Y2ggc2xvd2VyLFxuICAgKiBiZWNhdXNlIHdlIG11c3QgY29weSBkYXRhIGFuZCBkaXNwYXRjaCBldmVudHMuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5hbWVzcGFjZVxuICBleHBvcnQgbmFtZXNwYWNlIERlYnVnTG9nIHtcbiAgICBleHBvcnQgdHlwZSBFbnRyeSA9XG4gICAgICB8IFRlbXBsYXRlUHJlcFxuICAgICAgfCBUZW1wbGF0ZUluc3RhbnRpYXRlZFxuICAgICAgfCBUZW1wbGF0ZUluc3RhbnRpYXRlZEFuZFVwZGF0ZWRcbiAgICAgIHwgVGVtcGxhdGVVcGRhdGluZ1xuICAgICAgfCBCZWdpblJlbmRlclxuICAgICAgfCBFbmRSZW5kZXJcbiAgICAgIHwgQ29tbWl0UGFydEVudHJ5XG4gICAgICB8IFNldFBhcnRWYWx1ZTtcbiAgICBleHBvcnQgaW50ZXJmYWNlIFRlbXBsYXRlUHJlcCB7XG4gICAgICBraW5kOiAndGVtcGxhdGUgcHJlcCc7XG4gICAgICB0ZW1wbGF0ZTogVGVtcGxhdGU7XG4gICAgICBzdHJpbmdzOiBUZW1wbGF0ZVN0cmluZ3NBcnJheTtcbiAgICAgIGNsb25hYmxlVGVtcGxhdGU6IEhUTUxUZW1wbGF0ZUVsZW1lbnQ7XG4gICAgICBwYXJ0czogVGVtcGxhdGVQYXJ0W107XG4gICAgfVxuICAgIGV4cG9ydCBpbnRlcmZhY2UgQmVnaW5SZW5kZXIge1xuICAgICAga2luZDogJ2JlZ2luIHJlbmRlcic7XG4gICAgICBpZDogbnVtYmVyO1xuICAgICAgdmFsdWU6IHVua25vd247XG4gICAgICBjb250YWluZXI6IEhUTUxFbGVtZW50IHwgRG9jdW1lbnRGcmFnbWVudDtcbiAgICAgIG9wdGlvbnM6IFJlbmRlck9wdGlvbnMgfCB1bmRlZmluZWQ7XG4gICAgICBwYXJ0OiBDaGlsZFBhcnQgfCB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGV4cG9ydCBpbnRlcmZhY2UgRW5kUmVuZGVyIHtcbiAgICAgIGtpbmQ6ICdlbmQgcmVuZGVyJztcbiAgICAgIGlkOiBudW1iZXI7XG4gICAgICB2YWx1ZTogdW5rbm93bjtcbiAgICAgIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQgfCBEb2N1bWVudEZyYWdtZW50O1xuICAgICAgb3B0aW9uczogUmVuZGVyT3B0aW9ucyB8IHVuZGVmaW5lZDtcbiAgICAgIHBhcnQ6IENoaWxkUGFydDtcbiAgICB9XG4gICAgZXhwb3J0IGludGVyZmFjZSBUZW1wbGF0ZUluc3RhbnRpYXRlZCB7XG4gICAgICBraW5kOiAndGVtcGxhdGUgaW5zdGFudGlhdGVkJztcbiAgICAgIHRlbXBsYXRlOiBUZW1wbGF0ZSB8IENvbXBpbGVkVGVtcGxhdGU7XG4gICAgICBpbnN0YW5jZTogVGVtcGxhdGVJbnN0YW5jZTtcbiAgICAgIG9wdGlvbnM6IFJlbmRlck9wdGlvbnMgfCB1bmRlZmluZWQ7XG4gICAgICBmcmFnbWVudDogTm9kZTtcbiAgICAgIHBhcnRzOiBBcnJheTxQYXJ0IHwgdW5kZWZpbmVkPjtcbiAgICAgIHZhbHVlczogdW5rbm93bltdO1xuICAgIH1cbiAgICBleHBvcnQgaW50ZXJmYWNlIFRlbXBsYXRlSW5zdGFudGlhdGVkQW5kVXBkYXRlZCB7XG4gICAgICBraW5kOiAndGVtcGxhdGUgaW5zdGFudGlhdGVkIGFuZCB1cGRhdGVkJztcbiAgICAgIHRlbXBsYXRlOiBUZW1wbGF0ZSB8IENvbXBpbGVkVGVtcGxhdGU7XG4gICAgICBpbnN0YW5jZTogVGVtcGxhdGVJbnN0YW5jZTtcbiAgICAgIG9wdGlvbnM6IFJlbmRlck9wdGlvbnMgfCB1bmRlZmluZWQ7XG4gICAgICBmcmFnbWVudDogTm9kZTtcbiAgICAgIHBhcnRzOiBBcnJheTxQYXJ0IHwgdW5kZWZpbmVkPjtcbiAgICAgIHZhbHVlczogdW5rbm93bltdO1xuICAgIH1cbiAgICBleHBvcnQgaW50ZXJmYWNlIFRlbXBsYXRlVXBkYXRpbmcge1xuICAgICAga2luZDogJ3RlbXBsYXRlIHVwZGF0aW5nJztcbiAgICAgIHRlbXBsYXRlOiBUZW1wbGF0ZSB8IENvbXBpbGVkVGVtcGxhdGU7XG4gICAgICBpbnN0YW5jZTogVGVtcGxhdGVJbnN0YW5jZTtcbiAgICAgIG9wdGlvbnM6IFJlbmRlck9wdGlvbnMgfCB1bmRlZmluZWQ7XG4gICAgICBwYXJ0czogQXJyYXk8UGFydCB8IHVuZGVmaW5lZD47XG4gICAgICB2YWx1ZXM6IHVua25vd25bXTtcbiAgICB9XG4gICAgZXhwb3J0IGludGVyZmFjZSBTZXRQYXJ0VmFsdWUge1xuICAgICAga2luZDogJ3NldCBwYXJ0JztcbiAgICAgIHBhcnQ6IFBhcnQ7XG4gICAgICB2YWx1ZTogdW5rbm93bjtcbiAgICAgIHZhbHVlSW5kZXg6IG51bWJlcjtcbiAgICAgIHZhbHVlczogdW5rbm93bltdO1xuICAgICAgdGVtcGxhdGVJbnN0YW5jZTogVGVtcGxhdGVJbnN0YW5jZTtcbiAgICB9XG5cbiAgICBleHBvcnQgdHlwZSBDb21taXRQYXJ0RW50cnkgPVxuICAgICAgfCBDb21taXROb3RoaW5nVG9DaGlsZEVudHJ5XG4gICAgICB8IENvbW1pdFRleHRcbiAgICAgIHwgQ29tbWl0Tm9kZVxuICAgICAgfCBDb21taXRBdHRyaWJ1dGVcbiAgICAgIHwgQ29tbWl0UHJvcGVydHlcbiAgICAgIHwgQ29tbWl0Qm9vbGVhbkF0dHJpYnV0ZVxuICAgICAgfCBDb21taXRFdmVudExpc3RlbmVyXG4gICAgICB8IENvbW1pdFRvRWxlbWVudEJpbmRpbmc7XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIENvbW1pdE5vdGhpbmdUb0NoaWxkRW50cnkge1xuICAgICAga2luZDogJ2NvbW1pdCBub3RoaW5nIHRvIGNoaWxkJztcbiAgICAgIHN0YXJ0OiBDaGlsZE5vZGU7XG4gICAgICBlbmQ6IENoaWxkTm9kZSB8IG51bGw7XG4gICAgICBwYXJlbnQ6IERpc2Nvbm5lY3RhYmxlIHwgdW5kZWZpbmVkO1xuICAgICAgb3B0aW9uczogUmVuZGVyT3B0aW9ucyB8IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIENvbW1pdFRleHQge1xuICAgICAga2luZDogJ2NvbW1pdCB0ZXh0JztcbiAgICAgIG5vZGU6IFRleHQ7XG4gICAgICB2YWx1ZTogdW5rbm93bjtcbiAgICAgIG9wdGlvbnM6IFJlbmRlck9wdGlvbnMgfCB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBDb21taXROb2RlIHtcbiAgICAgIGtpbmQ6ICdjb21taXQgbm9kZSc7XG4gICAgICBzdGFydDogTm9kZTtcbiAgICAgIHBhcmVudDogRGlzY29ubmVjdGFibGUgfCB1bmRlZmluZWQ7XG4gICAgICB2YWx1ZTogTm9kZTtcbiAgICAgIG9wdGlvbnM6IFJlbmRlck9wdGlvbnMgfCB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBDb21taXRBdHRyaWJ1dGUge1xuICAgICAga2luZDogJ2NvbW1pdCBhdHRyaWJ1dGUnO1xuICAgICAgZWxlbWVudDogRWxlbWVudDtcbiAgICAgIG5hbWU6IHN0cmluZztcbiAgICAgIHZhbHVlOiB1bmtub3duO1xuICAgICAgb3B0aW9uczogUmVuZGVyT3B0aW9ucyB8IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIENvbW1pdFByb3BlcnR5IHtcbiAgICAgIGtpbmQ6ICdjb21taXQgcHJvcGVydHknO1xuICAgICAgZWxlbWVudDogRWxlbWVudDtcbiAgICAgIG5hbWU6IHN0cmluZztcbiAgICAgIHZhbHVlOiB1bmtub3duO1xuICAgICAgb3B0aW9uczogUmVuZGVyT3B0aW9ucyB8IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIENvbW1pdEJvb2xlYW5BdHRyaWJ1dGUge1xuICAgICAga2luZDogJ2NvbW1pdCBib29sZWFuIGF0dHJpYnV0ZSc7XG4gICAgICBlbGVtZW50OiBFbGVtZW50O1xuICAgICAgbmFtZTogc3RyaW5nO1xuICAgICAgdmFsdWU6IGJvb2xlYW47XG4gICAgICBvcHRpb25zOiBSZW5kZXJPcHRpb25zIHwgdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGV4cG9ydCBpbnRlcmZhY2UgQ29tbWl0RXZlbnRMaXN0ZW5lciB7XG4gICAgICBraW5kOiAnY29tbWl0IGV2ZW50IGxpc3RlbmVyJztcbiAgICAgIGVsZW1lbnQ6IEVsZW1lbnQ7XG4gICAgICBuYW1lOiBzdHJpbmc7XG4gICAgICB2YWx1ZTogdW5rbm93bjtcbiAgICAgIG9sZExpc3RlbmVyOiB1bmtub3duO1xuICAgICAgb3B0aW9uczogUmVuZGVyT3B0aW9ucyB8IHVuZGVmaW5lZDtcbiAgICAgIC8vIFRydWUgaWYgd2UncmUgcmVtb3ZpbmcgdGhlIG9sZCBldmVudCBsaXN0ZW5lciAoZS5nLiBiZWNhdXNlIHNldHRpbmdzIGNoYW5nZWQsIG9yIHZhbHVlIGlzIG5vdGhpbmcpXG4gICAgICByZW1vdmVMaXN0ZW5lcjogYm9vbGVhbjtcbiAgICAgIC8vIFRydWUgaWYgd2UncmUgYWRkaW5nIGEgbmV3IGV2ZW50IGxpc3RlbmVyIChlLmcuIGJlY2F1c2UgZmlyc3QgcmVuZGVyLCBvciBzZXR0aW5ncyBjaGFuZ2VkKVxuICAgICAgYWRkTGlzdGVuZXI6IGJvb2xlYW47XG4gICAgfVxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBDb21taXRUb0VsZW1lbnRCaW5kaW5nIHtcbiAgICAgIGtpbmQ6ICdjb21taXQgdG8gZWxlbWVudCBiaW5kaW5nJztcbiAgICAgIGVsZW1lbnQ6IEVsZW1lbnQ7XG4gICAgICB2YWx1ZTogdW5rbm93bjtcbiAgICAgIG9wdGlvbnM6IFJlbmRlck9wdGlvbnMgfCB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5cbmludGVyZmFjZSBEZWJ1Z0xvZ2dpbmdXaW5kb3cge1xuICAvLyBFdmVuIGluIGRldiBtb2RlLCB3ZSBnZW5lcmFsbHkgZG9uJ3Qgd2FudCB0byBlbWl0IHRoZXNlIGV2ZW50cywgYXMgdGhhdCdzXG4gIC8vIGFub3RoZXIgbGV2ZWwgb2YgY29zdCwgc28gb25seSBlbWl0IHRoZW0gd2hlbiBERVZfTU9ERSBpcyB0cnVlIF9hbmRfIHdoZW5cbiAgLy8gd2luZG93LmVtaXRMaXREZWJ1Z0V2ZW50cyBpcyB0cnVlLlxuICBlbWl0TGl0RGVidWdMb2dFdmVudHM/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFVzZWZ1bCBmb3IgdmlzdWFsaXppbmcgYW5kIGxvZ2dpbmcgaW5zaWdodHMgaW50byB3aGF0IHRoZSBMaXQgdGVtcGxhdGUgc3lzdGVtIGlzIGRvaW5nLlxuICpcbiAqIENvbXBpbGVkIG91dCBvZiBwcm9kIG1vZGUgYnVpbGRzLlxuICovXG5jb25zdCBkZWJ1Z0xvZ0V2ZW50ID0gREVWX01PREVcbiAgPyAoZXZlbnQ6IExpdFVuc3RhYmxlLkRlYnVnTG9nLkVudHJ5KSA9PiB7XG4gICAgICBjb25zdCBzaG91bGRFbWl0ID0gKGdsb2JhbCBhcyB1bmtub3duIGFzIERlYnVnTG9nZ2luZ1dpbmRvdylcbiAgICAgICAgLmVtaXRMaXREZWJ1Z0xvZ0V2ZW50cztcbiAgICAgIGlmICghc2hvdWxkRW1pdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBnbG9iYWwuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgbmV3IEN1c3RvbUV2ZW50PExpdFVuc3RhYmxlLkRlYnVnTG9nLkVudHJ5PignbGl0LWRlYnVnJywge1xuICAgICAgICAgIGRldGFpbDogZXZlbnQsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgOiB1bmRlZmluZWQ7XG4vLyBVc2VkIGZvciBjb25uZWN0aW5nIGJlZ2luUmVuZGVyIGFuZCBlbmRSZW5kZXIgZXZlbnRzIHdoZW4gdGhlcmUgYXJlIG5lc3RlZFxuLy8gcmVuZGVycyB3aGVuIGVycm9ycyBhcmUgdGhyb3duIHByZXZlbnRpbmcgYW4gZW5kUmVuZGVyIGV2ZW50IGZyb20gYmVpbmdcbi8vIGNhbGxlZC5cbmxldCBkZWJ1Z0xvZ1JlbmRlcklkID0gMDtcblxubGV0IGlzc3VlV2FybmluZzogKGNvZGU6IHN0cmluZywgd2FybmluZzogc3RyaW5nKSA9PiB2b2lkO1xuXG5pZiAoREVWX01PREUpIHtcbiAgZ2xvYmFsLmxpdElzc3VlZFdhcm5pbmdzID8/PSBuZXcgU2V0KCk7XG5cbiAgLy8gSXNzdWUgYSB3YXJuaW5nLCBpZiB3ZSBoYXZlbid0IGFscmVhZHkuXG4gIGlzc3VlV2FybmluZyA9IChjb2RlOiBzdHJpbmcsIHdhcm5pbmc6IHN0cmluZykgPT4ge1xuICAgIHdhcm5pbmcgKz0gY29kZVxuICAgICAgPyBgIFNlZSBodHRwczovL2xpdC5kZXYvbXNnLyR7Y29kZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uYFxuICAgICAgOiAnJztcbiAgICBpZiAoIWdsb2JhbC5saXRJc3N1ZWRXYXJuaW5ncyEuaGFzKHdhcm5pbmcpKSB7XG4gICAgICBjb25zb2xlLndhcm4od2FybmluZyk7XG4gICAgICBnbG9iYWwubGl0SXNzdWVkV2FybmluZ3MhLmFkZCh3YXJuaW5nKTtcbiAgICB9XG4gIH07XG5cbiAgaXNzdWVXYXJuaW5nKFxuICAgICdkZXYtbW9kZScsXG4gICAgYExpdCBpcyBpbiBkZXYgbW9kZS4gTm90IHJlY29tbWVuZGVkIGZvciBwcm9kdWN0aW9uIWBcbiAgKTtcbn1cblxuY29uc3Qgd3JhcCA9XG4gIEVOQUJMRV9TSEFEWURPTV9OT1BBVENIICYmXG4gIGdsb2JhbC5TaGFkeURPTT8uaW5Vc2UgJiZcbiAgZ2xvYmFsLlNoYWR5RE9NPy5ub1BhdGNoID09PSB0cnVlXG4gICAgPyBnbG9iYWwuU2hhZHlET00hLndyYXBcbiAgICA6IChub2RlOiBOb2RlKSA9PiBub2RlO1xuXG5jb25zdCB0cnVzdGVkVHlwZXMgPSAoZ2xvYmFsIGFzIHVua25vd24gYXMgUGFydGlhbDxXaW5kb3c+KS50cnVzdGVkVHlwZXM7XG5cbi8qKlxuICogT3VyIFRydXN0ZWRUeXBlUG9saWN5IGZvciBIVE1MIHdoaWNoIGlzIGRlY2xhcmVkIHVzaW5nIHRoZSBodG1sIHRlbXBsYXRlXG4gKiB0YWcgZnVuY3Rpb24uXG4gKlxuICogVGhhdCBIVE1MIGlzIGEgZGV2ZWxvcGVyLWF1dGhvcmVkIGNvbnN0YW50LCBhbmQgaXMgcGFyc2VkIHdpdGggaW5uZXJIVE1MXG4gKiBiZWZvcmUgYW55IHVudHJ1c3RlZCBleHByZXNzaW9ucyBoYXZlIGJlZW4gbWl4ZWQgaW4uIFRoZXJlZm9yIGl0IGlzXG4gKiBjb25zaWRlcmVkIHNhZmUgYnkgY29uc3RydWN0aW9uLlxuICovXG5jb25zdCBwb2xpY3kgPSB0cnVzdGVkVHlwZXNcbiAgPyB0cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5KCdsaXQtaHRtbCcsIHtcbiAgICAgIGNyZWF0ZUhUTUw6IChzKSA9PiBzLFxuICAgIH0pXG4gIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFVzZWQgdG8gc2FuaXRpemUgYW55IHZhbHVlIGJlZm9yZSBpdCBpcyB3cml0dGVuIGludG8gdGhlIERPTS4gVGhpcyBjYW4gYmVcbiAqIHVzZWQgdG8gaW1wbGVtZW50IGEgc2VjdXJpdHkgcG9saWN5IG9mIGFsbG93ZWQgYW5kIGRpc2FsbG93ZWQgdmFsdWVzIGluXG4gKiBvcmRlciB0byBwcmV2ZW50IFhTUyBhdHRhY2tzLlxuICpcbiAqIE9uZSB3YXkgb2YgdXNpbmcgdGhpcyBjYWxsYmFjayB3b3VsZCBiZSB0byBjaGVjayBhdHRyaWJ1dGVzIGFuZCBwcm9wZXJ0aWVzXG4gKiBhZ2FpbnN0IGEgbGlzdCBvZiBoaWdoIHJpc2sgZmllbGRzLCBhbmQgcmVxdWlyZSB0aGF0IHZhbHVlcyB3cml0dGVuIHRvIHN1Y2hcbiAqIGZpZWxkcyBiZSBpbnN0YW5jZXMgb2YgYSBjbGFzcyB3aGljaCBpcyBzYWZlIGJ5IGNvbnN0cnVjdGlvbi4gQ2xvc3VyZSdzIFNhZmVcbiAqIEhUTUwgVHlwZXMgaXMgb25lIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgdGVjaG5pcXVlIChcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvc2FmZS1odG1sLXR5cGVzL2Jsb2IvbWFzdGVyL2RvYy9zYWZlaHRtbC10eXBlcy5tZCkuXG4gKiBUaGUgVHJ1c3RlZFR5cGVzIHBvbHlmaWxsIGluIEFQSS1vbmx5IG1vZGUgY291bGQgYWxzbyBiZSB1c2VkIGFzIGEgYmFzaXNcbiAqIGZvciB0aGlzIHRlY2huaXF1ZSAoaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvdHJ1c3RlZC10eXBlcykuXG4gKlxuICogQHBhcmFtIG5vZGUgVGhlIEhUTUwgbm9kZSAodXN1YWxseSBlaXRoZXIgYSAjdGV4dCBub2RlIG9yIGFuIEVsZW1lbnQpIHRoYXRcbiAqICAgICBpcyBiZWluZyB3cml0dGVuIHRvLiBOb3RlIHRoYXQgdGhpcyBpcyBqdXN0IGFuIGV4ZW1wbGFyIG5vZGUsIHRoZSB3cml0ZVxuICogICAgIG1heSB0YWtlIHBsYWNlIGFnYWluc3QgYW5vdGhlciBpbnN0YW5jZSBvZiB0aGUgc2FtZSBjbGFzcyBvZiBub2RlLlxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgYW4gYXR0cmlidXRlIG9yIHByb3BlcnR5IChmb3IgZXhhbXBsZSwgJ2hyZWYnKS5cbiAqIEBwYXJhbSB0eXBlIEluZGljYXRlcyB3aGV0aGVyIHRoZSB3cml0ZSB0aGF0J3MgYWJvdXQgdG8gYmUgcGVyZm9ybWVkIHdpbGxcbiAqICAgICBiZSB0byBhIHByb3BlcnR5IG9yIGEgbm9kZS5cbiAqIEByZXR1cm4gQSBmdW5jdGlvbiB0aGF0IHdpbGwgc2FuaXRpemUgdGhpcyBjbGFzcyBvZiB3cml0ZXMuXG4gKi9cbmV4cG9ydCB0eXBlIFNhbml0aXplckZhY3RvcnkgPSAoXG4gIG5vZGU6IE5vZGUsXG4gIG5hbWU6IHN0cmluZyxcbiAgdHlwZTogJ3Byb3BlcnR5JyB8ICdhdHRyaWJ1dGUnXG4pID0+IFZhbHVlU2FuaXRpemVyO1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gd2hpY2ggY2FuIHNhbml0aXplIHZhbHVlcyB0aGF0IHdpbGwgYmUgd3JpdHRlbiB0byBhIHNwZWNpZmljIGtpbmRcbiAqIG9mIERPTSBzaW5rLlxuICpcbiAqIFNlZSBTYW5pdGl6ZXJGYWN0b3J5LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2FuaXRpemUuIFdpbGwgYmUgdGhlIGFjdHVhbCB2YWx1ZSBwYXNzZWQgaW50b1xuICogICAgIHRoZSBsaXQtaHRtbCB0ZW1wbGF0ZSBsaXRlcmFsLCBzbyB0aGlzIGNvdWxkIGJlIG9mIGFueSB0eXBlLlxuICogQHJldHVybiBUaGUgdmFsdWUgdG8gd3JpdGUgdG8gdGhlIERPTS4gVXN1YWxseSB0aGUgc2FtZSBhcyB0aGUgaW5wdXQgdmFsdWUsXG4gKiAgICAgdW5sZXNzIHNhbml0aXphdGlvbiBpcyBuZWVkZWQuXG4gKi9cbmV4cG9ydCB0eXBlIFZhbHVlU2FuaXRpemVyID0gKHZhbHVlOiB1bmtub3duKSA9PiB1bmtub3duO1xuXG5jb25zdCBpZGVudGl0eUZ1bmN0aW9uOiBWYWx1ZVNhbml0aXplciA9ICh2YWx1ZTogdW5rbm93bikgPT4gdmFsdWU7XG5jb25zdCBub29wU2FuaXRpemVyOiBTYW5pdGl6ZXJGYWN0b3J5ID0gKFxuICBfbm9kZTogTm9kZSxcbiAgX25hbWU6IHN0cmluZyxcbiAgX3R5cGU6ICdwcm9wZXJ0eScgfCAnYXR0cmlidXRlJ1xuKSA9PiBpZGVudGl0eUZ1bmN0aW9uO1xuXG4vKiogU2V0cyB0aGUgZ2xvYmFsIHNhbml0aXplciBmYWN0b3J5LiAqL1xuY29uc3Qgc2V0U2FuaXRpemVyID0gKG5ld1Nhbml0aXplcjogU2FuaXRpemVyRmFjdG9yeSkgPT4ge1xuICBpZiAoIUVOQUJMRV9FWFRSQV9TRUNVUklUWV9IT09LUykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc2FuaXRpemVyRmFjdG9yeUludGVybmFsICE9PSBub29wU2FuaXRpemVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEF0dGVtcHRlZCB0byBvdmVyd3JpdGUgZXhpc3RpbmcgbGl0LWh0bWwgc2VjdXJpdHkgcG9saWN5LmAgK1xuICAgICAgICBgIHNldFNhbml0aXplRE9NVmFsdWVGYWN0b3J5IHNob3VsZCBiZSBjYWxsZWQgYXQgbW9zdCBvbmNlLmBcbiAgICApO1xuICB9XG4gIHNhbml0aXplckZhY3RvcnlJbnRlcm5hbCA9IG5ld1Nhbml0aXplcjtcbn07XG5cbi8qKlxuICogT25seSB1c2VkIGluIGludGVybmFsIHRlc3RzLCBub3QgYSBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJLlxuICovXG5jb25zdCBfdGVzdE9ubHlDbGVhclNhbml0aXplckZhY3RvcnlEb05vdENhbGxPckVsc2UgPSAoKSA9PiB7XG4gIHNhbml0aXplckZhY3RvcnlJbnRlcm5hbCA9IG5vb3BTYW5pdGl6ZXI7XG59O1xuXG5jb25zdCBjcmVhdGVTYW5pdGl6ZXI6IFNhbml0aXplckZhY3RvcnkgPSAobm9kZSwgbmFtZSwgdHlwZSkgPT4ge1xuICByZXR1cm4gc2FuaXRpemVyRmFjdG9yeUludGVybmFsKG5vZGUsIG5hbWUsIHR5cGUpO1xufTtcblxuLy8gQWRkZWQgdG8gYW4gYXR0cmlidXRlIG5hbWUgdG8gbWFyayB0aGUgYXR0cmlidXRlIGFzIGJvdW5kIHNvIHdlIGNhbiBmaW5kXG4vLyBpdCBlYXNpbHkuXG5jb25zdCBib3VuZEF0dHJpYnV0ZVN1ZmZpeCA9ICckbGl0JCc7XG5cbi8vIFRoaXMgbWFya2VyIGlzIHVzZWQgaW4gbWFueSBzeW50YWN0aWMgcG9zaXRpb25zIGluIEhUTUwsIHNvIGl0IG11c3QgYmVcbi8vIGEgdmFsaWQgZWxlbWVudCBuYW1lIGFuZCBhdHRyaWJ1dGUgbmFtZS4gV2UgZG9uJ3Qgc3VwcG9ydCBkeW5hbWljIG5hbWVzICh5ZXQpXG4vLyBidXQgdGhpcyBhdCBsZWFzdCBlbnN1cmVzIHRoYXQgdGhlIHBhcnNlIHRyZWUgaXMgY2xvc2VyIHRvIHRoZSB0ZW1wbGF0ZVxuLy8gaW50ZW50aW9uLlxuY29uc3QgbWFya2VyID0gYGxpdCQke1N0cmluZyhNYXRoLnJhbmRvbSgpKS5zbGljZSg5KX0kYDtcblxuLy8gU3RyaW5nIHVzZWQgdG8gdGVsbCBpZiBhIGNvbW1lbnQgaXMgYSBtYXJrZXIgY29tbWVudFxuY29uc3QgbWFya2VyTWF0Y2ggPSAnPycgKyBtYXJrZXI7XG5cbi8vIFRleHQgdXNlZCB0byBpbnNlcnQgYSBjb21tZW50IG1hcmtlciBub2RlLiBXZSB1c2UgcHJvY2Vzc2luZyBpbnN0cnVjdGlvblxuLy8gc3ludGF4IGJlY2F1c2UgaXQncyBzbGlnaHRseSBzbWFsbGVyLCBidXQgcGFyc2VzIGFzIGEgY29tbWVudCBub2RlLlxuY29uc3Qgbm9kZU1hcmtlciA9IGA8JHttYXJrZXJNYXRjaH0+YDtcblxuY29uc3QgZCA9XG4gIE5PREVfTU9ERSAmJiBnbG9iYWwuZG9jdW1lbnQgPT09IHVuZGVmaW5lZFxuICAgID8gKHtcbiAgICAgICAgY3JlYXRlVHJlZVdhbGtlcigpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH0sXG4gICAgICB9IGFzIHVua25vd24gYXMgRG9jdW1lbnQpXG4gICAgOiBkb2N1bWVudDtcblxuLy8gQ3JlYXRlcyBhIGR5bmFtaWMgbWFya2VyLiBXZSBuZXZlciBoYXZlIHRvIHNlYXJjaCBmb3IgdGhlc2UgaW4gdGhlIERPTS5cbmNvbnN0IGNyZWF0ZU1hcmtlciA9ICh2ID0gJycpID0+IGQuY3JlYXRlQ29tbWVudCh2KTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdHlwZW9mLW9wZXJhdG9yXG50eXBlIFByaW1pdGl2ZSA9IG51bGwgfCB1bmRlZmluZWQgfCBib29sZWFuIHwgbnVtYmVyIHwgc3RyaW5nIHwgc3ltYm9sIHwgYmlnaW50O1xuY29uc3QgaXNQcmltaXRpdmUgPSAodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBQcmltaXRpdmUgPT5cbiAgdmFsdWUgPT09IG51bGwgfHwgKHR5cGVvZiB2YWx1ZSAhPSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUgIT0gJ2Z1bmN0aW9uJyk7XG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmNvbnN0IGlzSXRlcmFibGUgPSAodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBJdGVyYWJsZTx1bmtub3duPiA9PlxuICBpc0FycmF5KHZhbHVlKSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICB0eXBlb2YgKHZhbHVlIGFzIGFueSk/LltTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xuXG5jb25zdCBTUEFDRV9DSEFSID0gYFsgXFx0XFxuXFxmXFxyXWA7XG5jb25zdCBBVFRSX1ZBTFVFX0NIQVIgPSBgW14gXFx0XFxuXFxmXFxyXCInXFxgPD49XWA7XG5jb25zdCBOQU1FX0NIQVIgPSBgW15cXFxcc1wiJz49L11gO1xuXG4vLyBUaGVzZSByZWdleGVzIHJlcHJlc2VudCB0aGUgZml2ZSBwYXJzaW5nIHN0YXRlcyB0aGF0IHdlIGNhcmUgYWJvdXQgaW4gdGhlXG4vLyBUZW1wbGF0ZSdzIEhUTUwgc2Nhbm5lci4gVGhleSBtYXRjaCB0aGUgKmVuZCogb2YgdGhlIHN0YXRlIHRoZXkncmUgbmFtZWRcbi8vIGFmdGVyLlxuLy8gRGVwZW5kaW5nIG9uIHRoZSBtYXRjaCwgd2UgdHJhbnNpdGlvbiB0byBhIG5ldyBzdGF0ZS4gSWYgdGhlcmUncyBubyBtYXRjaCxcbi8vIHdlIHN0YXkgaW4gdGhlIHNhbWUgc3RhdGUuXG4vLyBOb3RlIHRoYXQgdGhlIHJlZ2V4ZXMgYXJlIHN0YXRlZnVsLiBXZSB1dGlsaXplIGxhc3RJbmRleCBhbmQgc3luYyBpdFxuLy8gYWNyb3NzIHRoZSBtdWx0aXBsZSByZWdleGVzIHVzZWQuIEluIGFkZGl0aW9uIHRvIHRoZSBmaXZlIHJlZ2V4ZXMgYmVsb3dcbi8vIHdlIGFsc28gZHluYW1pY2FsbHkgY3JlYXRlIGEgcmVnZXggdG8gZmluZCB0aGUgbWF0Y2hpbmcgZW5kIHRhZ3MgZm9yIHJhd1xuLy8gdGV4dCBlbGVtZW50cy5cblxuLyoqXG4gKiBFbmQgb2YgdGV4dCBpczogYDxgIGZvbGxvd2VkIGJ5OlxuICogICAoY29tbWVudCBzdGFydCkgb3IgKHRhZykgb3IgKGR5bmFtaWMgdGFnIGJpbmRpbmcpXG4gKi9cbmNvbnN0IHRleHRFbmRSZWdleCA9IC88KD86KCEtLXxcXC9bXmEtekEtWl0pfChcXC8/W2EtekEtWl1bXj5cXHNdKil8KFxcLz8kKSkvZztcbmNvbnN0IENPTU1FTlRfU1RBUlQgPSAxO1xuY29uc3QgVEFHX05BTUUgPSAyO1xuY29uc3QgRFlOQU1JQ19UQUdfTkFNRSA9IDM7XG5cbmNvbnN0IGNvbW1lbnRFbmRSZWdleCA9IC8tLT4vZztcbi8qKlxuICogQ29tbWVudHMgbm90IHN0YXJ0ZWQgd2l0aCA8IS0tLCBsaWtlIDwveywgY2FuIGJlIGVuZGVkIGJ5IGEgc2luZ2xlIGA+YFxuICovXG5jb25zdCBjb21tZW50MkVuZFJlZ2V4ID0gLz4vZztcblxuLyoqXG4gKiBUaGUgdGFnRW5kIHJlZ2V4IG1hdGNoZXMgdGhlIGVuZCBvZiB0aGUgXCJpbnNpZGUgYW4gb3BlbmluZ1wiIHRhZyBzeW50YXhcbiAqIHBvc2l0aW9uLiBJdCBlaXRoZXIgbWF0Y2hlcyBhIGA+YCwgYW4gYXR0cmlidXRlLWxpa2Ugc2VxdWVuY2UsIG9yIHRoZSBlbmRcbiAqIG9mIHRoZSBzdHJpbmcgYWZ0ZXIgYSBzcGFjZSAoYXR0cmlidXRlLW5hbWUgcG9zaXRpb24gZW5kaW5nKS5cbiAqXG4gKiBTZWUgYXR0cmlidXRlcyBpbiB0aGUgSFRNTCBzcGVjOlxuICogaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2VsZW1lbnRzLWF0dHJpYnV0ZXNcbiAqXG4gKiBcIiBcXHRcXG5cXGZcXHJcIiBhcmUgSFRNTCBzcGFjZSBjaGFyYWN0ZXJzOlxuICogaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2FzY2lpLXdoaXRlc3BhY2VcbiAqXG4gKiBTbyBhbiBhdHRyaWJ1dGUgaXM6XG4gKiAgKiBUaGUgbmFtZTogYW55IGNoYXJhY3RlciBleGNlcHQgYSB3aGl0ZXNwYWNlIGNoYXJhY3RlciwgKFwiKSwgKCcpLCBcIj5cIixcbiAqICAgIFwiPVwiLCBvciBcIi9cIi4gTm90ZTogdGhpcyBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgSFRNTCBzcGVjIHdoaWNoIGFsc28gZXhjbHVkZXMgY29udHJvbCBjaGFyYWN0ZXJzLlxuICogICogRm9sbG93ZWQgYnkgemVybyBvciBtb3JlIHNwYWNlIGNoYXJhY3RlcnNcbiAqICAqIEZvbGxvd2VkIGJ5IFwiPVwiXG4gKiAgKiBGb2xsb3dlZCBieSB6ZXJvIG9yIG1vcmUgc3BhY2UgY2hhcmFjdGVyc1xuICogICogRm9sbG93ZWQgYnk6XG4gKiAgICAqIEFueSBjaGFyYWN0ZXIgZXhjZXB0IHNwYWNlLCAoJyksIChcIiksIFwiPFwiLCBcIj5cIiwgXCI9XCIsIChgKSwgb3JcbiAqICAgICogKFwiKSB0aGVuIGFueSBub24tKFwiKSwgb3JcbiAqICAgICogKCcpIHRoZW4gYW55IG5vbi0oJylcbiAqL1xuY29uc3QgdGFnRW5kUmVnZXggPSBuZXcgUmVnRXhwKFxuICBgPnwke1NQQUNFX0NIQVJ9KD86KCR7TkFNRV9DSEFSfSspKCR7U1BBQ0VfQ0hBUn0qPSR7U1BBQ0VfQ0hBUn0qKD86JHtBVFRSX1ZBTFVFX0NIQVJ9fChcInwnKXwpKXwkKWAsXG4gICdnJ1xuKTtcbmNvbnN0IEVOVElSRV9NQVRDSCA9IDA7XG5jb25zdCBBVFRSSUJVVEVfTkFNRSA9IDE7XG5jb25zdCBTUEFDRVNfQU5EX0VRVUFMUyA9IDI7XG5jb25zdCBRVU9URV9DSEFSID0gMztcblxuY29uc3Qgc2luZ2xlUXVvdGVBdHRyRW5kUmVnZXggPSAvJy9nO1xuY29uc3QgZG91YmxlUXVvdGVBdHRyRW5kUmVnZXggPSAvXCIvZztcbi8qKlxuICogTWF0Y2hlcyB0aGUgcmF3IHRleHQgZWxlbWVudHMuXG4gKlxuICogQ29tbWVudHMgYXJlIG5vdCBwYXJzZWQgd2l0aGluIHJhdyB0ZXh0IGVsZW1lbnRzLCBzbyB3ZSBuZWVkIHRvIHNlYXJjaCB0aGVpclxuICogdGV4dCBjb250ZW50IGZvciBtYXJrZXIgc3RyaW5ncy5cbiAqL1xuY29uc3QgcmF3VGV4dEVsZW1lbnQgPSAvXig/OnNjcmlwdHxzdHlsZXx0ZXh0YXJlYXx0aXRsZSkkL2k7XG5cbi8qKiBUZW1wbGF0ZVJlc3VsdCB0eXBlcyAqL1xuY29uc3QgSFRNTF9SRVNVTFQgPSAxO1xuY29uc3QgU1ZHX1JFU1VMVCA9IDI7XG5cbnR5cGUgUmVzdWx0VHlwZSA9IHR5cGVvZiBIVE1MX1JFU1VMVCB8IHR5cGVvZiBTVkdfUkVTVUxUO1xuXG4vLyBUZW1wbGF0ZVBhcnQgdHlwZXNcbi8vIElNUE9SVEFOVDogdGhlc2UgbXVzdCBtYXRjaCB0aGUgdmFsdWVzIGluIFBhcnRUeXBlXG5jb25zdCBBVFRSSUJVVEVfUEFSVCA9IDE7XG5jb25zdCBDSElMRF9QQVJUID0gMjtcbmNvbnN0IFBST1BFUlRZX1BBUlQgPSAzO1xuY29uc3QgQk9PTEVBTl9BVFRSSUJVVEVfUEFSVCA9IDQ7XG5jb25zdCBFVkVOVF9QQVJUID0gNTtcbmNvbnN0IEVMRU1FTlRfUEFSVCA9IDY7XG5jb25zdCBDT01NRU5UX1BBUlQgPSA3O1xuXG4vKipcbiAqIFRoZSByZXR1cm4gdHlwZSBvZiB0aGUgdGVtcGxhdGUgdGFnIGZ1bmN0aW9ucywge0BsaW5rY29kZSBodG1sfSBhbmRcbiAqIHtAbGlua2NvZGUgc3ZnfS5cbiAqXG4gKiBBIGBUZW1wbGF0ZVJlc3VsdGAgb2JqZWN0IGhvbGRzIGFsbCB0aGUgaW5mb3JtYXRpb24gYWJvdXQgYSB0ZW1wbGF0ZVxuICogZXhwcmVzc2lvbiByZXF1aXJlZCB0byByZW5kZXIgaXQ6IHRoZSB0ZW1wbGF0ZSBzdHJpbmdzLCBleHByZXNzaW9uIHZhbHVlcyxcbiAqIGFuZCB0eXBlIG9mIHRlbXBsYXRlIChodG1sIG9yIHN2ZykuXG4gKlxuICogYFRlbXBsYXRlUmVzdWx0YCBvYmplY3RzIGRvIG5vdCBjcmVhdGUgYW55IERPTSBvbiB0aGVpciBvd24uIFRvIGNyZWF0ZSBvclxuICogdXBkYXRlIERPTSB5b3UgbmVlZCB0byByZW5kZXIgdGhlIGBUZW1wbGF0ZVJlc3VsdGAuIFNlZVxuICogW1JlbmRlcmluZ10oaHR0cHM6Ly9saXQuZGV2L2RvY3MvY29tcG9uZW50cy9yZW5kZXJpbmcpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqL1xuZXhwb3J0IHR5cGUgVGVtcGxhdGVSZXN1bHQ8VCBleHRlbmRzIFJlc3VsdFR5cGUgPSBSZXN1bHRUeXBlPiA9IHtcbiAgLy8gVGhpcyBwcm9wZXJ0eSBuZWVkcyB0byByZW1haW4gdW5taW5pZmllZC5cbiAgWydfJGxpdFR5cGUkJ106IFQ7XG4gIHN0cmluZ3M6IFRlbXBsYXRlU3RyaW5nc0FycmF5O1xuICB2YWx1ZXM6IHVua25vd25bXTtcbn07XG5cbmV4cG9ydCB0eXBlIEhUTUxUZW1wbGF0ZVJlc3VsdCA9IFRlbXBsYXRlUmVzdWx0PHR5cGVvZiBIVE1MX1JFU1VMVD47XG5cbmV4cG9ydCB0eXBlIFNWR1RlbXBsYXRlUmVzdWx0ID0gVGVtcGxhdGVSZXN1bHQ8dHlwZW9mIFNWR19SRVNVTFQ+O1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBpbGVkVGVtcGxhdGVSZXN1bHQge1xuICAvLyBUaGlzIGlzIGEgZmFjdG9yeSBpbiBvcmRlciB0byBtYWtlIHRlbXBsYXRlIGluaXRpYWxpemF0aW9uIGxhenlcbiAgLy8gYW5kIGFsbG93IFNoYWR5UmVuZGVyT3B0aW9ucyBzY29wZSB0byBiZSBwYXNzZWQgaW4uXG4gIC8vIFRoaXMgcHJvcGVydHkgbmVlZHMgdG8gcmVtYWluIHVubWluaWZpZWQuXG4gIFsnXyRsaXRUeXBlJCddOiBDb21waWxlZFRlbXBsYXRlO1xuICB2YWx1ZXM6IHVua25vd25bXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21waWxlZFRlbXBsYXRlIGV4dGVuZHMgT21pdDxUZW1wbGF0ZSwgJ2VsJz4ge1xuICAvLyBlbCBpcyBvdmVycmlkZGVuIHRvIGJlIG9wdGlvbmFsLiBXZSBpbml0aWFsaXplIGl0IG9uIGZpcnN0IHJlbmRlclxuICBlbD86IEhUTUxUZW1wbGF0ZUVsZW1lbnQ7XG5cbiAgLy8gVGhlIHByZXBhcmVkIEhUTUwgc3RyaW5nIHRvIGNyZWF0ZSBhIHRlbXBsYXRlIGVsZW1lbnQgZnJvbS5cbiAgaDogVHJ1c3RlZEhUTUw7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgdGVtcGxhdGUgbGl0ZXJhbCB0YWcgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgVGVtcGxhdGVSZXN1bHQgd2l0aFxuICogdGhlIGdpdmVuIHJlc3VsdCB0eXBlLlxuICovXG5jb25zdCB0YWcgPVxuICA8VCBleHRlbmRzIFJlc3VsdFR5cGU+KHR5cGU6IFQpID0+XG4gIChzdHJpbmdzOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSwgLi4udmFsdWVzOiB1bmtub3duW10pOiBUZW1wbGF0ZVJlc3VsdDxUPiA9PiB7XG4gICAgLy8gV2FybiBhZ2FpbnN0IHRlbXBsYXRlcyBvY3RhbCBlc2NhcGUgc2VxdWVuY2VzXG4gICAgLy8gV2UgZG8gdGhpcyBoZXJlIHJhdGhlciB0aGFuIGluIHJlbmRlciBzbyB0aGF0IHRoZSB3YXJuaW5nIGlzIGNsb3NlciB0byB0aGVcbiAgICAvLyB0ZW1wbGF0ZSBkZWZpbml0aW9uLlxuICAgIGlmIChERVZfTU9ERSAmJiBzdHJpbmdzLnNvbWUoKHMpID0+IHMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ1NvbWUgdGVtcGxhdGUgc3RyaW5ncyBhcmUgdW5kZWZpbmVkLlxcbicgK1xuICAgICAgICAgICdUaGlzIGlzIHByb2JhYmx5IGNhdXNlZCBieSBpbGxlZ2FsIG9jdGFsIGVzY2FwZSBzZXF1ZW5jZXMuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFRoaXMgcHJvcGVydHkgbmVlZHMgdG8gcmVtYWluIHVubWluaWZpZWQuXG4gICAgICBbJ18kbGl0VHlwZSQnXTogdHlwZSxcbiAgICAgIHN0cmluZ3MsXG4gICAgICB2YWx1ZXMsXG4gICAgfTtcbiAgfTtcblxuLyoqXG4gKiBJbnRlcnByZXRzIGEgdGVtcGxhdGUgbGl0ZXJhbCBhcyBhbiBIVE1MIHRlbXBsYXRlIHRoYXQgY2FuIGVmZmljaWVudGx5XG4gKiByZW5kZXIgdG8gYW5kIHVwZGF0ZSBhIGNvbnRhaW5lci5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgaGVhZGVyID0gKHRpdGxlOiBzdHJpbmcpID0+IGh0bWxgPGgxPiR7dGl0bGV9PC9oMT5gO1xuICogYGBgXG4gKlxuICogVGhlIGBodG1sYCB0YWcgcmV0dXJucyBhIGRlc2NyaXB0aW9uIG9mIHRoZSBET00gdG8gcmVuZGVyIGFzIGEgdmFsdWUuIEl0IGlzXG4gKiBsYXp5LCBtZWFuaW5nIG5vIHdvcmsgaXMgZG9uZSB1bnRpbCB0aGUgdGVtcGxhdGUgaXMgcmVuZGVyZWQuIFdoZW4gcmVuZGVyaW5nLFxuICogaWYgYSB0ZW1wbGF0ZSBjb21lcyBmcm9tIHRoZSBzYW1lIGV4cHJlc3Npb24gYXMgYSBwcmV2aW91c2x5IHJlbmRlcmVkIHJlc3VsdCxcbiAqIGl0J3MgZWZmaWNpZW50bHkgdXBkYXRlZCBpbnN0ZWFkIG9mIHJlcGxhY2VkLlxuICovXG5leHBvcnQgY29uc3QgaHRtbCA9IHRhZyhIVE1MX1JFU1VMVCk7XG5cbi8qKlxuICogSW50ZXJwcmV0cyBhIHRlbXBsYXRlIGxpdGVyYWwgYXMgYW4gU1ZHIGZyYWdtZW50IHRoYXQgY2FuIGVmZmljaWVudGx5XG4gKiByZW5kZXIgdG8gYW5kIHVwZGF0ZSBhIGNvbnRhaW5lci5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgcmVjdCA9IHN2Z2A8cmVjdCB3aWR0aD1cIjEwXCIgaGVpZ2h0PVwiMTBcIj48L3JlY3Q+YDtcbiAqXG4gKiBjb25zdCBteUltYWdlID0gaHRtbGBcbiAqICAgPHN2ZyB2aWV3Qm94PVwiMCAwIDEwIDEwXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxuICogICAgICR7cmVjdH1cbiAqICAgPC9zdmc+YDtcbiAqIGBgYFxuICpcbiAqIFRoZSBgc3ZnYCAqdGFnIGZ1bmN0aW9uKiBzaG91bGQgb25seSBiZSB1c2VkIGZvciBTVkcgZnJhZ21lbnRzLCBvciBlbGVtZW50c1xuICogdGhhdCB3b3VsZCBiZSBjb250YWluZWQgKippbnNpZGUqKiBhbiBgPHN2Zz5gIEhUTUwgZWxlbWVudC4gQSBjb21tb24gZXJyb3IgaXNcbiAqIHBsYWNpbmcgYW4gYDxzdmc+YCAqZWxlbWVudCogaW4gYSB0ZW1wbGF0ZSB0YWdnZWQgd2l0aCB0aGUgYHN2Z2AgdGFnXG4gKiBmdW5jdGlvbi4gVGhlIGA8c3ZnPmAgZWxlbWVudCBpcyBhbiBIVE1MIGVsZW1lbnQgYW5kIHNob3VsZCBiZSB1c2VkIHdpdGhpbiBhXG4gKiB0ZW1wbGF0ZSB0YWdnZWQgd2l0aCB0aGUge0BsaW5rY29kZSBodG1sfSB0YWcgZnVuY3Rpb24uXG4gKlxuICogSW4gTGl0RWxlbWVudCB1c2FnZSwgaXQncyBpbnZhbGlkIHRvIHJldHVybiBhbiBTVkcgZnJhZ21lbnQgZnJvbSB0aGVcbiAqIGByZW5kZXIoKWAgbWV0aG9kLCBhcyB0aGUgU1ZHIGZyYWdtZW50IHdpbGwgYmUgY29udGFpbmVkIHdpdGhpbiB0aGUgZWxlbWVudCdzXG4gKiBzaGFkb3cgcm9vdCBhbmQgdGh1cyBjYW5ub3QgYmUgdXNlZCB3aXRoaW4gYW4gYDxzdmc+YCBIVE1MIGVsZW1lbnQuXG4gKi9cbmV4cG9ydCBjb25zdCBzdmcgPSB0YWcoU1ZHX1JFU1VMVCk7XG5cbi8qKlxuICogQSBzZW50aW5lbCB2YWx1ZSB0aGF0IHNpZ25hbHMgdGhhdCBhIHZhbHVlIHdhcyBoYW5kbGVkIGJ5IGEgZGlyZWN0aXZlIGFuZFxuICogc2hvdWxkIG5vdCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG4gKi9cbmV4cG9ydCBjb25zdCBub0NoYW5nZSA9IFN5bWJvbC5mb3IoJ2xpdC1ub0NoYW5nZScpO1xuXG4vKipcbiAqIEEgc2VudGluZWwgdmFsdWUgdGhhdCBzaWduYWxzIGEgQ2hpbGRQYXJ0IHRvIGZ1bGx5IGNsZWFyIGl0cyBjb250ZW50LlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBidXR0b24gPSBodG1sYCR7XG4gKiAgdXNlci5pc0FkbWluXG4gKiAgICA/IGh0bWxgPGJ1dHRvbj5ERUxFVEU8L2J1dHRvbj5gXG4gKiAgICA6IG5vdGhpbmdcbiAqIH1gO1xuICogYGBgXG4gKlxuICogUHJlZmVyIHVzaW5nIGBub3RoaW5nYCBvdmVyIG90aGVyIGZhbHN5IHZhbHVlcyBhcyBpdCBwcm92aWRlcyBhIGNvbnNpc3RlbnRcbiAqIGJlaGF2aW9yIGJldHdlZW4gdmFyaW91cyBleHByZXNzaW9uIGJpbmRpbmcgY29udGV4dHMuXG4gKlxuICogSW4gY2hpbGQgZXhwcmVzc2lvbnMsIGB1bmRlZmluZWRgLCBgbnVsbGAsIGAnJ2AsIGFuZCBgbm90aGluZ2AgYWxsIGJlaGF2ZSB0aGVcbiAqIHNhbWUgYW5kIHJlbmRlciBubyBub2Rlcy4gSW4gYXR0cmlidXRlIGV4cHJlc3Npb25zLCBgbm90aGluZ2AgX3JlbW92ZXNfIHRoZVxuICogYXR0cmlidXRlLCB3aGlsZSBgdW5kZWZpbmVkYCBhbmQgYG51bGxgIHdpbGwgcmVuZGVyIGFuIGVtcHR5IHN0cmluZy4gSW5cbiAqIHByb3BlcnR5IGV4cHJlc3Npb25zIGBub3RoaW5nYCBiZWNvbWVzIGB1bmRlZmluZWRgLlxuICovXG5leHBvcnQgY29uc3Qgbm90aGluZyA9IFN5bWJvbC5mb3IoJ2xpdC1ub3RoaW5nJyk7XG5cbi8qKlxuICogVGhlIGNhY2hlIG9mIHByZXBhcmVkIHRlbXBsYXRlcywga2V5ZWQgYnkgdGhlIHRhZ2dlZCBUZW1wbGF0ZVN0cmluZ3NBcnJheVxuICogYW5kIF9ub3RfIGFjY291bnRpbmcgZm9yIHRoZSBzcGVjaWZpYyB0ZW1wbGF0ZSB0YWcgdXNlZC4gVGhpcyBtZWFucyB0aGF0XG4gKiB0ZW1wbGF0ZSB0YWdzIGNhbm5vdCBiZSBkeW5hbWljIC0gdGhlIG11c3Qgc3RhdGljYWxseSBiZSBvbmUgb2YgaHRtbCwgc3ZnLFxuICogb3IgYXR0ci4gVGhpcyByZXN0cmljdGlvbiBzaW1wbGlmaWVzIHRoZSBjYWNoZSBsb29rdXAsIHdoaWNoIGlzIG9uIHRoZSBob3RcbiAqIHBhdGggZm9yIHJlbmRlcmluZy5cbiAqL1xuY29uc3QgdGVtcGxhdGVDYWNoZSA9IG5ldyBXZWFrTWFwPFRlbXBsYXRlU3RyaW5nc0FycmF5LCBUZW1wbGF0ZT4oKTtcblxuLyoqXG4gKiBPYmplY3Qgc3BlY2lmeWluZyBvcHRpb25zIGZvciBjb250cm9sbGluZyBsaXQtaHRtbCByZW5kZXJpbmcuIE5vdGUgdGhhdFxuICogd2hpbGUgYHJlbmRlcmAgbWF5IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZSBgY29udGFpbmVyYCAoYW5kXG4gKiBgcmVuZGVyQmVmb3JlYCByZWZlcmVuY2Ugbm9kZSkgdG8gZWZmaWNpZW50bHkgdXBkYXRlIHRoZSByZW5kZXJlZCBjb250ZW50LFxuICogb25seSB0aGUgb3B0aW9ucyBwYXNzZWQgaW4gZHVyaW5nIHRoZSBmaXJzdCByZW5kZXIgYXJlIHJlc3BlY3RlZCBkdXJpbmdcbiAqIHRoZSBsaWZldGltZSBvZiByZW5kZXJzIHRvIHRoYXQgdW5pcXVlIGBjb250YWluZXJgICsgYHJlbmRlckJlZm9yZWBcbiAqIGNvbWJpbmF0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlbmRlck9wdGlvbnMge1xuICAvKipcbiAgICogQW4gb2JqZWN0IHRvIHVzZSBhcyB0aGUgYHRoaXNgIHZhbHVlIGZvciBldmVudCBsaXN0ZW5lcnMuIEl0J3Mgb2Z0ZW5cbiAgICogdXNlZnVsIHRvIHNldCB0aGlzIHRvIHRoZSBob3N0IGNvbXBvbmVudCByZW5kZXJpbmcgYSB0ZW1wbGF0ZS5cbiAgICovXG4gIGhvc3Q/OiBvYmplY3Q7XG4gIC8qKlxuICAgKiBBIERPTSBub2RlIGJlZm9yZSB3aGljaCB0byByZW5kZXIgY29udGVudCBpbiB0aGUgY29udGFpbmVyLlxuICAgKi9cbiAgcmVuZGVyQmVmb3JlPzogQ2hpbGROb2RlIHwgbnVsbDtcbiAgLyoqXG4gICAqIE5vZGUgdXNlZCBmb3IgY2xvbmluZyB0aGUgdGVtcGxhdGUgKGBpbXBvcnROb2RlYCB3aWxsIGJlIGNhbGxlZCBvbiB0aGlzXG4gICAqIG5vZGUpLiBUaGlzIGNvbnRyb2xzIHRoZSBgb3duZXJEb2N1bWVudGAgb2YgdGhlIHJlbmRlcmVkIERPTSwgYWxvbmcgd2l0aFxuICAgKiBhbnkgaW5oZXJpdGVkIGNvbnRleHQuIERlZmF1bHRzIHRvIHRoZSBnbG9iYWwgYGRvY3VtZW50YC5cbiAgICovXG4gIGNyZWF0aW9uU2NvcGU/OiB7aW1wb3J0Tm9kZShub2RlOiBOb2RlLCBkZWVwPzogYm9vbGVhbik6IE5vZGV9O1xuICAvKipcbiAgICogVGhlIGluaXRpYWwgY29ubmVjdGVkIHN0YXRlIGZvciB0aGUgdG9wLWxldmVsIHBhcnQgYmVpbmcgcmVuZGVyZWQuIElmIG5vXG4gICAqIGBpc0Nvbm5lY3RlZGAgb3B0aW9uIGlzIHNldCwgYEFzeW5jRGlyZWN0aXZlYHMgd2lsbCBiZSBjb25uZWN0ZWQgYnlcbiAgICogZGVmYXVsdC4gU2V0IHRvIGBmYWxzZWAgaWYgdGhlIGluaXRpYWwgcmVuZGVyIG9jY3VycyBpbiBhIGRpc2Nvbm5lY3RlZCB0cmVlXG4gICAqIGFuZCBgQXN5bmNEaXJlY3RpdmVgcyBzaG91bGQgc2VlIGBpc0Nvbm5lY3RlZCA9PT0gZmFsc2VgIGZvciB0aGVpciBpbml0aWFsXG4gICAqIHJlbmRlci4gVGhlIGBwYXJ0LnNldENvbm5lY3RlZCgpYCBtZXRob2QgbXVzdCBiZSB1c2VkIHN1YnNlcXVlbnQgdG8gaW5pdGlhbFxuICAgKiByZW5kZXIgdG8gY2hhbmdlIHRoZSBjb25uZWN0ZWQgc3RhdGUgb2YgdGhlIHBhcnQuXG4gICAqL1xuICBpc0Nvbm5lY3RlZD86IGJvb2xlYW47XG59XG5cbi8qKlxuICogUmVuZGVycyBhIHZhbHVlLCB1c3VhbGx5IGEgbGl0LWh0bWwgVGVtcGxhdGVSZXN1bHQsIHRvIHRoZSBjb250YWluZXIuXG4gKlxuICogVGhpcyBleGFtcGxlIHJlbmRlcnMgdGhlIHRleHQgXCJIZWxsbywgWm9lIVwiIGluc2lkZSBhIHBhcmFncmFwaCB0YWcsIGFwcGVuZGluZ1xuICogaXQgdG8gdGhlIGNvbnRhaW5lciBgZG9jdW1lbnQuYm9keWAuXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7aHRtbCwgcmVuZGVyfSBmcm9tICdsaXQnO1xuICpcbiAqIGNvbnN0IG5hbWUgPSBcIlpvZVwiO1xuICogcmVuZGVyKGh0bWxgPHA+SGVsbG8sICR7bmFtZX0hPC9wPmAsIGRvY3VtZW50LmJvZHkpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIEFueSBbcmVuZGVyYWJsZVxuICogICB2YWx1ZV0oaHR0cHM6Ly9saXQuZGV2L2RvY3MvdGVtcGxhdGVzL2V4cHJlc3Npb25zLyNjaGlsZC1leHByZXNzaW9ucyksXG4gKiAgIHR5cGljYWxseSBhIHtAbGlua2NvZGUgVGVtcGxhdGVSZXN1bHR9IGNyZWF0ZWQgYnkgZXZhbHVhdGluZyBhIHRlbXBsYXRlIHRhZ1xuICogICBsaWtlIHtAbGlua2NvZGUgaHRtbH0gb3Ige0BsaW5rY29kZSBzdmd9LlxuICogQHBhcmFtIGNvbnRhaW5lciBBIERPTSBjb250YWluZXIgdG8gcmVuZGVyIHRvLiBUaGUgZmlyc3QgcmVuZGVyIHdpbGwgYXBwZW5kXG4gKiAgIHRoZSByZW5kZXJlZCB2YWx1ZSB0byB0aGUgY29udGFpbmVyLCBhbmQgc3Vic2VxdWVudCByZW5kZXJzIHdpbGxcbiAqICAgZWZmaWNpZW50bHkgdXBkYXRlIHRoZSByZW5kZXJlZCB2YWx1ZSBpZiB0aGUgc2FtZSByZXN1bHQgdHlwZSB3YXNcbiAqICAgcHJldmlvdXNseSByZW5kZXJlZCB0aGVyZS5cbiAqIEBwYXJhbSBvcHRpb25zIFNlZSB7QGxpbmtjb2RlIFJlbmRlck9wdGlvbnN9IGZvciBvcHRpb25zIGRvY3VtZW50YXRpb24uXG4gKiBAc2VlXG4gKiB7QGxpbmsgaHR0cHM6Ly9saXQuZGV2L2RvY3MvbGlicmFyaWVzL3N0YW5kYWxvbmUtdGVtcGxhdGVzLyNyZW5kZXJpbmctbGl0LWh0bWwtdGVtcGxhdGVzfCBSZW5kZXJpbmcgTGl0IEhUTUwgVGVtcGxhdGVzfVxuICovXG5leHBvcnQgY29uc3QgcmVuZGVyID0gKFxuICB2YWx1ZTogdW5rbm93bixcbiAgY29udGFpbmVyOiBIVE1MRWxlbWVudCB8IERvY3VtZW50RnJhZ21lbnQsXG4gIG9wdGlvbnM/OiBSZW5kZXJPcHRpb25zXG4pOiBSb290UGFydCA9PiB7XG4gIGlmIChERVZfTU9ERSAmJiBjb250YWluZXIgPT0gbnVsbCkge1xuICAgIC8vIEdpdmUgYSBjbGVhcmVyIGVycm9yIG1lc3NhZ2UgdGhhblxuICAgIC8vICAgICBVbmNhdWdodCBUeXBlRXJyb3I6IENhbm5vdCByZWFkIHByb3BlcnRpZXMgb2YgbnVsbCAocmVhZGluZ1xuICAgIC8vICAgICAnXyRsaXRQYXJ0JCcpXG4gICAgLy8gd2hpY2ggcmVhZHMgbGlrZSBhbiBpbnRlcm5hbCBMaXQgZXJyb3IuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIGNvbnRhaW5lciB0byByZW5kZXIgaW50byBtYXkgbm90IGJlICR7Y29udGFpbmVyfWApO1xuICB9XG4gIGNvbnN0IHJlbmRlcklkID0gREVWX01PREUgPyBkZWJ1Z0xvZ1JlbmRlcklkKysgOiAwO1xuICBjb25zdCBwYXJ0T3duZXJOb2RlID0gb3B0aW9ucz8ucmVuZGVyQmVmb3JlID8/IGNvbnRhaW5lcjtcbiAgLy8gVGhpcyBwcm9wZXJ0eSBuZWVkcyB0byByZW1haW4gdW5taW5pZmllZC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgbGV0IHBhcnQ6IENoaWxkUGFydCA9IChwYXJ0T3duZXJOb2RlIGFzIGFueSlbJ18kbGl0UGFydCQnXTtcbiAgZGVidWdMb2dFdmVudD8uKHtcbiAgICBraW5kOiAnYmVnaW4gcmVuZGVyJyxcbiAgICBpZDogcmVuZGVySWQsXG4gICAgdmFsdWUsXG4gICAgY29udGFpbmVyLFxuICAgIG9wdGlvbnMsXG4gICAgcGFydCxcbiAgfSk7XG4gIGlmIChwYXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBlbmROb2RlID0gb3B0aW9ucz8ucmVuZGVyQmVmb3JlID8/IG51bGw7XG4gICAgLy8gVGhpcyBwcm9wZXJ0eSBuZWVkcyB0byByZW1haW4gdW5taW5pZmllZC5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIChwYXJ0T3duZXJOb2RlIGFzIGFueSlbJ18kbGl0UGFydCQnXSA9IHBhcnQgPSBuZXcgQ2hpbGRQYXJ0KFxuICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZShjcmVhdGVNYXJrZXIoKSwgZW5kTm9kZSksXG4gICAgICBlbmROb2RlLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgb3B0aW9ucyA/PyB7fVxuICAgICk7XG4gIH1cbiAgcGFydC5fJHNldFZhbHVlKHZhbHVlKTtcbiAgZGVidWdMb2dFdmVudD8uKHtcbiAgICBraW5kOiAnZW5kIHJlbmRlcicsXG4gICAgaWQ6IHJlbmRlcklkLFxuICAgIHZhbHVlLFxuICAgIGNvbnRhaW5lcixcbiAgICBvcHRpb25zLFxuICAgIHBhcnQsXG4gIH0pO1xuICByZXR1cm4gcGFydCBhcyBSb290UGFydDtcbn07XG5cbmlmIChFTkFCTEVfRVhUUkFfU0VDVVJJVFlfSE9PS1MpIHtcbiAgcmVuZGVyLnNldFNhbml0aXplciA9IHNldFNhbml0aXplcjtcbiAgcmVuZGVyLmNyZWF0ZVNhbml0aXplciA9IGNyZWF0ZVNhbml0aXplcjtcbiAgaWYgKERFVl9NT0RFKSB7XG4gICAgcmVuZGVyLl90ZXN0T25seUNsZWFyU2FuaXRpemVyRmFjdG9yeURvTm90Q2FsbE9yRWxzZSA9XG4gICAgICBfdGVzdE9ubHlDbGVhclNhbml0aXplckZhY3RvcnlEb05vdENhbGxPckVsc2U7XG4gIH1cbn1cblxuY29uc3Qgd2Fsa2VyID0gZC5jcmVhdGVUcmVlV2Fsa2VyKFxuICBkLFxuICAxMjkgLyogTm9kZUZpbHRlci5TSE9XX3tFTEVNRU5UfENPTU1FTlR9ICovLFxuICBudWxsLFxuICBmYWxzZVxuKTtcblxubGV0IHNhbml0aXplckZhY3RvcnlJbnRlcm5hbDogU2FuaXRpemVyRmFjdG9yeSA9IG5vb3BTYW5pdGl6ZXI7XG5cbi8vXG4vLyBDbGFzc2VzIG9ubHkgYmVsb3cgaGVyZSwgY29uc3QgdmFyaWFibGUgZGVjbGFyYXRpb25zIG9ubHkgYWJvdmUgaGVyZS4uLlxuLy9cbi8vIEtlZXBpbmcgdmFyaWFibGUgZGVjbGFyYXRpb25zIGFuZCBjbGFzc2VzIHRvZ2V0aGVyIGltcHJvdmVzIG1pbmlmaWNhdGlvbi5cbi8vIEludGVyZmFjZXMgYW5kIHR5cGUgYWxpYXNlcyBjYW4gYmUgaW50ZXJsZWF2ZWQgZnJlZWx5LlxuLy9cblxuLy8gVHlwZSBmb3IgY2xhc3NlcyB0aGF0IGhhdmUgYSBgX2RpcmVjdGl2ZWAgb3IgYF9kaXJlY3RpdmVzW11gIGZpZWxkLCB1c2VkIGJ5XG4vLyBgcmVzb2x2ZURpcmVjdGl2ZWBcbmV4cG9ydCBpbnRlcmZhY2UgRGlyZWN0aXZlUGFyZW50IHtcbiAgXyRwYXJlbnQ/OiBEaXJlY3RpdmVQYXJlbnQ7XG4gIF8kaXNDb25uZWN0ZWQ6IGJvb2xlYW47XG4gIF9fZGlyZWN0aXZlPzogRGlyZWN0aXZlO1xuICBfX2RpcmVjdGl2ZXM/OiBBcnJheTxEaXJlY3RpdmUgfCB1bmRlZmluZWQ+O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gSFRNTCBzdHJpbmcgZm9yIHRoZSBnaXZlbiBUZW1wbGF0ZVN0cmluZ3NBcnJheSBhbmQgcmVzdWx0IHR5cGVcbiAqIChIVE1MIG9yIFNWRyksIGFsb25nIHdpdGggdGhlIGNhc2Utc2Vuc2l0aXZlIGJvdW5kIGF0dHJpYnV0ZSBuYW1lcyBpblxuICogdGVtcGxhdGUgb3JkZXIuIFRoZSBIVE1MIGNvbnRhaW5zIGNvbW1lbnQgbWFya2VycyBkZW5vdGluZyB0aGUgYENoaWxkUGFydGBzXG4gKiBhbmQgc3VmZml4ZXMgb24gYm91bmQgYXR0cmlidXRlcyBkZW5vdGluZyB0aGUgYEF0dHJpYnV0ZVBhcnRzYC5cbiAqXG4gKiBAcGFyYW0gc3RyaW5ncyB0ZW1wbGF0ZSBzdHJpbmdzIGFycmF5XG4gKiBAcGFyYW0gdHlwZSBIVE1MIG9yIFNWR1xuICogQHJldHVybiBBcnJheSBjb250YWluaW5nIGBbaHRtbCwgYXR0ck5hbWVzXWAgKGFycmF5IHJldHVybmVkIGZvciB0ZXJzZW5lc3MsXG4gKiAgICAgdG8gYXZvaWQgb2JqZWN0IGZpZWxkcyBzaW5jZSB0aGlzIGNvZGUgaXMgc2hhcmVkIHdpdGggbm9uLW1pbmlmaWVkIFNTUlxuICogICAgIGNvZGUpXG4gKi9cbmNvbnN0IGdldFRlbXBsYXRlSHRtbCA9IChcbiAgc3RyaW5nczogVGVtcGxhdGVTdHJpbmdzQXJyYXksXG4gIHR5cGU6IFJlc3VsdFR5cGVcbik6IFtUcnVzdGVkSFRNTCwgQXJyYXk8c3RyaW5nIHwgdW5kZWZpbmVkPl0gPT4ge1xuICAvLyBJbnNlcnQgbWFrZXJzIGludG8gdGhlIHRlbXBsYXRlIEhUTUwgdG8gcmVwcmVzZW50IHRoZSBwb3NpdGlvbiBvZlxuICAvLyBiaW5kaW5ncy4gVGhlIGZvbGxvd2luZyBjb2RlIHNjYW5zIHRoZSB0ZW1wbGF0ZSBzdHJpbmdzIHRvIGRldGVybWluZSB0aGVcbiAgLy8gc3ludGFjdGljIHBvc2l0aW9uIG9mIHRoZSBiaW5kaW5ncy4gVGhleSBjYW4gYmUgaW4gdGV4dCBwb3NpdGlvbiwgd2hlcmVcbiAgLy8gd2UgaW5zZXJ0IGFuIEhUTUwgY29tbWVudCwgYXR0cmlidXRlIHZhbHVlIHBvc2l0aW9uLCB3aGVyZSB3ZSBpbnNlcnQgYVxuICAvLyBzZW50aW5lbCBzdHJpbmcgYW5kIHJlLXdyaXRlIHRoZSBhdHRyaWJ1dGUgbmFtZSwgb3IgaW5zaWRlIGEgdGFnIHdoZXJlXG4gIC8vIHdlIGluc2VydCB0aGUgc2VudGluZWwgc3RyaW5nLlxuICBjb25zdCBsID0gc3RyaW5ncy5sZW5ndGggLSAxO1xuICAvLyBTdG9yZXMgdGhlIGNhc2Utc2Vuc2l0aXZlIGJvdW5kIGF0dHJpYnV0ZSBuYW1lcyBpbiB0aGUgb3JkZXIgb2YgdGhlaXJcbiAgLy8gcGFydHMuIEVsZW1lbnRQYXJ0cyBhcmUgYWxzbyByZWZsZWN0ZWQgaW4gdGhpcyBhcnJheSBhcyB1bmRlZmluZWRcbiAgLy8gcmF0aGVyIHRoYW4gYSBzdHJpbmcsIHRvIGRpc2FtYmlndWF0ZSBmcm9tIGF0dHJpYnV0ZSBiaW5kaW5ncy5cbiAgY29uc3QgYXR0ck5hbWVzOiBBcnJheTxzdHJpbmcgfCB1bmRlZmluZWQ+ID0gW107XG4gIGxldCBodG1sID0gdHlwZSA9PT0gU1ZHX1JFU1VMVCA/ICc8c3ZnPicgOiAnJztcblxuICAvLyBXaGVuIHdlJ3JlIGluc2lkZSBhIHJhdyB0ZXh0IHRhZyAobm90IGl0J3MgdGV4dCBjb250ZW50KSwgdGhlIHJlZ2V4XG4gIC8vIHdpbGwgc3RpbGwgYmUgdGFnUmVnZXggc28gd2UgY2FuIGZpbmQgYXR0cmlidXRlcywgYnV0IHdpbGwgc3dpdGNoIHRvXG4gIC8vIHRoaXMgcmVnZXggd2hlbiB0aGUgdGFnIGVuZHMuXG4gIGxldCByYXdUZXh0RW5kUmVnZXg6IFJlZ0V4cCB8IHVuZGVmaW5lZDtcblxuICAvLyBUaGUgY3VycmVudCBwYXJzaW5nIHN0YXRlLCByZXByZXNlbnRlZCBhcyBhIHJlZmVyZW5jZSB0byBvbmUgb2YgdGhlXG4gIC8vIHJlZ2V4ZXNcbiAgbGV0IHJlZ2V4ID0gdGV4dEVuZFJlZ2V4O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgcyA9IHN0cmluZ3NbaV07XG4gICAgLy8gVGhlIGluZGV4IG9mIHRoZSBlbmQgb2YgdGhlIGxhc3QgYXR0cmlidXRlIG5hbWUuIFdoZW4gdGhpcyBpc1xuICAgIC8vIHBvc2l0aXZlIGF0IGVuZCBvZiBhIHN0cmluZywgaXQgbWVhbnMgd2UncmUgaW4gYW4gYXR0cmlidXRlIHZhbHVlXG4gICAgLy8gcG9zaXRpb24gYW5kIG5lZWQgdG8gcmV3cml0ZSB0aGUgYXR0cmlidXRlIG5hbWUuXG4gICAgLy8gV2UgYWxzbyB1c2UgYSBzcGVjaWFsIHZhbHVlIG9mIC0yIHRvIGluZGljYXRlIHRoYXQgd2UgZW5jb3VudGVyZWRcbiAgICAvLyB0aGUgZW5kIG9mIGEgc3RyaW5nIGluIGF0dHJpYnV0ZSBuYW1lIHBvc2l0aW9uLlxuICAgIGxldCBhdHRyTmFtZUVuZEluZGV4ID0gLTE7XG4gICAgbGV0IGF0dHJOYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgbGV0IGxhc3RJbmRleCA9IDA7XG4gICAgbGV0IG1hdGNoITogUmVnRXhwRXhlY0FycmF5IHwgbnVsbDtcblxuICAgIC8vIFRoZSBjb25kaXRpb25zIGluIHRoaXMgbG9vcCBoYW5kbGUgdGhlIGN1cnJlbnQgcGFyc2Ugc3RhdGUsIGFuZCB0aGVcbiAgICAvLyBhc3NpZ25tZW50cyB0byB0aGUgYHJlZ2V4YCB2YXJpYWJsZSBhcmUgdGhlIHN0YXRlIHRyYW5zaXRpb25zLlxuICAgIHdoaWxlIChsYXN0SW5kZXggPCBzLmxlbmd0aCkge1xuICAgICAgLy8gTWFrZSBzdXJlIHdlIHN0YXJ0IHNlYXJjaGluZyBmcm9tIHdoZXJlIHdlIHByZXZpb3VzbHkgbGVmdCBvZmZcbiAgICAgIHJlZ2V4Lmxhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgIG1hdGNoID0gcmVnZXguZXhlYyhzKTtcbiAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGxhc3RJbmRleCA9IHJlZ2V4Lmxhc3RJbmRleDtcbiAgICAgIGlmIChyZWdleCA9PT0gdGV4dEVuZFJlZ2V4KSB7XG4gICAgICAgIGlmIChtYXRjaFtDT01NRU5UX1NUQVJUXSA9PT0gJyEtLScpIHtcbiAgICAgICAgICByZWdleCA9IGNvbW1lbnRFbmRSZWdleDtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaFtDT01NRU5UX1NUQVJUXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gV2Ugc3RhcnRlZCBhIHdlaXJkIGNvbW1lbnQsIGxpa2UgPC97XG4gICAgICAgICAgcmVnZXggPSBjb21tZW50MkVuZFJlZ2V4O1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoW1RBR19OQU1FXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHJhd1RleHRFbGVtZW50LnRlc3QobWF0Y2hbVEFHX05BTUVdKSkge1xuICAgICAgICAgICAgLy8gUmVjb3JkIGlmIHdlIGVuY291bnRlciBhIHJhdy10ZXh0IGVsZW1lbnQuIFdlJ2xsIHN3aXRjaCB0b1xuICAgICAgICAgICAgLy8gdGhpcyByZWdleCBhdCB0aGUgZW5kIG9mIHRoZSB0YWcuXG4gICAgICAgICAgICByYXdUZXh0RW5kUmVnZXggPSBuZXcgUmVnRXhwKGA8LyR7bWF0Y2hbVEFHX05BTUVdfWAsICdnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlZ2V4ID0gdGFnRW5kUmVnZXg7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbRFlOQU1JQ19UQUdfTkFNRV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChERVZfTU9ERSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAnQmluZGluZ3MgaW4gdGFnIG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIHN0YXRpYyB0ZW1wbGF0ZXMgaW5zdGVhZC4gJyArXG4gICAgICAgICAgICAgICAgJ1NlZSBodHRwczovL2xpdC5kZXYvZG9jcy90ZW1wbGF0ZXMvZXhwcmVzc2lvbnMvI3N0YXRpYy1leHByZXNzaW9ucydcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlZ2V4ID0gdGFnRW5kUmVnZXg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVnZXggPT09IHRhZ0VuZFJlZ2V4KSB7XG4gICAgICAgIGlmIChtYXRjaFtFTlRJUkVfTUFUQ0hdID09PSAnPicpIHtcbiAgICAgICAgICAvLyBFbmQgb2YgYSB0YWcuIElmIHdlIGhhZCBzdGFydGVkIGEgcmF3LXRleHQgZWxlbWVudCwgdXNlIHRoYXRcbiAgICAgICAgICAvLyByZWdleFxuICAgICAgICAgIHJlZ2V4ID0gcmF3VGV4dEVuZFJlZ2V4ID8/IHRleHRFbmRSZWdleDtcbiAgICAgICAgICAvLyBXZSBtYXkgYmUgZW5kaW5nIGFuIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZSwgc28gbWFrZSBzdXJlIHdlXG4gICAgICAgICAgLy8gY2xlYXIgYW55IHBlbmRpbmcgYXR0ck5hbWVFbmRJbmRleFxuICAgICAgICAgIGF0dHJOYW1lRW5kSW5kZXggPSAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaFtBVFRSSUJVVEVfTkFNRV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIEF0dHJpYnV0ZSBuYW1lIHBvc2l0aW9uXG4gICAgICAgICAgYXR0ck5hbWVFbmRJbmRleCA9IC0yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF0dHJOYW1lRW5kSW5kZXggPSByZWdleC5sYXN0SW5kZXggLSBtYXRjaFtTUEFDRVNfQU5EX0VRVUFMU10ubGVuZ3RoO1xuICAgICAgICAgIGF0dHJOYW1lID0gbWF0Y2hbQVRUUklCVVRFX05BTUVdO1xuICAgICAgICAgIHJlZ2V4ID1cbiAgICAgICAgICAgIG1hdGNoW1FVT1RFX0NIQVJdID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyB0YWdFbmRSZWdleFxuICAgICAgICAgICAgICA6IG1hdGNoW1FVT1RFX0NIQVJdID09PSAnXCInXG4gICAgICAgICAgICAgID8gZG91YmxlUXVvdGVBdHRyRW5kUmVnZXhcbiAgICAgICAgICAgICAgOiBzaW5nbGVRdW90ZUF0dHJFbmRSZWdleDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgcmVnZXggPT09IGRvdWJsZVF1b3RlQXR0ckVuZFJlZ2V4IHx8XG4gICAgICAgIHJlZ2V4ID09PSBzaW5nbGVRdW90ZUF0dHJFbmRSZWdleFxuICAgICAgKSB7XG4gICAgICAgIHJlZ2V4ID0gdGFnRW5kUmVnZXg7XG4gICAgICB9IGVsc2UgaWYgKHJlZ2V4ID09PSBjb21tZW50RW5kUmVnZXggfHwgcmVnZXggPT09IGNvbW1lbnQyRW5kUmVnZXgpIHtcbiAgICAgICAgcmVnZXggPSB0ZXh0RW5kUmVnZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3Qgb25lIG9mIHRoZSBmaXZlIHN0YXRlIHJlZ2V4ZXMsIHNvIGl0IG11c3QgYmUgdGhlIGR5bmFtaWNhbGx5XG4gICAgICAgIC8vIGNyZWF0ZWQgcmF3IHRleHQgcmVnZXggYW5kIHdlJ3JlIGF0IHRoZSBjbG9zZSBvZiB0aGF0IGVsZW1lbnQuXG4gICAgICAgIHJlZ2V4ID0gdGFnRW5kUmVnZXg7XG4gICAgICAgIHJhd1RleHRFbmRSZWdleCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoREVWX01PREUpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgYSBhdHRyTmFtZUVuZEluZGV4LCB3aGljaCBpbmRpY2F0ZXMgdGhhdCB3ZSBzaG91bGRcbiAgICAgIC8vIHJld3JpdGUgdGhlIGF0dHJpYnV0ZSBuYW1lLCBhc3NlcnQgdGhhdCB3ZSdyZSBpbiBhIHZhbGlkIGF0dHJpYnV0ZVxuICAgICAgLy8gcG9zaXRpb24gLSBlaXRoZXIgaW4gYSB0YWcsIG9yIGEgcXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgIGNvbnNvbGUuYXNzZXJ0KFxuICAgICAgICBhdHRyTmFtZUVuZEluZGV4ID09PSAtMSB8fFxuICAgICAgICAgIHJlZ2V4ID09PSB0YWdFbmRSZWdleCB8fFxuICAgICAgICAgIHJlZ2V4ID09PSBzaW5nbGVRdW90ZUF0dHJFbmRSZWdleCB8fFxuICAgICAgICAgIHJlZ2V4ID09PSBkb3VibGVRdW90ZUF0dHJFbmRSZWdleCxcbiAgICAgICAgJ3VuZXhwZWN0ZWQgcGFyc2Ugc3RhdGUgQidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gV2UgaGF2ZSBmb3VyIGNhc2VzOlxuICAgIC8vICAxLiBXZSdyZSBpbiB0ZXh0IHBvc2l0aW9uLCBhbmQgbm90IGluIGEgcmF3IHRleHQgZWxlbWVudFxuICAgIC8vICAgICAocmVnZXggPT09IHRleHRFbmRSZWdleCk6IGluc2VydCBhIGNvbW1lbnQgbWFya2VyLlxuICAgIC8vICAyLiBXZSBoYXZlIGEgbm9uLW5lZ2F0aXZlIGF0dHJOYW1lRW5kSW5kZXggd2hpY2ggbWVhbnMgd2UgbmVlZCB0b1xuICAgIC8vICAgICByZXdyaXRlIHRoZSBhdHRyaWJ1dGUgbmFtZSB0byBhZGQgYSBib3VuZCBhdHRyaWJ1dGUgc3VmZml4LlxuICAgIC8vICAzLiBXZSdyZSBhdCB0aGUgbm9uLWZpcnN0IGJpbmRpbmcgaW4gYSBtdWx0aS1iaW5kaW5nIGF0dHJpYnV0ZSwgdXNlIGFcbiAgICAvLyAgICAgcGxhaW4gbWFya2VyLlxuICAgIC8vICA0LiBXZSdyZSBzb21ld2hlcmUgZWxzZSBpbnNpZGUgdGhlIHRhZy4gSWYgd2UncmUgaW4gYXR0cmlidXRlIG5hbWVcbiAgICAvLyAgICAgcG9zaXRpb24gKGF0dHJOYW1lRW5kSW5kZXggPT09IC0yKSwgYWRkIGEgc2VxdWVudGlhbCBzdWZmaXggdG9cbiAgICAvLyAgICAgZ2VuZXJhdGUgYSB1bmlxdWUgYXR0cmlidXRlIG5hbWUuXG5cbiAgICAvLyBEZXRlY3QgYSBiaW5kaW5nIG5leHQgdG8gc2VsZi1jbG9zaW5nIHRhZyBlbmQgYW5kIGluc2VydCBhIHNwYWNlIHRvXG4gICAgLy8gc2VwYXJhdGUgdGhlIG1hcmtlciBmcm9tIHRoZSB0YWcgZW5kOlxuICAgIGNvbnN0IGVuZCA9XG4gICAgICByZWdleCA9PT0gdGFnRW5kUmVnZXggJiYgc3RyaW5nc1tpICsgMV0uc3RhcnRzV2l0aCgnLz4nKSA/ICcgJyA6ICcnO1xuICAgIGh0bWwgKz1cbiAgICAgIHJlZ2V4ID09PSB0ZXh0RW5kUmVnZXhcbiAgICAgICAgPyBzICsgbm9kZU1hcmtlclxuICAgICAgICA6IGF0dHJOYW1lRW5kSW5kZXggPj0gMFxuICAgICAgICA/IChhdHRyTmFtZXMucHVzaChhdHRyTmFtZSEpLFxuICAgICAgICAgIHMuc2xpY2UoMCwgYXR0ck5hbWVFbmRJbmRleCkgK1xuICAgICAgICAgICAgYm91bmRBdHRyaWJ1dGVTdWZmaXggK1xuICAgICAgICAgICAgcy5zbGljZShhdHRyTmFtZUVuZEluZGV4KSkgK1xuICAgICAgICAgIG1hcmtlciArXG4gICAgICAgICAgZW5kXG4gICAgICAgIDogcyArXG4gICAgICAgICAgbWFya2VyICtcbiAgICAgICAgICAoYXR0ck5hbWVFbmRJbmRleCA9PT0gLTIgPyAoYXR0ck5hbWVzLnB1c2godW5kZWZpbmVkKSwgaSkgOiBlbmQpO1xuICB9XG5cbiAgY29uc3QgaHRtbFJlc3VsdDogc3RyaW5nIHwgVHJ1c3RlZEhUTUwgPVxuICAgIGh0bWwgKyAoc3RyaW5nc1tsXSB8fCAnPD8+JykgKyAodHlwZSA9PT0gU1ZHX1JFU1VMVCA/ICc8L3N2Zz4nIDogJycpO1xuXG4gIC8vIEEgc2VjdXJpdHkgY2hlY2sgdG8gcHJldmVudCBzcG9vZmluZyBvZiBMaXQgdGVtcGxhdGUgcmVzdWx0cy5cbiAgLy8gSW4gdGhlIGZ1dHVyZSwgd2UgbWF5IGJlIGFibGUgdG8gcmVwbGFjZSB0aGlzIHdpdGggQXJyYXkuaXNUZW1wbGF0ZU9iamVjdCxcbiAgLy8gdGhvdWdoIHdlIG1pZ2h0IG5lZWQgdG8gbWFrZSB0aGF0IGNoZWNrIGluc2lkZSBvZiB0aGUgaHRtbCBhbmQgc3ZnXG4gIC8vIGZ1bmN0aW9ucywgYmVjYXVzZSBwcmVjb21waWxlZCB0ZW1wbGF0ZXMgZG9uJ3QgY29tZSBpbiBhc1xuICAvLyBUZW1wbGF0ZVN0cmluZ0FycmF5IG9iamVjdHMuXG4gIGlmICghQXJyYXkuaXNBcnJheShzdHJpbmdzKSB8fCAhc3RyaW5ncy5oYXNPd25Qcm9wZXJ0eSgncmF3JykpIHtcbiAgICBsZXQgbWVzc2FnZSA9ICdpbnZhbGlkIHRlbXBsYXRlIHN0cmluZ3MgYXJyYXknO1xuICAgIGlmIChERVZfTU9ERSkge1xuICAgICAgbWVzc2FnZSA9IGBcbiAgICAgICAgICBJbnRlcm5hbCBFcnJvcjogZXhwZWN0ZWQgdGVtcGxhdGUgc3RyaW5ncyB0byBiZSBhbiBhcnJheVxuICAgICAgICAgIHdpdGggYSAncmF3JyBmaWVsZC4gRmFraW5nIGEgdGVtcGxhdGUgc3RyaW5ncyBhcnJheSBieVxuICAgICAgICAgIGNhbGxpbmcgaHRtbCBvciBzdmcgbGlrZSBhbiBvcmRpbmFyeSBmdW5jdGlvbiBpcyBlZmZlY3RpdmVseVxuICAgICAgICAgIHRoZSBzYW1lIGFzIGNhbGxpbmcgdW5zYWZlSHRtbCBhbmQgY2FuIGxlYWQgdG8gbWFqb3Igc2VjdXJpdHlcbiAgICAgICAgICBpc3N1ZXMsIGUuZy4gb3BlbmluZyB5b3VyIGNvZGUgdXAgdG8gWFNTIGF0dGFja3MuXG5cbiAgICAgICAgICBJZiB5b3UncmUgdXNpbmcgdGhlIGh0bWwgb3Igc3ZnIHRhZ2dlZCB0ZW1wbGF0ZSBmdW5jdGlvbnMgbm9ybWFsbHlcbiAgICAgICAgICBhbmQgYW5kIHN0aWxsIHNlZWluZyB0aGlzIGVycm9yLCBwbGVhc2UgZmlsZSBhIGJ1ZyBhdFxuICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9saXQvbGl0L2lzc3Vlcy9uZXc/dGVtcGxhdGU9YnVnX3JlcG9ydC5tZFxuICAgICAgICAgIGFuZCBpbmNsdWRlIGluZm9ybWF0aW9uIGFib3V0IHlvdXIgYnVpbGQgdG9vbGluZywgaWYgYW55LlxuICAgICAgICBgXG4gICAgICAgIC50cmltKClcbiAgICAgICAgLnJlcGxhY2UoL1xcbiAqL2csICdcXG4nKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIC8vIFJldHVybmVkIGFzIGFuIGFycmF5IGZvciB0ZXJzZW5lc3NcbiAgcmV0dXJuIFtcbiAgICBwb2xpY3kgIT09IHVuZGVmaW5lZFxuICAgICAgPyBwb2xpY3kuY3JlYXRlSFRNTChodG1sUmVzdWx0KVxuICAgICAgOiAoaHRtbFJlc3VsdCBhcyB1bmtub3duIGFzIFRydXN0ZWRIVE1MKSxcbiAgICBhdHRyTmFtZXMsXG4gIF07XG59O1xuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgdHlwZSB7VGVtcGxhdGV9O1xuY2xhc3MgVGVtcGxhdGUge1xuICAvKiogQGludGVybmFsICovXG4gIGVsITogSFRNTFRlbXBsYXRlRWxlbWVudDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwYXJ0czogQXJyYXk8VGVtcGxhdGVQYXJ0PiA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIC8vIFRoaXMgcHJvcGVydHkgbmVlZHMgdG8gcmVtYWluIHVubWluaWZpZWQuXG4gICAge3N0cmluZ3MsIFsnXyRsaXRUeXBlJCddOiB0eXBlfTogVGVtcGxhdGVSZXN1bHQsXG4gICAgb3B0aW9ucz86IFJlbmRlck9wdGlvbnNcbiAgKSB7XG4gICAgbGV0IG5vZGU6IE5vZGUgfCBudWxsO1xuICAgIGxldCBub2RlSW5kZXggPSAwO1xuICAgIGxldCBhdHRyTmFtZUluZGV4ID0gMDtcbiAgICBjb25zdCBwYXJ0Q291bnQgPSBzdHJpbmdzLmxlbmd0aCAtIDE7XG4gICAgY29uc3QgcGFydHMgPSB0aGlzLnBhcnRzO1xuXG4gICAgLy8gQ3JlYXRlIHRlbXBsYXRlIGVsZW1lbnRcbiAgICBjb25zdCBbaHRtbCwgYXR0ck5hbWVzXSA9IGdldFRlbXBsYXRlSHRtbChzdHJpbmdzLCB0eXBlKTtcbiAgICB0aGlzLmVsID0gVGVtcGxhdGUuY3JlYXRlRWxlbWVudChodG1sLCBvcHRpb25zKTtcbiAgICB3YWxrZXIuY3VycmVudE5vZGUgPSB0aGlzLmVsLmNvbnRlbnQ7XG5cbiAgICAvLyBSZXBhcmVudCBTVkcgbm9kZXMgaW50byB0ZW1wbGF0ZSByb290XG4gICAgaWYgKHR5cGUgPT09IFNWR19SRVNVTFQpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmVsLmNvbnRlbnQ7XG4gICAgICBjb25zdCBzdmdFbGVtZW50ID0gY29udGVudC5maXJzdENoaWxkITtcbiAgICAgIHN2Z0VsZW1lbnQucmVtb3ZlKCk7XG4gICAgICBjb250ZW50LmFwcGVuZCguLi5zdmdFbGVtZW50LmNoaWxkTm9kZXMpO1xuICAgIH1cblxuICAgIC8vIFdhbGsgdGhlIHRlbXBsYXRlIHRvIGZpbmQgYmluZGluZyBtYXJrZXJzIGFuZCBjcmVhdGUgVGVtcGxhdGVQYXJ0c1xuICAgIHdoaWxlICgobm9kZSA9IHdhbGtlci5uZXh0Tm9kZSgpKSAhPT0gbnVsbCAmJiBwYXJ0cy5sZW5ndGggPCBwYXJ0Q291bnQpIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIGlmIChERVZfTU9ERSkge1xuICAgICAgICAgIGNvbnN0IHRhZyA9IChub2RlIGFzIEVsZW1lbnQpLmxvY2FsTmFtZTtcbiAgICAgICAgICAvLyBXYXJuIGlmIGB0ZXh0YXJlYWAgaW5jbHVkZXMgYW4gZXhwcmVzc2lvbiBhbmQgdGhyb3cgaWYgYHRlbXBsYXRlYFxuICAgICAgICAgIC8vIGRvZXMgc2luY2UgdGhlc2UgYXJlIG5vdCBzdXBwb3J0ZWQuIFdlIGRvIHRoaXMgYnkgY2hlY2tpbmdcbiAgICAgICAgICAvLyBpbm5lckhUTUwgZm9yIGFueXRoaW5nIHRoYXQgbG9va3MgbGlrZSBhIG1hcmtlci4gVGhpcyBjYXRjaGVzXG4gICAgICAgICAgLy8gY2FzZXMgbGlrZSBiaW5kaW5ncyBpbiB0ZXh0YXJlYSB0aGVyZSBtYXJrZXJzIHR1cm4gaW50byB0ZXh0IG5vZGVzLlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC9eKD86dGV4dGFyZWF8dGVtcGxhdGUpJC9pIS50ZXN0KHRhZykgJiZcbiAgICAgICAgICAgIChub2RlIGFzIEVsZW1lbnQpLmlubmVySFRNTC5pbmNsdWRlcyhtYXJrZXIpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBtID1cbiAgICAgICAgICAgICAgYEV4cHJlc3Npb25zIGFyZSBub3Qgc3VwcG9ydGVkIGluc2lkZSBcXGAke3RhZ31cXGAgYCArXG4gICAgICAgICAgICAgIGBlbGVtZW50cy4gU2VlIGh0dHBzOi8vbGl0LmRldi9tc2cvZXhwcmVzc2lvbi1pbi0ke3RhZ30gZm9yIG1vcmUgYCArXG4gICAgICAgICAgICAgIGBpbmZvcm1hdGlvbi5gO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSk7XG4gICAgICAgICAgICB9IGVsc2UgaXNzdWVXYXJuaW5nKCcnLCBtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyAoanVzdGluZmFnbmFuaSk6IGZvciBhdHRlbXB0ZWQgZHluYW1pYyB0YWcgbmFtZXMsIHdlIGRvbid0XG4gICAgICAgIC8vIGluY3JlbWVudCB0aGUgYmluZGluZ0luZGV4LCBhbmQgaXQnbGwgYmUgb2ZmIGJ5IDEgaW4gdGhlIGVsZW1lbnRcbiAgICAgICAgLy8gYW5kIG9mZiBieSB0d28gYWZ0ZXIgaXQuXG4gICAgICAgIGlmICgobm9kZSBhcyBFbGVtZW50KS5oYXNBdHRyaWJ1dGVzKCkpIHtcbiAgICAgICAgICAvLyBXZSBkZWZlciByZW1vdmluZyBib3VuZCBhdHRyaWJ1dGVzIGJlY2F1c2Ugb24gSUUgd2UgbWlnaHQgbm90IGJlXG4gICAgICAgICAgLy8gaXRlcmF0aW5nIGF0dHJpYnV0ZXMgaW4gdGhlaXIgdGVtcGxhdGUgb3JkZXIsIGFuZCB3b3VsZCBzb21ldGltZXNcbiAgICAgICAgICAvLyByZW1vdmUgYW4gYXR0cmlidXRlIHRoYXQgd2Ugc3RpbGwgbmVlZCB0byBjcmVhdGUgYSBwYXJ0IGZvci5cbiAgICAgICAgICBjb25zdCBhdHRyc1RvUmVtb3ZlID0gW107XG4gICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIChub2RlIGFzIEVsZW1lbnQpLmdldEF0dHJpYnV0ZU5hbWVzKCkpIHtcbiAgICAgICAgICAgIC8vIGBuYW1lYCBpcyB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHdlJ3JlIGl0ZXJhdGluZyBvdmVyLCBidXQgbm90XG4gICAgICAgICAgICAvLyBfbmVjY2Vzc2FyaWx5XyB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHdlIHdpbGwgY3JlYXRlIGEgcGFydFxuICAgICAgICAgICAgLy8gZm9yLiBUaGV5IGNhbiBiZSBkaWZmZXJlbnQgaW4gYnJvd3NlcnMgdGhhdCBkb24ndCBpdGVyYXRlIG9uXG4gICAgICAgICAgICAvLyBhdHRyaWJ1dGVzIGluIHNvdXJjZSBvcmRlci4gSW4gdGhhdCBjYXNlIHRoZSBhdHRyTmFtZXMgYXJyYXlcbiAgICAgICAgICAgIC8vIGNvbnRhaW5zIHRoZSBhdHRyaWJ1dGUgbmFtZSB3ZSdsbCBwcm9jZXNzIG5leHQuIFdlIG9ubHkgbmVlZCB0aGVcbiAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSBuYW1lIGhlcmUgdG8ga25vdyBpZiB3ZSBzaG91bGQgcHJvY2VzcyBhIGJvdW5kIGF0dHJpYnV0ZVxuICAgICAgICAgICAgLy8gb24gdGhpcyBlbGVtZW50LlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBuYW1lLmVuZHNXaXRoKGJvdW5kQXR0cmlidXRlU3VmZml4KSB8fFxuICAgICAgICAgICAgICBuYW1lLnN0YXJ0c1dpdGgobWFya2VyKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlYWxOYW1lID0gYXR0ck5hbWVzW2F0dHJOYW1lSW5kZXgrK107XG4gICAgICAgICAgICAgIGF0dHJzVG9SZW1vdmUucHVzaChuYW1lKTtcbiAgICAgICAgICAgICAgaWYgKHJlYWxOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBMb3dlcmNhc2UgZm9yIGNhc2Utc2Vuc2l0aXZlIFNWRyBhdHRyaWJ1dGVzIGxpa2Ugdmlld0JveFxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKG5vZGUgYXMgRWxlbWVudCkuZ2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgcmVhbE5hbWUudG9Mb3dlckNhc2UoKSArIGJvdW5kQXR0cmlidXRlU3VmZml4XG4gICAgICAgICAgICAgICAgKSE7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGljcyA9IHZhbHVlLnNwbGl0KG1hcmtlcik7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IC8oWy4/QF0pPyguKikvLmV4ZWMocmVhbE5hbWUpITtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IEFUVFJJQlVURV9QQVJULFxuICAgICAgICAgICAgICAgICAgaW5kZXg6IG5vZGVJbmRleCxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IG1bMl0sXG4gICAgICAgICAgICAgICAgICBzdHJpbmdzOiBzdGF0aWNzLFxuICAgICAgICAgICAgICAgICAgY3RvcjpcbiAgICAgICAgICAgICAgICAgICAgbVsxXSA9PT0gJy4nXG4gICAgICAgICAgICAgICAgICAgICAgPyBQcm9wZXJ0eVBhcnRcbiAgICAgICAgICAgICAgICAgICAgICA6IG1bMV0gPT09ICc/J1xuICAgICAgICAgICAgICAgICAgICAgID8gQm9vbGVhbkF0dHJpYnV0ZVBhcnRcbiAgICAgICAgICAgICAgICAgICAgICA6IG1bMV0gPT09ICdAJ1xuICAgICAgICAgICAgICAgICAgICAgID8gRXZlbnRQYXJ0XG4gICAgICAgICAgICAgICAgICAgICAgOiBBdHRyaWJ1dGVQYXJ0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgdHlwZTogRUxFTUVOVF9QQVJULFxuICAgICAgICAgICAgICAgICAgaW5kZXg6IG5vZGVJbmRleCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgYXR0cnNUb1JlbW92ZSkge1xuICAgICAgICAgICAgKG5vZGUgYXMgRWxlbWVudCkucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIChqdXN0aW5mYWduYW5pKTogYmVuY2htYXJrIHRoZSByZWdleCBhZ2FpbnN0IHRlc3RpbmcgZm9yIGVhY2hcbiAgICAgICAgLy8gb2YgdGhlIDMgcmF3IHRleHQgZWxlbWVudCBuYW1lcy5cbiAgICAgICAgaWYgKHJhd1RleHRFbGVtZW50LnRlc3QoKG5vZGUgYXMgRWxlbWVudCkudGFnTmFtZSkpIHtcbiAgICAgICAgICAvLyBGb3IgcmF3IHRleHQgZWxlbWVudHMgd2UgbmVlZCB0byBzcGxpdCB0aGUgdGV4dCBjb250ZW50IG9uXG4gICAgICAgICAgLy8gbWFya2VycywgY3JlYXRlIGEgVGV4dCBub2RlIGZvciBlYWNoIHNlZ21lbnQsIGFuZCBjcmVhdGVcbiAgICAgICAgICAvLyBhIFRlbXBsYXRlUGFydCBmb3IgZWFjaCBtYXJrZXIuXG4gICAgICAgICAgY29uc3Qgc3RyaW5ncyA9IChub2RlIGFzIEVsZW1lbnQpLnRleHRDb250ZW50IS5zcGxpdChtYXJrZXIpO1xuICAgICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IHN0cmluZ3MubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpZiAobGFzdEluZGV4ID4gMCkge1xuICAgICAgICAgICAgKG5vZGUgYXMgRWxlbWVudCkudGV4dENvbnRlbnQgPSB0cnVzdGVkVHlwZXNcbiAgICAgICAgICAgICAgPyAodHJ1c3RlZFR5cGVzLmVtcHR5U2NyaXB0IGFzIHVua25vd24gYXMgJycpXG4gICAgICAgICAgICAgIDogJyc7XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIG5ldyB0ZXh0IG5vZGUgZm9yIGVhY2ggbGl0ZXJhbCBzZWN0aW9uXG4gICAgICAgICAgICAvLyBUaGVzZSBub2RlcyBhcmUgYWxzbyB1c2VkIGFzIHRoZSBtYXJrZXJzIGZvciBub2RlIHBhcnRzXG4gICAgICAgICAgICAvLyBXZSBjYW4ndCB1c2UgZW1wdHkgdGV4dCBub2RlcyBhcyBtYXJrZXJzIGJlY2F1c2UgdGhleSdyZVxuICAgICAgICAgICAgLy8gbm9ybWFsaXplZCB3aGVuIGNsb25pbmcgaW4gSUUgKGNvdWxkIHNpbXBsaWZ5IHdoZW5cbiAgICAgICAgICAgIC8vIElFIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgIChub2RlIGFzIEVsZW1lbnQpLmFwcGVuZChzdHJpbmdzW2ldLCBjcmVhdGVNYXJrZXIoKSk7XG4gICAgICAgICAgICAgIC8vIFdhbGsgcGFzdCB0aGUgbWFya2VyIG5vZGUgd2UganVzdCBhZGRlZFxuICAgICAgICAgICAgICB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAgICAgICAgICAgcGFydHMucHVzaCh7dHlwZTogQ0hJTERfUEFSVCwgaW5kZXg6ICsrbm9kZUluZGV4fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3RlIGJlY2F1c2UgdGhpcyBtYXJrZXIgaXMgYWRkZWQgYWZ0ZXIgdGhlIHdhbGtlcidzIGN1cnJlbnRcbiAgICAgICAgICAgIC8vIG5vZGUsIGl0IHdpbGwgYmUgd2Fsa2VkIHRvIGluIHRoZSBvdXRlciBsb29wIChhbmQgaWdub3JlZCksIHNvXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIGFkanVzdCBub2RlSW5kZXggaGVyZVxuICAgICAgICAgICAgKG5vZGUgYXMgRWxlbWVudCkuYXBwZW5kKHN0cmluZ3NbbGFzdEluZGV4XSwgY3JlYXRlTWFya2VyKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSA4KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSAobm9kZSBhcyBDb21tZW50KS5kYXRhO1xuICAgICAgICBpZiAoZGF0YSA9PT0gbWFya2VyTWF0Y2gpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHt0eXBlOiBDSElMRF9QQVJULCBpbmRleDogbm9kZUluZGV4fSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGkgPSAtMTtcbiAgICAgICAgICB3aGlsZSAoKGkgPSAobm9kZSBhcyBDb21tZW50KS5kYXRhLmluZGV4T2YobWFya2VyLCBpICsgMSkpICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gQ29tbWVudCBub2RlIGhhcyBhIGJpbmRpbmcgbWFya2VyIGluc2lkZSwgbWFrZSBhbiBpbmFjdGl2ZSBwYXJ0XG4gICAgICAgICAgICAvLyBUaGUgYmluZGluZyB3b24ndCB3b3JrLCBidXQgc3Vic2VxdWVudCBiaW5kaW5ncyB3aWxsXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHt0eXBlOiBDT01NRU5UX1BBUlQsIGluZGV4OiBub2RlSW5kZXh9KTtcbiAgICAgICAgICAgIC8vIE1vdmUgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2hcbiAgICAgICAgICAgIGkgKz0gbWFya2VyLmxlbmd0aCAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlSW5kZXgrKztcbiAgICB9XG4gICAgZGVidWdMb2dFdmVudD8uKHtcbiAgICAgIGtpbmQ6ICd0ZW1wbGF0ZSBwcmVwJyxcbiAgICAgIHRlbXBsYXRlOiB0aGlzLFxuICAgICAgY2xvbmFibGVUZW1wbGF0ZTogdGhpcy5lbCxcbiAgICAgIHBhcnRzOiB0aGlzLnBhcnRzLFxuICAgICAgc3RyaW5ncyxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIE92ZXJyaWRkZW4gdmlhIGBsaXRIdG1sUG9seWZpbGxTdXBwb3J0YCB0byBwcm92aWRlIHBsYXRmb3JtIHN1cHBvcnQuXG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgY3JlYXRlRWxlbWVudChodG1sOiBUcnVzdGVkSFRNTCwgX29wdGlvbnM/OiBSZW5kZXJPcHRpb25zKSB7XG4gICAgY29uc3QgZWwgPSBkLmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgZWwuaW5uZXJIVE1MID0gaHRtbCBhcyB1bmtub3duIGFzIHN0cmluZztcbiAgICByZXR1cm4gZWw7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBEaXNjb25uZWN0YWJsZSB7XG4gIF8kcGFyZW50PzogRGlzY29ubmVjdGFibGU7XG4gIF8kZGlzY29ubmVjdGFibGVDaGlsZHJlbj86IFNldDxEaXNjb25uZWN0YWJsZT47XG4gIC8vIFJhdGhlciB0aGFuIGhvbGQgY29ubmVjdGlvbiBzdGF0ZSBvbiBpbnN0YW5jZXMsIERpc2Nvbm5lY3RhYmxlcyByZWN1cnNpdmVseVxuICAvLyBmZXRjaCB0aGUgY29ubmVjdGlvbiBzdGF0ZSBmcm9tIHRoZSBSb290UGFydCB0aGV5IGFyZSBjb25uZWN0ZWQgaW4gdmlhXG4gIC8vIGdldHRlcnMgdXAgdGhlIERpc2Nvbm5lY3RhYmxlIHRyZWUgdmlhIF8kcGFyZW50IHJlZmVyZW5jZXMuIFRoaXMgcHVzaGVzIHRoZVxuICAvLyBjb3N0IG9mIHRyYWNraW5nIHRoZSBpc0Nvbm5lY3RlZCBzdGF0ZSB0byBgQXN5bmNEaXJlY3RpdmVzYCwgYW5kIGF2b2lkc1xuICAvLyBuZWVkaW5nIHRvIHBhc3MgYWxsIERpc2Nvbm5lY3RhYmxlcyAocGFydHMsIHRlbXBsYXRlIGluc3RhbmNlcywgYW5kXG4gIC8vIGRpcmVjdGl2ZXMpIHRoZWlyIGNvbm5lY3Rpb24gc3RhdGUgZWFjaCB0aW1lIGl0IGNoYW5nZXMsIHdoaWNoIHdvdWxkIGJlXG4gIC8vIGNvc3RseSBmb3IgdHJlZXMgdGhhdCBoYXZlIG5vIEFzeW5jRGlyZWN0aXZlcy5cbiAgXyRpc0Nvbm5lY3RlZDogYm9vbGVhbjtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZURpcmVjdGl2ZShcbiAgcGFydDogQ2hpbGRQYXJ0IHwgQXR0cmlidXRlUGFydCB8IEVsZW1lbnRQYXJ0LFxuICB2YWx1ZTogdW5rbm93bixcbiAgcGFyZW50OiBEaXJlY3RpdmVQYXJlbnQgPSBwYXJ0LFxuICBhdHRyaWJ1dGVJbmRleD86IG51bWJlclxuKTogdW5rbm93biB7XG4gIC8vIEJhaWwgZWFybHkgaWYgdGhlIHZhbHVlIGlzIGV4cGxpY2l0bHkgbm9DaGFuZ2UuIE5vdGUsIHRoaXMgbWVhbnMgYW55XG4gIC8vIG5lc3RlZCBkaXJlY3RpdmUgaXMgc3RpbGwgYXR0YWNoZWQgYW5kIGlzIG5vdCBydW4uXG4gIGlmICh2YWx1ZSA9PT0gbm9DaGFuZ2UpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgbGV0IGN1cnJlbnREaXJlY3RpdmUgPVxuICAgIGF0dHJpYnV0ZUluZGV4ICE9PSB1bmRlZmluZWRcbiAgICAgID8gKHBhcmVudCBhcyBBdHRyaWJ1dGVQYXJ0KS5fX2RpcmVjdGl2ZXM/LlthdHRyaWJ1dGVJbmRleF1cbiAgICAgIDogKHBhcmVudCBhcyBDaGlsZFBhcnQgfCBFbGVtZW50UGFydCB8IERpcmVjdGl2ZSkuX19kaXJlY3RpdmU7XG4gIGNvbnN0IG5leHREaXJlY3RpdmVDb25zdHJ1Y3RvciA9IGlzUHJpbWl0aXZlKHZhbHVlKVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiAvLyBUaGlzIHByb3BlcnR5IG5lZWRzIHRvIHJlbWFpbiB1bm1pbmlmaWVkLlxuICAgICAgKHZhbHVlIGFzIERpcmVjdGl2ZVJlc3VsdClbJ18kbGl0RGlyZWN0aXZlJCddO1xuICBpZiAoY3VycmVudERpcmVjdGl2ZT8uY29uc3RydWN0b3IgIT09IG5leHREaXJlY3RpdmVDb25zdHJ1Y3Rvcikge1xuICAgIC8vIFRoaXMgcHJvcGVydHkgbmVlZHMgdG8gcmVtYWluIHVubWluaWZpZWQuXG4gICAgY3VycmVudERpcmVjdGl2ZT8uWydfJG5vdGlmeURpcmVjdGl2ZUNvbm5lY3Rpb25DaGFuZ2VkJ10/LihmYWxzZSk7XG4gICAgaWYgKG5leHREaXJlY3RpdmVDb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjdXJyZW50RGlyZWN0aXZlID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50RGlyZWN0aXZlID0gbmV3IG5leHREaXJlY3RpdmVDb25zdHJ1Y3RvcihwYXJ0IGFzIFBhcnRJbmZvKTtcbiAgICAgIGN1cnJlbnREaXJlY3RpdmUuXyRpbml0aWFsaXplKHBhcnQsIHBhcmVudCwgYXR0cmlidXRlSW5kZXgpO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgKChwYXJlbnQgYXMgQXR0cmlidXRlUGFydCkuX19kaXJlY3RpdmVzID8/PSBbXSlbYXR0cmlidXRlSW5kZXhdID1cbiAgICAgICAgY3VycmVudERpcmVjdGl2ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgKHBhcmVudCBhcyBDaGlsZFBhcnQgfCBEaXJlY3RpdmUpLl9fZGlyZWN0aXZlID0gY3VycmVudERpcmVjdGl2ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGN1cnJlbnREaXJlY3RpdmUgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gcmVzb2x2ZURpcmVjdGl2ZShcbiAgICAgIHBhcnQsXG4gICAgICBjdXJyZW50RGlyZWN0aXZlLl8kcmVzb2x2ZShwYXJ0LCAodmFsdWUgYXMgRGlyZWN0aXZlUmVzdWx0KS52YWx1ZXMpLFxuICAgICAgY3VycmVudERpcmVjdGl2ZSxcbiAgICAgIGF0dHJpYnV0ZUluZGV4XG4gICAgKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQW4gdXBkYXRlYWJsZSBpbnN0YW5jZSBvZiBhIFRlbXBsYXRlLiBIb2xkcyByZWZlcmVuY2VzIHRvIHRoZSBQYXJ0cyB1c2VkIHRvXG4gKiB1cGRhdGUgdGhlIHRlbXBsYXRlIGluc3RhbmNlLlxuICovXG5jbGFzcyBUZW1wbGF0ZUluc3RhbmNlIGltcGxlbWVudHMgRGlzY29ubmVjdGFibGUge1xuICAvKiogQGludGVybmFsICovXG4gIF8kdGVtcGxhdGU6IFRlbXBsYXRlO1xuICAvKiogQGludGVybmFsICovXG4gIF9wYXJ0czogQXJyYXk8UGFydCB8IHVuZGVmaW5lZD4gPSBbXTtcblxuICAvKiogQGludGVybmFsICovXG4gIF8kcGFyZW50OiBDaGlsZFBhcnQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgXyRkaXNjb25uZWN0YWJsZUNoaWxkcmVuPzogU2V0PERpc2Nvbm5lY3RhYmxlPiA9IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZTogVGVtcGxhdGUsIHBhcmVudDogQ2hpbGRQYXJ0KSB7XG4gICAgdGhpcy5fJHRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgdGhpcy5fJHBhcmVudCA9IHBhcmVudDtcbiAgfVxuXG4gIC8vIENhbGxlZCBieSBDaGlsZFBhcnQgcGFyZW50Tm9kZSBnZXR0ZXJcbiAgZ2V0IHBhcmVudE5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuXyRwYXJlbnQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIC8vIFNlZSBjb21tZW50IGluIERpc2Nvbm5lY3RhYmxlIGludGVyZmFjZSBmb3Igd2h5IHRoaXMgaXMgYSBnZXR0ZXJcbiAgZ2V0IF8kaXNDb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuXyRwYXJlbnQuXyRpc0Nvbm5lY3RlZDtcbiAgfVxuXG4gIC8vIFRoaXMgbWV0aG9kIGlzIHNlcGFyYXRlIGZyb20gdGhlIGNvbnN0cnVjdG9yIGJlY2F1c2Ugd2UgbmVlZCB0byByZXR1cm4gYVxuICAvLyBEb2N1bWVudEZyYWdtZW50IGFuZCB3ZSBkb24ndCB3YW50IHRvIGhvbGQgb250byBpdCB3aXRoIGFuIGluc3RhbmNlIGZpZWxkLlxuICBfY2xvbmUob3B0aW9uczogUmVuZGVyT3B0aW9ucyB8IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsOiB7Y29udGVudH0sXG4gICAgICBwYXJ0czogcGFydHMsXG4gICAgfSA9IHRoaXMuXyR0ZW1wbGF0ZTtcbiAgICBjb25zdCBmcmFnbWVudCA9IChvcHRpb25zPy5jcmVhdGlvblNjb3BlID8/IGQpLmltcG9ydE5vZGUoY29udGVudCwgdHJ1ZSk7XG4gICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gZnJhZ21lbnQ7XG5cbiAgICBsZXQgbm9kZSA9IHdhbGtlci5uZXh0Tm9kZSgpITtcbiAgICBsZXQgbm9kZUluZGV4ID0gMDtcbiAgICBsZXQgcGFydEluZGV4ID0gMDtcbiAgICBsZXQgdGVtcGxhdGVQYXJ0ID0gcGFydHNbMF07XG5cbiAgICB3aGlsZSAodGVtcGxhdGVQYXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChub2RlSW5kZXggPT09IHRlbXBsYXRlUGFydC5pbmRleCkge1xuICAgICAgICBsZXQgcGFydDogUGFydCB8IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRlbXBsYXRlUGFydC50eXBlID09PSBDSElMRF9QQVJUKSB7XG4gICAgICAgICAgcGFydCA9IG5ldyBDaGlsZFBhcnQoXG4gICAgICAgICAgICBub2RlIGFzIEhUTUxFbGVtZW50LFxuICAgICAgICAgICAgbm9kZS5uZXh0U2libGluZyxcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZVBhcnQudHlwZSA9PT0gQVRUUklCVVRFX1BBUlQpIHtcbiAgICAgICAgICBwYXJ0ID0gbmV3IHRlbXBsYXRlUGFydC5jdG9yKFxuICAgICAgICAgICAgbm9kZSBhcyBIVE1MRWxlbWVudCxcbiAgICAgICAgICAgIHRlbXBsYXRlUGFydC5uYW1lLFxuICAgICAgICAgICAgdGVtcGxhdGVQYXJ0LnN0cmluZ3MsXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGVQYXJ0LnR5cGUgPT09IEVMRU1FTlRfUEFSVCkge1xuICAgICAgICAgIHBhcnQgPSBuZXcgRWxlbWVudFBhcnQobm9kZSBhcyBIVE1MRWxlbWVudCwgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgdGVtcGxhdGVQYXJ0ID0gcGFydHNbKytwYXJ0SW5kZXhdO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGVJbmRleCAhPT0gdGVtcGxhdGVQYXJ0Py5pbmRleCkge1xuICAgICAgICBub2RlID0gd2Fsa2VyLm5leHROb2RlKCkhO1xuICAgICAgICBub2RlSW5kZXgrKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9XG5cbiAgX3VwZGF0ZSh2YWx1ZXM6IEFycmF5PHVua25vd24+KSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiB0aGlzLl9wYXJ0cykge1xuICAgICAgaWYgKHBhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWJ1Z0xvZ0V2ZW50Py4oe1xuICAgICAgICAgIGtpbmQ6ICdzZXQgcGFydCcsXG4gICAgICAgICAgcGFydCxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVzW2ldLFxuICAgICAgICAgIHZhbHVlSW5kZXg6IGksXG4gICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgIHRlbXBsYXRlSW5zdGFuY2U6IHRoaXMsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoKHBhcnQgYXMgQXR0cmlidXRlUGFydCkuc3RyaW5ncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgKHBhcnQgYXMgQXR0cmlidXRlUGFydCkuXyRzZXRWYWx1ZSh2YWx1ZXMsIHBhcnQgYXMgQXR0cmlidXRlUGFydCwgaSk7XG4gICAgICAgICAgLy8gVGhlIG51bWJlciBvZiB2YWx1ZXMgdGhlIHBhcnQgY29uc3VtZXMgaXMgcGFydC5zdHJpbmdzLmxlbmd0aCAtIDFcbiAgICAgICAgICAvLyBzaW5jZSB2YWx1ZXMgYXJlIGluIGJldHdlZW4gdGVtcGxhdGUgc3BhbnMuIFdlIGluY3JlbWVudCBpIGJ5IDFcbiAgICAgICAgICAvLyBsYXRlciBpbiB0aGUgbG9vcCwgc28gaW5jcmVtZW50IGl0IGJ5IHBhcnQuc3RyaW5ncy5sZW5ndGggLSAyIGhlcmVcbiAgICAgICAgICBpICs9IChwYXJ0IGFzIEF0dHJpYnV0ZVBhcnQpLnN0cmluZ3MhLmxlbmd0aCAtIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFydC5fJHNldFZhbHVlKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9XG4gIH1cbn1cblxuLypcbiAqIFBhcnRzXG4gKi9cbnR5cGUgQXR0cmlidXRlVGVtcGxhdGVQYXJ0ID0ge1xuICByZWFkb25seSB0eXBlOiB0eXBlb2YgQVRUUklCVVRFX1BBUlQ7XG4gIHJlYWRvbmx5IGluZGV4OiBudW1iZXI7XG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICByZWFkb25seSBjdG9yOiB0eXBlb2YgQXR0cmlidXRlUGFydDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICByZWFkb25seSBzdHJpbmdzOiBSZWFkb25seUFycmF5PHN0cmluZz47XG59O1xudHlwZSBOb2RlVGVtcGxhdGVQYXJ0ID0ge1xuICByZWFkb25seSB0eXBlOiB0eXBlb2YgQ0hJTERfUEFSVDtcbiAgcmVhZG9ubHkgaW5kZXg6IG51bWJlcjtcbn07XG50eXBlIEVsZW1lbnRUZW1wbGF0ZVBhcnQgPSB7XG4gIHJlYWRvbmx5IHR5cGU6IHR5cGVvZiBFTEVNRU5UX1BBUlQ7XG4gIHJlYWRvbmx5IGluZGV4OiBudW1iZXI7XG59O1xudHlwZSBDb21tZW50VGVtcGxhdGVQYXJ0ID0ge1xuICByZWFkb25seSB0eXBlOiB0eXBlb2YgQ09NTUVOVF9QQVJUO1xuICByZWFkb25seSBpbmRleDogbnVtYmVyO1xufTtcblxuLyoqXG4gKiBBIFRlbXBsYXRlUGFydCByZXByZXNlbnRzIGEgZHluYW1pYyBwYXJ0IGluIGEgdGVtcGxhdGUsIGJlZm9yZSB0aGUgdGVtcGxhdGVcbiAqIGlzIGluc3RhbnRpYXRlZC4gV2hlbiBhIHRlbXBsYXRlIGlzIGluc3RhbnRpYXRlZCBQYXJ0cyBhcmUgY3JlYXRlZCBmcm9tXG4gKiBUZW1wbGF0ZVBhcnRzLlxuICovXG50eXBlIFRlbXBsYXRlUGFydCA9XG4gIHwgTm9kZVRlbXBsYXRlUGFydFxuICB8IEF0dHJpYnV0ZVRlbXBsYXRlUGFydFxuICB8IEVsZW1lbnRUZW1wbGF0ZVBhcnRcbiAgfCBDb21tZW50VGVtcGxhdGVQYXJ0O1xuXG5leHBvcnQgdHlwZSBQYXJ0ID1cbiAgfCBDaGlsZFBhcnRcbiAgfCBBdHRyaWJ1dGVQYXJ0XG4gIHwgUHJvcGVydHlQYXJ0XG4gIHwgQm9vbGVhbkF0dHJpYnV0ZVBhcnRcbiAgfCBFbGVtZW50UGFydFxuICB8IEV2ZW50UGFydDtcblxuZXhwb3J0IHR5cGUge0NoaWxkUGFydH07XG5jbGFzcyBDaGlsZFBhcnQgaW1wbGVtZW50cyBEaXNjb25uZWN0YWJsZSB7XG4gIHJlYWRvbmx5IHR5cGUgPSBDSElMRF9QQVJUO1xuICByZWFkb25seSBvcHRpb25zOiBSZW5kZXJPcHRpb25zIHwgdW5kZWZpbmVkO1xuICBfJGNvbW1pdHRlZFZhbHVlOiB1bmtub3duID0gbm90aGluZztcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfX2RpcmVjdGl2ZT86IERpcmVjdGl2ZTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfJHN0YXJ0Tm9kZTogQ2hpbGROb2RlO1xuICAvKiogQGludGVybmFsICovXG4gIF8kZW5kTm9kZTogQ2hpbGROb2RlIHwgbnVsbDtcbiAgcHJpdmF0ZSBfdGV4dFNhbml0aXplcjogVmFsdWVTYW5pdGl6ZXIgfCB1bmRlZmluZWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgXyRwYXJlbnQ6IERpc2Nvbm5lY3RhYmxlIHwgdW5kZWZpbmVkO1xuICAvKipcbiAgICogQ29ubmVjdGlvbiBzdGF0ZSBmb3IgUm9vdFBhcnRzIG9ubHkgKGkuZS4gQ2hpbGRQYXJ0IHdpdGhvdXQgXyRwYXJlbnRcbiAgICogcmV0dXJuZWQgZnJvbSB0b3AtbGV2ZWwgYHJlbmRlcmApLiBUaGlzIGZpZWxkIGlzIHVuc2VkIG90aGVyd2lzZS4gVGhlXG4gICAqIGludGVudGlvbiB3b3VsZCBjbGVhcmVyIGlmIHdlIG1hZGUgYFJvb3RQYXJ0YCBhIHN1YmNsYXNzIG9mIGBDaGlsZFBhcnRgXG4gICAqIHdpdGggdGhpcyBmaWVsZCAoYW5kIGEgZGlmZmVyZW50IF8kaXNDb25uZWN0ZWQgZ2V0dGVyKSwgYnV0IHRoZSBzdWJjbGFzc1xuICAgKiBjYXVzZWQgYSBwZXJmIHJlZ3Jlc3Npb24sIHBvc3NpYmx5IGR1ZSB0byBtYWtpbmcgY2FsbCBzaXRlcyBwb2x5bW9ycGhpYy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBfX2lzQ29ubmVjdGVkOiBib29sZWFuO1xuXG4gIC8vIFNlZSBjb21tZW50IGluIERpc2Nvbm5lY3RhYmxlIGludGVyZmFjZSBmb3Igd2h5IHRoaXMgaXMgYSBnZXR0ZXJcbiAgZ2V0IF8kaXNDb25uZWN0ZWQoKSB7XG4gICAgLy8gQ2hpbGRQYXJ0cyB0aGF0IGFyZSBub3QgYXQgdGhlIHJvb3Qgc2hvdWxkIGFsd2F5cyBiZSBjcmVhdGVkIHdpdGggYVxuICAgIC8vIHBhcmVudDsgb25seSBSb290Q2hpbGROb2RlJ3Mgd29uJ3QsIHNvIHRoZXkgcmV0dXJuIHRoZSBsb2NhbCBpc0Nvbm5lY3RlZFxuICAgIC8vIHN0YXRlXG4gICAgcmV0dXJuIHRoaXMuXyRwYXJlbnQ/Ll8kaXNDb25uZWN0ZWQgPz8gdGhpcy5fX2lzQ29ubmVjdGVkO1xuICB9XG5cbiAgLy8gVGhlIGZvbGxvd2luZyBmaWVsZHMgd2lsbCBiZSBwYXRjaGVkIG9udG8gQ2hpbGRQYXJ0cyB3aGVuIHJlcXVpcmVkIGJ5XG4gIC8vIEFzeW5jRGlyZWN0aXZlXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgXyRkaXNjb25uZWN0YWJsZUNoaWxkcmVuPzogU2V0PERpc2Nvbm5lY3RhYmxlPiA9IHVuZGVmaW5lZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfJG5vdGlmeUNvbm5lY3Rpb25DaGFuZ2VkPyhcbiAgICBpc0Nvbm5lY3RlZDogYm9vbGVhbixcbiAgICByZW1vdmVGcm9tUGFyZW50PzogYm9vbGVhbixcbiAgICBmcm9tPzogbnVtYmVyXG4gICk6IHZvaWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgXyRyZXBhcmVudERpc2Nvbm5lY3RhYmxlcz8ocGFyZW50OiBEaXNjb25uZWN0YWJsZSk6IHZvaWQ7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgc3RhcnROb2RlOiBDaGlsZE5vZGUsXG4gICAgZW5kTm9kZTogQ2hpbGROb2RlIHwgbnVsbCxcbiAgICBwYXJlbnQ6IFRlbXBsYXRlSW5zdGFuY2UgfCBDaGlsZFBhcnQgfCB1bmRlZmluZWQsXG4gICAgb3B0aW9uczogUmVuZGVyT3B0aW9ucyB8IHVuZGVmaW5lZFxuICApIHtcbiAgICB0aGlzLl8kc3RhcnROb2RlID0gc3RhcnROb2RlO1xuICAgIHRoaXMuXyRlbmROb2RlID0gZW5kTm9kZTtcbiAgICB0aGlzLl8kcGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgLy8gTm90ZSBfX2lzQ29ubmVjdGVkIGlzIG9ubHkgZXZlciBhY2Nlc3NlZCBvbiBSb290UGFydHMgKGkuZS4gd2hlbiB0aGVyZSBpc1xuICAgIC8vIG5vIF8kcGFyZW50KTsgdGhlIHZhbHVlIG9uIGEgbm9uLXJvb3QtcGFydCBpcyBcImRvbid0IGNhcmVcIiwgYnV0IGNoZWNraW5nXG4gICAgLy8gZm9yIHBhcmVudCB3b3VsZCBiZSBtb3JlIGNvZGVcbiAgICB0aGlzLl9faXNDb25uZWN0ZWQgPSBvcHRpb25zPy5pc0Nvbm5lY3RlZCA/PyB0cnVlO1xuICAgIGlmIChFTkFCTEVfRVhUUkFfU0VDVVJJVFlfSE9PS1MpIHtcbiAgICAgIC8vIEV4cGxpY2l0bHkgaW5pdGlhbGl6ZSBmb3IgY29uc2lzdGVudCBjbGFzcyBzaGFwZS5cbiAgICAgIHRoaXMuX3RleHRTYW5pdGl6ZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwYXJlbnQgbm9kZSBpbnRvIHdoaWNoIHRoZSBwYXJ0IHJlbmRlcnMgaXRzIGNvbnRlbnQuXG4gICAqXG4gICAqIEEgQ2hpbGRQYXJ0J3MgY29udGVudCBjb25zaXN0cyBvZiBhIHJhbmdlIG9mIGFkamFjZW50IGNoaWxkIG5vZGVzIG9mXG4gICAqIGAucGFyZW50Tm9kZWAsIHBvc3NpYmx5IGJvcmRlcmVkIGJ5ICdtYXJrZXIgbm9kZXMnIChgLnN0YXJ0Tm9kZWAgYW5kXG4gICAqIGAuZW5kTm9kZWApLlxuICAgKlxuICAgKiAtIElmIGJvdGggYC5zdGFydE5vZGVgIGFuZCBgLmVuZE5vZGVgIGFyZSBub24tbnVsbCwgdGhlbiB0aGUgcGFydCdzIGNvbnRlbnRcbiAgICogY29uc2lzdHMgb2YgYWxsIHNpYmxpbmdzIGJldHdlZW4gYC5zdGFydE5vZGVgIGFuZCBgLmVuZE5vZGVgLCBleGNsdXNpdmVseS5cbiAgICpcbiAgICogLSBJZiBgLnN0YXJ0Tm9kZWAgaXMgbm9uLW51bGwgYnV0IGAuZW5kTm9kZWAgaXMgbnVsbCwgdGhlbiB0aGUgcGFydCdzXG4gICAqIGNvbnRlbnQgY29uc2lzdHMgb2YgYWxsIHNpYmxpbmdzIGZvbGxvd2luZyBgLnN0YXJ0Tm9kZWAsIHVwIHRvIGFuZFxuICAgKiBpbmNsdWRpbmcgdGhlIGxhc3QgY2hpbGQgb2YgYC5wYXJlbnROb2RlYC4gSWYgYC5lbmROb2RlYCBpcyBub24tbnVsbCwgdGhlblxuICAgKiBgLnN0YXJ0Tm9kZWAgd2lsbCBhbHdheXMgYmUgbm9uLW51bGwuXG4gICAqXG4gICAqIC0gSWYgYm90aCBgLmVuZE5vZGVgIGFuZCBgLnN0YXJ0Tm9kZWAgYXJlIG51bGwsIHRoZW4gdGhlIHBhcnQncyBjb250ZW50XG4gICAqIGNvbnNpc3RzIG9mIGFsbCBjaGlsZCBub2RlcyBvZiBgLnBhcmVudE5vZGVgLlxuICAgKi9cbiAgZ2V0IHBhcmVudE5vZGUoKTogTm9kZSB7XG4gICAgbGV0IHBhcmVudE5vZGU6IE5vZGUgPSB3cmFwKHRoaXMuXyRzdGFydE5vZGUpLnBhcmVudE5vZGUhO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuXyRwYXJlbnQ7XG4gICAgaWYgKFxuICAgICAgcGFyZW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIHBhcmVudE5vZGUubm9kZVR5cGUgPT09IDExIC8qIE5vZGUuRE9DVU1FTlRfRlJBR01FTlQgKi9cbiAgICApIHtcbiAgICAgIC8vIElmIHRoZSBwYXJlbnROb2RlIGlzIGEgRG9jdW1lbnRGcmFnbWVudCwgaXQgbWF5IGJlIGJlY2F1c2UgdGhlIERPTSBpc1xuICAgICAgLy8gc3RpbGwgaW4gdGhlIGNsb25lZCBmcmFnbWVudCBkdXJpbmcgaW5pdGlhbCByZW5kZXI7IGlmIHNvLCBnZXQgdGhlIHJlYWxcbiAgICAgIC8vIHBhcmVudE5vZGUgdGhlIHBhcnQgd2lsbCBiZSBjb21taXR0ZWQgaW50byBieSBhc2tpbmcgdGhlIHBhcmVudC5cbiAgICAgIHBhcmVudE5vZGUgPSAocGFyZW50IGFzIENoaWxkUGFydCB8IFRlbXBsYXRlSW5zdGFuY2UpLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnROb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwYXJ0J3MgbGVhZGluZyBtYXJrZXIgbm9kZSwgaWYgYW55LiBTZWUgYC5wYXJlbnROb2RlYCBmb3IgbW9yZVxuICAgKiBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGdldCBzdGFydE5vZGUoKTogTm9kZSB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLl8kc3RhcnROb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwYXJ0J3MgdHJhaWxpbmcgbWFya2VyIG5vZGUsIGlmIGFueS4gU2VlIGAucGFyZW50Tm9kZWAgZm9yIG1vcmVcbiAgICogaW5mb3JtYXRpb24uXG4gICAqL1xuICBnZXQgZW5kTm9kZSgpOiBOb2RlIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuXyRlbmROb2RlO1xuICB9XG5cbiAgXyRzZXRWYWx1ZSh2YWx1ZTogdW5rbm93biwgZGlyZWN0aXZlUGFyZW50OiBEaXJlY3RpdmVQYXJlbnQgPSB0aGlzKTogdm9pZCB7XG4gICAgaWYgKERFVl9NT0RFICYmIHRoaXMucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGhpcyBcXGBDaGlsZFBhcnRcXGAgaGFzIG5vIFxcYHBhcmVudE5vZGVcXGAgYW5kIHRoZXJlZm9yZSBjYW5ub3QgYWNjZXB0IGEgdmFsdWUuIFRoaXMgbGlrZWx5IG1lYW5zIHRoZSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIHBhcnQgd2FzIG1hbmlwdWxhdGVkIGluIGFuIHVuc3VwcG9ydGVkIHdheSBvdXRzaWRlIG9mIExpdCdzIGNvbnRyb2wgc3VjaCB0aGF0IHRoZSBwYXJ0J3MgbWFya2VyIG5vZGVzIHdlcmUgZWplY3RlZCBmcm9tIERPTS4gRm9yIGV4YW1wbGUsIHNldHRpbmcgdGhlIGVsZW1lbnQncyBcXGBpbm5lckhUTUxcXGAgb3IgXFxgdGV4dENvbnRlbnRcXGAgY2FuIGRvIHRoaXMuYFxuICAgICAgKTtcbiAgICB9XG4gICAgdmFsdWUgPSByZXNvbHZlRGlyZWN0aXZlKHRoaXMsIHZhbHVlLCBkaXJlY3RpdmVQYXJlbnQpO1xuICAgIGlmIChpc1ByaW1pdGl2ZSh2YWx1ZSkpIHtcbiAgICAgIC8vIE5vbi1yZW5kZXJpbmcgY2hpbGQgdmFsdWVzLiBJdCdzIGltcG9ydGFudCB0aGF0IHRoZXNlIGRvIG5vdCByZW5kZXJcbiAgICAgIC8vIGVtcHR5IHRleHQgbm9kZXMgdG8gYXZvaWQgaXNzdWVzIHdpdGggcHJldmVudGluZyBkZWZhdWx0IDxzbG90PlxuICAgICAgLy8gZmFsbGJhY2sgY29udGVudC5cbiAgICAgIGlmICh2YWx1ZSA9PT0gbm90aGluZyB8fCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09PSAnJykge1xuICAgICAgICBpZiAodGhpcy5fJGNvbW1pdHRlZFZhbHVlICE9PSBub3RoaW5nKSB7XG4gICAgICAgICAgZGVidWdMb2dFdmVudD8uKHtcbiAgICAgICAgICAgIGtpbmQ6ICdjb21taXQgbm90aGluZyB0byBjaGlsZCcsXG4gICAgICAgICAgICBzdGFydDogdGhpcy5fJHN0YXJ0Tm9kZSxcbiAgICAgICAgICAgIGVuZDogdGhpcy5fJGVuZE5vZGUsXG4gICAgICAgICAgICBwYXJlbnQ6IHRoaXMuXyRwYXJlbnQsXG4gICAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5fJGNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fJGNvbW1pdHRlZFZhbHVlID0gbm90aGluZztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IHRoaXMuXyRjb21taXR0ZWRWYWx1ZSAmJiB2YWx1ZSAhPT0gbm9DaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fY29tbWl0VGV4dCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIHByb3BlcnR5IG5lZWRzIHRvIHJlbWFpbiB1bm1pbmlmaWVkLlxuICAgIH0gZWxzZSBpZiAoKHZhbHVlIGFzIFRlbXBsYXRlUmVzdWx0KVsnXyRsaXRUeXBlJCddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX2NvbW1pdFRlbXBsYXRlUmVzdWx0KHZhbHVlIGFzIFRlbXBsYXRlUmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKCh2YWx1ZSBhcyBOb2RlKS5ub2RlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoREVWX01PREUgJiYgdGhpcy5vcHRpb25zPy5ob3N0ID09PSB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jb21taXRUZXh0KFxuICAgICAgICAgIGBbcHJvYmFibGUgbWlzdGFrZTogcmVuZGVyZWQgYSB0ZW1wbGF0ZSdzIGhvc3QgaW4gaXRzZWxmIGAgK1xuICAgICAgICAgICAgYChjb21tb25seSBjYXVzZWQgYnkgd3JpdGluZyBcXCR7dGhpc30gaW4gYSB0ZW1wbGF0ZV1gXG4gICAgICAgICk7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgQXR0ZW1wdGVkIHRvIHJlbmRlciB0aGUgdGVtcGxhdGUgaG9zdGAsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgYGluc2lkZSBpdHNlbGYuIFRoaXMgaXMgYWxtb3N0IGFsd2F5cyBhIG1pc3Rha2UsIGFuZCBpbiBkZXYgbW9kZSBgLFxuICAgICAgICAgIGB3ZSByZW5kZXIgc29tZSB3YXJuaW5nIHRleHQuIEluIHByb2R1Y3Rpb24gaG93ZXZlciwgd2UnbGwgYCxcbiAgICAgICAgICBgcmVuZGVyIGl0LCB3aGljaCB3aWxsIHVzdWFsbHkgcmVzdWx0IGluIGFuIGVycm9yLCBhbmQgc29tZXRpbWVzIGAsXG4gICAgICAgICAgYGluIHRoZSBlbGVtZW50IGRpc2FwcGVhcmluZyBmcm9tIHRoZSBET00uYFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9jb21taXROb2RlKHZhbHVlIGFzIE5vZGUpO1xuICAgIH0gZWxzZSBpZiAoaXNJdGVyYWJsZSh2YWx1ZSkpIHtcbiAgICAgIHRoaXMuX2NvbW1pdEl0ZXJhYmxlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2ssIHdpbGwgcmVuZGVyIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICAgIHRoaXMuX2NvbW1pdFRleHQodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2luc2VydDxUIGV4dGVuZHMgTm9kZT4obm9kZTogVCwgcmVmID0gdGhpcy5fJGVuZE5vZGUpIHtcbiAgICByZXR1cm4gd3JhcCh3cmFwKHRoaXMuXyRzdGFydE5vZGUpLnBhcmVudE5vZGUhKS5pbnNlcnRCZWZvcmUobm9kZSwgcmVmKTtcbiAgfVxuXG4gIHByaXZhdGUgX2NvbW1pdE5vZGUodmFsdWU6IE5vZGUpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fJGNvbW1pdHRlZFZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fJGNsZWFyKCk7XG4gICAgICBpZiAoXG4gICAgICAgIEVOQUJMRV9FWFRSQV9TRUNVUklUWV9IT09LUyAmJlxuICAgICAgICBzYW5pdGl6ZXJGYWN0b3J5SW50ZXJuYWwgIT09IG5vb3BTYW5pdGl6ZXJcbiAgICAgICkge1xuICAgICAgICBjb25zdCBwYXJlbnROb2RlTmFtZSA9IHRoaXMuXyRzdGFydE5vZGUucGFyZW50Tm9kZT8ubm9kZU5hbWU7XG4gICAgICAgIGlmIChwYXJlbnROb2RlTmFtZSA9PT0gJ1NUWUxFJyB8fCBwYXJlbnROb2RlTmFtZSA9PT0gJ1NDUklQVCcpIHtcbiAgICAgICAgICBsZXQgbWVzc2FnZSA9ICdGb3JiaWRkZW4nO1xuICAgICAgICAgIGlmIChERVZfTU9ERSkge1xuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGVOYW1lID09PSAnU1RZTEUnKSB7XG4gICAgICAgICAgICAgIG1lc3NhZ2UgPVxuICAgICAgICAgICAgICAgIGBMaXQgZG9lcyBub3Qgc3VwcG9ydCBiaW5kaW5nIGluc2lkZSBzdHlsZSBub2Rlcy4gYCArXG4gICAgICAgICAgICAgICAgYFRoaXMgaXMgYSBzZWN1cml0eSByaXNrLCBhcyBzdHlsZSBpbmplY3Rpb24gYXR0YWNrcyBjYW4gYCArXG4gICAgICAgICAgICAgICAgYGV4ZmlsdHJhdGUgZGF0YSBhbmQgc3Bvb2YgVUlzLiBgICtcbiAgICAgICAgICAgICAgICBgQ29uc2lkZXIgaW5zdGVhZCB1c2luZyBjc3NcXGAuLi5cXGAgbGl0ZXJhbHMgYCArXG4gICAgICAgICAgICAgICAgYHRvIGNvbXBvc2Ugc3R5bGVzLCBhbmQgbWFrZSBkbyBkeW5hbWljIHN0eWxpbmcgd2l0aCBgICtcbiAgICAgICAgICAgICAgICBgY3NzIGN1c3RvbSBwcm9wZXJ0aWVzLCA6OnBhcnRzLCA8c2xvdD5zLCBgICtcbiAgICAgICAgICAgICAgICBgYW5kIGJ5IG11dGF0aW5nIHRoZSBET00gcmF0aGVyIHRoYW4gc3R5bGVzaGVldHMuYDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1lc3NhZ2UgPVxuICAgICAgICAgICAgICAgIGBMaXQgZG9lcyBub3Qgc3VwcG9ydCBiaW5kaW5nIGluc2lkZSBzY3JpcHQgbm9kZXMuIGAgK1xuICAgICAgICAgICAgICAgIGBUaGlzIGlzIGEgc2VjdXJpdHkgcmlzaywgYXMgaXQgY291bGQgYWxsb3cgYXJiaXRyYXJ5IGAgK1xuICAgICAgICAgICAgICAgIGBjb2RlIGV4ZWN1dGlvbi5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlYnVnTG9nRXZlbnQ/Lih7XG4gICAgICAgIGtpbmQ6ICdjb21taXQgbm9kZScsXG4gICAgICAgIHN0YXJ0OiB0aGlzLl8kc3RhcnROb2RlLFxuICAgICAgICBwYXJlbnQ6IHRoaXMuXyRwYXJlbnQsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgfSk7XG4gICAgICB0aGlzLl8kY29tbWl0dGVkVmFsdWUgPSB0aGlzLl9pbnNlcnQodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2NvbW1pdFRleHQodmFsdWU6IHVua25vd24pOiB2b2lkIHtcbiAgICAvLyBJZiB0aGUgY29tbWl0dGVkIHZhbHVlIGlzIGEgcHJpbWl0aXZlIGl0IG1lYW5zIHdlIGNhbGxlZCBfY29tbWl0VGV4dCBvblxuICAgIC8vIHRoZSBwcmV2aW91cyByZW5kZXIsIGFuZCB3ZSBrbm93IHRoYXQgdGhpcy5fJHN0YXJ0Tm9kZS5uZXh0U2libGluZyBpcyBhXG4gICAgLy8gVGV4dCBub2RlLiBXZSBjYW4gbm93IGp1c3QgcmVwbGFjZSB0aGUgdGV4dCBjb250ZW50ICguZGF0YSkgb2YgdGhlIG5vZGUuXG4gICAgaWYgKFxuICAgICAgdGhpcy5fJGNvbW1pdHRlZFZhbHVlICE9PSBub3RoaW5nICYmXG4gICAgICBpc1ByaW1pdGl2ZSh0aGlzLl8kY29tbWl0dGVkVmFsdWUpXG4gICAgKSB7XG4gICAgICBjb25zdCBub2RlID0gd3JhcCh0aGlzLl8kc3RhcnROb2RlKS5uZXh0U2libGluZyBhcyBUZXh0O1xuICAgICAgaWYgKEVOQUJMRV9FWFRSQV9TRUNVUklUWV9IT09LUykge1xuICAgICAgICBpZiAodGhpcy5fdGV4dFNhbml0aXplciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5fdGV4dFNhbml0aXplciA9IGNyZWF0ZVNhbml0aXplcihub2RlLCAnZGF0YScsICdwcm9wZXJ0eScpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdGhpcy5fdGV4dFNhbml0aXplcih2YWx1ZSk7XG4gICAgICB9XG4gICAgICBkZWJ1Z0xvZ0V2ZW50Py4oe1xuICAgICAgICBraW5kOiAnY29tbWl0IHRleHQnLFxuICAgICAgICBub2RlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgfSk7XG4gICAgICAobm9kZSBhcyBUZXh0KS5kYXRhID0gdmFsdWUgYXMgc3RyaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoRU5BQkxFX0VYVFJBX1NFQ1VSSVRZX0hPT0tTKSB7XG4gICAgICAgIGNvbnN0IHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgICAgICB0aGlzLl9jb21taXROb2RlKHRleHROb2RlKTtcbiAgICAgICAgLy8gV2hlbiBzZXR0aW5nIHRleHQgY29udGVudCwgZm9yIHNlY3VyaXR5IHB1cnBvc2VzIGl0IG1hdHRlcnMgYSBsb3RcbiAgICAgICAgLy8gd2hhdCB0aGUgcGFyZW50IGlzLiBGb3IgZXhhbXBsZSwgPHN0eWxlPiBhbmQgPHNjcmlwdD4gbmVlZCB0byBiZVxuICAgICAgICAvLyBoYW5kbGVkIHdpdGggY2FyZSwgd2hpbGUgPHNwYW4+IGRvZXMgbm90LiBTbyBmaXJzdCB3ZSBuZWVkIHRvIHB1dCBhXG4gICAgICAgIC8vIHRleHQgbm9kZSBpbnRvIHRoZSBkb2N1bWVudCwgdGhlbiB3ZSBjYW4gc2FuaXRpemUgaXRzIGNvbnRlbnQuXG4gICAgICAgIGlmICh0aGlzLl90ZXh0U2FuaXRpemVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLl90ZXh0U2FuaXRpemVyID0gY3JlYXRlU2FuaXRpemVyKHRleHROb2RlLCAnZGF0YScsICdwcm9wZXJ0eScpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdGhpcy5fdGV4dFNhbml0aXplcih2YWx1ZSk7XG4gICAgICAgIGRlYnVnTG9nRXZlbnQ/Lih7XG4gICAgICAgICAga2luZDogJ2NvbW1pdCB0ZXh0JyxcbiAgICAgICAgICBub2RlOiB0ZXh0Tm9kZSxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICB0ZXh0Tm9kZS5kYXRhID0gdmFsdWUgYXMgc3RyaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY29tbWl0Tm9kZShkLmNyZWF0ZVRleHROb2RlKHZhbHVlIGFzIHN0cmluZykpO1xuICAgICAgICBkZWJ1Z0xvZ0V2ZW50Py4oe1xuICAgICAgICAgIGtpbmQ6ICdjb21taXQgdGV4dCcsXG4gICAgICAgICAgbm9kZTogd3JhcCh0aGlzLl8kc3RhcnROb2RlKS5uZXh0U2libGluZyBhcyBUZXh0LFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuXyRjb21taXR0ZWRWYWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgcHJpdmF0ZSBfY29tbWl0VGVtcGxhdGVSZXN1bHQoXG4gICAgcmVzdWx0OiBUZW1wbGF0ZVJlc3VsdCB8IENvbXBpbGVkVGVtcGxhdGVSZXN1bHRcbiAgKTogdm9pZCB7XG4gICAgLy8gVGhpcyBwcm9wZXJ0eSBuZWVkcyB0byByZW1haW4gdW5taW5pZmllZC5cbiAgICBjb25zdCB7dmFsdWVzLCBbJ18kbGl0VHlwZSQnXTogdHlwZX0gPSByZXN1bHQ7XG4gICAgLy8gSWYgJGxpdFR5cGUkIGlzIGEgbnVtYmVyLCByZXN1bHQgaXMgYSBwbGFpbiBUZW1wbGF0ZVJlc3VsdCBhbmQgd2UgZ2V0XG4gICAgLy8gdGhlIHRlbXBsYXRlIGZyb20gdGhlIHRlbXBsYXRlIGNhY2hlLiBJZiBub3QsIHJlc3VsdCBpcyBhXG4gICAgLy8gQ29tcGlsZWRUZW1wbGF0ZVJlc3VsdCBhbmQgXyRsaXRUeXBlJCBpcyBhIENvbXBpbGVkVGVtcGxhdGUgYW5kIHdlIG5lZWRcbiAgICAvLyB0byBjcmVhdGUgdGhlIDx0ZW1wbGF0ZT4gZWxlbWVudCB0aGUgZmlyc3QgdGltZSB3ZSBzZWUgaXQuXG4gICAgY29uc3QgdGVtcGxhdGU6IFRlbXBsYXRlIHwgQ29tcGlsZWRUZW1wbGF0ZSA9XG4gICAgICB0eXBlb2YgdHlwZSA9PT0gJ251bWJlcidcbiAgICAgICAgPyB0aGlzLl8kZ2V0VGVtcGxhdGUocmVzdWx0IGFzIFRlbXBsYXRlUmVzdWx0KVxuICAgICAgICA6ICh0eXBlLmVsID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICh0eXBlLmVsID0gVGVtcGxhdGUuY3JlYXRlRWxlbWVudCh0eXBlLmgsIHRoaXMub3B0aW9ucykpLFxuICAgICAgICAgIHR5cGUpO1xuXG4gICAgaWYgKCh0aGlzLl8kY29tbWl0dGVkVmFsdWUgYXMgVGVtcGxhdGVJbnN0YW5jZSk/Ll8kdGVtcGxhdGUgPT09IHRlbXBsYXRlKSB7XG4gICAgICBkZWJ1Z0xvZ0V2ZW50Py4oe1xuICAgICAgICBraW5kOiAndGVtcGxhdGUgdXBkYXRpbmcnLFxuICAgICAgICB0ZW1wbGF0ZSxcbiAgICAgICAgaW5zdGFuY2U6IHRoaXMuXyRjb21taXR0ZWRWYWx1ZSBhcyBUZW1wbGF0ZUluc3RhbmNlLFxuICAgICAgICBwYXJ0czogKHRoaXMuXyRjb21taXR0ZWRWYWx1ZSBhcyBUZW1wbGF0ZUluc3RhbmNlKS5fcGFydHMsXG4gICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgICAgdmFsdWVzLFxuICAgICAgfSk7XG4gICAgICAodGhpcy5fJGNvbW1pdHRlZFZhbHVlIGFzIFRlbXBsYXRlSW5zdGFuY2UpLl91cGRhdGUodmFsdWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgVGVtcGxhdGVJbnN0YW5jZSh0ZW1wbGF0ZSBhcyBUZW1wbGF0ZSwgdGhpcyk7XG4gICAgICBjb25zdCBmcmFnbWVudCA9IGluc3RhbmNlLl9jbG9uZSh0aGlzLm9wdGlvbnMpO1xuICAgICAgZGVidWdMb2dFdmVudD8uKHtcbiAgICAgICAga2luZDogJ3RlbXBsYXRlIGluc3RhbnRpYXRlZCcsXG4gICAgICAgIHRlbXBsYXRlLFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgcGFydHM6IGluc3RhbmNlLl9wYXJ0cyxcbiAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgICBmcmFnbWVudCxcbiAgICAgICAgdmFsdWVzLFxuICAgICAgfSk7XG4gICAgICBpbnN0YW5jZS5fdXBkYXRlKHZhbHVlcyk7XG4gICAgICBkZWJ1Z0xvZ0V2ZW50Py4oe1xuICAgICAgICBraW5kOiAndGVtcGxhdGUgaW5zdGFudGlhdGVkIGFuZCB1cGRhdGVkJyxcbiAgICAgICAgdGVtcGxhdGUsXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICBwYXJ0czogaW5zdGFuY2UuX3BhcnRzLFxuICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGZyYWdtZW50LFxuICAgICAgICB2YWx1ZXMsXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2NvbW1pdE5vZGUoZnJhZ21lbnQpO1xuICAgICAgdGhpcy5fJGNvbW1pdHRlZFZhbHVlID0gaW5zdGFuY2U7XG4gICAgfVxuICB9XG5cbiAgLy8gT3ZlcnJpZGRlbiB2aWEgYGxpdEh0bWxQb2x5ZmlsbFN1cHBvcnRgIHRvIHByb3ZpZGUgcGxhdGZvcm0gc3VwcG9ydC5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfJGdldFRlbXBsYXRlKHJlc3VsdDogVGVtcGxhdGVSZXN1bHQpIHtcbiAgICBsZXQgdGVtcGxhdGUgPSB0ZW1wbGF0ZUNhY2hlLmdldChyZXN1bHQuc3RyaW5ncyk7XG4gICAgaWYgKHRlbXBsYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRlbXBsYXRlQ2FjaGUuc2V0KHJlc3VsdC5zdHJpbmdzLCAodGVtcGxhdGUgPSBuZXcgVGVtcGxhdGUocmVzdWx0KSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH1cblxuICBwcml2YXRlIF9jb21taXRJdGVyYWJsZSh2YWx1ZTogSXRlcmFibGU8dW5rbm93bj4pOiB2b2lkIHtcbiAgICAvLyBGb3IgYW4gSXRlcmFibGUsIHdlIGNyZWF0ZSBhIG5ldyBJbnN0YW5jZVBhcnQgcGVyIGl0ZW0sIHRoZW4gc2V0IGl0c1xuICAgIC8vIHZhbHVlIHRvIHRoZSBpdGVtLiBUaGlzIGlzIGEgbGl0dGxlIGJpdCBvZiBvdmVyaGVhZCBmb3IgZXZlcnkgaXRlbSBpblxuICAgIC8vIGFuIEl0ZXJhYmxlLCBidXQgaXQgbGV0cyB1cyByZWN1cnNlIGVhc2lseSBhbmQgZWZmaWNpZW50bHkgdXBkYXRlIEFycmF5c1xuICAgIC8vIG9mIFRlbXBsYXRlUmVzdWx0cyB0aGF0IHdpbGwgYmUgY29tbW9ubHkgcmV0dXJuZWQgZnJvbSBleHByZXNzaW9ucyBsaWtlOlxuICAgIC8vIGFycmF5Lm1hcCgoaSkgPT4gaHRtbGAke2l9YCksIGJ5IHJldXNpbmcgZXhpc3RpbmcgVGVtcGxhdGVJbnN0YW5jZXMuXG5cbiAgICAvLyBJZiB2YWx1ZSBpcyBhbiBhcnJheSwgdGhlbiB0aGUgcHJldmlvdXMgcmVuZGVyIHdhcyBvZiBhblxuICAgIC8vIGl0ZXJhYmxlIGFuZCB2YWx1ZSB3aWxsIGNvbnRhaW4gdGhlIENoaWxkUGFydHMgZnJvbSB0aGUgcHJldmlvdXNcbiAgICAvLyByZW5kZXIuIElmIHZhbHVlIGlzIG5vdCBhbiBhcnJheSwgY2xlYXIgdGhpcyBwYXJ0IGFuZCBtYWtlIGEgbmV3XG4gICAgLy8gYXJyYXkgZm9yIENoaWxkUGFydHMuXG4gICAgaWYgKCFpc0FycmF5KHRoaXMuXyRjb21taXR0ZWRWYWx1ZSkpIHtcbiAgICAgIHRoaXMuXyRjb21taXR0ZWRWYWx1ZSA9IFtdO1xuICAgICAgdGhpcy5fJGNsZWFyKCk7XG4gICAgfVxuXG4gICAgLy8gTGV0cyB1cyBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IGl0ZW1zIHdlIHN0YW1wZWQgc28gd2UgY2FuIGNsZWFyIGxlZnRvdmVyXG4gICAgLy8gaXRlbXMgZnJvbSBhIHByZXZpb3VzIHJlbmRlclxuICAgIGNvbnN0IGl0ZW1QYXJ0cyA9IHRoaXMuXyRjb21taXR0ZWRWYWx1ZSBhcyBDaGlsZFBhcnRbXTtcbiAgICBsZXQgcGFydEluZGV4ID0gMDtcbiAgICBsZXQgaXRlbVBhcnQ6IENoaWxkUGFydCB8IHVuZGVmaW5lZDtcblxuICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgaWYgKHBhcnRJbmRleCA9PT0gaXRlbVBhcnRzLmxlbmd0aCkge1xuICAgICAgICAvLyBJZiBubyBleGlzdGluZyBwYXJ0LCBjcmVhdGUgYSBuZXcgb25lXG4gICAgICAgIC8vIFRPRE8gKGp1c3RpbmZhZ25hbmkpOiB0ZXN0IHBlcmYgaW1wYWN0IG9mIGFsd2F5cyBjcmVhdGluZyB0d28gcGFydHNcbiAgICAgICAgLy8gaW5zdGVhZCBvZiBzaGFyaW5nIHBhcnRzIGJldHdlZW4gbm9kZXNcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2xpdC9saXQvaXNzdWVzLzEyNjZcbiAgICAgICAgaXRlbVBhcnRzLnB1c2goXG4gICAgICAgICAgKGl0ZW1QYXJ0ID0gbmV3IENoaWxkUGFydChcbiAgICAgICAgICAgIHRoaXMuX2luc2VydChjcmVhdGVNYXJrZXIoKSksXG4gICAgICAgICAgICB0aGlzLl9pbnNlcnQoY3JlYXRlTWFya2VyKCkpLFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1xuICAgICAgICAgICkpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXVzZSBhbiBleGlzdGluZyBwYXJ0XG4gICAgICAgIGl0ZW1QYXJ0ID0gaXRlbVBhcnRzW3BhcnRJbmRleF07XG4gICAgICB9XG4gICAgICBpdGVtUGFydC5fJHNldFZhbHVlKGl0ZW0pO1xuICAgICAgcGFydEluZGV4Kys7XG4gICAgfVxuXG4gICAgaWYgKHBhcnRJbmRleCA8IGl0ZW1QYXJ0cy5sZW5ndGgpIHtcbiAgICAgIC8vIGl0ZW1QYXJ0cyBhbHdheXMgaGF2ZSBlbmQgbm9kZXNcbiAgICAgIHRoaXMuXyRjbGVhcihcbiAgICAgICAgaXRlbVBhcnQgJiYgd3JhcChpdGVtUGFydC5fJGVuZE5vZGUhKS5uZXh0U2libGluZyxcbiAgICAgICAgcGFydEluZGV4XG4gICAgICApO1xuICAgICAgLy8gVHJ1bmNhdGUgdGhlIHBhcnRzIGFycmF5IHNvIF92YWx1ZSByZWZsZWN0cyB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAgaXRlbVBhcnRzLmxlbmd0aCA9IHBhcnRJbmRleDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgbm9kZXMgY29udGFpbmVkIHdpdGhpbiB0aGlzIFBhcnQgZnJvbSB0aGUgRE9NLlxuICAgKlxuICAgKiBAcGFyYW0gc3RhcnQgU3RhcnQgbm9kZSB0byBjbGVhciBmcm9tLCBmb3IgY2xlYXJpbmcgYSBzdWJzZXQgb2YgdGhlIHBhcnQnc1xuICAgKiAgICAgRE9NICh1c2VkIHdoZW4gdHJ1bmNhdGluZyBpdGVyYWJsZXMpXG4gICAqIEBwYXJhbSBmcm9tICBXaGVuIGBzdGFydGAgaXMgc3BlY2lmaWVkLCB0aGUgaW5kZXggd2l0aGluIHRoZSBpdGVyYWJsZSBmcm9tXG4gICAqICAgICB3aGljaCBDaGlsZFBhcnRzIGFyZSBiZWluZyByZW1vdmVkLCB1c2VkIGZvciBkaXNjb25uZWN0aW5nIGRpcmVjdGl2ZXMgaW5cbiAgICogICAgIHRob3NlIFBhcnRzLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF8kY2xlYXIoXG4gICAgc3RhcnQ6IENoaWxkTm9kZSB8IG51bGwgPSB3cmFwKHRoaXMuXyRzdGFydE5vZGUpLm5leHRTaWJsaW5nLFxuICAgIGZyb20/OiBudW1iZXJcbiAgKSB7XG4gICAgdGhpcy5fJG5vdGlmeUNvbm5lY3Rpb25DaGFuZ2VkPy4oZmFsc2UsIHRydWUsIGZyb20pO1xuICAgIHdoaWxlIChzdGFydCAmJiBzdGFydCAhPT0gdGhpcy5fJGVuZE5vZGUpIHtcbiAgICAgIGNvbnN0IG4gPSB3cmFwKHN0YXJ0ISkubmV4dFNpYmxpbmc7XG4gICAgICAod3JhcChzdGFydCEpIGFzIEVsZW1lbnQpLnJlbW92ZSgpO1xuICAgICAgc3RhcnQgPSBuO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2YgUm9vdFBhcnQncyBgaXNDb25uZWN0ZWRgLiBOb3RlIHRoYXQgdGhpcyBtZXRvZFxuICAgKiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYFJvb3RQYXJ0YHMgKHRoZSBgQ2hpbGRQYXJ0YCByZXR1cm5lZCBmcm9tIGFcbiAgICogdG9wLWxldmVsIGByZW5kZXIoKWAgY2FsbCkuIEl0IGhhcyBubyBlZmZlY3Qgb24gbm9uLXJvb3QgQ2hpbGRQYXJ0cy5cbiAgICogQHBhcmFtIGlzQ29ubmVjdGVkIFdoZXRoZXIgdG8gc2V0XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc2V0Q29ubmVjdGVkKGlzQ29ubmVjdGVkOiBib29sZWFuKSB7XG4gICAgaWYgKHRoaXMuXyRwYXJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fX2lzQ29ubmVjdGVkID0gaXNDb25uZWN0ZWQ7XG4gICAgICB0aGlzLl8kbm90aWZ5Q29ubmVjdGlvbkNoYW5nZWQ/Lihpc0Nvbm5lY3RlZCk7XG4gICAgfSBlbHNlIGlmIChERVZfTU9ERSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAncGFydC5zZXRDb25uZWN0ZWQoKSBtYXkgb25seSBiZSBjYWxsZWQgb24gYSAnICtcbiAgICAgICAgICAnUm9vdFBhcnQgcmV0dXJuZWQgZnJvbSByZW5kZXIoKS4nXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEEgdG9wLWxldmVsIGBDaGlsZFBhcnRgIHJldHVybmVkIGZyb20gYHJlbmRlcmAgdGhhdCBtYW5hZ2VzIHRoZSBjb25uZWN0ZWRcbiAqIHN0YXRlIG9mIGBBc3luY0RpcmVjdGl2ZWBzIGNyZWF0ZWQgdGhyb3VnaG91dCB0aGUgdHJlZSBiZWxvdyBpdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSb290UGFydCBleHRlbmRzIENoaWxkUGFydCB7XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjb25uZWN0aW9uIHN0YXRlIGZvciBgQXN5bmNEaXJlY3RpdmVgcyBjb250YWluZWQgd2l0aGluIHRoaXMgcm9vdFxuICAgKiBDaGlsZFBhcnQuXG4gICAqXG4gICAqIGxpdC1odG1sIGRvZXMgbm90IGF1dG9tYXRpY2FsbHkgbW9uaXRvciB0aGUgY29ubmVjdGVkbmVzcyBvZiBET00gcmVuZGVyZWQ7XG4gICAqIGFzIHN1Y2gsIGl0IGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgY2FsbGVyIHRvIGByZW5kZXJgIHRvIGVuc3VyZSB0aGF0XG4gICAqIGBwYXJ0LnNldENvbm5lY3RlZChmYWxzZSlgIGlzIGNhbGxlZCBiZWZvcmUgdGhlIHBhcnQgb2JqZWN0IGlzIHBvdGVudGlhbGx5XG4gICAqIGRpc2NhcmRlZCwgdG8gZW5zdXJlIHRoYXQgYEFzeW5jRGlyZWN0aXZlYHMgaGF2ZSBhIGNoYW5jZSB0byBkaXNwb3NlIG9mXG4gICAqIGFueSByZXNvdXJjZXMgYmVpbmcgaGVsZC4gSWYgYSBgUm9vdFBhcnRgIHRoYXQgd2FzIHByZXZvdXNseVxuICAgKiBkaXNjb25uZWN0ZWQgaXMgc3Vic2VxdWVudGx5IHJlLWNvbm5lY3RlZCAoYW5kIGl0cyBgQXN5bmNEaXJlY3RpdmVgcyBzaG91bGRcbiAgICogcmUtY29ubmVjdCksIGBzZXRDb25uZWN0ZWQodHJ1ZSlgIHNob3VsZCBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSBpc0Nvbm5lY3RlZCBXaGV0aGVyIGRpcmVjdGl2ZXMgd2l0aGluIHRoaXMgdHJlZSBzaG91bGQgYmUgY29ubmVjdGVkXG4gICAqIG9yIG5vdFxuICAgKi9cbiAgc2V0Q29ubmVjdGVkKGlzQ29ubmVjdGVkOiBib29sZWFuKTogdm9pZDtcbn1cblxuZXhwb3J0IHR5cGUge0F0dHJpYnV0ZVBhcnR9O1xuY2xhc3MgQXR0cmlidXRlUGFydCBpbXBsZW1lbnRzIERpc2Nvbm5lY3RhYmxlIHtcbiAgcmVhZG9ubHkgdHlwZSA9IEFUVFJJQlVURV9QQVJUIGFzXG4gICAgfCB0eXBlb2YgQVRUUklCVVRFX1BBUlRcbiAgICB8IHR5cGVvZiBQUk9QRVJUWV9QQVJUXG4gICAgfCB0eXBlb2YgQk9PTEVBTl9BVFRSSUJVVEVfUEFSVFxuICAgIHwgdHlwZW9mIEVWRU5UX1BBUlQ7XG4gIHJlYWRvbmx5IGVsZW1lbnQ6IEhUTUxFbGVtZW50O1xuICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IG9wdGlvbnM6IFJlbmRlck9wdGlvbnMgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIElmIHRoaXMgYXR0cmlidXRlIHBhcnQgcmVwcmVzZW50cyBhbiBpbnRlcnBvbGF0aW9uLCB0aGlzIGNvbnRhaW5zIHRoZVxuICAgKiBzdGF0aWMgc3RyaW5ncyBvZiB0aGUgaW50ZXJwb2xhdGlvbi4gRm9yIHNpbmdsZS12YWx1ZSwgY29tcGxldGUgYmluZGluZ3MsXG4gICAqIHRoaXMgaXMgdW5kZWZpbmVkLlxuICAgKi9cbiAgcmVhZG9ubHkgc3RyaW5ncz86IFJlYWRvbmx5QXJyYXk8c3RyaW5nPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfJGNvbW1pdHRlZFZhbHVlOiB1bmtub3duIHwgQXJyYXk8dW5rbm93bj4gPSBub3RoaW5nO1xuICAvKiogQGludGVybmFsICovXG4gIF9fZGlyZWN0aXZlcz86IEFycmF5PERpcmVjdGl2ZSB8IHVuZGVmaW5lZD47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgXyRwYXJlbnQ6IERpc2Nvbm5lY3RhYmxlO1xuICAvKiogQGludGVybmFsICovXG4gIF8kZGlzY29ubmVjdGFibGVDaGlsZHJlbj86IFNldDxEaXNjb25uZWN0YWJsZT4gPSB1bmRlZmluZWQ7XG5cbiAgcHJvdGVjdGVkIF9zYW5pdGl6ZXI6IFZhbHVlU2FuaXRpemVyIHwgdW5kZWZpbmVkO1xuXG4gIGdldCB0YWdOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQudGFnTmFtZTtcbiAgfVxuXG4gIC8vIFNlZSBjb21tZW50IGluIERpc2Nvbm5lY3RhYmxlIGludGVyZmFjZSBmb3Igd2h5IHRoaXMgaXMgYSBnZXR0ZXJcbiAgZ2V0IF8kaXNDb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuXyRwYXJlbnQuXyRpc0Nvbm5lY3RlZDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGVsZW1lbnQ6IEhUTUxFbGVtZW50LFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBzdHJpbmdzOiBSZWFkb25seUFycmF5PHN0cmluZz4sXG4gICAgcGFyZW50OiBEaXNjb25uZWN0YWJsZSxcbiAgICBvcHRpb25zOiBSZW5kZXJPcHRpb25zIHwgdW5kZWZpbmVkXG4gICkge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLl8kcGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgaWYgKHN0cmluZ3MubGVuZ3RoID4gMiB8fCBzdHJpbmdzWzBdICE9PSAnJyB8fCBzdHJpbmdzWzFdICE9PSAnJykge1xuICAgICAgdGhpcy5fJGNvbW1pdHRlZFZhbHVlID0gbmV3IEFycmF5KHN0cmluZ3MubGVuZ3RoIC0gMSkuZmlsbChuZXcgU3RyaW5nKCkpO1xuICAgICAgdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fJGNvbW1pdHRlZFZhbHVlID0gbm90aGluZztcbiAgICB9XG4gICAgaWYgKEVOQUJMRV9FWFRSQV9TRUNVUklUWV9IT09LUykge1xuICAgICAgdGhpcy5fc2FuaXRpemVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGlzIHBhcnQgYnkgcmVzb2x2aW5nIHRoZSB2YWx1ZSBmcm9tIHBvc3NpYmx5IG11bHRpcGxlXG4gICAqIHZhbHVlcyBhbmQgc3RhdGljIHN0cmluZ3MgYW5kIGNvbW1pdHRpbmcgaXQgdG8gdGhlIERPTS5cbiAgICogSWYgdGhpcyBwYXJ0IGlzIHNpbmdsZS12YWx1ZWQsIGB0aGlzLl9zdHJpbmdzYCB3aWxsIGJlIHVuZGVmaW5lZCwgYW5kIHRoZVxuICAgKiBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgd2l0aCBhIHNpbmdsZSB2YWx1ZSBhcmd1bWVudC4gSWYgdGhpcyBwYXJ0IGlzXG4gICAqIG11bHRpLXZhbHVlLCBgdGhpcy5fc3RyaW5nc2Agd2lsbCBiZSBkZWZpbmVkLCBhbmQgdGhlIG1ldGhvZCBpcyBjYWxsZWRcbiAgICogd2l0aCB0aGUgdmFsdWUgYXJyYXkgb2YgdGhlIHBhcnQncyBvd25pbmcgVGVtcGxhdGVJbnN0YW5jZSwgYW5kIGFuIG9mZnNldFxuICAgKiBpbnRvIHRoZSB2YWx1ZSBhcnJheSBmcm9tIHdoaWNoIHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHJlYWQuXG4gICAqIFRoaXMgbWV0aG9kIGlzIG92ZXJsb2FkZWQgdGhpcyB3YXkgdG8gZWxpbWluYXRlIHNob3J0LWxpdmVkIGFycmF5IHNsaWNlc1xuICAgKiBvZiB0aGUgdGVtcGxhdGUgaW5zdGFuY2UgdmFsdWVzLCBhbmQgYWxsb3cgYSBmYXN0LXBhdGggZm9yIHNpbmdsZS12YWx1ZWRcbiAgICogcGFydHMuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgcGFydCB2YWx1ZSwgb3IgYW4gYXJyYXkgb2YgdmFsdWVzIGZvciBtdWx0aS12YWx1ZWQgcGFydHNcbiAgICogQHBhcmFtIHZhbHVlSW5kZXggdGhlIGluZGV4IHRvIHN0YXJ0IHJlYWRpbmcgdmFsdWVzIGZyb20uIGB1bmRlZmluZWRgIGZvclxuICAgKiAgIHNpbmdsZS12YWx1ZWQgcGFydHNcbiAgICogQHBhcmFtIG5vQ29tbWl0IGNhdXNlcyB0aGUgcGFydCB0byBub3QgY29tbWl0IGl0cyB2YWx1ZSB0byB0aGUgRE9NLiBVc2VkXG4gICAqICAgaW4gaHlkcmF0aW9uIHRvIHByaW1lIGF0dHJpYnV0ZSBwYXJ0cyB3aXRoIHRoZWlyIGZpcnN0LXJlbmRlcmVkIHZhbHVlLFxuICAgKiAgIGJ1dCBub3Qgc2V0IHRoZSBhdHRyaWJ1dGUsIGFuZCBpbiBTU1IgdG8gbm8tb3AgdGhlIERPTSBvcGVyYXRpb24gYW5kXG4gICAqICAgY2FwdHVyZSB0aGUgdmFsdWUgZm9yIHNlcmlhbGl6YXRpb24uXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgXyRzZXRWYWx1ZShcbiAgICB2YWx1ZTogdW5rbm93biB8IEFycmF5PHVua25vd24+LFxuICAgIGRpcmVjdGl2ZVBhcmVudDogRGlyZWN0aXZlUGFyZW50ID0gdGhpcyxcbiAgICB2YWx1ZUluZGV4PzogbnVtYmVyLFxuICAgIG5vQ29tbWl0PzogYm9vbGVhblxuICApIHtcbiAgICBjb25zdCBzdHJpbmdzID0gdGhpcy5zdHJpbmdzO1xuXG4gICAgLy8gV2hldGhlciBhbnkgb2YgdGhlIHZhbHVlcyBoYXMgY2hhbmdlZCwgZm9yIGRpcnR5LWNoZWNraW5nXG4gICAgbGV0IGNoYW5nZSA9IGZhbHNlO1xuXG4gICAgaWYgKHN0cmluZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gU2luZ2xlLXZhbHVlIGJpbmRpbmcgY2FzZVxuICAgICAgdmFsdWUgPSByZXNvbHZlRGlyZWN0aXZlKHRoaXMsIHZhbHVlLCBkaXJlY3RpdmVQYXJlbnQsIDApO1xuICAgICAgY2hhbmdlID1cbiAgICAgICAgIWlzUHJpbWl0aXZlKHZhbHVlKSB8fFxuICAgICAgICAodmFsdWUgIT09IHRoaXMuXyRjb21taXR0ZWRWYWx1ZSAmJiB2YWx1ZSAhPT0gbm9DaGFuZ2UpO1xuICAgICAgaWYgKGNoYW5nZSkge1xuICAgICAgICB0aGlzLl8kY29tbWl0dGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW50ZXJwb2xhdGlvbiBjYXNlXG4gICAgICBjb25zdCB2YWx1ZXMgPSB2YWx1ZSBhcyBBcnJheTx1bmtub3duPjtcbiAgICAgIHZhbHVlID0gc3RyaW5nc1swXTtcblxuICAgICAgbGV0IGksIHY7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc3RyaW5ncy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgdiA9IHJlc29sdmVEaXJlY3RpdmUodGhpcywgdmFsdWVzW3ZhbHVlSW5kZXghICsgaV0sIGRpcmVjdGl2ZVBhcmVudCwgaSk7XG5cbiAgICAgICAgaWYgKHYgPT09IG5vQ2hhbmdlKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgYG5vQ2hhbmdlYCwgdXNlIHRoZSBwcmV2aW91cyB2YWx1ZVxuICAgICAgICAgIHYgPSAodGhpcy5fJGNvbW1pdHRlZFZhbHVlIGFzIEFycmF5PHVua25vd24+KVtpXTtcbiAgICAgICAgfVxuICAgICAgICBjaGFuZ2UgfHw9XG4gICAgICAgICAgIWlzUHJpbWl0aXZlKHYpIHx8IHYgIT09ICh0aGlzLl8kY29tbWl0dGVkVmFsdWUgYXMgQXJyYXk8dW5rbm93bj4pW2ldO1xuICAgICAgICBpZiAodiA9PT0gbm90aGluZykge1xuICAgICAgICAgIHZhbHVlID0gbm90aGluZztcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gbm90aGluZykge1xuICAgICAgICAgIHZhbHVlICs9ICh2ID8/ICcnKSArIHN0cmluZ3NbaSArIDFdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGFsd2F5cyByZWNvcmQgZWFjaCB2YWx1ZSwgZXZlbiBpZiBvbmUgaXMgYG5vdGhpbmdgLCBmb3IgZnV0dXJlXG4gICAgICAgIC8vIGNoYW5nZSBkZXRlY3Rpb24uXG4gICAgICAgICh0aGlzLl8kY29tbWl0dGVkVmFsdWUgYXMgQXJyYXk8dW5rbm93bj4pW2ldID0gdjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNoYW5nZSAmJiAhbm9Db21taXQpIHtcbiAgICAgIHRoaXMuX2NvbW1pdFZhbHVlKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9jb21taXRWYWx1ZSh2YWx1ZTogdW5rbm93bikge1xuICAgIGlmICh2YWx1ZSA9PT0gbm90aGluZykge1xuICAgICAgKHdyYXAodGhpcy5lbGVtZW50KSBhcyBFbGVtZW50KS5yZW1vdmVBdHRyaWJ1dGUodGhpcy5uYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEVOQUJMRV9FWFRSQV9TRUNVUklUWV9IT09LUykge1xuICAgICAgICBpZiAodGhpcy5fc2FuaXRpemVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLl9zYW5pdGl6ZXIgPSBzYW5pdGl6ZXJGYWN0b3J5SW50ZXJuYWwoXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgICB0aGlzLm5hbWUsXG4gICAgICAgICAgICAnYXR0cmlidXRlJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB0aGlzLl9zYW5pdGl6ZXIodmFsdWUgPz8gJycpO1xuICAgICAgfVxuICAgICAgZGVidWdMb2dFdmVudD8uKHtcbiAgICAgICAga2luZDogJ2NvbW1pdCBhdHRyaWJ1dGUnLFxuICAgICAgICBlbGVtZW50OiB0aGlzLmVsZW1lbnQsXG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgIH0pO1xuICAgICAgKHdyYXAodGhpcy5lbGVtZW50KSBhcyBFbGVtZW50KS5zZXRBdHRyaWJ1dGUoXG4gICAgICAgIHRoaXMubmFtZSxcbiAgICAgICAgKHZhbHVlID8/ICcnKSBhcyBzdHJpbmdcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB0eXBlIHtQcm9wZXJ0eVBhcnR9O1xuY2xhc3MgUHJvcGVydHlQYXJ0IGV4dGVuZHMgQXR0cmlidXRlUGFydCB7XG4gIG92ZXJyaWRlIHJlYWRvbmx5IHR5cGUgPSBQUk9QRVJUWV9QQVJUO1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgb3ZlcnJpZGUgX2NvbW1pdFZhbHVlKHZhbHVlOiB1bmtub3duKSB7XG4gICAgaWYgKEVOQUJMRV9FWFRSQV9TRUNVUklUWV9IT09LUykge1xuICAgICAgaWYgKHRoaXMuX3Nhbml0aXplciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3Nhbml0aXplciA9IHNhbml0aXplckZhY3RvcnlJbnRlcm5hbChcbiAgICAgICAgICB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgdGhpcy5uYW1lLFxuICAgICAgICAgICdwcm9wZXJ0eSdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdGhpcy5fc2FuaXRpemVyKHZhbHVlKTtcbiAgICB9XG4gICAgZGVidWdMb2dFdmVudD8uKHtcbiAgICAgIGtpbmQ6ICdjb21taXQgcHJvcGVydHknLFxuICAgICAgZWxlbWVudDogdGhpcy5lbGVtZW50LFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgdmFsdWUsXG4gICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgfSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAodGhpcy5lbGVtZW50IGFzIGFueSlbdGhpcy5uYW1lXSA9IHZhbHVlID09PSBub3RoaW5nID8gdW5kZWZpbmVkIDogdmFsdWU7XG4gIH1cbn1cblxuLy8gVGVtcG9yYXJ5IHdvcmthcm91bmQgZm9yIGh0dHBzOi8vY3JidWcuY29tLzk5MzI2OFxuLy8gQ3VycmVudGx5LCBhbnkgYXR0cmlidXRlIHN0YXJ0aW5nIHdpdGggXCJvblwiIGlzIGNvbnNpZGVyZWQgdG8gYmUgYVxuLy8gVHJ1c3RlZFNjcmlwdCBzb3VyY2UuIFN1Y2ggYm9vbGVhbiBhdHRyaWJ1dGVzIG11c3QgYmUgc2V0IHRvIHRoZSBlcXVpdmFsZW50XG4vLyB0cnVzdGVkIGVtcHR5U2NyaXB0IHZhbHVlLlxuY29uc3QgZW1wdHlTdHJpbmdGb3JCb29sZWFuQXR0cmlidXRlID0gdHJ1c3RlZFR5cGVzXG4gID8gKHRydXN0ZWRUeXBlcy5lbXB0eVNjcmlwdCBhcyB1bmtub3duIGFzICcnKVxuICA6ICcnO1xuXG5leHBvcnQgdHlwZSB7Qm9vbGVhbkF0dHJpYnV0ZVBhcnR9O1xuY2xhc3MgQm9vbGVhbkF0dHJpYnV0ZVBhcnQgZXh0ZW5kcyBBdHRyaWJ1dGVQYXJ0IHtcbiAgb3ZlcnJpZGUgcmVhZG9ubHkgdHlwZSA9IEJPT0xFQU5fQVRUUklCVVRFX1BBUlQ7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBvdmVycmlkZSBfY29tbWl0VmFsdWUodmFsdWU6IHVua25vd24pIHtcbiAgICBkZWJ1Z0xvZ0V2ZW50Py4oe1xuICAgICAga2luZDogJ2NvbW1pdCBib29sZWFuIGF0dHJpYnV0ZScsXG4gICAgICBlbGVtZW50OiB0aGlzLmVsZW1lbnQsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICB2YWx1ZTogISEodmFsdWUgJiYgdmFsdWUgIT09IG5vdGhpbmcpLFxuICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgIH0pO1xuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSAhPT0gbm90aGluZykge1xuICAgICAgKHdyYXAodGhpcy5lbGVtZW50KSBhcyBFbGVtZW50KS5zZXRBdHRyaWJ1dGUoXG4gICAgICAgIHRoaXMubmFtZSxcbiAgICAgICAgZW1wdHlTdHJpbmdGb3JCb29sZWFuQXR0cmlidXRlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAod3JhcCh0aGlzLmVsZW1lbnQpIGFzIEVsZW1lbnQpLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLm5hbWUpO1xuICAgIH1cbiAgfVxufVxuXG50eXBlIEV2ZW50TGlzdGVuZXJXaXRoT3B0aW9ucyA9IEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3QgJlxuICBQYXJ0aWFsPEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zPjtcblxuLyoqXG4gKiBBbiBBdHRyaWJ1dGVQYXJ0IHRoYXQgbWFuYWdlcyBhbiBldmVudCBsaXN0ZW5lciB2aWEgYWRkL3JlbW92ZUV2ZW50TGlzdGVuZXIuXG4gKlxuICogVGhpcyBwYXJ0IHdvcmtzIGJ5IGFkZGluZyBpdHNlbGYgYXMgdGhlIGV2ZW50IGxpc3RlbmVyIG9uIGFuIGVsZW1lbnQsIHRoZW5cbiAqIGRlbGVnYXRpbmcgdG8gdGhlIHZhbHVlIHBhc3NlZCB0byBpdC4gVGhpcyByZWR1Y2VzIHRoZSBudW1iZXIgb2YgY2FsbHMgdG9cbiAqIGFkZC9yZW1vdmVFdmVudExpc3RlbmVyIGlmIHRoZSBsaXN0ZW5lciBjaGFuZ2VzIGZyZXF1ZW50bHksIHN1Y2ggYXMgd2hlbiBhblxuICogaW5saW5lIGZ1bmN0aW9uIGlzIHVzZWQgYXMgYSBsaXN0ZW5lci5cbiAqXG4gKiBCZWNhdXNlIGV2ZW50IG9wdGlvbnMgYXJlIHBhc3NlZCB3aGVuIGFkZGluZyBsaXN0ZW5lcnMsIHdlIG11c3QgdGFrZSBjYXNlXG4gKiB0byBhZGQgYW5kIHJlbW92ZSB0aGUgcGFydCBhcyBhIGxpc3RlbmVyIHdoZW4gdGhlIGV2ZW50IG9wdGlvbnMgY2hhbmdlLlxuICovXG5leHBvcnQgdHlwZSB7RXZlbnRQYXJ0fTtcbmNsYXNzIEV2ZW50UGFydCBleHRlbmRzIEF0dHJpYnV0ZVBhcnQge1xuICBvdmVycmlkZSByZWFkb25seSB0eXBlID0gRVZFTlRfUEFSVDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBlbGVtZW50OiBIVE1MRWxlbWVudCxcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgc3RyaW5nczogUmVhZG9ubHlBcnJheTxzdHJpbmc+LFxuICAgIHBhcmVudDogRGlzY29ubmVjdGFibGUsXG4gICAgb3B0aW9uczogUmVuZGVyT3B0aW9ucyB8IHVuZGVmaW5lZFxuICApIHtcbiAgICBzdXBlcihlbGVtZW50LCBuYW1lLCBzdHJpbmdzLCBwYXJlbnQsIG9wdGlvbnMpO1xuXG4gICAgaWYgKERFVl9NT0RFICYmIHRoaXMuc3RyaW5ncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBIFxcYDwke2VsZW1lbnQubG9jYWxOYW1lfT5cXGAgaGFzIGEgXFxgQCR7bmFtZX09Li4uXFxgIGxpc3RlbmVyIHdpdGggYCArXG4gICAgICAgICAgJ2ludmFsaWQgY29udGVudC4gRXZlbnQgbGlzdGVuZXJzIGluIHRlbXBsYXRlcyBtdXN0IGhhdmUgZXhhY3RseSAnICtcbiAgICAgICAgICAnb25lIGV4cHJlc3Npb24gYW5kIG5vIHN1cnJvdW5kaW5nIHRleHQuJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvLyBFdmVudFBhcnQgZG9lcyBub3QgdXNlIHRoZSBiYXNlIF8kc2V0VmFsdWUvX3Jlc29sdmVWYWx1ZSBpbXBsZW1lbnRhdGlvblxuICAvLyBzaW5jZSB0aGUgZGlydHkgY2hlY2tpbmcgaXMgbW9yZSBjb21wbGV4XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgb3ZlcnJpZGUgXyRzZXRWYWx1ZShcbiAgICBuZXdMaXN0ZW5lcjogdW5rbm93bixcbiAgICBkaXJlY3RpdmVQYXJlbnQ6IERpcmVjdGl2ZVBhcmVudCA9IHRoaXNcbiAgKSB7XG4gICAgbmV3TGlzdGVuZXIgPVxuICAgICAgcmVzb2x2ZURpcmVjdGl2ZSh0aGlzLCBuZXdMaXN0ZW5lciwgZGlyZWN0aXZlUGFyZW50LCAwKSA/PyBub3RoaW5nO1xuICAgIGlmIChuZXdMaXN0ZW5lciA9PT0gbm9DaGFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb2xkTGlzdGVuZXIgPSB0aGlzLl8kY29tbWl0dGVkVmFsdWU7XG5cbiAgICAvLyBJZiB0aGUgbmV3IHZhbHVlIGlzIG5vdGhpbmcgb3IgYW55IG9wdGlvbnMgY2hhbmdlIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZVxuICAgIC8vIHBhcnQgYXMgYSBsaXN0ZW5lci5cbiAgICBjb25zdCBzaG91bGRSZW1vdmVMaXN0ZW5lciA9XG4gICAgICAobmV3TGlzdGVuZXIgPT09IG5vdGhpbmcgJiYgb2xkTGlzdGVuZXIgIT09IG5vdGhpbmcpIHx8XG4gICAgICAobmV3TGlzdGVuZXIgYXMgRXZlbnRMaXN0ZW5lcldpdGhPcHRpb25zKS5jYXB0dXJlICE9PVxuICAgICAgICAob2xkTGlzdGVuZXIgYXMgRXZlbnRMaXN0ZW5lcldpdGhPcHRpb25zKS5jYXB0dXJlIHx8XG4gICAgICAobmV3TGlzdGVuZXIgYXMgRXZlbnRMaXN0ZW5lcldpdGhPcHRpb25zKS5vbmNlICE9PVxuICAgICAgICAob2xkTGlzdGVuZXIgYXMgRXZlbnRMaXN0ZW5lcldpdGhPcHRpb25zKS5vbmNlIHx8XG4gICAgICAobmV3TGlzdGVuZXIgYXMgRXZlbnRMaXN0ZW5lcldpdGhPcHRpb25zKS5wYXNzaXZlICE9PVxuICAgICAgICAob2xkTGlzdGVuZXIgYXMgRXZlbnRMaXN0ZW5lcldpdGhPcHRpb25zKS5wYXNzaXZlO1xuXG4gICAgLy8gSWYgdGhlIG5ldyB2YWx1ZSBpcyBub3Qgbm90aGluZyBhbmQgd2UgcmVtb3ZlZCB0aGUgbGlzdGVuZXIsIHdlIGhhdmVcbiAgICAvLyB0byBhZGQgdGhlIHBhcnQgYXMgYSBsaXN0ZW5lci5cbiAgICBjb25zdCBzaG91bGRBZGRMaXN0ZW5lciA9XG4gICAgICBuZXdMaXN0ZW5lciAhPT0gbm90aGluZyAmJlxuICAgICAgKG9sZExpc3RlbmVyID09PSBub3RoaW5nIHx8IHNob3VsZFJlbW92ZUxpc3RlbmVyKTtcblxuICAgIGRlYnVnTG9nRXZlbnQ/Lih7XG4gICAgICBraW5kOiAnY29tbWl0IGV2ZW50IGxpc3RlbmVyJyxcbiAgICAgIGVsZW1lbnQ6IHRoaXMuZWxlbWVudCxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIHZhbHVlOiBuZXdMaXN0ZW5lcixcbiAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgIHJlbW92ZUxpc3RlbmVyOiBzaG91bGRSZW1vdmVMaXN0ZW5lcixcbiAgICAgIGFkZExpc3RlbmVyOiBzaG91bGRBZGRMaXN0ZW5lcixcbiAgICAgIG9sZExpc3RlbmVyLFxuICAgIH0pO1xuICAgIGlmIChzaG91bGRSZW1vdmVMaXN0ZW5lcikge1xuICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIHRoaXMubmFtZSxcbiAgICAgICAgdGhpcyxcbiAgICAgICAgb2xkTGlzdGVuZXIgYXMgRXZlbnRMaXN0ZW5lcldpdGhPcHRpb25zXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkQWRkTGlzdGVuZXIpIHtcbiAgICAgIC8vIEJld2FyZTogSUUxMSBhbmQgQ2hyb21lIDQxIGRvbid0IGxpa2UgdXNpbmcgdGhlIGxpc3RlbmVyIGFzIHRoZVxuICAgICAgLy8gb3B0aW9ucyBvYmplY3QuIEZpZ3VyZSBvdXQgaG93IHRvIGRlYWwgdy8gdGhpcyBpbiBJRTExIC0gbWF5YmVcbiAgICAgIC8vIHBhdGNoIGFkZEV2ZW50TGlzdGVuZXI/XG4gICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgdGhpcy5uYW1lLFxuICAgICAgICB0aGlzLFxuICAgICAgICBuZXdMaXN0ZW5lciBhcyBFdmVudExpc3RlbmVyV2l0aE9wdGlvbnNcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuXyRjb21taXR0ZWRWYWx1ZSA9IG5ld0xpc3RlbmVyO1xuICB9XG5cbiAgaGFuZGxlRXZlbnQoZXZlbnQ6IEV2ZW50KSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl8kY29tbWl0dGVkVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuXyRjb21taXR0ZWRWYWx1ZS5jYWxsKHRoaXMub3B0aW9ucz8uaG9zdCA/PyB0aGlzLmVsZW1lbnQsIGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgKHRoaXMuXyRjb21taXR0ZWRWYWx1ZSBhcyBFdmVudExpc3RlbmVyT2JqZWN0KS5oYW5kbGVFdmVudChldmVudCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB0eXBlIHtFbGVtZW50UGFydH07XG5jbGFzcyBFbGVtZW50UGFydCBpbXBsZW1lbnRzIERpc2Nvbm5lY3RhYmxlIHtcbiAgcmVhZG9ubHkgdHlwZSA9IEVMRU1FTlRfUEFSVDtcblxuICAvKiogQGludGVybmFsICovXG4gIF9fZGlyZWN0aXZlPzogRGlyZWN0aXZlO1xuXG4gIC8vIFRoaXMgaXMgdG8gZW5zdXJlIHRoYXQgZXZlcnkgUGFydCBoYXMgYSBfJGNvbW1pdHRlZFZhbHVlXG4gIF8kY29tbWl0dGVkVmFsdWU6IHVuZGVmaW5lZDtcblxuICAvKiogQGludGVybmFsICovXG4gIF8kcGFyZW50ITogRGlzY29ubmVjdGFibGU7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfJGRpc2Nvbm5lY3RhYmxlQ2hpbGRyZW4/OiBTZXQ8RGlzY29ubmVjdGFibGU+ID0gdW5kZWZpbmVkO1xuXG4gIG9wdGlvbnM6IFJlbmRlck9wdGlvbnMgfCB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGVsZW1lbnQ6IEVsZW1lbnQsXG4gICAgcGFyZW50OiBEaXNjb25uZWN0YWJsZSxcbiAgICBvcHRpb25zOiBSZW5kZXJPcHRpb25zIHwgdW5kZWZpbmVkXG4gICkge1xuICAgIHRoaXMuXyRwYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIC8vIFNlZSBjb21tZW50IGluIERpc2Nvbm5lY3RhYmxlIGludGVyZmFjZSBmb3Igd2h5IHRoaXMgaXMgYSBnZXR0ZXJcbiAgZ2V0IF8kaXNDb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuXyRwYXJlbnQuXyRpc0Nvbm5lY3RlZDtcbiAgfVxuXG4gIF8kc2V0VmFsdWUodmFsdWU6IHVua25vd24pOiB2b2lkIHtcbiAgICBkZWJ1Z0xvZ0V2ZW50Py4oe1xuICAgICAga2luZDogJ2NvbW1pdCB0byBlbGVtZW50IGJpbmRpbmcnLFxuICAgICAgZWxlbWVudDogdGhpcy5lbGVtZW50LFxuICAgICAgdmFsdWUsXG4gICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgfSk7XG4gICAgcmVzb2x2ZURpcmVjdGl2ZSh0aGlzLCB2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBFTkQgVVNFUlMgU0hPVUxEIE5PVCBSRUxZIE9OIFRISVMgT0JKRUNULlxuICpcbiAqIFByaXZhdGUgZXhwb3J0cyBmb3IgdXNlIGJ5IG90aGVyIExpdCBwYWNrYWdlcywgbm90IGludGVuZGVkIGZvciB1c2UgYnlcbiAqIGV4dGVybmFsIHVzZXJzLlxuICpcbiAqIFdlIGN1cnJlbnRseSBkbyBub3QgbWFrZSBhIG1hbmdsZWQgcm9sbHVwIGJ1aWxkIG9mIHRoZSBsaXQtc3NyIGNvZGUuIEluIG9yZGVyXG4gKiB0byBrZWVwIGEgbnVtYmVyIG9mIChvdGhlcndpc2UgcHJpdmF0ZSkgdG9wLWxldmVsIGV4cG9ydHMgIG1hbmdsZWQgaW4gdGhlXG4gKiBjbGllbnQgc2lkZSBjb2RlLCB3ZSBleHBvcnQgYSBfJExIIG9iamVjdCBjb250YWluaW5nIHRob3NlIG1lbWJlcnMgKG9yXG4gKiBoZWxwZXIgbWV0aG9kcyBmb3IgYWNjZXNzaW5nIHByaXZhdGUgZmllbGRzIG9mIHRob3NlIG1lbWJlcnMpLCBhbmQgdGhlblxuICogcmUtZXhwb3J0IHRoZW0gZm9yIHVzZSBpbiBsaXQtc3NyLiBUaGlzIGtlZXBzIGxpdC1zc3IgYWdub3N0aWMgdG8gd2hldGhlciB0aGVcbiAqIGNsaWVudC1zaWRlIGNvZGUgaXMgYmVpbmcgdXNlZCBpbiBgZGV2YCBtb2RlIG9yIGBwcm9kYCBtb2RlLlxuICpcbiAqIFRoaXMgaGFzIGEgdW5pcXVlIG5hbWUsIHRvIGRpc2FtYmlndWF0ZSBpdCBmcm9tIHByaXZhdGUgZXhwb3J0cyBpblxuICogbGl0LWVsZW1lbnQsIHdoaWNoIHJlLWV4cG9ydHMgYWxsIG9mIGxpdC1odG1sLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBfJExIID0ge1xuICAvLyBVc2VkIGluIGxpdC1zc3JcbiAgX2JvdW5kQXR0cmlidXRlU3VmZml4OiBib3VuZEF0dHJpYnV0ZVN1ZmZpeCxcbiAgX21hcmtlcjogbWFya2VyLFxuICBfbWFya2VyTWF0Y2g6IG1hcmtlck1hdGNoLFxuICBfSFRNTF9SRVNVTFQ6IEhUTUxfUkVTVUxULFxuICBfZ2V0VGVtcGxhdGVIdG1sOiBnZXRUZW1wbGF0ZUh0bWwsXG4gIC8vIFVzZWQgaW4gaHlkcmF0ZVxuICBfVGVtcGxhdGVJbnN0YW5jZTogVGVtcGxhdGVJbnN0YW5jZSxcbiAgX2lzSXRlcmFibGU6IGlzSXRlcmFibGUsXG4gIF9yZXNvbHZlRGlyZWN0aXZlOiByZXNvbHZlRGlyZWN0aXZlLFxuICAvLyBVc2VkIGluIHRlc3RzIGFuZCBwcml2YXRlLXNzci1zdXBwb3J0XG4gIF9DaGlsZFBhcnQ6IENoaWxkUGFydCxcbiAgX0F0dHJpYnV0ZVBhcnQ6IEF0dHJpYnV0ZVBhcnQsXG4gIF9Cb29sZWFuQXR0cmlidXRlUGFydDogQm9vbGVhbkF0dHJpYnV0ZVBhcnQsXG4gIF9FdmVudFBhcnQ6IEV2ZW50UGFydCxcbiAgX1Byb3BlcnR5UGFydDogUHJvcGVydHlQYXJ0LFxuICBfRWxlbWVudFBhcnQ6IEVsZW1lbnRQYXJ0LFxufTtcblxuLy8gQXBwbHkgcG9seWZpbGxzIGlmIGF2YWlsYWJsZVxuY29uc3QgcG9seWZpbGxTdXBwb3J0ID0gREVWX01PREVcbiAgPyBnbG9iYWwubGl0SHRtbFBvbHlmaWxsU3VwcG9ydERldk1vZGVcbiAgOiBnbG9iYWwubGl0SHRtbFBvbHlmaWxsU3VwcG9ydDtcbnBvbHlmaWxsU3VwcG9ydD8uKFRlbXBsYXRlLCBDaGlsZFBhcnQpO1xuXG4vLyBJTVBPUlRBTlQ6IGRvIG5vdCBjaGFuZ2UgdGhlIHByb3BlcnR5IG5hbWUgb3IgdGhlIGFzc2lnbm1lbnQgZXhwcmVzc2lvbi5cbi8vIFRoaXMgbGluZSB3aWxsIGJlIHVzZWQgaW4gcmVnZXhlcyB0byBzZWFyY2ggZm9yIGxpdC1odG1sIHVzYWdlLlxuKGdsb2JhbC5saXRIdG1sVmVyc2lvbnMgPz89IFtdKS5wdXNoKCcyLjMuMScpO1xuaWYgKERFVl9NT0RFICYmIGdsb2JhbC5saXRIdG1sVmVyc2lvbnMubGVuZ3RoID4gMSkge1xuICBpc3N1ZVdhcm5pbmchKFxuICAgICdtdWx0aXBsZS12ZXJzaW9ucycsXG4gICAgYE11bHRpcGxlIHZlcnNpb25zIG9mIExpdCBsb2FkZWQuIGAgK1xuICAgICAgYExvYWRpbmcgbXVsdGlwbGUgdmVyc2lvbnMgaXMgbm90IHJlY29tbWVuZGVkLmBcbiAgKTtcbn1cbiIsICIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cblxuLyoqXG4gKiBUaGUgbWFpbiBMaXRFbGVtZW50IG1vZHVsZSwgd2hpY2ggZGVmaW5lcyB0aGUge0BsaW5rY29kZSBMaXRFbGVtZW50fSBiYXNlXG4gKiBjbGFzcyBhbmQgcmVsYXRlZCBBUElzLlxuICpcbiAqICBMaXRFbGVtZW50IGNvbXBvbmVudHMgY2FuIGRlZmluZSBhIHRlbXBsYXRlIGFuZCBhIHNldCBvZiBvYnNlcnZlZFxuICogcHJvcGVydGllcy4gQ2hhbmdpbmcgYW4gb2JzZXJ2ZWQgcHJvcGVydHkgdHJpZ2dlcnMgYSByZS1yZW5kZXIgb2YgdGhlXG4gKiBlbGVtZW50LlxuICpcbiAqICBJbXBvcnQge0BsaW5rY29kZSBMaXRFbGVtZW50fSBhbmQge0BsaW5rY29kZSBodG1sfSBmcm9tIHRoaXMgbW9kdWxlIHRvXG4gKiBjcmVhdGUgYSBjb21wb25lbnQ6XG4gKlxuICogIGBgYGpzXG4gKiBpbXBvcnQge0xpdEVsZW1lbnQsIGh0bWx9IGZyb20gJ2xpdC1lbGVtZW50JztcbiAqXG4gKiBjbGFzcyBNeUVsZW1lbnQgZXh0ZW5kcyBMaXRFbGVtZW50IHtcbiAqXG4gKiAgIC8vIERlY2xhcmUgb2JzZXJ2ZWQgcHJvcGVydGllc1xuICogICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gKiAgICAgcmV0dXJuIHtcbiAqICAgICAgIGFkamVjdGl2ZToge31cbiAqICAgICB9XG4gKiAgIH1cbiAqXG4gKiAgIGNvbnN0cnVjdG9yKCkge1xuICogICAgIHRoaXMuYWRqZWN0aXZlID0gJ2F3ZXNvbWUnO1xuICogICB9XG4gKlxuICogICAvLyBEZWZpbmUgdGhlIGVsZW1lbnQncyB0ZW1wbGF0ZVxuICogICByZW5kZXIoKSB7XG4gKiAgICAgcmV0dXJuIGh0bWxgPHA+eW91ciAke2FkamVjdGl2ZX0gdGVtcGxhdGUgaGVyZTwvcD5gO1xuICogICB9XG4gKiB9XG4gKlxuICogY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdteS1lbGVtZW50JywgTXlFbGVtZW50KTtcbiAqIGBgYFxuICpcbiAqIGBMaXRFbGVtZW50YCBleHRlbmRzIHtAbGlua2NvZGUgUmVhY3RpdmVFbGVtZW50fSBhbmQgYWRkcyBsaXQtaHRtbFxuICogdGVtcGxhdGluZy4gVGhlIGBSZWFjdGl2ZUVsZW1lbnRgIGNsYXNzIGlzIHByb3ZpZGVkIGZvciB1c2VycyB0aGF0IHdhbnQgdG9cbiAqIGJ1aWxkIHRoZWlyIG93biBjdXN0b20gZWxlbWVudCBiYXNlIGNsYXNzZXMgdGhhdCBkb24ndCB1c2UgbGl0LWh0bWwuXG4gKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cbmltcG9ydCB7UHJvcGVydHlWYWx1ZXMsIFJlYWN0aXZlRWxlbWVudH0gZnJvbSAnQGxpdC9yZWFjdGl2ZS1lbGVtZW50JztcbmltcG9ydCB7cmVuZGVyLCBSZW5kZXJPcHRpb25zLCBub0NoYW5nZSwgUm9vdFBhcnR9IGZyb20gJ2xpdC1odG1sJztcbmV4cG9ydCAqIGZyb20gJ0BsaXQvcmVhY3RpdmUtZWxlbWVudCc7XG5leHBvcnQgKiBmcm9tICdsaXQtaHRtbCc7XG5cbmltcG9ydCB7TGl0VW5zdGFibGV9IGZyb20gJ2xpdC1odG1sJztcbmltcG9ydCB7UmVhY3RpdmVVbnN0YWJsZX0gZnJvbSAnQGxpdC9yZWFjdGl2ZS1lbGVtZW50JztcblxuLyoqXG4gKiBDb250YWlucyB0eXBlcyB0aGF0IGFyZSBwYXJ0IG9mIHRoZSB1bnN0YWJsZSBkZWJ1ZyBBUEkuXG4gKlxuICogRXZlcnl0aGluZyBpbiB0aGlzIEFQSSBpcyBub3Qgc3RhYmxlIGFuZCBtYXkgY2hhbmdlIG9yIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZSxcbiAqIGV2ZW4gb24gcGF0Y2ggcmVsZWFzZXMuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbmFtZXNwYWNlXG5leHBvcnQgbmFtZXNwYWNlIFVuc3RhYmxlIHtcbiAgLyoqXG4gICAqIFdoZW4gTGl0IGlzIHJ1bm5pbmcgaW4gZGV2IG1vZGUgYW5kIGB3aW5kb3cuZW1pdExpdERlYnVnTG9nRXZlbnRzYCBpcyB0cnVlLFxuICAgKiB3ZSB3aWxsIGVtaXQgJ2xpdC1kZWJ1ZycgZXZlbnRzIHRvIHdpbmRvdywgd2l0aCBsaXZlIGRldGFpbHMgYWJvdXQgdGhlIHVwZGF0ZSBhbmQgcmVuZGVyXG4gICAqIGxpZmVjeWNsZS4gVGhlc2UgY2FuIGJlIHVzZWZ1bCBmb3Igd3JpdGluZyBkZWJ1ZyB0b29saW5nIGFuZCB2aXN1YWxpemF0aW9ucy5cbiAgICpcbiAgICogUGxlYXNlIGJlIGF3YXJlIHRoYXQgcnVubmluZyB3aXRoIHdpbmRvdy5lbWl0TGl0RGVidWdMb2dFdmVudHMgaGFzIHBlcmZvcm1hbmNlIG92ZXJoZWFkLFxuICAgKiBtYWtpbmcgY2VydGFpbiBvcGVyYXRpb25zIHRoYXQgYXJlIG5vcm1hbGx5IHZlcnkgY2hlYXAgKGxpa2UgYSBuby1vcCByZW5kZXIpIG11Y2ggc2xvd2VyLFxuICAgKiBiZWNhdXNlIHdlIG11c3QgY29weSBkYXRhIGFuZCBkaXNwYXRjaCBldmVudHMuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5hbWVzcGFjZVxuICBleHBvcnQgbmFtZXNwYWNlIERlYnVnTG9nIHtcbiAgICBleHBvcnQgdHlwZSBFbnRyeSA9XG4gICAgICB8IExpdFVuc3RhYmxlLkRlYnVnTG9nLkVudHJ5XG4gICAgICB8IFJlYWN0aXZlVW5zdGFibGUuRGVidWdMb2cuRW50cnk7XG4gIH1cbn1cblxuLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGV4cG9ydCBSZWFjdGl2ZUVsZW1lbnQgYXMgVXBkYXRpbmdFbGVtZW50LiBOb3RlLFxuLy8gSUUgdHJhbnNwaWxhdGlvbiByZXF1aXJlcyBleHBvcnRpbmcgbGlrZSB0aGlzLlxuZXhwb3J0IGNvbnN0IFVwZGF0aW5nRWxlbWVudCA9IFJlYWN0aXZlRWxlbWVudDtcblxuY29uc3QgREVWX01PREUgPSB0cnVlO1xuXG5sZXQgaXNzdWVXYXJuaW5nOiAoY29kZTogc3RyaW5nLCB3YXJuaW5nOiBzdHJpbmcpID0+IHZvaWQ7XG5cbmlmIChERVZfTU9ERSkge1xuICAvLyBFbnN1cmUgd2FybmluZ3MgYXJlIGlzc3VlZCBvbmx5IDF4LCBldmVuIGlmIG11bHRpcGxlIHZlcnNpb25zIG9mIExpdFxuICAvLyBhcmUgbG9hZGVkLlxuICBjb25zdCBpc3N1ZWRXYXJuaW5nczogU2V0PHN0cmluZyB8IHVuZGVmaW5lZD4gPVxuICAgIChnbG9iYWxUaGlzLmxpdElzc3VlZFdhcm5pbmdzID8/PSBuZXcgU2V0KCkpO1xuXG4gIC8vIElzc3VlIGEgd2FybmluZywgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5LlxuICBpc3N1ZVdhcm5pbmcgPSAoY29kZTogc3RyaW5nLCB3YXJuaW5nOiBzdHJpbmcpID0+IHtcbiAgICB3YXJuaW5nICs9IGAgU2VlIGh0dHBzOi8vbGl0LmRldi9tc2cvJHtjb2RlfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gO1xuICAgIGlmICghaXNzdWVkV2FybmluZ3MuaGFzKHdhcm5pbmcpKSB7XG4gICAgICBjb25zb2xlLndhcm4od2FybmluZyk7XG4gICAgICBpc3N1ZWRXYXJuaW5ncy5hZGQod2FybmluZyk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEJhc2UgZWxlbWVudCBjbGFzcyB0aGF0IG1hbmFnZXMgZWxlbWVudCBwcm9wZXJ0aWVzIGFuZCBhdHRyaWJ1dGVzLCBhbmRcbiAqIHJlbmRlcnMgYSBsaXQtaHRtbCB0ZW1wbGF0ZS5cbiAqXG4gKiBUbyBkZWZpbmUgYSBjb21wb25lbnQsIHN1YmNsYXNzIGBMaXRFbGVtZW50YCBhbmQgaW1wbGVtZW50IGFcbiAqIGByZW5kZXJgIG1ldGhvZCB0byBwcm92aWRlIHRoZSBjb21wb25lbnQncyB0ZW1wbGF0ZS4gRGVmaW5lIHByb3BlcnRpZXNcbiAqIHVzaW5nIHRoZSB7QGxpbmtjb2RlIExpdEVsZW1lbnQucHJvcGVydGllcyBwcm9wZXJ0aWVzfSBwcm9wZXJ0eSBvciB0aGVcbiAqIHtAbGlua2NvZGUgcHJvcGVydHl9IGRlY29yYXRvci5cbiAqL1xuZXhwb3J0IGNsYXNzIExpdEVsZW1lbnQgZXh0ZW5kcyBSZWFjdGl2ZUVsZW1lbnQge1xuICAvKipcbiAgICogRW5zdXJlIHRoaXMgY2xhc3MgaXMgbWFya2VkIGFzIGBmaW5hbGl6ZWRgIGFzIGFuIG9wdGltaXphdGlvbiBlbnN1cmluZ1xuICAgKiBpdCB3aWxsIG5vdCBuZWVkbGVzc2x5IHRyeSB0byBgZmluYWxpemVgLlxuICAgKlxuICAgKiBOb3RlIHRoaXMgcHJvcGVydHkgbmFtZSBpcyBhIHN0cmluZyB0byBwcmV2ZW50IGJyZWFraW5nIENsb3N1cmUgSlMgQ29tcGlsZXJcbiAgICogb3B0aW1pemF0aW9ucy4gU2VlIEBsaXQvcmVhY3RpdmUtZWxlbWVudCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICovXG4gIHByb3RlY3RlZCBzdGF0aWMgb3ZlcnJpZGUgWydmaW5hbGl6ZWQnXSA9IHRydWU7XG5cbiAgLy8gVGhpcyBwcm9wZXJ0eSBuZWVkcyB0byByZW1haW4gdW5taW5pZmllZC5cbiAgc3RhdGljIFsnXyRsaXRFbGVtZW50JCddID0gdHJ1ZTtcblxuICAvKipcbiAgICogQGNhdGVnb3J5IHJlbmRlcmluZ1xuICAgKi9cbiAgcmVhZG9ubHkgcmVuZGVyT3B0aW9uczogUmVuZGVyT3B0aW9ucyA9IHtob3N0OiB0aGlzfTtcblxuICBwcml2YXRlIF9fY2hpbGRQYXJ0OiBSb290UGFydCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogQGNhdGVnb3J5IHJlbmRlcmluZ1xuICAgKi9cbiAgcHJvdGVjdGVkIG92ZXJyaWRlIGNyZWF0ZVJlbmRlclJvb3QoKSB7XG4gICAgY29uc3QgcmVuZGVyUm9vdCA9IHN1cGVyLmNyZWF0ZVJlbmRlclJvb3QoKTtcbiAgICAvLyBXaGVuIGFkb3B0ZWRTdHlsZVNoZWV0cyBhcmUgc2hpbW1lZCwgdGhleSBhcmUgaW5zZXJ0ZWQgaW50byB0aGVcbiAgICAvLyBzaGFkb3dSb290IGJ5IGNyZWF0ZVJlbmRlclJvb3QuIEFkanVzdCB0aGUgcmVuZGVyQmVmb3JlIG5vZGUgc28gdGhhdFxuICAgIC8vIGFueSBzdHlsZXMgaW4gTGl0IGNvbnRlbnQgcmVuZGVyIGJlZm9yZSBhZG9wdGVkU3R5bGVTaGVldHMuIFRoaXMgaXNcbiAgICAvLyBpbXBvcnRhbnQgc28gdGhhdCBhZG9wdGVkU3R5bGVTaGVldHMgaGF2ZSBwcmVjZWRlbmNlIG92ZXIgc3R5bGVzIGluXG4gICAgLy8gdGhlIHNoYWRvd1Jvb3QuXG4gICAgdGhpcy5yZW5kZXJPcHRpb25zLnJlbmRlckJlZm9yZSA/Pz0gcmVuZGVyUm9vdCEuZmlyc3RDaGlsZCBhcyBDaGlsZE5vZGU7XG4gICAgcmV0dXJuIHJlbmRlclJvb3Q7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZWxlbWVudC4gVGhpcyBtZXRob2QgcmVmbGVjdHMgcHJvcGVydHkgdmFsdWVzIHRvIGF0dHJpYnV0ZXNcbiAgICogYW5kIGNhbGxzIGByZW5kZXJgIHRvIHJlbmRlciBET00gdmlhIGxpdC1odG1sLiBTZXR0aW5nIHByb3BlcnRpZXMgaW5zaWRlXG4gICAqIHRoaXMgbWV0aG9kIHdpbGwgKm5vdCogdHJpZ2dlciBhbm90aGVyIHVwZGF0ZS5cbiAgICogQHBhcmFtIGNoYW5nZWRQcm9wZXJ0aWVzIE1hcCBvZiBjaGFuZ2VkIHByb3BlcnRpZXMgd2l0aCBvbGQgdmFsdWVzXG4gICAqIEBjYXRlZ29yeSB1cGRhdGVzXG4gICAqL1xuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdXBkYXRlKGNoYW5nZWRQcm9wZXJ0aWVzOiBQcm9wZXJ0eVZhbHVlcykge1xuICAgIC8vIFNldHRpbmcgcHJvcGVydGllcyBpbiBgcmVuZGVyYCBzaG91bGQgbm90IHRyaWdnZXIgYW4gdXBkYXRlLiBTaW5jZVxuICAgIC8vIHVwZGF0ZXMgYXJlIGFsbG93ZWQgYWZ0ZXIgc3VwZXIudXBkYXRlLCBpdCdzIGltcG9ydGFudCB0byBjYWxsIGByZW5kZXJgXG4gICAgLy8gYmVmb3JlIHRoYXQuXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnJlbmRlcigpO1xuICAgIGlmICghdGhpcy5oYXNVcGRhdGVkKSB7XG4gICAgICB0aGlzLnJlbmRlck9wdGlvbnMuaXNDb25uZWN0ZWQgPSB0aGlzLmlzQ29ubmVjdGVkO1xuICAgIH1cbiAgICBzdXBlci51cGRhdGUoY2hhbmdlZFByb3BlcnRpZXMpO1xuICAgIHRoaXMuX19jaGlsZFBhcnQgPSByZW5kZXIodmFsdWUsIHRoaXMucmVuZGVyUm9vdCwgdGhpcy5yZW5kZXJPcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhZGRlZCB0byB0aGUgZG9jdW1lbnQncyBET00uXG4gICAqXG4gICAqIEluIGBjb25uZWN0ZWRDYWxsYmFjaygpYCB5b3Ugc2hvdWxkIHNldHVwIHRhc2tzIHRoYXQgc2hvdWxkIG9ubHkgb2NjdXIgd2hlblxuICAgKiB0aGUgZWxlbWVudCBpcyBjb25uZWN0ZWQgdG8gdGhlIGRvY3VtZW50LiBUaGUgbW9zdCBjb21tb24gb2YgdGhlc2UgaXNcbiAgICogYWRkaW5nIGV2ZW50IGxpc3RlbmVycyB0byBub2RlcyBleHRlcm5hbCB0byB0aGUgZWxlbWVudCwgbGlrZSBhIGtleWRvd25cbiAgICogZXZlbnQgaGFuZGxlciBhZGRlZCB0byB0aGUgd2luZG93LlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICogICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgKiAgIGFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9oYW5kbGVLZXlkb3duKTtcbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogVHlwaWNhbGx5LCBhbnl0aGluZyBkb25lIGluIGBjb25uZWN0ZWRDYWxsYmFjaygpYCBzaG91bGQgYmUgdW5kb25lIHdoZW4gdGhlXG4gICAqIGVsZW1lbnQgaXMgZGlzY29ubmVjdGVkLCBpbiBgZGlzY29ubmVjdGVkQ2FsbGJhY2soKWAuXG4gICAqXG4gICAqIEBjYXRlZ29yeSBsaWZlY3ljbGVcbiAgICovXG4gIG92ZXJyaWRlIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgdGhpcy5fX2NoaWxkUGFydD8uc2V0Q29ubmVjdGVkKHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgZG9jdW1lbnQncyBET00uXG4gICAqXG4gICAqIFRoaXMgY2FsbGJhY2sgaXMgdGhlIG1haW4gc2lnbmFsIHRvIHRoZSBlbGVtZW50IHRoYXQgaXQgbWF5IG5vIGxvbmdlciBiZVxuICAgKiB1c2VkLiBgZGlzY29ubmVjdGVkQ2FsbGJhY2soKWAgc2hvdWxkIGVuc3VyZSB0aGF0IG5vdGhpbmcgaXMgaG9sZGluZyBhXG4gICAqIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCAoc3VjaCBhcyBldmVudCBsaXN0ZW5lcnMgYWRkZWQgdG8gbm9kZXMgZXh0ZXJuYWxcbiAgICogdG8gdGhlIGVsZW1lbnQpLCBzbyB0aGF0IGl0IGlzIGZyZWUgdG8gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAqXG4gICAqIGBgYHRzXG4gICAqIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgKiAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAqICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9oYW5kbGVLZXlkb3duKTtcbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogQW4gZWxlbWVudCBtYXkgYmUgcmUtY29ubmVjdGVkIGFmdGVyIGJlaW5nIGRpc2Nvbm5lY3RlZC5cbiAgICpcbiAgICogQGNhdGVnb3J5IGxpZmVjeWNsZVxuICAgKi9cbiAgb3ZlcnJpZGUgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICB0aGlzLl9fY2hpbGRQYXJ0Py5zZXRDb25uZWN0ZWQoZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgb24gZWFjaCB1cGRhdGUgdG8gcGVyZm9ybSByZW5kZXJpbmcgdGFza3MuIFRoaXMgbWV0aG9kIG1heSByZXR1cm5cbiAgICogYW55IHZhbHVlIHJlbmRlcmFibGUgYnkgbGl0LWh0bWwncyBgQ2hpbGRQYXJ0YCAtIHR5cGljYWxseSBhXG4gICAqIGBUZW1wbGF0ZVJlc3VsdGAuIFNldHRpbmcgcHJvcGVydGllcyBpbnNpZGUgdGhpcyBtZXRob2Qgd2lsbCAqbm90KiB0cmlnZ2VyXG4gICAqIHRoZSBlbGVtZW50IHRvIHVwZGF0ZS5cbiAgICogQGNhdGVnb3J5IHJlbmRlcmluZ1xuICAgKi9cbiAgcHJvdGVjdGVkIHJlbmRlcigpOiB1bmtub3duIHtcbiAgICByZXR1cm4gbm9DaGFuZ2U7XG4gIH1cbn1cblxuLy8gSW5zdGFsbCBoeWRyYXRpb24gaWYgYXZhaWxhYmxlXG5nbG9iYWxUaGlzLmxpdEVsZW1lbnRIeWRyYXRlU3VwcG9ydD8uKHtMaXRFbGVtZW50fSk7XG5cbi8vIEFwcGx5IHBvbHlmaWxscyBpZiBhdmFpbGFibGVcbmNvbnN0IHBvbHlmaWxsU3VwcG9ydCA9IERFVl9NT0RFXG4gID8gZ2xvYmFsVGhpcy5saXRFbGVtZW50UG9seWZpbGxTdXBwb3J0RGV2TW9kZVxuICA6IGdsb2JhbFRoaXMubGl0RWxlbWVudFBvbHlmaWxsU3VwcG9ydDtcbnBvbHlmaWxsU3VwcG9ydD8uKHtMaXRFbGVtZW50fSk7XG5cbi8vIERFViBtb2RlIHdhcm5pbmdzXG5pZiAoREVWX01PREUpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuICAvLyBOb3RlLCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGNsb3N1cmUgY29tcGlsYXRpb24sIHRoaXMgYWNjZXNzXG4gIC8vIG5lZWRzIHRvIGJlIGFzIGEgc3RyaW5nIHByb3BlcnR5IGluZGV4LlxuICAoTGl0RWxlbWVudCBhcyBhbnkpWydmaW5hbGl6ZSddID0gZnVuY3Rpb24gKHRoaXM6IHR5cGVvZiBMaXRFbGVtZW50KSB7XG4gICAgY29uc3QgZmluYWxpemVkID0gKFJlYWN0aXZlRWxlbWVudCBhcyBhbnkpLmZpbmFsaXplLmNhbGwodGhpcyk7XG4gICAgaWYgKCFmaW5hbGl6ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgd2FyblJlbW92ZWRPclJlbmFtZWQgPSAob2JqOiBhbnksIG5hbWU6IHN0cmluZywgcmVuYW1lZCA9IGZhbHNlKSA9PiB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNvbnN0IGN0b3JOYW1lID0gKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicgPyBvYmogOiBvYmouY29uc3RydWN0b3IpXG4gICAgICAgICAgLm5hbWU7XG4gICAgICAgIGlzc3VlV2FybmluZyhcbiAgICAgICAgICByZW5hbWVkID8gJ3JlbmFtZWQtYXBpJyA6ICdyZW1vdmVkLWFwaScsXG4gICAgICAgICAgYFxcYCR7bmFtZX1cXGAgaXMgaW1wbGVtZW50ZWQgb24gY2xhc3MgJHtjdG9yTmFtZX0uIEl0IGAgK1xuICAgICAgICAgICAgYGhhcyBiZWVuICR7cmVuYW1lZCA/ICdyZW5hbWVkJyA6ICdyZW1vdmVkJ30gYCArXG4gICAgICAgICAgICBgaW4gdGhpcyB2ZXJzaW9uIG9mIExpdEVsZW1lbnQuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gICAgd2FyblJlbW92ZWRPclJlbmFtZWQodGhpcywgJ3JlbmRlcicpO1xuICAgIHdhcm5SZW1vdmVkT3JSZW5hbWVkKHRoaXMsICdnZXRTdHlsZXMnLCB0cnVlKTtcbiAgICB3YXJuUmVtb3ZlZE9yUmVuYW1lZCgodGhpcyBhcyB0eXBlb2YgTGl0RWxlbWVudCkucHJvdG90eXBlLCAnYWRvcHRTdHlsZXMnKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG59XG5cbi8qKlxuICogRU5EIFVTRVJTIFNIT1VMRCBOT1QgUkVMWSBPTiBUSElTIE9CSkVDVC5cbiAqXG4gKiBQcml2YXRlIGV4cG9ydHMgZm9yIHVzZSBieSBvdGhlciBMaXQgcGFja2FnZXMsIG5vdCBpbnRlbmRlZCBmb3IgdXNlIGJ5XG4gKiBleHRlcm5hbCB1c2Vycy5cbiAqXG4gKiBXZSBjdXJyZW50bHkgZG8gbm90IG1ha2UgYSBtYW5nbGVkIHJvbGx1cCBidWlsZCBvZiB0aGUgbGl0LXNzciBjb2RlLiBJbiBvcmRlclxuICogdG8ga2VlcCBhIG51bWJlciBvZiAob3RoZXJ3aXNlIHByaXZhdGUpIHRvcC1sZXZlbCBleHBvcnRzICBtYW5nbGVkIGluIHRoZVxuICogY2xpZW50IHNpZGUgY29kZSwgd2UgZXhwb3J0IGEgXyRMRSBvYmplY3QgY29udGFpbmluZyB0aG9zZSBtZW1iZXJzIChvclxuICogaGVscGVyIG1ldGhvZHMgZm9yIGFjY2Vzc2luZyBwcml2YXRlIGZpZWxkcyBvZiB0aG9zZSBtZW1iZXJzKSwgYW5kIHRoZW5cbiAqIHJlLWV4cG9ydCB0aGVtIGZvciB1c2UgaW4gbGl0LXNzci4gVGhpcyBrZWVwcyBsaXQtc3NyIGFnbm9zdGljIHRvIHdoZXRoZXIgdGhlXG4gKiBjbGllbnQtc2lkZSBjb2RlIGlzIGJlaW5nIHVzZWQgaW4gYGRldmAgbW9kZSBvciBgcHJvZGAgbW9kZS5cbiAqXG4gKiBUaGlzIGhhcyBhIHVuaXF1ZSBuYW1lLCB0byBkaXNhbWJpZ3VhdGUgaXQgZnJvbSBwcml2YXRlIGV4cG9ydHMgaW5cbiAqIGxpdC1odG1sLCBzaW5jZSB0aGlzIG1vZHVsZSByZS1leHBvcnRzIGFsbCBvZiBsaXQtaHRtbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgXyRMRSA9IHtcbiAgXyRhdHRyaWJ1dGVUb1Byb3BlcnR5OiAoXG4gICAgZWw6IExpdEVsZW1lbnQsXG4gICAgbmFtZTogc3RyaW5nLFxuICAgIHZhbHVlOiBzdHJpbmcgfCBudWxsXG4gICkgPT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIChlbCBhcyBhbnkpLl8kYXR0cmlidXRlVG9Qcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG4gIH0sXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBfJGNoYW5nZWRQcm9wZXJ0aWVzOiAoZWw6IExpdEVsZW1lbnQpID0+IChlbCBhcyBhbnkpLl8kY2hhbmdlZFByb3BlcnRpZXMsXG59O1xuXG4vLyBJTVBPUlRBTlQ6IGRvIG5vdCBjaGFuZ2UgdGhlIHByb3BlcnR5IG5hbWUgb3IgdGhlIGFzc2lnbm1lbnQgZXhwcmVzc2lvbi5cbi8vIFRoaXMgbGluZSB3aWxsIGJlIHVzZWQgaW4gcmVnZXhlcyB0byBzZWFyY2ggZm9yIExpdEVsZW1lbnQgdXNhZ2UuXG4oZ2xvYmFsVGhpcy5saXRFbGVtZW50VmVyc2lvbnMgPz89IFtdKS5wdXNoKCczLjIuMicpO1xuaWYgKERFVl9NT0RFICYmIGdsb2JhbFRoaXMubGl0RWxlbWVudFZlcnNpb25zLmxlbmd0aCA+IDEpIHtcbiAgaXNzdWVXYXJuaW5nIShcbiAgICAnbXVsdGlwbGUtdmVyc2lvbnMnLFxuICAgIGBNdWx0aXBsZSB2ZXJzaW9ucyBvZiBMaXQgbG9hZGVkLiBMb2FkaW5nIG11bHRpcGxlIHZlcnNpb25zIGAgK1xuICAgICAgYGlzIG5vdCByZWNvbW1lbmRlZC5gXG4gICk7XG59XG4iLCAiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG5cbi8qXG4gKiBJTVBPUlRBTlQ6IEZvciBjb21wYXRpYmlsaXR5IHdpdGggdHNpY2tsZSBhbmQgdGhlIENsb3N1cmUgSlMgY29tcGlsZXIsIGFsbFxuICogcHJvcGVydHkgZGVjb3JhdG9ycyAoYnV0IG5vdCBjbGFzcyBkZWNvcmF0b3JzKSBpbiB0aGlzIGZpbGUgdGhhdCBoYXZlXG4gKiBhbiBARXhwb3J0RGVjb3JhdGVkSXRlbXMgYW5ub3RhdGlvbiBtdXN0IGJlIGRlZmluZWQgYXMgYSByZWd1bGFyIGZ1bmN0aW9uLFxuICogbm90IGFuIGFycm93IGZ1bmN0aW9uLlxuICovXG5pbXBvcnQge0NvbnN0cnVjdG9yLCBDbGFzc0Rlc2NyaXB0b3J9IGZyb20gJy4vYmFzZS5qcyc7XG5cbi8qKlxuICogQWxsb3cgZm9yIGN1c3RvbSBlbGVtZW50IGNsYXNzZXMgd2l0aCBwcml2YXRlIGNvbnN0cnVjdG9yc1xuICovXG50eXBlIEN1c3RvbUVsZW1lbnRDbGFzcyA9IE9taXQ8dHlwZW9mIEhUTUxFbGVtZW50LCAnbmV3Jz47XG5cbmNvbnN0IGxlZ2FjeUN1c3RvbUVsZW1lbnQgPSAodGFnTmFtZTogc3RyaW5nLCBjbGF6ejogQ3VzdG9tRWxlbWVudENsYXNzKSA9PiB7XG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBjbGF6eiBhcyBDdXN0b21FbGVtZW50Q29uc3RydWN0b3IpO1xuICAvLyBDYXN0IGFzIGFueSBiZWNhdXNlIFRTIGRvZXNuJ3QgcmVjb2duaXplIHRoZSByZXR1cm4gdHlwZSBhcyBiZWluZyBhXG4gIC8vIHN1YnR5cGUgb2YgdGhlIGRlY29yYXRlZCBjbGFzcyB3aGVuIGNsYXp6IGlzIHR5cGVkIGFzXG4gIC8vIGBDb25zdHJ1Y3RvcjxIVE1MRWxlbWVudD5gIGZvciBzb21lIHJlYXNvbi5cbiAgLy8gYENvbnN0cnVjdG9yPEhUTUxFbGVtZW50PmAgaXMgaGVscGZ1bCB0byBtYWtlIHN1cmUgdGhlIGRlY29yYXRvciBpc1xuICAvLyBhcHBsaWVkIHRvIGVsZW1lbnRzIGhvd2V2ZXIuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIHJldHVybiBjbGF6eiBhcyBhbnk7XG59O1xuXG5jb25zdCBzdGFuZGFyZEN1c3RvbUVsZW1lbnQgPSAoXG4gIHRhZ05hbWU6IHN0cmluZyxcbiAgZGVzY3JpcHRvcjogQ2xhc3NEZXNjcmlwdG9yXG4pID0+IHtcbiAgY29uc3Qge2tpbmQsIGVsZW1lbnRzfSA9IGRlc2NyaXB0b3I7XG4gIHJldHVybiB7XG4gICAga2luZCxcbiAgICBlbGVtZW50cyxcbiAgICAvLyBUaGlzIGNhbGxiYWNrIGlzIGNhbGxlZCBvbmNlIHRoZSBjbGFzcyBpcyBvdGhlcndpc2UgZnVsbHkgZGVmaW5lZFxuICAgIGZpbmlzaGVyKGNsYXp6OiBDb25zdHJ1Y3RvcjxIVE1MRWxlbWVudD4pIHtcbiAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBjbGF6eik7XG4gICAgfSxcbiAgfTtcbn07XG5cbi8qKlxuICogQ2xhc3MgZGVjb3JhdG9yIGZhY3RvcnkgdGhhdCBkZWZpbmVzIHRoZSBkZWNvcmF0ZWQgY2xhc3MgYXMgYSBjdXN0b20gZWxlbWVudC5cbiAqXG4gKiBgYGBqc1xuICogQGN1c3RvbUVsZW1lbnQoJ215LWVsZW1lbnQnKVxuICogY2xhc3MgTXlFbGVtZW50IGV4dGVuZHMgTGl0RWxlbWVudCB7XG4gKiAgIHJlbmRlcigpIHtcbiAqICAgICByZXR1cm4gaHRtbGBgO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqIEBjYXRlZ29yeSBEZWNvcmF0b3JcbiAqIEBwYXJhbSB0YWdOYW1lIFRoZSB0YWcgbmFtZSBvZiB0aGUgY3VzdG9tIGVsZW1lbnQgdG8gZGVmaW5lLlxuICovXG5leHBvcnQgY29uc3QgY3VzdG9tRWxlbWVudCA9XG4gICh0YWdOYW1lOiBzdHJpbmcpID0+XG4gIChjbGFzc09yRGVzY3JpcHRvcjogQ3VzdG9tRWxlbWVudENsYXNzIHwgQ2xhc3NEZXNjcmlwdG9yKSA9PlxuICAgIHR5cGVvZiBjbGFzc09yRGVzY3JpcHRvciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBsZWdhY3lDdXN0b21FbGVtZW50KHRhZ05hbWUsIGNsYXNzT3JEZXNjcmlwdG9yKVxuICAgICAgOiBzdGFuZGFyZEN1c3RvbUVsZW1lbnQodGFnTmFtZSwgY2xhc3NPckRlc2NyaXB0b3IgYXMgQ2xhc3NEZXNjcmlwdG9yKTtcbiIsICIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cblxuLypcbiAqIElNUE9SVEFOVDogRm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0c2lja2xlIGFuZCB0aGUgQ2xvc3VyZSBKUyBjb21waWxlciwgYWxsXG4gKiBwcm9wZXJ0eSBkZWNvcmF0b3JzIChidXQgbm90IGNsYXNzIGRlY29yYXRvcnMpIGluIHRoaXMgZmlsZSB0aGF0IGhhdmVcbiAqIGFuIEBFeHBvcnREZWNvcmF0ZWRJdGVtcyBhbm5vdGF0aW9uIG11c3QgYmUgZGVmaW5lZCBhcyBhIHJlZ3VsYXIgZnVuY3Rpb24sXG4gKiBub3QgYW4gYXJyb3cgZnVuY3Rpb24uXG4gKi9cbmltcG9ydCB7UHJvcGVydHlEZWNsYXJhdGlvbiwgUmVhY3RpdmVFbGVtZW50fSBmcm9tICcuLi9yZWFjdGl2ZS1lbGVtZW50LmpzJztcbmltcG9ydCB7Q2xhc3NFbGVtZW50fSBmcm9tICcuL2Jhc2UuanMnO1xuXG5jb25zdCBzdGFuZGFyZFByb3BlcnR5ID0gKFxuICBvcHRpb25zOiBQcm9wZXJ0eURlY2xhcmF0aW9uLFxuICBlbGVtZW50OiBDbGFzc0VsZW1lbnRcbikgPT4ge1xuICAvLyBXaGVuIGRlY29yYXRpbmcgYW4gYWNjZXNzb3IsIHBhc3MgaXQgdGhyb3VnaCBhbmQgYWRkIHByb3BlcnR5IG1ldGFkYXRhLlxuICAvLyBOb3RlLCB0aGUgYGhhc093blByb3BlcnR5YCBjaGVjayBpbiBgY3JlYXRlUHJvcGVydHlgIGVuc3VyZXMgd2UgZG9uJ3RcbiAgLy8gc3RvbXAgb3ZlciB0aGUgdXNlcidzIGFjY2Vzc29yLlxuICBpZiAoXG4gICAgZWxlbWVudC5raW5kID09PSAnbWV0aG9kJyAmJlxuICAgIGVsZW1lbnQuZGVzY3JpcHRvciAmJlxuICAgICEoJ3ZhbHVlJyBpbiBlbGVtZW50LmRlc2NyaXB0b3IpXG4gICkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5lbGVtZW50LFxuICAgICAgZmluaXNoZXIoY2xheno6IHR5cGVvZiBSZWFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgY2xhenouY3JlYXRlUHJvcGVydHkoZWxlbWVudC5rZXksIG9wdGlvbnMpO1xuICAgICAgfSxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIGNyZWF0ZVByb3BlcnR5KCkgdGFrZXMgY2FyZSBvZiBkZWZpbmluZyB0aGUgcHJvcGVydHksIGJ1dCB3ZSBzdGlsbFxuICAgIC8vIG11c3QgcmV0dXJuIHNvbWUga2luZCBvZiBkZXNjcmlwdG9yLCBzbyByZXR1cm4gYSBkZXNjcmlwdG9yIGZvciBhblxuICAgIC8vIHVudXNlZCBwcm90b3R5cGUgZmllbGQuIFRoZSBmaW5pc2hlciBjYWxscyBjcmVhdGVQcm9wZXJ0eSgpLlxuICAgIHJldHVybiB7XG4gICAgICBraW5kOiAnZmllbGQnLFxuICAgICAga2V5OiBTeW1ib2woKSxcbiAgICAgIHBsYWNlbWVudDogJ293bicsXG4gICAgICBkZXNjcmlwdG9yOiB7fSxcbiAgICAgIC8vIHN0b3JlIHRoZSBvcmlnaW5hbCBrZXkgc28gc3Vic2VxdWVudCBkZWNvcmF0b3JzIGhhdmUgYWNjZXNzIHRvIGl0LlxuICAgICAgb3JpZ2luYWxLZXk6IGVsZW1lbnQua2V5LFxuICAgICAgLy8gV2hlbiBAYmFiZWwvcGx1Z2luLXByb3Bvc2FsLWRlY29yYXRvcnMgaW1wbGVtZW50cyBpbml0aWFsaXplcnMsXG4gICAgICAvLyBkbyB0aGlzIGluc3RlYWQgb2YgdGhlIGluaXRpYWxpemVyIGJlbG93LiBTZWU6XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYmFiZWwvYmFiZWwvaXNzdWVzLzkyNjAgZXh0cmFzOiBbXG4gICAgICAvLyAgIHtcbiAgICAgIC8vICAgICBraW5kOiAnaW5pdGlhbGl6ZXInLFxuICAgICAgLy8gICAgIHBsYWNlbWVudDogJ293bicsXG4gICAgICAvLyAgICAgaW5pdGlhbGl6ZXI6IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIsXG4gICAgICAvLyAgIH1cbiAgICAgIC8vIF0sXG4gICAgICBpbml0aWFsaXplcih0aGlzOiB7W2tleTogc3RyaW5nXTogdW5rbm93bn0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50LmluaXRpYWxpemVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpc1tlbGVtZW50LmtleSBhcyBzdHJpbmddID0gZWxlbWVudC5pbml0aWFsaXplci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZmluaXNoZXIoY2xheno6IHR5cGVvZiBSZWFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgY2xhenouY3JlYXRlUHJvcGVydHkoZWxlbWVudC5rZXksIG9wdGlvbnMpO1xuICAgICAgfSxcbiAgICB9O1xuICB9XG59O1xuXG5jb25zdCBsZWdhY3lQcm9wZXJ0eSA9IChcbiAgb3B0aW9uczogUHJvcGVydHlEZWNsYXJhdGlvbixcbiAgcHJvdG86IE9iamVjdCxcbiAgbmFtZTogUHJvcGVydHlLZXlcbikgPT4ge1xuICAocHJvdG8uY29uc3RydWN0b3IgYXMgdHlwZW9mIFJlYWN0aXZlRWxlbWVudCkuY3JlYXRlUHJvcGVydHkobmFtZSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEEgcHJvcGVydHkgZGVjb3JhdG9yIHdoaWNoIGNyZWF0ZXMgYSByZWFjdGl2ZSBwcm9wZXJ0eSB0aGF0IHJlZmxlY3RzIGFcbiAqIGNvcnJlc3BvbmRpbmcgYXR0cmlidXRlIHZhbHVlLiBXaGVuIGEgZGVjb3JhdGVkIHByb3BlcnR5IGlzIHNldFxuICogdGhlIGVsZW1lbnQgd2lsbCB1cGRhdGUgYW5kIHJlbmRlci4gQSB7QGxpbmtjb2RlIFByb3BlcnR5RGVjbGFyYXRpb259IG1heVxuICogb3B0aW9uYWxseSBiZSBzdXBwbGllZCB0byBjb25maWd1cmUgcHJvcGVydHkgZmVhdHVyZXMuXG4gKlxuICogVGhpcyBkZWNvcmF0b3Igc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgcHVibGljIGZpZWxkcy4gQXMgcHVibGljIGZpZWxkcyxcbiAqIHByb3BlcnRpZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgcHJpbWFyaWx5IHNldHRhYmxlIGJ5IGVsZW1lbnQgdXNlcnMsXG4gKiBlaXRoZXIgdmlhIGF0dHJpYnV0ZSBvciB0aGUgcHJvcGVydHkgaXRzZWxmLlxuICpcbiAqIEdlbmVyYWxseSwgcHJvcGVydGllcyB0aGF0IGFyZSBjaGFuZ2VkIGJ5IHRoZSBlbGVtZW50IHNob3VsZCBiZSBwcml2YXRlIG9yXG4gKiBwcm90ZWN0ZWQgZmllbGRzIGFuZCBzaG91bGQgdXNlIHRoZSB7QGxpbmtjb2RlIHN0YXRlfSBkZWNvcmF0b3IuXG4gKlxuICogSG93ZXZlciwgc29tZXRpbWVzIGVsZW1lbnQgY29kZSBkb2VzIG5lZWQgdG8gc2V0IGEgcHVibGljIHByb3BlcnR5LiBUaGlzXG4gKiBzaG91bGQgdHlwaWNhbGx5IG9ubHkgYmUgZG9uZSBpbiByZXNwb25zZSB0byB1c2VyIGludGVyYWN0aW9uLCBhbmQgYW4gZXZlbnRcbiAqIHNob3VsZCBiZSBmaXJlZCBpbmZvcm1pbmcgdGhlIHVzZXI7IGZvciBleGFtcGxlLCBhIGNoZWNrYm94IHNldHMgaXRzXG4gKiBgY2hlY2tlZGAgcHJvcGVydHkgd2hlbiBjbGlja2VkIGFuZCBmaXJlcyBhIGBjaGFuZ2VkYCBldmVudC4gTXV0YXRpbmcgcHVibGljXG4gKiBwcm9wZXJ0aWVzIHNob3VsZCB0eXBpY2FsbHkgbm90IGJlIGRvbmUgZm9yIG5vbi1wcmltaXRpdmUgKG9iamVjdCBvciBhcnJheSlcbiAqIHByb3BlcnRpZXMuIEluIG90aGVyIGNhc2VzIHdoZW4gYW4gZWxlbWVudCBuZWVkcyB0byBtYW5hZ2Ugc3RhdGUsIGEgcHJpdmF0ZVxuICogcHJvcGVydHkgZGVjb3JhdGVkIHZpYSB0aGUge0BsaW5rY29kZSBzdGF0ZX0gZGVjb3JhdG9yIHNob3VsZCBiZSB1c2VkLiBXaGVuXG4gKiBuZWVkZWQsIHN0YXRlIHByb3BlcnRpZXMgY2FuIGJlIGluaXRpYWxpemVkIHZpYSBwdWJsaWMgcHJvcGVydGllcyB0b1xuICogZmFjaWxpdGF0ZSBjb21wbGV4IGludGVyYWN0aW9ucy5cbiAqXG4gKiBgYGB0c1xuICogY2xhc3MgTXlFbGVtZW50IHtcbiAqICAgQHByb3BlcnR5KHsgdHlwZTogQm9vbGVhbiB9KVxuICogICBjbGlja2VkID0gZmFsc2U7XG4gKiB9XG4gKiBgYGBcbiAqIEBjYXRlZ29yeSBEZWNvcmF0b3JcbiAqIEBFeHBvcnREZWNvcmF0ZWRJdGVtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvcGVydHkob3B0aW9ucz86IFByb3BlcnR5RGVjbGFyYXRpb24pIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgcmV0dXJuIChwcm90b09yRGVzY3JpcHRvcjogT2JqZWN0IHwgQ2xhc3NFbGVtZW50LCBuYW1lPzogUHJvcGVydHlLZXkpOiBhbnkgPT5cbiAgICBuYW1lICE9PSB1bmRlZmluZWRcbiAgICAgID8gbGVnYWN5UHJvcGVydHkob3B0aW9ucyEsIHByb3RvT3JEZXNjcmlwdG9yIGFzIE9iamVjdCwgbmFtZSlcbiAgICAgIDogc3RhbmRhcmRQcm9wZXJ0eShvcHRpb25zISwgcHJvdG9PckRlc2NyaXB0b3IgYXMgQ2xhc3NFbGVtZW50KTtcbn1cbiIsICIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cblxuLypcbiAqIElNUE9SVEFOVDogRm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0c2lja2xlIGFuZCB0aGUgQ2xvc3VyZSBKUyBjb21waWxlciwgYWxsXG4gKiBwcm9wZXJ0eSBkZWNvcmF0b3JzIChidXQgbm90IGNsYXNzIGRlY29yYXRvcnMpIGluIHRoaXMgZmlsZSB0aGF0IGhhdmVcbiAqIGFuIEBFeHBvcnREZWNvcmF0ZWRJdGVtcyBhbm5vdGF0aW9uIG11c3QgYmUgZGVmaW5lZCBhcyBhIHJlZ3VsYXIgZnVuY3Rpb24sXG4gKiBub3QgYW4gYXJyb3cgZnVuY3Rpb24uXG4gKi9cblxuaW1wb3J0IHtkZWNvcmF0ZVByb3BlcnR5fSBmcm9tICcuL2Jhc2UuanMnO1xuXG5pbXBvcnQgdHlwZSB7UmVhY3RpdmVFbGVtZW50fSBmcm9tICcuLi9yZWFjdGl2ZS1lbGVtZW50LmpzJztcbmltcG9ydCB0eXBlIHtRdWVyeUFzc2lnbmVkTm9kZXNPcHRpb25zfSBmcm9tICcuL3F1ZXJ5LWFzc2lnbmVkLW5vZGVzLmpzJztcblxuY29uc3QgTk9ERV9NT0RFID0gZmFsc2U7XG5jb25zdCBnbG9iYWwgPSBOT0RFX01PREUgPyBnbG9iYWxUaGlzIDogd2luZG93O1xuXG4vKipcbiAqIEEgdGlueSBtb2R1bGUgc2NvcGVkIHBvbHlmaWxsIGZvciBIVE1MU2xvdEVsZW1lbnQuYXNzaWduZWRFbGVtZW50cy5cbiAqL1xuY29uc3Qgc2xvdEFzc2lnbmVkRWxlbWVudHMgPVxuICBnbG9iYWwuSFRNTFNsb3RFbGVtZW50Py5wcm90b3R5cGUuYXNzaWduZWRFbGVtZW50cyAhPSBudWxsXG4gICAgPyAoc2xvdDogSFRNTFNsb3RFbGVtZW50LCBvcHRzPzogQXNzaWduZWROb2Rlc09wdGlvbnMpID0+XG4gICAgICAgIHNsb3QuYXNzaWduZWRFbGVtZW50cyhvcHRzKVxuICAgIDogKHNsb3Q6IEhUTUxTbG90RWxlbWVudCwgb3B0cz86IEFzc2lnbmVkTm9kZXNPcHRpb25zKSA9PlxuICAgICAgICBzbG90XG4gICAgICAgICAgLmFzc2lnbmVkTm9kZXMob3B0cylcbiAgICAgICAgICAuZmlsdGVyKFxuICAgICAgICAgICAgKG5vZGUpOiBub2RlIGlzIEVsZW1lbnQgPT4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREVcbiAgICAgICAgICApO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHRoZSB7QGxpbmtjb2RlIHF1ZXJ5QXNzaWduZWRFbGVtZW50c30gZGVjb3JhdG9yLiBFeHRlbmRzIHRoZVxuICogb3B0aW9ucyB0aGF0IGNhbiBiZSBwYXNzZWQgaW50b1xuICogW0hUTUxTbG90RWxlbWVudC5hc3NpZ25lZEVsZW1lbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTFNsb3RFbGVtZW50L2Fzc2lnbmVkRWxlbWVudHMpLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5QXNzaWduZWRFbGVtZW50c09wdGlvbnNcbiAgZXh0ZW5kcyBRdWVyeUFzc2lnbmVkTm9kZXNPcHRpb25zIHtcbiAgLyoqXG4gICAqIENTUyBzZWxlY3RvciB1c2VkIHRvIGZpbHRlciB0aGUgZWxlbWVudHMgcmV0dXJuZWQuIEZvciBleGFtcGxlLCBhIHNlbGVjdG9yXG4gICAqIG9mIGBcIi5pdGVtXCJgIHdpbGwgb25seSBpbmNsdWRlIGVsZW1lbnRzIHdpdGggdGhlIGBpdGVtYCBjbGFzcy5cbiAgICovXG4gIHNlbGVjdG9yPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIEEgcHJvcGVydHkgZGVjb3JhdG9yIHRoYXQgY29udmVydHMgYSBjbGFzcyBwcm9wZXJ0eSBpbnRvIGEgZ2V0dGVyIHRoYXRcbiAqIHJldHVybnMgdGhlIGBhc3NpZ25lZEVsZW1lbnRzYCBvZiB0aGUgZ2l2ZW4gYHNsb3RgLiBQcm92aWRlcyBhIGRlY2xhcmF0aXZlXG4gKiB3YXkgdG8gdXNlXG4gKiBbYEhUTUxTbG90RWxlbWVudC5hc3NpZ25lZEVsZW1lbnRzYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxTbG90RWxlbWVudC9hc3NpZ25lZEVsZW1lbnRzKS5cbiAqXG4gKiBDYW4gYmUgcGFzc2VkIGFuIG9wdGlvbmFsIHtAbGlua2NvZGUgUXVlcnlBc3NpZ25lZEVsZW1lbnRzT3B0aW9uc30gb2JqZWN0LlxuICpcbiAqIEV4YW1wbGUgdXNhZ2U6XG4gKiBgYGB0c1xuICogY2xhc3MgTXlFbGVtZW50IHtcbiAqICAgQHF1ZXJ5QXNzaWduZWRFbGVtZW50cyh7IHNsb3Q6ICdsaXN0JyB9KVxuICogICBsaXN0SXRlbXMhOiBBcnJheTxIVE1MRWxlbWVudD47XG4gKiAgIEBxdWVyeUFzc2lnbmVkRWxlbWVudHMoKVxuICogICB1bm5hbWVkU2xvdEVscyE6IEFycmF5PEhUTUxFbGVtZW50PjtcbiAqXG4gKiAgIHJlbmRlcigpIHtcbiAqICAgICByZXR1cm4gaHRtbGBcbiAqICAgICAgIDxzbG90IG5hbWU9XCJsaXN0XCI+PC9zbG90PlxuICogICAgICAgPHNsb3Q+PC9zbG90PlxuICogICAgIGA7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIE5vdGUsIHRoZSB0eXBlIG9mIHRoaXMgcHJvcGVydHkgc2hvdWxkIGJlIGFubm90YXRlZCBhcyBgQXJyYXk8SFRNTEVsZW1lbnQ+YC5cbiAqXG4gKiBAY2F0ZWdvcnkgRGVjb3JhdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeUFzc2lnbmVkRWxlbWVudHMob3B0aW9ucz86IFF1ZXJ5QXNzaWduZWRFbGVtZW50c09wdGlvbnMpIHtcbiAgY29uc3Qge3Nsb3QsIHNlbGVjdG9yfSA9IG9wdGlvbnMgPz8ge307XG4gIHJldHVybiBkZWNvcmF0ZVByb3BlcnR5KHtcbiAgICBkZXNjcmlwdG9yOiAoX25hbWU6IFByb3BlcnR5S2V5KSA9PiAoe1xuICAgICAgZ2V0KHRoaXM6IFJlYWN0aXZlRWxlbWVudCkge1xuICAgICAgICBjb25zdCBzbG90U2VsZWN0b3IgPSBgc2xvdCR7c2xvdCA/IGBbbmFtZT0ke3Nsb3R9XWAgOiAnOm5vdChbbmFtZV0pJ31gO1xuICAgICAgICBjb25zdCBzbG90RWwgPVxuICAgICAgICAgIHRoaXMucmVuZGVyUm9vdD8ucXVlcnlTZWxlY3RvcjxIVE1MU2xvdEVsZW1lbnQ+KHNsb3RTZWxlY3Rvcik7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID1cbiAgICAgICAgICBzbG90RWwgIT0gbnVsbCA/IHNsb3RBc3NpZ25lZEVsZW1lbnRzKHNsb3RFbCwgb3B0aW9ucykgOiBbXTtcbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnRzLmZpbHRlcigobm9kZSkgPT4gbm9kZS5tYXRjaGVzKHNlbGVjdG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgfSksXG4gIH0pO1xufVxuIiwgImltcG9ydCBhcHBsZXNjcmlwdCBmcm9tIFwibm9kZS1vc2FzY3JpcHRcIjtcblxuZXhwb3J0IGNvbnN0IGV4ZWN1dG9yID0gYXN5bmMgKHNjcmlwdDogc3RyaW5nLCB2YXJpYWJsZXM6IHtba2V5OiBzdHJpbmddOiBhbnl9IHwgbnVsbCA9IG51bGwpOiBQcm9taXNlPHVua25vd24+ID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBsZXQgY2hpbGRQcm9jZXNzID0gYXBwbGVzY3JpcHQuZXhlY3V0ZShzY3JpcHQsIHZhcmlhYmxlcywgKGVycjogYW55LCByZXM6IGFueSwgcmF3OiBhbnkpID0+IHtcbiAgICAgICAgICAgIGlmKGVycikgcmVqZWN0KGVycik7XG4gICAgICAgICAgICByZXNvbHZlKHJlcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY2hpbGRQcm9jZXNzLnN0ZGluLnBhdXNlKCk7XG4gICAgICAgICAgICBjaGlsZFByb2Nlc3Mua2lsbCgpO1xuICAgICAgICAgICAgcmVqZWN0KFwiQXBwbGUgU2NyaXB0IHRpbWVkIG91dFwiKVxuICAgICAgICB9LCAzMDAwMClcbiAgICB9KVxufVxuXG4iLCAiaW1wb3J0IHsgUGx1Z2luU2V0dGluZ1RhYiwgQXBwLCBTZXR0aW5nIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgQXBwbGVSZW1pbmRlcnNQbHVnaW4gZnJvbSBcIi4uL21haW5cIjtcblxuZXhwb3J0IGludGVyZmFjZSBBcHBsZVJlbWluZGVyc1BsdWdpblNldHRpbmdzIHtcblx0YXV0b1JlZnJlc2hUaW1lOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBBcHBsZVJlbWluZGVyc1BsdWdpblNldHRpbmdzID0ge1xuXHRhdXRvUmVmcmVzaFRpbWU6IDYwXG59XG5cbmV4cG9ydCBjbGFzcyBTYW1wbGVTZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG5cdHBsdWdpbjogQXBwbGVSZW1pbmRlcnNQbHVnaW47XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogQXBwbGVSZW1pbmRlcnNQbHVnaW4pIHtcblx0XHRzdXBlcihhcHAsIHBsdWdpbik7XG5cdFx0dGhpcy5wbHVnaW4gPSBwbHVnaW47XG5cdH1cblxuXHRkaXNwbGF5KCk6IHZvaWQge1xuXHRcdGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG5cblx0XHRjb250YWluZXJFbC5lbXB0eSgpO1xuXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnQXBwbGUgUmVtaW5kZXJzIFBsdWdpbicgfSk7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdBdXRvIFJlZnJlc2ggVGltZSAoc2Vjb25kcyknKVxuXHRcdFx0LnNldERlc2MoJ1BsZWFzZSBpbnB1dCB0aW1lIGluIHNlY29uZHMuIFRoaXMgY29udHJvbHMgdGhlIGludGVydmFsIGJldHdlZW4gd2hpY2ggdGhlIHBsdWdpbiBhdXRvbWF0aWNhbGx5IHJlZnJlc2hlcyB3aXRoIEFwcGxlIFJlbWluZGVycy4gKFJlc3RhcnQgT2JzaWRpYW4gZm9yIGNoYW5nZXMgdG8gdGFrZSBhZmZlY3QpJylcblx0XHRcdC5zZXRUb29sdGlwKFwiMzAwIHNlY29uZHMgPSA1IG1pbnV0ZXNcIilcblx0XHRcdC5hZGRTbGlkZXIodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdC5zZXRMaW1pdHMoNjAsIDYwMCwgMTApXG5cdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5hdXRvUmVmcmVzaFRpbWUpXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5hdXRvUmVmcmVzaFRpbWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0fSkpO1xuXHR9XG59IiwgImltcG9ydCB7IEZpbHRlck1vZGVsLCBSZW1pbmRlck1vZGVsIH0gZnJvbSBcInNyYy9tb2RlbHMvc2hhcmVkLm1vZGVsc1wiO1xuaW1wb3J0ICogYXMgY2hyb25vIGZyb20gJ2Nocm9uby1ub2RlJztcbmltcG9ydCB7IG1vbWVudCB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgQVBQTEVfREFURV9GT1JNQVQgfSBmcm9tIFwic3JjL2RhdGEvY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVkaWNhdGUocmVtaW5kZXI6IFJlbWluZGVyTW9kZWwsIGZpbHRlcnM6IEZpbHRlck1vZGVsW10gfCB1bmRlZmluZWQsIGZpbGVuYW1lOiBzdHJpbmcgfCBudWxsKSB7XG5cdHZhciBtYXRjaCA9IHRydWU7XG5cblx0aWYgKGZpbHRlcnMgPT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cblx0ZmlsdGVycy5mb3JFYWNoKChmaWx0ZXIpID0+IHtcblx0XHRpZiAoZmlsdGVyICE9IG51bGwpIHtcblx0XHRcdGlmIChmaWx0ZXIuZGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdGlmIChyZW1pbmRlcltcImR1ZSBkYXRlXCJdID09IFwibWlzc2luZyB2YWx1ZVwiKSB7XG5cdFx0XHRcdFx0bWF0Y2ggJiY9IGZhbHNlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBkYXRlID1cblx0XHRcdFx0XHRcdGZpbHRlci5kYXRlID09IFwiZGFpbHkgbm90ZVwiXG5cdFx0XHRcdFx0XHRcdD8gZmlsZW5hbWVcblx0XHRcdFx0XHRcdFx0OiBmaWx0ZXIuZGF0ZTtcblxuXHRcdFx0XHRcdGlmIChkYXRlKSB7XG5cdFx0XHRcdFx0XHR2YXIgcmFuZ2UgPSBjaHJvbm8ucGFyc2UoZGF0ZSlbMF07XG5cblx0XHRcdFx0XHRcdHZhciBzdGFydCA9IG1vbWVudChyYW5nZS5zdGFydC5kYXRlKCkpO1xuXHRcdFx0XHRcdFx0aWYgKHJhbmdlLmVuZCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBlbmQgPSBtb21lbnQocmFuZ2UuZW5kLmRhdGUoKSk7XG5cdFx0XHRcdFx0XHRcdG1hdGNoICYmPSBtb21lbnQoXG5cdFx0XHRcdFx0XHRcdFx0cmVtaW5kZXJbXCJkdWUgZGF0ZVwiXSxcblx0XHRcdFx0XHRcdFx0XHRBUFBMRV9EQVRFX0ZPUk1BVFxuXHRcdFx0XHRcdFx0XHQpLmlzQmV0d2VlbihzdGFydCwgZW5kLCBcImRheVwiLCBcIltdXCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoICYmPSBtb21lbnQocmVtaW5kZXJbXCJkdWUgZGF0ZVwiXSwgQVBQTEVfREFURV9GT1JNQVQpLmlzU2FtZShzdGFydCwgXCJkYXlcIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGZpbHRlci5wcmlvcml0eSAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBwcmlvcml0eSA9IDA7XG5cdFx0XHRcdHN3aXRjaCAoZmlsdGVyLnByaW9yaXR5KSB7XG5cdFx0XHRcdFx0Y2FzZSBcImhpZ2hcIjpcblx0XHRcdFx0XHRcdHByaW9yaXR5ID0gMTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJtZWRpdW1cIjpcblx0XHRcdFx0XHRcdHByaW9yaXR5ID0gNTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJsb3dcIjpcblx0XHRcdFx0XHRcdHByaW9yaXR5ID0gOTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRwcmlvcml0eSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWF0Y2ggJiY9IHJlbWluZGVyLnByaW9yaXR5ID09IHByaW9yaXR5O1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBtYXRjaDtcbn0iLCAiZXhwb3J0IGNvbnN0IEFQUExFX0RBVEVfRk9STUFUID0gXCJkZGRkLCBERCBNTU1NIGF0IEg6bTpzc1wiOyIsICJpbXBvcnQgeyBleGVjdXRvciB9IGZyb20gJy4vYXBwbGUtaW50ZWdyYXRpb24nO1xuaW1wb3J0IHsgQXBwbGVSZW1pbmRlclNwZWMsIEZpbHRlck1vZGVsLCBMaXN0TW9kZWwsIFJlbWluZGVyTW9kZWwgfSBmcm9tICcuLi9tb2RlbHMvc2hhcmVkLm1vZGVscyc7XG5pbXBvcnQgeyBBcHBsZVJlbWluZGVyc1BsdWdpblNldHRpbmdzLCBERUZBVUxUX1NFVFRJTkdTIH0gZnJvbSAnLi4vdWkvc2V0dGluZ3MnO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHsgcHJlZGljYXRlIH0gZnJvbSAnLi91dGlsaXRpZXMnO1xuXG5cblxuZXhwb3J0IGNvbnN0IFJlbWluZGVyc0RhdGFTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgbG9nZ2VyID0gY29uc29sZS5sb2c7XG4gICAgbGV0IHNldHRpbmdzOiBBcHBsZVJlbWluZGVyc1BsdWdpblNldHRpbmdzID0gREVGQVVMVF9TRVRUSU5HUztcblxuICAgIGNvbnN0IGdldEFsbExpc3RzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBsb2dnZXIoXCJHZXR0aW5nIGFsbCBsaXN0c1wiKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGV4ZWN1dG9yKGB0ZWxsIGFwcGxpY2F0aW9uIFwiUmVtaW5kZXJzXCIgdG8gcmV0dXJuIHByb3BlcnRpZXMgb2YgbGlzdHNgKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0TGlzdCA9IGFzeW5jIChsaXN0X25hbWU6IExpc3RNb2RlbFtcIm5hbWVcIl0pOiBQcm9taXNlPExpc3RNb2RlbD4gPT4ge1xuICAgICAgICBsb2dnZXIoXCJMb29raW5nIGZvciBcIiArIGxpc3RfbmFtZSlcbiAgICAgICAgbGV0IHJldCA9IDxMaXN0TW9kZWw+YXdhaXQgZXhlY3V0b3IoXG4gICAgICAgICAgICBgdGVsbCBhcHBsaWNhdGlvbiBcIlJlbWluZGVyc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydGllcyBvZiBsaXN0IGxpc3RfbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgb24gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQgbGlzIHRvIG1ha2UgbmV3IGxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQgbmFtZSBvZiBsaXMgdG8gbGlzdF9uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnRpZXMgb2YgbGlzXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgdHJ5XG4gICAgICAgICAgICAgICAgICAgIGVuZCB0ZWxsYCxcbiAgICAgICAgICAgIHsgbGlzdF9uYW1lIH1cbiAgICAgICAgKTtcblxuICAgICAgICBsb2dnZXIoXCJEb25lXCIsIDMwMDApXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBjb25zdCBnZXRSZW1pbmRlcnMgPSBhc3luYyAobGlzdF9uYW1lOiBMaXN0TW9kZWxbXCJuYW1lXCJdLCBmaWx0ZXJzOiBGaWx0ZXJNb2RlbFtdIHwgdW5kZWZpbmVkKTogUHJvbWlzZTxSZW1pbmRlck1vZGVsW10+ID0+IHtcbiAgICAgICAgbG9nZ2VyKFwiR2V0dGluZyByZW1pbmRlcnMgaW4gXCIgKyBsaXN0X25hbWUpXG4gICAgICAgIGxldCB4ID0gYXdhaXQgZXhlY3V0b3IoXG4gICAgICAgICAgICBgdGVsbCBsaXN0IGxpc3RfbmFtZSBpbiBhcHBsaWNhdGlvbiBcIlJlbWluZGVyc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQgYnVmZmVyIHRvICgoY3VycmVudCBkYXRlKSAtIGhvdXJzICogMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0aWVzIG9mIHJlbWluZGVycyB3aG9zZSBjb21wbGV0aW9uIGRhdGUgY29tZXMgYWZ0ZXIgYnVmZmVyIG9yIGNvbXBsZXRlZCBpcyBmYWxzZVx0XG4gICAgICAgICAgICAgICAgICAgIGVuZCB0ZWxsYCxcbiAgICAgICAgICAgIHsgbGlzdF9uYW1lIH1cbiAgICAgICAgKTtcbiAgICAgICAgbG9nZ2VyKFwiRG9uZVwiLCAzMDAwKVxuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh4KSkgcmV0dXJuIFtdO1xuICAgICAgICBpZihmaWx0ZXJzKSB7XG4gICAgICAgICAgICB4ID0geC5maWx0ZXIoKHZhbHVlKSA9PiBwcmVkaWNhdGUodmFsdWUsIGZpbHRlcnMsIG51bGwpKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiA8UmVtaW5kZXJNb2RlbFtdPng7XG4gICAgfTtcbiAgICBjb25zdCBnZXRPckNyZWF0ZVJlbWluZGVyID0gYXN5bmMgKGxpc3RfbmFtZTogTGlzdE1vZGVsW1wibmFtZVwiXSwgcmVtaW5kZXJfbmFtZTogUmVtaW5kZXJNb2RlbFtcIm5hbWVcIl0pID0+IHtcbiAgICAgICAgbG9nZ2VyKFwiTG9va2luZyBmb3IgXCIgKyByZW1pbmRlcl9uYW1lICsgXCIgaW4gXCIgKyBsaXN0X25hbWUgKyBcIiBiZWZvcmUgYXR0ZW1wdGluZyB0byBjcmVhdGVcIilcbiAgICAgICAgcmV0dXJuIGF3YWl0IGV4ZWN1dG9yKGB0ZWxsIGxpc3QgbGlzdF9uYW1lIGluIGFwcGxpY2F0aW9uIFwiUmVtaW5kZXJzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0aWVzIG9mIHJlbWluZGVyIHJlbWluZGVyX25hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0IHJlbSB0byBtYWtlIG5ldyByZW1pbmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldCBuYW1lIG9mIHJlbSB0byByZW1pbmRlcl9uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnRpZXMgb2YgcmVtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgdHJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCB0ZWxsYCxcbiAgICAgICAgICAgIHsgbGlzdF9uYW1lLCByZW1pbmRlcl9uYW1lIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVmcmVzaFJlbWluZGVyID0gKHJlbWluZGVySWQ6IFJlbWluZGVyTW9kZWxbXCJpZFwiXSkgPT4geyB9O1xuICAgIGNvbnN0IHRvZ2dsZVJlbWluZGVyRG9uZVN0YXR1cyA9IGFzeW5jIChsaXN0X25hbWU6IExpc3RNb2RlbFtcIm5hbWVcIl0sIHJlbWluZGVyX25hbWU6IFJlbWluZGVyTW9kZWxbXCJuYW1lXCJdKTogUHJvbWlzZTxSZW1pbmRlck1vZGVsPiA9PiB7XG5cbiAgICAgICAgbG9nZ2VyKFwiVG9nZ2xpbmcgUmVtaW5kZXI6IFwiICsgcmVtaW5kZXJfbmFtZSArIFwiIGluIGxpc3QgXCIgKyBsaXN0X25hbWUpXG4gICAgICAgIGxldCByZXQgPSA8UmVtaW5kZXJNb2RlbD5hd2FpdCBleGVjdXRvcihgdGVsbCBsaXN0IGxpc3RfbmFtZSBpbiBhcHBsaWNhdGlvbiBcIlJlbWluZGVyc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQgcmVtIHRvIHJlbWluZGVyIHJlbWluZGVyX25hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldCBjb21wbGV0ZWQgaW4gcmVtIHRvIG5vdCBjb21wbGV0ZWQgaW4gcmVtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydGllcyBvZiByZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kIHRlbGxgLFxuICAgICAgICAgICAgeyBsaXN0X25hbWUsIHJlbWluZGVyX25hbWUgfSk7XG4gICAgICAgIGxvZ2dlcihcIkRvbmVcIiwgMzAwMCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGdldEFsbExpc3RzLFxuICAgICAgICBnZXRMaXN0LFxuICAgICAgICBnZXRSZW1pbmRlcnMsXG4gICAgICAgIGdldE9yQ3JlYXRlUmVtaW5kZXIsXG4gICAgICAgIHJlZnJlc2hSZW1pbmRlcixcbiAgICAgICAgdG9nZ2xlUmVtaW5kZXJEb25lU3RhdHVzLFxuXG4gICAgICAgIHNldExvZ2dlcjogKGZ1bmM6IChhcmc6IGFueSwgY2xlYXJBZnRlcjogbnVtYmVyIHwgdW5kZWZpbmVkKSA9PiB2b2lkKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIgPSAoeCwgY2xlYXJBZnRlcikgPT4ge1xuICAgICAgICAgICAgICAgIGZ1bmMoeCwgY2xlYXJBZnRlcik7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coeyB4LCBjbGVhckFmdGVyIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldFNldHRpbmdzOiAoX3NldHRpbmdzOiBBcHBsZVJlbWluZGVyc1BsdWdpblNldHRpbmdzKSA9PiB7XG4gICAgICAgICAgICBzZXR0aW5ncyA9IF9zZXR0aW5ncztcbiAgICAgICAgfSxcblxuICAgICAgICBmZXRjaERhdGE6IChzcGVjOiBBcHBsZVJlbWluZGVyU3BlYywgZmlsZU5hbWU6IHN0cmluZyB8IG51bGwgPSBudWxsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIGdldExpc3Qoc3BlYy5saXN0KSxcbiAgICAgICAgICAgICAgICBnZXRSZW1pbmRlcnMoc3BlY1tcImxpc3RcIl0sIHNwZWNbXCJmaWx0ZXJzXCJdKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRTZXR0aW5nczogKCkgPT4gc2V0dGluZ3NcbiAgICB9XG59KSgpOyIsICJpbXBvcnQgeyBzdmcsIExpdEVsZW1lbnQgfSBmcm9tIFwibGl0XCI7XG5pbXBvcnQgeyBjdXN0b21FbGVtZW50IH0gZnJvbSBcImxpdC9kZWNvcmF0b3JzLmpzXCI7XG5cblxuQGN1c3RvbUVsZW1lbnQoJ2FwcGxlLWxpc3QtbG9hZGluZy1iYXInKVxuZXhwb3J0IGNsYXNzIExvYWRpbmdCYXJDb21wb25lbnQgZXh0ZW5kcyBMaXRFbGVtZW50IHtcblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiBzdmdgXG48IS0tIDw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cInV0Zi04XCI/PiAtLT5cbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHN0eWxlPVwibWFyZ2luOiBhdXRvOyBiYWNrZ3JvdW5kLWltYWdlOiBub25lOyBkaXNwbGF5OiBibG9jazsgc2hhcGUtcmVuZGVyaW5nOiBhdXRvO1wiIHdpZHRoPVwiMTAwcHhcIiBoZWlnaHQ9XCIxMDBweFwiIHZpZXdCb3g9XCIwIDAgMTAwIDEwMFwiIHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWlkWU1pZFwiPlxuPGcgdHJhbnNmb3JtPVwicm90YXRlKDAgNTAgNTApXCI+XG4gIDxyZWN0IHg9XCI0N1wiIHk9XCIyNFwiIHJ4PVwiM1wiIHJ5PVwiNlwiIHdpZHRoPVwiNlwiIGhlaWdodD1cIjEyXCIgZmlsbD1cIiMwMDAwMDBcIj5cbiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPVwib3BhY2l0eVwiIHZhbHVlcz1cIjE7MFwiIGtleVRpbWVzPVwiMDsxXCIgZHVyPVwiMXNcIiBiZWdpbj1cIi0wLjkxNjY2NjY2NjY2NjY2NjZzXCIgcmVwZWF0Q291bnQ9XCJpbmRlZmluaXRlXCI+PC9hbmltYXRlPlxuICA8L3JlY3Q+XG48L2c+PGcgdHJhbnNmb3JtPVwicm90YXRlKDMwIDUwIDUwKVwiPlxuICA8cmVjdCB4PVwiNDdcIiB5PVwiMjRcIiByeD1cIjNcIiByeT1cIjZcIiB3aWR0aD1cIjZcIiBoZWlnaHQ9XCIxMlwiIGZpbGw9XCIjMDAwMDAwXCI+XG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cIm9wYWNpdHlcIiB2YWx1ZXM9XCIxOzBcIiBrZXlUaW1lcz1cIjA7MVwiIGR1cj1cIjFzXCIgYmVnaW49XCItMC44MzMzMzMzMzMzMzMzMzM0c1wiIHJlcGVhdENvdW50PVwiaW5kZWZpbml0ZVwiPjwvYW5pbWF0ZT5cbiAgPC9yZWN0PlxuPC9nPjxnIHRyYW5zZm9ybT1cInJvdGF0ZSg2MCA1MCA1MClcIj5cbiAgPHJlY3QgeD1cIjQ3XCIgeT1cIjI0XCIgcng9XCIzXCIgcnk9XCI2XCIgd2lkdGg9XCI2XCIgaGVpZ2h0PVwiMTJcIiBmaWxsPVwiIzAwMDAwMFwiPlxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XCJvcGFjaXR5XCIgdmFsdWVzPVwiMTswXCIga2V5VGltZXM9XCIwOzFcIiBkdXI9XCIxc1wiIGJlZ2luPVwiLTAuNzVzXCIgcmVwZWF0Q291bnQ9XCJpbmRlZmluaXRlXCI+PC9hbmltYXRlPlxuICA8L3JlY3Q+XG48L2c+PGcgdHJhbnNmb3JtPVwicm90YXRlKDkwIDUwIDUwKVwiPlxuICA8cmVjdCB4PVwiNDdcIiB5PVwiMjRcIiByeD1cIjNcIiByeT1cIjZcIiB3aWR0aD1cIjZcIiBoZWlnaHQ9XCIxMlwiIGZpbGw9XCIjMDAwMDAwXCI+XG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cIm9wYWNpdHlcIiB2YWx1ZXM9XCIxOzBcIiBrZXlUaW1lcz1cIjA7MVwiIGR1cj1cIjFzXCIgYmVnaW49XCItMC42NjY2NjY2NjY2NjY2NjY2c1wiIHJlcGVhdENvdW50PVwiaW5kZWZpbml0ZVwiPjwvYW5pbWF0ZT5cbiAgPC9yZWN0PlxuPC9nPjxnIHRyYW5zZm9ybT1cInJvdGF0ZSgxMjAgNTAgNTApXCI+XG4gIDxyZWN0IHg9XCI0N1wiIHk9XCIyNFwiIHJ4PVwiM1wiIHJ5PVwiNlwiIHdpZHRoPVwiNlwiIGhlaWdodD1cIjEyXCIgZmlsbD1cIiMwMDAwMDBcIj5cbiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPVwib3BhY2l0eVwiIHZhbHVlcz1cIjE7MFwiIGtleVRpbWVzPVwiMDsxXCIgZHVyPVwiMXNcIiBiZWdpbj1cIi0wLjU4MzMzMzMzMzMzMzMzMzRzXCIgcmVwZWF0Q291bnQ9XCJpbmRlZmluaXRlXCI+PC9hbmltYXRlPlxuICA8L3JlY3Q+XG48L2c+PGcgdHJhbnNmb3JtPVwicm90YXRlKDE1MCA1MCA1MClcIj5cbiAgPHJlY3QgeD1cIjQ3XCIgeT1cIjI0XCIgcng9XCIzXCIgcnk9XCI2XCIgd2lkdGg9XCI2XCIgaGVpZ2h0PVwiMTJcIiBmaWxsPVwiIzAwMDAwMFwiPlxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XCJvcGFjaXR5XCIgdmFsdWVzPVwiMTswXCIga2V5VGltZXM9XCIwOzFcIiBkdXI9XCIxc1wiIGJlZ2luPVwiLTAuNXNcIiByZXBlYXRDb3VudD1cImluZGVmaW5pdGVcIj48L2FuaW1hdGU+XG4gIDwvcmVjdD5cbjwvZz48ZyB0cmFuc2Zvcm09XCJyb3RhdGUoMTgwIDUwIDUwKVwiPlxuICA8cmVjdCB4PVwiNDdcIiB5PVwiMjRcIiByeD1cIjNcIiByeT1cIjZcIiB3aWR0aD1cIjZcIiBoZWlnaHQ9XCIxMlwiIGZpbGw9XCIjMDAwMDAwXCI+XG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cIm9wYWNpdHlcIiB2YWx1ZXM9XCIxOzBcIiBrZXlUaW1lcz1cIjA7MVwiIGR1cj1cIjFzXCIgYmVnaW49XCItMC40MTY2NjY2NjY2NjY2NjY3c1wiIHJlcGVhdENvdW50PVwiaW5kZWZpbml0ZVwiPjwvYW5pbWF0ZT5cbiAgPC9yZWN0PlxuPC9nPjxnIHRyYW5zZm9ybT1cInJvdGF0ZSgyMTAgNTAgNTApXCI+XG4gIDxyZWN0IHg9XCI0N1wiIHk9XCIyNFwiIHJ4PVwiM1wiIHJ5PVwiNlwiIHdpZHRoPVwiNlwiIGhlaWdodD1cIjEyXCIgZmlsbD1cIiMwMDAwMDBcIj5cbiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPVwib3BhY2l0eVwiIHZhbHVlcz1cIjE7MFwiIGtleVRpbWVzPVwiMDsxXCIgZHVyPVwiMXNcIiBiZWdpbj1cIi0wLjMzMzMzMzMzMzMzMzMzMzNzXCIgcmVwZWF0Q291bnQ9XCJpbmRlZmluaXRlXCI+PC9hbmltYXRlPlxuICA8L3JlY3Q+XG48L2c+PGcgdHJhbnNmb3JtPVwicm90YXRlKDI0MCA1MCA1MClcIj5cbiAgPHJlY3QgeD1cIjQ3XCIgeT1cIjI0XCIgcng9XCIzXCIgcnk9XCI2XCIgd2lkdGg9XCI2XCIgaGVpZ2h0PVwiMTJcIiBmaWxsPVwiIzAwMDAwMFwiPlxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XCJvcGFjaXR5XCIgdmFsdWVzPVwiMTswXCIga2V5VGltZXM9XCIwOzFcIiBkdXI9XCIxc1wiIGJlZ2luPVwiLTAuMjVzXCIgcmVwZWF0Q291bnQ9XCJpbmRlZmluaXRlXCI+PC9hbmltYXRlPlxuICA8L3JlY3Q+XG48L2c+PGcgdHJhbnNmb3JtPVwicm90YXRlKDI3MCA1MCA1MClcIj5cbiAgPHJlY3QgeD1cIjQ3XCIgeT1cIjI0XCIgcng9XCIzXCIgcnk9XCI2XCIgd2lkdGg9XCI2XCIgaGVpZ2h0PVwiMTJcIiBmaWxsPVwiIzAwMDAwMFwiPlxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XCJvcGFjaXR5XCIgdmFsdWVzPVwiMTswXCIga2V5VGltZXM9XCIwOzFcIiBkdXI9XCIxc1wiIGJlZ2luPVwiLTAuMTY2NjY2NjY2NjY2NjY2NjZzXCIgcmVwZWF0Q291bnQ9XCJpbmRlZmluaXRlXCI+PC9hbmltYXRlPlxuICA8L3JlY3Q+XG48L2c+PGcgdHJhbnNmb3JtPVwicm90YXRlKDMwMCA1MCA1MClcIj5cbiAgPHJlY3QgeD1cIjQ3XCIgeT1cIjI0XCIgcng9XCIzXCIgcnk9XCI2XCIgd2lkdGg9XCI2XCIgaGVpZ2h0PVwiMTJcIiBmaWxsPVwiIzAwMDAwMFwiPlxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XCJvcGFjaXR5XCIgdmFsdWVzPVwiMTswXCIga2V5VGltZXM9XCIwOzFcIiBkdXI9XCIxc1wiIGJlZ2luPVwiLTAuMDgzMzMzMzMzMzMzMzMzMzNzXCIgcmVwZWF0Q291bnQ9XCJpbmRlZmluaXRlXCI+PC9hbmltYXRlPlxuICA8L3JlY3Q+XG48L2c+PGcgdHJhbnNmb3JtPVwicm90YXRlKDMzMCA1MCA1MClcIj5cbiAgPHJlY3QgeD1cIjQ3XCIgeT1cIjI0XCIgcng9XCIzXCIgcnk9XCI2XCIgd2lkdGg9XCI2XCIgaGVpZ2h0PVwiMTJcIiBmaWxsPVwiIzAwMDAwMFwiPlxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XCJvcGFjaXR5XCIgdmFsdWVzPVwiMTswXCIga2V5VGltZXM9XCIwOzFcIiBkdXI9XCIxc1wiIGJlZ2luPVwiMHNcIiByZXBlYXRDb3VudD1cImluZGVmaW5pdGVcIj48L2FuaW1hdGU+XG4gIDwvcmVjdD5cbjwvZz5cbjwvc3ZnPlxuXHRcdGBcblx0fVxufSIsICJpbXBvcnQgeyBMaXRFbGVtZW50LCBodG1sLCBjc3MsIENTU1Jlc3VsdEdyb3VwIH0gZnJvbSAnbGl0JztcbmltcG9ydCB7IGN1c3RvbUVsZW1lbnQsIHByb3BlcnR5IH0gZnJvbSAnbGl0L2RlY29yYXRvcnMuanMnO1xuaW1wb3J0IHsgbW9tZW50IH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgQVBQTEVfREFURV9GT1JNQVQgfSBmcm9tICdzcmMvZGF0YS9jb25zdGFudHMnO1xuaW1wb3J0IHsgUmVtaW5kZXJNb2RlbCB9IGZyb20gJ3NyYy9tb2RlbHMvc2hhcmVkLm1vZGVscyc7XG5pbXBvcnQgeyBSZW1pbmRlcnNEYXRhU2VydmljZSB9IGZyb20gJ3NyYy9kYXRhL3JlbWluZGVycy1kYXRhLnNlcnZpY2UnO1xuXG5AY3VzdG9tRWxlbWVudCgnYXBwbGUtcmVtaW5kZXItZWxlbWVudCcpXG5leHBvcnQgY2xhc3MgUmVtaW5kZXJFbGVtZW50IGV4dGVuZHMgTGl0RWxlbWVudCB7XG5cblx0QHByb3BlcnR5KCkgbGlzdF9uYW1lOiBzdHJpbmc7XG5cdEBwcm9wZXJ0eSgpIG1vZGVsOiBSZW1pbmRlck1vZGVsO1xuXG5cdHN0YXRpYyBzdHlsZXM/OiBDU1NSZXN1bHRHcm91cCB8IHVuZGVmaW5lZCA9IGNzc2Bcblx0XHQuY2hlY2tib3gtcm91bmQge1xuXHRcdFx0d2lkdGg6IDEuM2VtO1xuXHRcdFx0aGVpZ2h0OiAxLjNlbTtcblx0XHRcdGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMCk7XG5cdFx0XHRib3JkZXItcmFkaXVzOiA1MCU7XG5cdFx0XHR2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuXHRcdFx0Ym9yZGVyOiAxcHggc29saWQgcmdiKDE3MCwgMTY4LCAxNjgpO1xuXHRcdFx0LXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xuXHRcdFx0b3V0bGluZTogbm9uZTtcblx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHRcdG9wYWNpdHk6IDAuMztcblx0XHR9XG5cblx0XHQuY2hlY2tib3gtcm91bmQ6Y2hlY2tlZCB7XG5cdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiBncmF5O1xuXHRcdH1cblxuXHRcdC5hcHBsZS1yZW1pbmRlci1uYW1lIHtcblx0XHRcdHBhZGRpbmctbGVmdDogMXJlbTtcblx0XHR9XG5cblx0XHQuYXBwbGUtcmVtaW5kZXItZHVlLWRhdGUge1xuXHRcdFx0b3BhY2l0eTogMC4zO1xuXHRcdFx0cGFkZGluZy1sZWZ0OiA0ZW07XG5cdFx0fVxuXHRcdC5hcHBsZS1yZW1pbmRlci1jb250YWluZXIge1xuXHRcdFx0cGFkZGluZzogMDtcblx0XHRcdG1hcmdpbjogMDtcblx0XHR9XG5cdFx0LmFwcGxlLXJlbWluZGVyLXByaW9yaXR5IHtcblx0XHRcdGNvbG9yOiByZWQ7XG5cdFx0fVxuXHRcdC5hcHBsZS1yZW1pbmRlci1ub3RlIHtcblx0XHRcdG9wYWNpdHk6IDAuMztcblx0XHRcdHBhZGRpbmctbGVmdDogNGVtO1xuXHRcdH1cblx0XHQuYXBwbGUtbGlzdC1icmVhayB7XG5cdFx0XHRtYXJnaW46IDA7XG5cdFx0fVxuXG5cdFx0LmFwcGxlLWxpc3QtcmVtaW5kZXItYnJlYWstbGluZSB7XG5cdFx0XHRtYXJnaW4tbGVmdDogMmVtO1xuXHRcdFx0bWFyZ2luLXRvcDogMC41ZW07XG5cdFx0XHRtYXJnaW4tYm90dG9tOiAwLjVlbTtcblx0XHRcdHBhZGRpbmc6IDA7XG5cdFx0XHRoZWlnaHQ6IDAuNXB4O1xuXHRcdFx0b3BhY2l0eTogMC4yO1xuXHRcdH1cblx0YDtcblxuXHRvbkNoZWNrYm94Q2hhbmdlKGV2ZW50OiBhbnkpIHtcblx0XHRSZW1pbmRlcnNEYXRhU2VydmljZS50b2dnbGVSZW1pbmRlckRvbmVTdGF0dXModGhpcy5saXN0X25hbWUsIHRoaXMubW9kZWwubmFtZSkudGhlbihyZW0gPT4ge1xuXHRcdFx0dGhpcy5tb2RlbCA9IHJlbTtcblx0XHR9KTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gaHRtbGBcblx0XHRcdDxzcGFuIGNsYXNzPVwiYXBwbGUtcmVtaW5kZXItY29udGFpbmVyXCI+XG5cdFx0XHRcdDxpbnB1dFxuXHRcdFx0XHRcdHR5cGU9XCJjaGVja2JveFwiXG5cdFx0XHRcdFx0Y2xhc3M9XCJjaGVja2JveC1yb3VuZFwiXG5cdFx0XHRcdFx0QGNoYW5nZT0ke3RoaXMub25DaGVja2JveENoYW5nZX1cblx0XHRcdFx0XHQ/Y2hlY2tlZD0ke3RoaXMubW9kZWwuY29tcGxldGVkfSAvPlxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImFwcGxlLXJlbWluZGVyLWZpZWxkc1wiPlxuXHRcdFx0XHRcdCR7KHRoaXMubW9kZWwucHJpb3JpdHkgJiYgdGhpcy5tb2RlbC5wcmlvcml0eSA+IDApID9cblx0XHRcdFx0aHRtbGBcblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJhcHBsZS1yZW1pbmRlci1wcmlvcml0eVwiPlxuXHRcdFx0XHRcdFx0XHRcdCR7QXJyYXkuZnJvbShBcnJheShNYXRoLmNlaWwoKDEwIC0gdGhpcy5tb2RlbC5wcmlvcml0eSkgLyAzKSkua2V5cygpKS5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHByZXYgKyAnIScsIFwiXCIpfVxuXHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRgOiBcIlwiXG5cdFx0XHR9XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJhcHBsZS1yZW1pbmRlci1uYW1lXCI+ICR7dGhpcy5tb2RlbC5uYW1lfSA8L3NwYW4+XG5cdFx0XHRcdFx0JHsodGhpcy5tb2RlbC5ib2R5ICYmIHRoaXMubW9kZWwuYm9keSAhPSAnbWlzc2luZyB2YWx1ZScpID9cblx0XHRcdFx0aHRtbGA8YnIgLz48c21hbGwgY2xhc3M9XCJhcHBsZS1yZW1pbmRlci1ub3RlXCI+JHt0aGlzLm1vZGVsLmJvZHl9PC9zbWFsbD5gXG5cdFx0XHRcdDogXCJcIlxuXHRcdFx0fVxuXHRcdFx0XHRcdCR7KHRoaXMubW9kZWxbJ2R1ZSBkYXRlJ10gJiYgdGhpcy5tb2RlbFsnZHVlIGRhdGUnXSAhPSAnbWlzc2luZyB2YWx1ZScpID9cblx0XHRcdFx0aHRtbGA8YnIgLz48c21hbGwgY2xhc3M9XCJhcHBsZS1yZW1pbmRlci1kdWUtZGF0ZVwiPiR7bW9tZW50KHRoaXMubW9kZWxbJ2R1ZSBkYXRlJ10sIEFQUExFX0RBVEVfRk9STUFUKS5mb3JtYXQoJ1xcdCBZWVlZL01NL0RELCBoaDptbSBhIChaKScpfTwvc21hbGw+YFxuXHRcdFx0XHQ6IFwiXCJcblx0XHRcdH1cblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdFx0PGJyIGNsYXNzPVwiYXBwbGUtbGlzdC1icmVha1wiLz5cblx0XHRcdFx0XHRcdFx0XHRcdDxociBjbGFzcz1cImFwcGxlLWxpc3QtcmVtaW5kZXItYnJlYWstbGluZVwiIC8+XG5cdFx0YDtcblx0fVxuXG5cbn1cbiIsICJpbXBvcnQgeyBMaXRFbGVtZW50LCBodG1sLCBjc3MsIENTU1Jlc3VsdEdyb3VwIH0gZnJvbSAnbGl0JztcbmltcG9ydCB7IGN1c3RvbUVsZW1lbnQsIHByb3BlcnR5IH0gZnJvbSAnbGl0L2RlY29yYXRvcnMuanMnO1xuaW1wb3J0IHsgQXBwbGVSZW1pbmRlclNwZWMsIExpc3RNb2RlbCwgUmVtaW5kZXJNb2RlbCB9IGZyb20gJ3NyYy9tb2RlbHMvc2hhcmVkLm1vZGVscyc7XG5pbXBvcnQgeyBSZW1pbmRlcnNEYXRhU2VydmljZSB9IGZyb20gJ3NyYy9kYXRhL3JlbWluZGVycy1kYXRhLnNlcnZpY2UnO1xuaW1wb3J0IHsgTG9hZGluZ0JhckNvbXBvbmVudCB9IGZyb20gJy4vbG9hZGluZy1iYXIuZWxlbWVudCc7XG5pbXBvcnQgeyBSZW1pbmRlckVsZW1lbnQgfSBmcm9tICcuL3JlbWluZGVyLmVsZW1lbnQnO1xuXG5AY3VzdG9tRWxlbWVudCgnYXBwbGUtbGlzdC1lbGVtZW50JylcbmV4cG9ydCBjbGFzcyBMaXN0RWxlbWVudCBleHRlbmRzIExpdEVsZW1lbnQge1xuXG5cdEBwcm9wZXJ0eSgpIHNwZWM6IEFwcGxlUmVtaW5kZXJTcGVjO1xuXG5cdEBwcm9wZXJ0eSgpIHJlZnJlc2hEaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG5cdEBwcm9wZXJ0eSgpIHJlbWluZGVyczogUmVtaW5kZXJNb2RlbFtdID0gW107XG5cdEBwcm9wZXJ0eSgpIGxpc3RNZXRhOiBMaXN0TW9kZWw7XG5cblx0cHJpdmF0ZSByZWFkb25seSBsb2FkaW5nQmFyID0gbmV3IExvYWRpbmdCYXJDb21wb25lbnQoKTtcblxuXHRnZXQgZWxlbWVudHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVtaW5kZXJzLm1hcCgocmVtKSA9PiB7XG5cdFx0XHRsZXQgZWwgPSBuZXcgUmVtaW5kZXJFbGVtZW50KCk7XG5cdFx0XHRlbC5tb2RlbCA9IHJlbTtcblx0XHRcdGVsLmxpc3RfbmFtZSA9IHRoaXMubGlzdE1ldGEubmFtZTtcblx0XHRcdHJldHVybiBlbDtcblx0XHR9KTtcblx0fVxuXG5cdGNvbnN0cnVjdG9yKF9zcGVjOiBBcHBsZVJlbWluZGVyU3BlYykge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5zcGVjID0gX3NwZWM7XG5cdH1cblxuXHRzdGF0aWMgc3R5bGVzPzogQ1NTUmVzdWx0R3JvdXAgfCB1bmRlZmluZWQgPSBjc3NgXG5cdFx0LmFwcGxlLWxpc3QtcmVtaW5kZXJzIHtcblx0XHRcdG1hcmdpbjogMDtcblx0XHRcdHBhZGRpbmc6IDA7XG5cdFx0fVxuXG5cdFx0LmFwcGxlLWxpc3QtdG9wLXJ1bGUsXG5cdFx0LmFwcGxlLWxpc3QtYm90dG9tLXJ1bGUge1xuXHRcdFx0b3BhY2l0eTogMDtcblx0XHR9XG5cdGA7XG5cblx0cmVmcmVzaCgpIHtcblx0XHR0aGlzLnJlZnJlc2hEaXNhYmxlZCA9IHRydWU7XG5cdFx0UmVtaW5kZXJzRGF0YVNlcnZpY2UuZmV0Y2hEYXRhKHRoaXMuc3BlYykudGhlbigoW2xpc3REYXRhLCByZW1pbmRlcnNdKSA9PiB7XG5cdFx0XHR0aGlzLmxpc3RNZXRhID0gbGlzdERhdGE7XG5cdFx0XHR0aGlzLnJlbWluZGVycyA9IHJlbWluZGVycztcblx0XHRcdHRoaXMucmVmcmVzaERpc2FibGVkID0gZmFsc2U7XG5cdFx0fSlcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gaHRtbGBcblx0XHRcdDxkaXYgY2xhc3M9XCJhcHBsZS1saXN0LWNvbnRhaW5lclwiPlxuXHRcdFx0XHQ8aHIgY2xhc3M9XCJhcHBsZS1saXN0LXRvcC1ydWxlXCIgLz5cblx0XHRcdFx0PGgyPlxuXHRcdFx0XHRcdDxzcGFuXG5cdFx0XHRcdFx0XHRzdHlsZT1cImNvbG9yOiAke3RoaXMubGlzdE1ldGE/LmNvbG9yfVwiPiR7KCF0aGlzLmxpc3RNZXRhPy5uYW1lKT8gdGhpcy5zcGVjPy5saXN0OiB0aGlzLmxpc3RNZXRhLm5hbWV9PC9zcGFuPlxuXHRcdFx0XHQ8L2gyPlxuXG5cdFx0XHRcdCR7KHRoaXMubGlzdE1ldGEpID8gaHRtbGBcblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImFwcGxlLWxpc3QtcmVtaW5kZXJzXCI+XG5cdFx0XHRcdFx0XHQkeyh0aGlzLmVsZW1lbnRzLmxlbmd0aCA+IDApPyB0aGlzLmVsZW1lbnRzOiBodG1sYDxzbWFsbCBzdHlsZT1cInBhZGRpbmctYm90dG9tOiAxcmVtO1wiPk5vIHJlbWluZGVycyBmb3VuZDwvc21hbGw+YH1cblx0XHRcdFx0XHQ8L3NwYW4+XG5cblx0XHRcdFx0YFxuXHRcdFx0XHRcdDogdGhpcy5sb2FkaW5nQmFyXG5cdFx0XHRcdH1cblx0XHRcdFx0PGJyIC8+XG5cdFx0XHRcdDxidXR0b24gQGNsaWNrPVwiJHt0aGlzLnJlZnJlc2h9XCIgP2Rpc2FibGVkPVwiJHt0aGlzLnJlZnJlc2hEaXNhYmxlZH1cIj5SZWZyZXNoPC9idXR0b24+XG5cdFx0XHRcdDxociBjbGFzcz1cImFwcGxlLWxpc3QtYm90dG9tLXJ1bGVcIiAvPlxuXHRcdFx0PC9kaXY+XG5cdFx0YDtcblx0fVxufVxuIiwgImNvbnN0IEFMSUFTID0gU3ltYm9sLmZvcigneWFtbC5hbGlhcycpO1xuY29uc3QgRE9DID0gU3ltYm9sLmZvcigneWFtbC5kb2N1bWVudCcpO1xuY29uc3QgTUFQID0gU3ltYm9sLmZvcigneWFtbC5tYXAnKTtcbmNvbnN0IFBBSVIgPSBTeW1ib2wuZm9yKCd5YW1sLnBhaXInKTtcbmNvbnN0IFNDQUxBUiA9IFN5bWJvbC5mb3IoJ3lhbWwuc2NhbGFyJyk7XG5jb25zdCBTRVEgPSBTeW1ib2wuZm9yKCd5YW1sLnNlcScpO1xuY29uc3QgTk9ERV9UWVBFID0gU3ltYm9sLmZvcigneWFtbC5ub2RlLnR5cGUnKTtcbmNvbnN0IGlzQWxpYXMgPSAobm9kZSkgPT4gISFub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiBub2RlW05PREVfVFlQRV0gPT09IEFMSUFTO1xuY29uc3QgaXNEb2N1bWVudCA9IChub2RlKSA9PiAhIW5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGVbTk9ERV9UWVBFXSA9PT0gRE9DO1xuY29uc3QgaXNNYXAgPSAobm9kZSkgPT4gISFub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiBub2RlW05PREVfVFlQRV0gPT09IE1BUDtcbmNvbnN0IGlzUGFpciA9IChub2RlKSA9PiAhIW5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGVbTk9ERV9UWVBFXSA9PT0gUEFJUjtcbmNvbnN0IGlzU2NhbGFyID0gKG5vZGUpID0+ICEhbm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZVtOT0RFX1RZUEVdID09PSBTQ0FMQVI7XG5jb25zdCBpc1NlcSA9IChub2RlKSA9PiAhIW5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGVbTk9ERV9UWVBFXSA9PT0gU0VRO1xuZnVuY3Rpb24gaXNDb2xsZWN0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcpXG4gICAgICAgIHN3aXRjaCAobm9kZVtOT0RFX1RZUEVdKSB7XG4gICAgICAgICAgICBjYXNlIE1BUDpcbiAgICAgICAgICAgIGNhc2UgU0VROlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNOb2RlKG5vZGUpIHtcbiAgICBpZiAobm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcpXG4gICAgICAgIHN3aXRjaCAobm9kZVtOT0RFX1RZUEVdKSB7XG4gICAgICAgICAgICBjYXNlIEFMSUFTOlxuICAgICAgICAgICAgY2FzZSBNQVA6XG4gICAgICAgICAgICBjYXNlIFNDQUxBUjpcbiAgICAgICAgICAgIGNhc2UgU0VROlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3QgaGFzQW5jaG9yID0gKG5vZGUpID0+IChpc1NjYWxhcihub2RlKSB8fCBpc0NvbGxlY3Rpb24obm9kZSkpICYmICEhbm9kZS5hbmNob3I7XG5jbGFzcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IodHlwZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgTk9ERV9UWVBFLCB7IHZhbHVlOiB0eXBlIH0pO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlIGEgY29weSBvZiB0aGlzIG5vZGUuICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRoaXMpKTtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2UpXG4gICAgICAgICAgICBjb3B5LnJhbmdlID0gdGhpcy5yYW5nZS5zbGljZSgpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEFMSUFTLCBET0MsIE1BUCwgTk9ERV9UWVBFLCBOb2RlQmFzZSwgUEFJUiwgU0NBTEFSLCBTRVEsIGhhc0FuY2hvciwgaXNBbGlhcywgaXNDb2xsZWN0aW9uLCBpc0RvY3VtZW50LCBpc01hcCwgaXNOb2RlLCBpc1BhaXIsIGlzU2NhbGFyLCBpc1NlcSB9O1xuIiwgImltcG9ydCB7IGlzRG9jdW1lbnQsIGlzTm9kZSwgaXNQYWlyLCBpc0NvbGxlY3Rpb24sIGlzTWFwLCBpc1NlcSwgaXNTY2FsYXIsIGlzQWxpYXMgfSBmcm9tICcuL25vZGVzL05vZGUuanMnO1xuXG5jb25zdCBCUkVBSyA9IFN5bWJvbCgnYnJlYWsgdmlzaXQnKTtcbmNvbnN0IFNLSVAgPSBTeW1ib2woJ3NraXAgY2hpbGRyZW4nKTtcbmNvbnN0IFJFTU9WRSA9IFN5bWJvbCgncmVtb3ZlIG5vZGUnKTtcbi8qKlxuICogQXBwbHkgYSB2aXNpdG9yIHRvIGFuIEFTVCBub2RlIG9yIGRvY3VtZW50LlxuICpcbiAqIFdhbGtzIHRocm91Z2ggdGhlIHRyZWUgKGRlcHRoLWZpcnN0KSBzdGFydGluZyBmcm9tIGBub2RlYCwgY2FsbGluZyBhXG4gKiBgdmlzaXRvcmAgZnVuY3Rpb24gd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAgIC0gYGtleWA6IEZvciBzZXF1ZW5jZSB2YWx1ZXMgYW5kIG1hcCBgUGFpcmAsIHRoZSBub2RlJ3MgaW5kZXggaW4gdGhlXG4gKiAgICAgY29sbGVjdGlvbi4gV2l0aGluIGEgYFBhaXJgLCBgJ2tleSdgIG9yIGAndmFsdWUnYCwgY29ycmVzcG9uZGluZ2x5LlxuICogICAgIGBudWxsYCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAqICAgLSBgbm9kZWA6IFRoZSBjdXJyZW50IG5vZGUuXG4gKiAgIC0gYHBhdGhgOiBUaGUgYW5jZXN0cnkgb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSB2aXNpdG9yIG1heSBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIHRyYXZlcnNhbDpcbiAqICAgLSBgdW5kZWZpbmVkYCAoZGVmYXVsdCk6IERvIG5vdGhpbmcgYW5kIGNvbnRpbnVlXG4gKiAgIC0gYHZpc2l0LlNLSVBgOiBEbyBub3QgdmlzaXQgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgY29udGludWUgd2l0aCBuZXh0XG4gKiAgICAgc2libGluZ1xuICogICAtIGB2aXNpdC5CUkVBS2A6IFRlcm1pbmF0ZSB0cmF2ZXJzYWwgY29tcGxldGVseVxuICogICAtIGB2aXNpdC5SRU1PVkVgOiBSZW1vdmUgdGhlIGN1cnJlbnQgbm9kZSwgdGhlbiBjb250aW51ZSB3aXRoIHRoZSBuZXh0IG9uZVxuICogICAtIGBOb2RlYDogUmVwbGFjZSB0aGUgY3VycmVudCBub2RlLCB0aGVuIGNvbnRpbnVlIGJ5IHZpc2l0aW5nIGl0XG4gKiAgIC0gYG51bWJlcmA6IFdoaWxlIGl0ZXJhdGluZyB0aGUgaXRlbXMgb2YgYSBzZXF1ZW5jZSBvciBtYXAsIHNldCB0aGUgaW5kZXhcbiAqICAgICBvZiB0aGUgbmV4dCBzdGVwLiBUaGlzIGlzIHVzZWZ1bCBlc3BlY2lhbGx5IGlmIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudFxuICogICAgIG5vZGUgaGFzIGNoYW5nZWQuXG4gKlxuICogSWYgYHZpc2l0b3JgIGlzIGEgc2luZ2xlIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFsbCB2YWx1ZXNcbiAqIGVuY291bnRlcmVkIGluIHRoZSB0cmVlLCBpbmNsdWRpbmcgZS5nLiBgbnVsbGAgdmFsdWVzLiBBbHRlcm5hdGl2ZWx5LFxuICogc2VwYXJhdGUgdmlzaXRvciBmdW5jdGlvbnMgbWF5IGJlIGRlZmluZWQgZm9yIGVhY2ggYE1hcGAsIGBQYWlyYCwgYFNlcWAsXG4gKiBgQWxpYXNgIGFuZCBgU2NhbGFyYCBub2RlLiBUbyBkZWZpbmUgdGhlIHNhbWUgdmlzaXRvciBmdW5jdGlvbiBmb3IgbW9yZSB0aGFuXG4gKiBvbmUgbm9kZSB0eXBlLCB1c2UgdGhlIGBDb2xsZWN0aW9uYCAobWFwIGFuZCBzZXEpLCBgVmFsdWVgIChtYXAsIHNlcSAmIHNjYWxhcilcbiAqIGFuZCBgTm9kZWAgKGFsaWFzLCBtYXAsIHNlcSAmIHNjYWxhcikgdGFyZ2V0cy4gT2YgYWxsIHRoZXNlLCBvbmx5IHRoZSBtb3N0XG4gKiBzcGVjaWZpYyBkZWZpbmVkIG9uZSB3aWxsIGJlIHVzZWQgZm9yIGVhY2ggbm9kZS5cbiAqL1xuZnVuY3Rpb24gdmlzaXQobm9kZSwgdmlzaXRvcikge1xuICAgIGNvbnN0IHZpc2l0b3JfID0gaW5pdFZpc2l0b3IodmlzaXRvcik7XG4gICAgaWYgKGlzRG9jdW1lbnQobm9kZSkpIHtcbiAgICAgICAgY29uc3QgY2QgPSB2aXNpdF8obnVsbCwgbm9kZS5jb250ZW50cywgdmlzaXRvcl8sIE9iamVjdC5mcmVlemUoW25vZGVdKSk7XG4gICAgICAgIGlmIChjZCA9PT0gUkVNT1ZFKVxuICAgICAgICAgICAgbm9kZS5jb250ZW50cyA9IG51bGw7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgdmlzaXRfKG51bGwsIG5vZGUsIHZpc2l0b3JfLCBPYmplY3QuZnJlZXplKFtdKSk7XG59XG4vLyBXaXRob3V0IHRoZSBgYXMgc3ltYm9sYCBjYXN0cywgVFMgZGVjbGFyZXMgdGhlc2UgaW4gdGhlIGB2aXNpdGBcbi8vIG5hbWVzcGFjZSB1c2luZyBgdmFyYCwgYnV0IHRoZW4gY29tcGxhaW5zIGFib3V0IHRoYXQgYmVjYXVzZVxuLy8gYHVuaXF1ZSBzeW1ib2xgIG11c3QgYmUgYGNvbnN0YC5cbi8qKiBUZXJtaW5hdGUgdmlzaXQgdHJhdmVyc2FsIGNvbXBsZXRlbHkgKi9cbnZpc2l0LkJSRUFLID0gQlJFQUs7XG4vKiogRG8gbm90IHZpc2l0IHRoZSBjaGlsZHJlbiBvZiB0aGUgY3VycmVudCBub2RlICovXG52aXNpdC5TS0lQID0gU0tJUDtcbi8qKiBSZW1vdmUgdGhlIGN1cnJlbnQgbm9kZSAqL1xudmlzaXQuUkVNT1ZFID0gUkVNT1ZFO1xuZnVuY3Rpb24gdmlzaXRfKGtleSwgbm9kZSwgdmlzaXRvciwgcGF0aCkge1xuICAgIGNvbnN0IGN0cmwgPSBjYWxsVmlzaXRvcihrZXksIG5vZGUsIHZpc2l0b3IsIHBhdGgpO1xuICAgIGlmIChpc05vZGUoY3RybCkgfHwgaXNQYWlyKGN0cmwpKSB7XG4gICAgICAgIHJlcGxhY2VOb2RlKGtleSwgcGF0aCwgY3RybCk7XG4gICAgICAgIHJldHVybiB2aXNpdF8oa2V5LCBjdHJsLCB2aXNpdG9yLCBwYXRoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjdHJsICE9PSAnc3ltYm9sJykge1xuICAgICAgICBpZiAoaXNDb2xsZWN0aW9uKG5vZGUpKSB7XG4gICAgICAgICAgICBwYXRoID0gT2JqZWN0LmZyZWV6ZShwYXRoLmNvbmNhdChub2RlKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaSA9IHZpc2l0XyhpLCBub2RlLml0ZW1zW2ldLCB2aXNpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNpID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgaSA9IGNpIC0gMTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaSA9PT0gQlJFQUspXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCUkVBSztcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaSA9PT0gUkVNT1ZFKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaXRlbXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGFpcihub2RlKSkge1xuICAgICAgICAgICAgcGF0aCA9IE9iamVjdC5mcmVlemUocGF0aC5jb25jYXQobm9kZSkpO1xuICAgICAgICAgICAgY29uc3QgY2sgPSB2aXNpdF8oJ2tleScsIG5vZGUua2V5LCB2aXNpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgIGlmIChjayA9PT0gQlJFQUspXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2sgPT09IFJFTU9WRSlcbiAgICAgICAgICAgICAgICBub2RlLmtleSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBjdiA9IHZpc2l0XygndmFsdWUnLCBub2RlLnZhbHVlLCB2aXNpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgIGlmIChjdiA9PT0gQlJFQUspXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLO1xuICAgICAgICAgICAgZWxzZSBpZiAoY3YgPT09IFJFTU9WRSlcbiAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3RybDtcbn1cbi8qKlxuICogQXBwbHkgYW4gYXN5bmMgdmlzaXRvciB0byBhbiBBU1Qgbm9kZSBvciBkb2N1bWVudC5cbiAqXG4gKiBXYWxrcyB0aHJvdWdoIHRoZSB0cmVlIChkZXB0aC1maXJzdCkgc3RhcnRpbmcgZnJvbSBgbm9kZWAsIGNhbGxpbmcgYVxuICogYHZpc2l0b3JgIGZ1bmN0aW9uIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogICAtIGBrZXlgOiBGb3Igc2VxdWVuY2UgdmFsdWVzIGFuZCBtYXAgYFBhaXJgLCB0aGUgbm9kZSdzIGluZGV4IGluIHRoZVxuICogICAgIGNvbGxlY3Rpb24uIFdpdGhpbiBhIGBQYWlyYCwgYCdrZXknYCBvciBgJ3ZhbHVlJ2AsIGNvcnJlc3BvbmRpbmdseS5cbiAqICAgICBgbnVsbGAgZm9yIHRoZSByb290IG5vZGUuXG4gKiAgIC0gYG5vZGVgOiBUaGUgY3VycmVudCBub2RlLlxuICogICAtIGBwYXRoYDogVGhlIGFuY2VzdHJ5IG9mIHRoZSBjdXJyZW50IG5vZGUuXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgdmlzaXRvciBtYXkgYmUgdXNlZCB0byBjb250cm9sIHRoZSB0cmF2ZXJzYWw6XG4gKiAgIC0gYFByb21pc2VgOiBNdXN0IHJlc29sdmUgdG8gb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzXG4gKiAgIC0gYHVuZGVmaW5lZGAgKGRlZmF1bHQpOiBEbyBub3RoaW5nIGFuZCBjb250aW51ZVxuICogICAtIGB2aXNpdC5TS0lQYDogRG8gbm90IHZpc2l0IHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUsIGNvbnRpbnVlIHdpdGggbmV4dFxuICogICAgIHNpYmxpbmdcbiAqICAgLSBgdmlzaXQuQlJFQUtgOiBUZXJtaW5hdGUgdHJhdmVyc2FsIGNvbXBsZXRlbHlcbiAqICAgLSBgdmlzaXQuUkVNT1ZFYDogUmVtb3ZlIHRoZSBjdXJyZW50IG5vZGUsIHRoZW4gY29udGludWUgd2l0aCB0aGUgbmV4dCBvbmVcbiAqICAgLSBgTm9kZWA6IFJlcGxhY2UgdGhlIGN1cnJlbnQgbm9kZSwgdGhlbiBjb250aW51ZSBieSB2aXNpdGluZyBpdFxuICogICAtIGBudW1iZXJgOiBXaGlsZSBpdGVyYXRpbmcgdGhlIGl0ZW1zIG9mIGEgc2VxdWVuY2Ugb3IgbWFwLCBzZXQgdGhlIGluZGV4XG4gKiAgICAgb2YgdGhlIG5leHQgc3RlcC4gVGhpcyBpcyB1c2VmdWwgZXNwZWNpYWxseSBpZiB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnRcbiAqICAgICBub2RlIGhhcyBjaGFuZ2VkLlxuICpcbiAqIElmIGB2aXNpdG9yYCBpcyBhIHNpbmdsZSBmdW5jdGlvbiwgaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhbGwgdmFsdWVzXG4gKiBlbmNvdW50ZXJlZCBpbiB0aGUgdHJlZSwgaW5jbHVkaW5nIGUuZy4gYG51bGxgIHZhbHVlcy4gQWx0ZXJuYXRpdmVseSxcbiAqIHNlcGFyYXRlIHZpc2l0b3IgZnVuY3Rpb25zIG1heSBiZSBkZWZpbmVkIGZvciBlYWNoIGBNYXBgLCBgUGFpcmAsIGBTZXFgLFxuICogYEFsaWFzYCBhbmQgYFNjYWxhcmAgbm9kZS4gVG8gZGVmaW5lIHRoZSBzYW1lIHZpc2l0b3IgZnVuY3Rpb24gZm9yIG1vcmUgdGhhblxuICogb25lIG5vZGUgdHlwZSwgdXNlIHRoZSBgQ29sbGVjdGlvbmAgKG1hcCBhbmQgc2VxKSwgYFZhbHVlYCAobWFwLCBzZXEgJiBzY2FsYXIpXG4gKiBhbmQgYE5vZGVgIChhbGlhcywgbWFwLCBzZXEgJiBzY2FsYXIpIHRhcmdldHMuIE9mIGFsbCB0aGVzZSwgb25seSB0aGUgbW9zdFxuICogc3BlY2lmaWMgZGVmaW5lZCBvbmUgd2lsbCBiZSB1c2VkIGZvciBlYWNoIG5vZGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHZpc2l0QXN5bmMobm9kZSwgdmlzaXRvcikge1xuICAgIGNvbnN0IHZpc2l0b3JfID0gaW5pdFZpc2l0b3IodmlzaXRvcik7XG4gICAgaWYgKGlzRG9jdW1lbnQobm9kZSkpIHtcbiAgICAgICAgY29uc3QgY2QgPSBhd2FpdCB2aXNpdEFzeW5jXyhudWxsLCBub2RlLmNvbnRlbnRzLCB2aXNpdG9yXywgT2JqZWN0LmZyZWV6ZShbbm9kZV0pKTtcbiAgICAgICAgaWYgKGNkID09PSBSRU1PVkUpXG4gICAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICBhd2FpdCB2aXNpdEFzeW5jXyhudWxsLCBub2RlLCB2aXNpdG9yXywgT2JqZWN0LmZyZWV6ZShbXSkpO1xufVxuLy8gV2l0aG91dCB0aGUgYGFzIHN5bWJvbGAgY2FzdHMsIFRTIGRlY2xhcmVzIHRoZXNlIGluIHRoZSBgdmlzaXRgXG4vLyBuYW1lc3BhY2UgdXNpbmcgYHZhcmAsIGJ1dCB0aGVuIGNvbXBsYWlucyBhYm91dCB0aGF0IGJlY2F1c2Vcbi8vIGB1bmlxdWUgc3ltYm9sYCBtdXN0IGJlIGBjb25zdGAuXG4vKiogVGVybWluYXRlIHZpc2l0IHRyYXZlcnNhbCBjb21wbGV0ZWx5ICovXG52aXNpdEFzeW5jLkJSRUFLID0gQlJFQUs7XG4vKiogRG8gbm90IHZpc2l0IHRoZSBjaGlsZHJlbiBvZiB0aGUgY3VycmVudCBub2RlICovXG52aXNpdEFzeW5jLlNLSVAgPSBTS0lQO1xuLyoqIFJlbW92ZSB0aGUgY3VycmVudCBub2RlICovXG52aXNpdEFzeW5jLlJFTU9WRSA9IFJFTU9WRTtcbmFzeW5jIGZ1bmN0aW9uIHZpc2l0QXN5bmNfKGtleSwgbm9kZSwgdmlzaXRvciwgcGF0aCkge1xuICAgIGNvbnN0IGN0cmwgPSBhd2FpdCBjYWxsVmlzaXRvcihrZXksIG5vZGUsIHZpc2l0b3IsIHBhdGgpO1xuICAgIGlmIChpc05vZGUoY3RybCkgfHwgaXNQYWlyKGN0cmwpKSB7XG4gICAgICAgIHJlcGxhY2VOb2RlKGtleSwgcGF0aCwgY3RybCk7XG4gICAgICAgIHJldHVybiB2aXNpdEFzeW5jXyhrZXksIGN0cmwsIHZpc2l0b3IsIHBhdGgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGN0cmwgIT09ICdzeW1ib2wnKSB7XG4gICAgICAgIGlmIChpc0NvbGxlY3Rpb24obm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGggPSBPYmplY3QuZnJlZXplKHBhdGguY29uY2F0KG5vZGUpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNpID0gYXdhaXQgdmlzaXRBc3luY18oaSwgbm9kZS5pdGVtc1tpXSwgdmlzaXRvciwgcGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgICAgIGkgPSBjaSAtIDE7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2kgPT09IEJSRUFLKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2kgPT09IFJFTU9WRSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLml0ZW1zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BhaXIobm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGggPSBPYmplY3QuZnJlZXplKHBhdGguY29uY2F0KG5vZGUpKTtcbiAgICAgICAgICAgIGNvbnN0IGNrID0gYXdhaXQgdmlzaXRBc3luY18oJ2tleScsIG5vZGUua2V5LCB2aXNpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgIGlmIChjayA9PT0gQlJFQUspXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2sgPT09IFJFTU9WRSlcbiAgICAgICAgICAgICAgICBub2RlLmtleSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBjdiA9IGF3YWl0IHZpc2l0QXN5bmNfKCd2YWx1ZScsIG5vZGUudmFsdWUsIHZpc2l0b3IsIHBhdGgpO1xuICAgICAgICAgICAgaWYgKGN2ID09PSBCUkVBSylcbiAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICBlbHNlIGlmIChjdiA9PT0gUkVNT1ZFKVxuICAgICAgICAgICAgICAgIG5vZGUudmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdHJsO1xufVxuZnVuY3Rpb24gaW5pdFZpc2l0b3IodmlzaXRvcikge1xuICAgIGlmICh0eXBlb2YgdmlzaXRvciA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgKHZpc2l0b3IuQ29sbGVjdGlvbiB8fCB2aXNpdG9yLk5vZGUgfHwgdmlzaXRvci5WYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgQWxpYXM6IHZpc2l0b3IuTm9kZSxcbiAgICAgICAgICAgIE1hcDogdmlzaXRvci5Ob2RlLFxuICAgICAgICAgICAgU2NhbGFyOiB2aXNpdG9yLk5vZGUsXG4gICAgICAgICAgICBTZXE6IHZpc2l0b3IuTm9kZVxuICAgICAgICB9LCB2aXNpdG9yLlZhbHVlICYmIHtcbiAgICAgICAgICAgIE1hcDogdmlzaXRvci5WYWx1ZSxcbiAgICAgICAgICAgIFNjYWxhcjogdmlzaXRvci5WYWx1ZSxcbiAgICAgICAgICAgIFNlcTogdmlzaXRvci5WYWx1ZVxuICAgICAgICB9LCB2aXNpdG9yLkNvbGxlY3Rpb24gJiYge1xuICAgICAgICAgICAgTWFwOiB2aXNpdG9yLkNvbGxlY3Rpb24sXG4gICAgICAgICAgICBTZXE6IHZpc2l0b3IuQ29sbGVjdGlvblxuICAgICAgICB9LCB2aXNpdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHZpc2l0b3I7XG59XG5mdW5jdGlvbiBjYWxsVmlzaXRvcihrZXksIG5vZGUsIHZpc2l0b3IsIHBhdGgpIHtcbiAgICBpZiAodHlwZW9mIHZpc2l0b3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aXNpdG9yKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgaWYgKGlzTWFwKG5vZGUpKVxuICAgICAgICByZXR1cm4gdmlzaXRvci5NYXA/LihrZXksIG5vZGUsIHBhdGgpO1xuICAgIGlmIChpc1NlcShub2RlKSlcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuU2VxPy4oa2V5LCBub2RlLCBwYXRoKTtcbiAgICBpZiAoaXNQYWlyKG5vZGUpKVxuICAgICAgICByZXR1cm4gdmlzaXRvci5QYWlyPy4oa2V5LCBub2RlLCBwYXRoKTtcbiAgICBpZiAoaXNTY2FsYXIobm9kZSkpXG4gICAgICAgIHJldHVybiB2aXNpdG9yLlNjYWxhcj8uKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgaWYgKGlzQWxpYXMobm9kZSkpXG4gICAgICAgIHJldHVybiB2aXNpdG9yLkFsaWFzPy4oa2V5LCBub2RlLCBwYXRoKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gcmVwbGFjZU5vZGUoa2V5LCBwYXRoLCBub2RlKSB7XG4gICAgY29uc3QgcGFyZW50ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIGlmIChpc0NvbGxlY3Rpb24ocGFyZW50KSkge1xuICAgICAgICBwYXJlbnQuaXRlbXNba2V5XSA9IG5vZGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGFpcihwYXJlbnQpKSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdrZXknKVxuICAgICAgICAgICAgcGFyZW50LmtleSA9IG5vZGU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHBhcmVudC52YWx1ZSA9IG5vZGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRG9jdW1lbnQocGFyZW50KSkge1xuICAgICAgICBwYXJlbnQuY29udGVudHMgPSBub2RlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcHQgPSBpc0FsaWFzKHBhcmVudCkgPyAnYWxpYXMnIDogJ3NjYWxhcic7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlcGxhY2Ugbm9kZSB3aXRoICR7cHR9IHBhcmVudGApO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgdmlzaXQsIHZpc2l0QXN5bmMgfTtcbiIsICJpbXBvcnQgeyBpc05vZGUgfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IHZpc2l0IH0gZnJvbSAnLi4vdmlzaXQuanMnO1xuXG5jb25zdCBlc2NhcGVDaGFycyA9IHtcbiAgICAnISc6ICclMjEnLFxuICAgICcsJzogJyUyQycsXG4gICAgJ1snOiAnJTVCJyxcbiAgICAnXSc6ICclNUQnLFxuICAgICd7JzogJyU3QicsXG4gICAgJ30nOiAnJTdEJ1xufTtcbmNvbnN0IGVzY2FwZVRhZ05hbWUgPSAodG4pID0+IHRuLnJlcGxhY2UoL1shLFtcXF17fV0vZywgY2ggPT4gZXNjYXBlQ2hhcnNbY2hdKTtcbmNsYXNzIERpcmVjdGl2ZXMge1xuICAgIGNvbnN0cnVjdG9yKHlhbWwsIHRhZ3MpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaXJlY3RpdmVzLWVuZC9kb2Mtc3RhcnQgbWFya2VyIGAtLS1gLiBJZiBgbnVsbGAsIGEgbWFya2VyIG1heSBzdGlsbCBiZVxuICAgICAgICAgKiBpbmNsdWRlZCBpbiB0aGUgZG9jdW1lbnQncyBzdHJpbmdpZmllZCByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZG9jU3RhcnQgPSBudWxsO1xuICAgICAgICAvKiogVGhlIGRvYy1lbmQgbWFya2VyIGAuLi5gLiAgKi9cbiAgICAgICAgdGhpcy5kb2NFbmQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy55YW1sID0gT2JqZWN0LmFzc2lnbih7fSwgRGlyZWN0aXZlcy5kZWZhdWx0WWFtbCwgeWFtbCk7XG4gICAgICAgIHRoaXMudGFncyA9IE9iamVjdC5hc3NpZ24oe30sIERpcmVjdGl2ZXMuZGVmYXVsdFRhZ3MsIHRhZ3MpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgY29weSA9IG5ldyBEaXJlY3RpdmVzKHRoaXMueWFtbCwgdGhpcy50YWdzKTtcbiAgICAgICAgY29weS5kb2NTdGFydCA9IHRoaXMuZG9jU3RhcnQ7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEdXJpbmcgcGFyc2luZywgZ2V0IGEgRGlyZWN0aXZlcyBpbnN0YW5jZSBmb3IgdGhlIGN1cnJlbnQgZG9jdW1lbnQgYW5kXG4gICAgICogdXBkYXRlIHRoZSBzdHJlYW0gc3RhdGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHZlcnNpb24ncyBzcGVjLlxuICAgICAqL1xuICAgIGF0RG9jdW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBEaXJlY3RpdmVzKHRoaXMueWFtbCwgdGhpcy50YWdzKTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnlhbWwudmVyc2lvbikge1xuICAgICAgICAgICAgY2FzZSAnMS4xJzpcbiAgICAgICAgICAgICAgICB0aGlzLmF0TmV4dERvY3VtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJzEuMic6XG4gICAgICAgICAgICAgICAgdGhpcy5hdE5leHREb2N1bWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMueWFtbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZXhwbGljaXQ6IERpcmVjdGl2ZXMuZGVmYXVsdFlhbWwuZXhwbGljaXQsXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb246ICcxLjInXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBEaXJlY3RpdmVzLmRlZmF1bHRUYWdzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25FcnJvciAtIE1heSBiZSBjYWxsZWQgZXZlbiBpZiB0aGUgYWN0aW9uIHdhcyBzdWNjZXNzZnVsXG4gICAgICogQHJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3NcbiAgICAgKi9cbiAgICBhZGQobGluZSwgb25FcnJvcikge1xuICAgICAgICBpZiAodGhpcy5hdE5leHREb2N1bWVudCkge1xuICAgICAgICAgICAgdGhpcy55YW1sID0geyBleHBsaWNpdDogRGlyZWN0aXZlcy5kZWZhdWx0WWFtbC5leHBsaWNpdCwgdmVyc2lvbjogJzEuMScgfTtcbiAgICAgICAgICAgIHRoaXMudGFncyA9IE9iamVjdC5hc3NpZ24oe30sIERpcmVjdGl2ZXMuZGVmYXVsdFRhZ3MpO1xuICAgICAgICAgICAgdGhpcy5hdE5leHREb2N1bWVudCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRzID0gbGluZS50cmltKCkuc3BsaXQoL1sgXFx0XSsvKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnJVRBRyc6IHtcbiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoMCwgJyVUQUcgZGlyZWN0aXZlIHNob3VsZCBjb250YWluIGV4YWN0bHkgdHdvIHBhcnRzJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPCAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBbaGFuZGxlLCBwcmVmaXhdID0gcGFydHM7XG4gICAgICAgICAgICAgICAgdGhpcy50YWdzW2hhbmRsZV0gPSBwcmVmaXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICclWUFNTCc6IHtcbiAgICAgICAgICAgICAgICB0aGlzLnlhbWwuZXhwbGljaXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcigwLCAnJVlBTUwgZGlyZWN0aXZlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHBhcnQnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBbdmVyc2lvbl0gPSBwYXJ0cztcbiAgICAgICAgICAgICAgICBpZiAodmVyc2lvbiA9PT0gJzEuMScgfHwgdmVyc2lvbiA9PT0gJzEuMicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55YW1sLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSAvXlxcZCtcXC5cXGQrJC8udGVzdCh2ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcig2LCBgVW5zdXBwb3J0ZWQgWUFNTCB2ZXJzaW9uICR7dmVyc2lvbn1gLCBpc1ZhbGlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgb25FcnJvcigwLCBgVW5rbm93biBkaXJlY3RpdmUgJHtuYW1lfWAsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyBhIHRhZywgbWF0Y2hpbmcgaGFuZGxlcyB0byB0aG9zZSBkZWZpbmVkIGluICVUQUcgZGlyZWN0aXZlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFJlc29sdmVkIHRhZywgd2hpY2ggbWF5IGFsc28gYmUgdGhlIG5vbi1zcGVjaWZpYyB0YWcgYCchJ2Agb3IgYVxuICAgICAqICAgYCchbG9jYWwnYCB0YWcsIG9yIGBudWxsYCBpZiB1bnJlc29sdmFibGUuXG4gICAgICovXG4gICAgdGFnTmFtZShzb3VyY2UsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gJyEnKVxuICAgICAgICAgICAgcmV0dXJuICchJzsgLy8gbm9uLXNwZWNpZmljIHRhZ1xuICAgICAgICBpZiAoc291cmNlWzBdICE9PSAnIScpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoYE5vdCBhIHZhbGlkIHRhZzogJHtzb3VyY2V9YCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlWzFdID09PSAnPCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHZlcmJhdGltID0gc291cmNlLnNsaWNlKDIsIC0xKTtcbiAgICAgICAgICAgIGlmICh2ZXJiYXRpbSA9PT0gJyEnIHx8IHZlcmJhdGltID09PSAnISEnKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcihgVmVyYmF0aW0gdGFncyBhcmVuJ3QgcmVzb2x2ZWQsIHNvICR7c291cmNlfSBpcyBpbnZhbGlkLmApO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvdXJjZVtzb3VyY2UubGVuZ3RoIC0gMV0gIT09ICc+JylcbiAgICAgICAgICAgICAgICBvbkVycm9yKCdWZXJiYXRpbSB0YWdzIG11c3QgZW5kIHdpdGggYSA+Jyk7XG4gICAgICAgICAgICByZXR1cm4gdmVyYmF0aW07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgWywgaGFuZGxlLCBzdWZmaXhdID0gc291cmNlLm1hdGNoKC9eKC4qISkoW14hXSopJC8pO1xuICAgICAgICBpZiAoIXN1ZmZpeClcbiAgICAgICAgICAgIG9uRXJyb3IoYFRoZSAke3NvdXJjZX0gdGFnIGhhcyBubyBzdWZmaXhgKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gdGhpcy50YWdzW2hhbmRsZV07XG4gICAgICAgIGlmIChwcmVmaXgpXG4gICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgZGVjb2RlVVJJQ29tcG9uZW50KHN1ZmZpeCk7XG4gICAgICAgIGlmIChoYW5kbGUgPT09ICchJylcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7IC8vIGxvY2FsIHRhZ1xuICAgICAgICBvbkVycm9yKGBDb3VsZCBub3QgcmVzb2x2ZSB0YWc6ICR7c291cmNlfWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBmdWxseSByZXNvbHZlZCB0YWcsIHJldHVybnMgaXRzIHByaW50YWJsZSBzdHJpbmcgZm9ybSxcbiAgICAgKiB0YWtpbmcgaW50byBhY2NvdW50IGN1cnJlbnQgdGFnIHByZWZpeGVzIGFuZCBkZWZhdWx0cy5cbiAgICAgKi9cbiAgICB0YWdTdHJpbmcodGFnKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2hhbmRsZSwgcHJlZml4XSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnRhZ3MpKSB7XG4gICAgICAgICAgICBpZiAodGFnLnN0YXJ0c1dpdGgocHJlZml4KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlICsgZXNjYXBlVGFnTmFtZSh0YWcuc3Vic3RyaW5nKHByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFnWzBdID09PSAnIScgPyB0YWcgOiBgITwke3RhZ30+YDtcbiAgICB9XG4gICAgdG9TdHJpbmcoZG9jKSB7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gdGhpcy55YW1sLmV4cGxpY2l0XG4gICAgICAgICAgICA/IFtgJVlBTUwgJHt0aGlzLnlhbWwudmVyc2lvbiB8fCAnMS4yJ31gXVxuICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgY29uc3QgdGFnRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHRoaXMudGFncyk7XG4gICAgICAgIGxldCB0YWdOYW1lcztcbiAgICAgICAgaWYgKGRvYyAmJiB0YWdFbnRyaWVzLmxlbmd0aCA+IDAgJiYgaXNOb2RlKGRvYy5jb250ZW50cykpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZ3MgPSB7fTtcbiAgICAgICAgICAgIHZpc2l0KGRvYy5jb250ZW50cywgKF9rZXksIG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOb2RlKG5vZGUpICYmIG5vZGUudGFnKVxuICAgICAgICAgICAgICAgICAgICB0YWdzW25vZGUudGFnXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRhZ05hbWVzID0gT2JqZWN0LmtleXModGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGFnTmFtZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBbaGFuZGxlLCBwcmVmaXhdIG9mIHRhZ0VudHJpZXMpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGUgPT09ICchIScgJiYgcHJlZml4ID09PSAndGFnOnlhbWwub3JnLDIwMDI6JylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghZG9jIHx8IHRhZ05hbWVzLnNvbWUodG4gPT4gdG4uc3RhcnRzV2l0aChwcmVmaXgpKSlcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGAlVEFHICR7aGFuZGxlfSAke3ByZWZpeH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZXMuam9pbignXFxuJyk7XG4gICAgfVxufVxuRGlyZWN0aXZlcy5kZWZhdWx0WWFtbCA9IHsgZXhwbGljaXQ6IGZhbHNlLCB2ZXJzaW9uOiAnMS4yJyB9O1xuRGlyZWN0aXZlcy5kZWZhdWx0VGFncyA9IHsgJyEhJzogJ3RhZzp5YW1sLm9yZywyMDAyOicgfTtcblxuZXhwb3J0IHsgRGlyZWN0aXZlcyB9O1xuIiwgImltcG9ydCB7IGlzU2NhbGFyLCBpc0NvbGxlY3Rpb24gfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IHZpc2l0IH0gZnJvbSAnLi4vdmlzaXQuanMnO1xuXG4vKipcbiAqIFZlcmlmeSB0aGF0IHRoZSBpbnB1dCBzdHJpbmcgaXMgYSB2YWxpZCBhbmNob3IuXG4gKlxuICogV2lsbCB0aHJvdyBvbiBlcnJvcnMuXG4gKi9cbmZ1bmN0aW9uIGFuY2hvcklzVmFsaWQoYW5jaG9yKSB7XG4gICAgaWYgKC9bXFx4MDAtXFx4MTlcXHMsW1xcXXt9XS8udGVzdChhbmNob3IpKSB7XG4gICAgICAgIGNvbnN0IHNhID0gSlNPTi5zdHJpbmdpZnkoYW5jaG9yKTtcbiAgICAgICAgY29uc3QgbXNnID0gYEFuY2hvciBtdXN0IG5vdCBjb250YWluIHdoaXRlc3BhY2Ugb3IgY29udHJvbCBjaGFyYWN0ZXJzOiAke3NhfWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFuY2hvck5hbWVzKHJvb3QpIHtcbiAgICBjb25zdCBhbmNob3JzID0gbmV3IFNldCgpO1xuICAgIHZpc2l0KHJvb3QsIHtcbiAgICAgICAgVmFsdWUoX2tleSwgbm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuYW5jaG9yKVxuICAgICAgICAgICAgICAgIGFuY2hvcnMuYWRkKG5vZGUuYW5jaG9yKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhbmNob3JzO1xufVxuLyoqIEZpbmQgYSBuZXcgYW5jaG9yIG5hbWUgd2l0aCB0aGUgZ2l2ZW4gYHByZWZpeGAgYW5kIGEgb25lLWluZGV4ZWQgc3VmZml4LiAqL1xuZnVuY3Rpb24gZmluZE5ld0FuY2hvcihwcmVmaXgsIGV4Y2x1ZGUpIHtcbiAgICBmb3IgKGxldCBpID0gMTsgdHJ1ZTsgKytpKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBgJHtwcmVmaXh9JHtpfWA7XG4gICAgICAgIGlmICghZXhjbHVkZS5oYXMobmFtZSkpXG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVOb2RlQW5jaG9ycyhkb2MsIHByZWZpeCkge1xuICAgIGNvbnN0IGFsaWFzT2JqZWN0cyA9IFtdO1xuICAgIGNvbnN0IHNvdXJjZU9iamVjdHMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IHByZXZBbmNob3JzID0gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBvbkFuY2hvcjogKHNvdXJjZSkgPT4ge1xuICAgICAgICAgICAgYWxpYXNPYmplY3RzLnB1c2goc291cmNlKTtcbiAgICAgICAgICAgIGlmICghcHJldkFuY2hvcnMpXG4gICAgICAgICAgICAgICAgcHJldkFuY2hvcnMgPSBhbmNob3JOYW1lcyhkb2MpO1xuICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gZmluZE5ld0FuY2hvcihwcmVmaXgsIHByZXZBbmNob3JzKTtcbiAgICAgICAgICAgIHByZXZBbmNob3JzLmFkZChhbmNob3IpO1xuICAgICAgICAgICAgcmV0dXJuIGFuY2hvcjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpdGggY2lyY3VsYXIgcmVmZXJlbmNlcywgdGhlIHNvdXJjZSBub2RlIGlzIG9ubHkgcmVzb2x2ZWQgYWZ0ZXIgYWxsXG4gICAgICAgICAqIG9mIGl0cyBjaGlsZCBub2RlcyBhcmUuIFRoaXMgaXMgd2h5IGFuY2hvcnMgYXJlIHNldCBvbmx5IGFmdGVyIGFsbCBvZlxuICAgICAgICAgKiB0aGUgbm9kZXMgaGF2ZSBiZWVuIGNyZWF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBzZXRBbmNob3JzOiAoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBhbGlhc09iamVjdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWYgPSBzb3VyY2VPYmplY3RzLmdldChzb3VyY2UpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVmID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICByZWYuYW5jaG9yICYmXG4gICAgICAgICAgICAgICAgICAgIChpc1NjYWxhcihyZWYubm9kZSkgfHwgaXNDb2xsZWN0aW9uKHJlZi5ub2RlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmLm5vZGUuYW5jaG9yID0gcmVmLmFuY2hvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdGYWlsZWQgdG8gcmVzb2x2ZSByZXBlYXRlZCBvYmplY3QgKHRoaXMgc2hvdWxkIG5vdCBoYXBwZW4pJyk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzb3VyY2VPYmplY3RzXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgYW5jaG9ySXNWYWxpZCwgYW5jaG9yTmFtZXMsIGNyZWF0ZU5vZGVBbmNob3JzLCBmaW5kTmV3QW5jaG9yIH07XG4iLCAiaW1wb3J0IHsgYW5jaG9ySXNWYWxpZCB9IGZyb20gJy4uL2RvYy9hbmNob3JzLmpzJztcbmltcG9ydCB7IHZpc2l0IH0gZnJvbSAnLi4vdmlzaXQuanMnO1xuaW1wb3J0IHsgTm9kZUJhc2UsIEFMSUFTLCBpc0FsaWFzLCBpc0NvbGxlY3Rpb24sIGlzUGFpciB9IGZyb20gJy4vTm9kZS5qcyc7XG5cbmNsYXNzIEFsaWFzIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgICAgICBzdXBlcihBTElBUyk7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3RhZycsIHtcbiAgICAgICAgICAgIHNldCgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsaWFzIG5vZGVzIGNhbm5vdCBoYXZlIHRhZ3MnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmUgdGhlIHZhbHVlIG9mIHRoaXMgYWxpYXMgd2l0aGluIGBkb2NgLCBmaW5kaW5nIHRoZSBsYXN0XG4gICAgICogaW5zdGFuY2Ugb2YgdGhlIGBzb3VyY2VgIGFuY2hvciBiZWZvcmUgdGhpcyBub2RlLlxuICAgICAqL1xuICAgIHJlc29sdmUoZG9jKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmlzaXQoZG9jLCB7XG4gICAgICAgICAgICBOb2RlOiAoX2tleSwgbm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChub2RlID09PSB0aGlzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQuQlJFQUs7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuYW5jaG9yID09PSB0aGlzLnNvdXJjZSlcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICB0b0pTT04oX2FyZywgY3R4KSB7XG4gICAgICAgIGlmICghY3R4KVxuICAgICAgICAgICAgcmV0dXJuIHsgc291cmNlOiB0aGlzLnNvdXJjZSB9O1xuICAgICAgICBjb25zdCB7IGFuY2hvcnMsIGRvYywgbWF4QWxpYXNDb3VudCB9ID0gY3R4O1xuICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJlc29sdmUoZG9jKTtcbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBVbnJlc29sdmVkIGFsaWFzICh0aGUgYW5jaG9yIG11c3QgYmUgc2V0IGJlZm9yZSB0aGUgYWxpYXMpOiAke3RoaXMuc291cmNlfWA7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gYW5jaG9ycy5nZXQoc291cmNlKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghZGF0YSB8fCBkYXRhLnJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSAnVGhpcyBzaG91bGQgbm90IGhhcHBlbjogQWxpYXMgYW5jaG9yIHdhcyBub3QgcmVzb2x2ZWQ/JztcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhBbGlhc0NvdW50ID49IDApIHtcbiAgICAgICAgICAgIGRhdGEuY291bnQgKz0gMTtcbiAgICAgICAgICAgIGlmIChkYXRhLmFsaWFzQ291bnQgPT09IDApXG4gICAgICAgICAgICAgICAgZGF0YS5hbGlhc0NvdW50ID0gZ2V0QWxpYXNDb3VudChkb2MsIHNvdXJjZSwgYW5jaG9ycyk7XG4gICAgICAgICAgICBpZiAoZGF0YS5jb3VudCAqIGRhdGEuYWxpYXNDb3VudCA+IG1heEFsaWFzQ291bnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSAnRXhjZXNzaXZlIGFsaWFzIGNvdW50IGluZGljYXRlcyBhIHJlc291cmNlIGV4aGF1c3Rpb24gYXR0YWNrJztcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IobXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YS5yZXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKGN0eCwgX29uQ29tbWVudCwgX29uQ2hvbXBLZWVwKSB7XG4gICAgICAgIGNvbnN0IHNyYyA9IGAqJHt0aGlzLnNvdXJjZX1gO1xuICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICBhbmNob3JJc1ZhbGlkKHRoaXMuc291cmNlKTtcbiAgICAgICAgICAgIGlmIChjdHgub3B0aW9ucy52ZXJpZnlBbGlhc09yZGVyICYmICFjdHguYW5jaG9ycy5oYXModGhpcy5zb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gYFVucmVzb2x2ZWQgYWxpYXMgKHRoZSBhbmNob3IgbXVzdCBiZSBzZXQgYmVmb3JlIHRoZSBhbGlhcyk6ICR7dGhpcy5zb3VyY2V9YDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdHguaW1wbGljaXRLZXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3NyY30gYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3JjO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEFsaWFzQ291bnQoZG9jLCBub2RlLCBhbmNob3JzKSB7XG4gICAgaWYgKGlzQWxpYXMobm9kZSkpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gbm9kZS5yZXNvbHZlKGRvYyk7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IGFuY2hvcnMgJiYgc291cmNlICYmIGFuY2hvcnMuZ2V0KHNvdXJjZSk7XG4gICAgICAgIHJldHVybiBhbmNob3IgPyBhbmNob3IuY291bnQgKiBhbmNob3IuYWxpYXNDb3VudCA6IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQ29sbGVjdGlvbihub2RlKSkge1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygbm9kZS5pdGVtcykge1xuICAgICAgICAgICAgY29uc3QgYyA9IGdldEFsaWFzQ291bnQoZG9jLCBpdGVtLCBhbmNob3JzKTtcbiAgICAgICAgICAgIGlmIChjID4gY291bnQpXG4gICAgICAgICAgICAgICAgY291bnQgPSBjO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQYWlyKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGtjID0gZ2V0QWxpYXNDb3VudChkb2MsIG5vZGUua2V5LCBhbmNob3JzKTtcbiAgICAgICAgY29uc3QgdmMgPSBnZXRBbGlhc0NvdW50KGRvYywgbm9kZS52YWx1ZSwgYW5jaG9ycyk7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChrYywgdmMpO1xuICAgIH1cbiAgICByZXR1cm4gMTtcbn1cblxuZXhwb3J0IHsgQWxpYXMgfTtcbiIsICJpbXBvcnQgeyBoYXNBbmNob3IgfSBmcm9tICcuL05vZGUuanMnO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgYW55IG5vZGUgb3IgaXRzIGNvbnRlbnRzIHRvIG5hdGl2ZSBKYXZhU2NyaXB0XG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGlucHV0IHZhbHVlXG4gKiBAcGFyYW0gYXJnIC0gSWYgYHZhbHVlYCBkZWZpbmVzIGEgYHRvSlNPTigpYCBtZXRob2QsIHVzZSB0aGlzXG4gKiAgIGFzIGl0cyBmaXJzdCBhcmd1bWVudFxuICogQHBhcmFtIGN0eCAtIENvbnZlcnNpb24gY29udGV4dCwgb3JpZ2luYWxseSBzZXQgaW4gRG9jdW1lbnQjdG9KUygpLiBJZlxuICogICBgeyBrZWVwOiB0cnVlIH1gIGlzIG5vdCBzZXQsIG91dHB1dCBzaG91bGQgYmUgc3VpdGFibGUgZm9yIEpTT05cbiAqICAgc3RyaW5naWZpY2F0aW9uLlxuICovXG5mdW5jdGlvbiB0b0pTKHZhbHVlLCBhcmcsIGN0eCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodiwgaSkgPT4gdG9KUyh2LCBTdHJpbmcoaSksIGN0eCkpO1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGxcbiAgICAgICAgaWYgKCFjdHggfHwgIWhhc0FuY2hvcih2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9KU09OKGFyZywgY3R4KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHsgYWxpYXNDb3VudDogMCwgY291bnQ6IDEsIHJlczogdW5kZWZpbmVkIH07XG4gICAgICAgIGN0eC5hbmNob3JzLnNldCh2YWx1ZSwgZGF0YSk7XG4gICAgICAgIGN0eC5vbkNyZWF0ZSA9IHJlcyA9PiB7XG4gICAgICAgICAgICBkYXRhLnJlcyA9IHJlcztcbiAgICAgICAgICAgIGRlbGV0ZSBjdHgub25DcmVhdGU7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcyA9IHZhbHVlLnRvSlNPTihhcmcsIGN0eCk7XG4gICAgICAgIGlmIChjdHgub25DcmVhdGUpXG4gICAgICAgICAgICBjdHgub25DcmVhdGUocmVzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgJiYgIWN0eD8ua2VlcClcbiAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgeyB0b0pTIH07XG4iLCAiaW1wb3J0IHsgTm9kZUJhc2UsIFNDQUxBUiB9IGZyb20gJy4vTm9kZS5qcyc7XG5pbXBvcnQgeyB0b0pTIH0gZnJvbSAnLi90b0pTLmpzJztcblxuY29uc3QgaXNTY2FsYXJWYWx1ZSA9ICh2YWx1ZSkgPT4gIXZhbHVlIHx8ICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jyk7XG5jbGFzcyBTY2FsYXIgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoU0NBTEFSKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICB0b0pTT04oYXJnLCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIGN0eD8ua2VlcCA/IHRoaXMudmFsdWUgOiB0b0pTKHRoaXMudmFsdWUsIGFyZywgY3R4KTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcodGhpcy52YWx1ZSk7XG4gICAgfVxufVxuU2NhbGFyLkJMT0NLX0ZPTERFRCA9ICdCTE9DS19GT0xERUQnO1xuU2NhbGFyLkJMT0NLX0xJVEVSQUwgPSAnQkxPQ0tfTElURVJBTCc7XG5TY2FsYXIuUExBSU4gPSAnUExBSU4nO1xuU2NhbGFyLlFVT1RFX0RPVUJMRSA9ICdRVU9URV9ET1VCTEUnO1xuU2NhbGFyLlFVT1RFX1NJTkdMRSA9ICdRVU9URV9TSU5HTEUnO1xuXG5leHBvcnQgeyBTY2FsYXIsIGlzU2NhbGFyVmFsdWUgfTtcbiIsICJpbXBvcnQgeyBBbGlhcyB9IGZyb20gJy4uL25vZGVzL0FsaWFzLmpzJztcbmltcG9ydCB7IGlzTm9kZSwgaXNQYWlyLCBNQVAsIFNFUSwgaXNEb2N1bWVudCB9IGZyb20gJy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvU2NhbGFyLmpzJztcblxuY29uc3QgZGVmYXVsdFRhZ1ByZWZpeCA9ICd0YWc6eWFtbC5vcmcsMjAwMjonO1xuZnVuY3Rpb24gZmluZFRhZ09iamVjdCh2YWx1ZSwgdGFnTmFtZSwgdGFncykge1xuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGFncy5maWx0ZXIodCA9PiB0LnRhZyA9PT0gdGFnTmFtZSk7XG4gICAgICAgIGNvbnN0IHRhZ09iaiA9IG1hdGNoLmZpbmQodCA9PiAhdC5mb3JtYXQpID8/IG1hdGNoWzBdO1xuICAgICAgICBpZiAoIXRhZ09iailcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGFnICR7dGFnTmFtZX0gbm90IGZvdW5kYCk7XG4gICAgICAgIHJldHVybiB0YWdPYmo7XG4gICAgfVxuICAgIHJldHVybiB0YWdzLmZpbmQodCA9PiB0LmlkZW50aWZ5Py4odmFsdWUpICYmICF0LmZvcm1hdCk7XG59XG5mdW5jdGlvbiBjcmVhdGVOb2RlKHZhbHVlLCB0YWdOYW1lLCBjdHgpIHtcbiAgICBpZiAoaXNEb2N1bWVudCh2YWx1ZSkpXG4gICAgICAgIHZhbHVlID0gdmFsdWUuY29udGVudHM7XG4gICAgaWYgKGlzTm9kZSh2YWx1ZSkpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBpZiAoaXNQYWlyKHZhbHVlKSkge1xuICAgICAgICBjb25zdCBtYXAgPSBjdHguc2NoZW1hW01BUF0uY3JlYXRlTm9kZT8uKGN0eC5zY2hlbWEsIG51bGwsIGN0eCk7XG4gICAgICAgIG1hcC5pdGVtcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nIHx8XG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyIHx8XG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgQm9vbGVhbiB8fFxuICAgICAgICAodHlwZW9mIEJpZ0ludCA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEJpZ0ludCkgLy8gbm90IHN1cHBvcnRlZCBldmVyeXdoZXJlXG4gICAgKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2VyaWFsaXplanNvbnByb3BlcnR5XG4gICAgICAgIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgIH1cbiAgICBjb25zdCB7IGFsaWFzRHVwbGljYXRlT2JqZWN0cywgb25BbmNob3IsIG9uVGFnT2JqLCBzY2hlbWEsIHNvdXJjZU9iamVjdHMgfSA9IGN0eDtcbiAgICAvLyBEZXRlY3QgZHVwbGljYXRlIHJlZmVyZW5jZXMgdG8gdGhlIHNhbWUgb2JqZWN0ICYgdXNlIEFsaWFzIG5vZGVzIGZvciBhbGxcbiAgICAvLyBhZnRlciBmaXJzdC4gVGhlIGByZWZgIHdyYXBwZXIgYWxsb3dzIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIHRvIHJlc29sdmUuXG4gICAgbGV0IHJlZiA9IHVuZGVmaW5lZDtcbiAgICBpZiAoYWxpYXNEdXBsaWNhdGVPYmplY3RzICYmIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmVmID0gc291cmNlT2JqZWN0cy5nZXQodmFsdWUpO1xuICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgICBpZiAoIXJlZi5hbmNob3IpXG4gICAgICAgICAgICAgICAgcmVmLmFuY2hvciA9IG9uQW5jaG9yKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxpYXMocmVmLmFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYgPSB7IGFuY2hvcjogbnVsbCwgbm9kZTogbnVsbCB9O1xuICAgICAgICAgICAgc291cmNlT2JqZWN0cy5zZXQodmFsdWUsIHJlZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhZ05hbWU/LnN0YXJ0c1dpdGgoJyEhJykpXG4gICAgICAgIHRhZ05hbWUgPSBkZWZhdWx0VGFnUHJlZml4ICsgdGFnTmFtZS5zbGljZSgyKTtcbiAgICBsZXQgdGFnT2JqID0gZmluZFRhZ09iamVjdCh2YWx1ZSwgdGFnTmFtZSwgc2NoZW1hLnRhZ3MpO1xuICAgIGlmICghdGFnT2JqKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBTY2FsYXIodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHJlZilcbiAgICAgICAgICAgICAgICByZWYubm9kZSA9IG5vZGU7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICB0YWdPYmogPVxuICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBNYXBcbiAgICAgICAgICAgICAgICA/IHNjaGVtYVtNQVBdXG4gICAgICAgICAgICAgICAgOiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA/IHNjaGVtYVtTRVFdXG4gICAgICAgICAgICAgICAgICAgIDogc2NoZW1hW01BUF07XG4gICAgfVxuICAgIGlmIChvblRhZ09iaikge1xuICAgICAgICBvblRhZ09iaih0YWdPYmopO1xuICAgICAgICBkZWxldGUgY3R4Lm9uVGFnT2JqO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gdGFnT2JqPy5jcmVhdGVOb2RlXG4gICAgICAgID8gdGFnT2JqLmNyZWF0ZU5vZGUoY3R4LnNjaGVtYSwgdmFsdWUsIGN0eClcbiAgICAgICAgOiBuZXcgU2NhbGFyKHZhbHVlKTtcbiAgICBpZiAodGFnTmFtZSlcbiAgICAgICAgbm9kZS50YWcgPSB0YWdOYW1lO1xuICAgIGlmIChyZWYpXG4gICAgICAgIHJlZi5ub2RlID0gbm9kZTtcbiAgICByZXR1cm4gbm9kZTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlTm9kZSB9O1xuIiwgImltcG9ydCB7IGNyZWF0ZU5vZGUgfSBmcm9tICcuLi9kb2MvY3JlYXRlTm9kZS5qcyc7XG5pbXBvcnQgeyBOb2RlQmFzZSwgaXNOb2RlLCBpc1BhaXIsIGlzQ29sbGVjdGlvbiwgaXNTY2FsYXIgfSBmcm9tICcuL05vZGUuanMnO1xuXG5mdW5jdGlvbiBjb2xsZWN0aW9uRnJvbVBhdGgoc2NoZW1hLCBwYXRoLCB2YWx1ZSkge1xuICAgIGxldCB2ID0gdmFsdWU7XG4gICAgZm9yIChsZXQgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgY29uc3QgayA9IHBhdGhbaV07XG4gICAgICAgIGlmICh0eXBlb2YgayA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzSW50ZWdlcihrKSAmJiBrID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBbXTtcbiAgICAgICAgICAgIGFba10gPSB2O1xuICAgICAgICAgICAgdiA9IGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2ID0gbmV3IE1hcChbW2ssIHZdXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZU5vZGUodiwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGFsaWFzRHVwbGljYXRlT2JqZWN0czogZmFsc2UsXG4gICAgICAgIGtlZXBVbmRlZmluZWQ6IGZhbHNlLFxuICAgICAgICBvbkFuY2hvcjogKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHNob3VsZCBub3QgaGFwcGVuLCBwbGVhc2UgcmVwb3J0IGEgYnVnLicpO1xuICAgICAgICB9LFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIHNvdXJjZU9iamVjdHM6IG5ldyBNYXAoKVxuICAgIH0pO1xufVxuLy8gVHlwZSBndWFyZCBpcyBpbnRlbnRpb25hbGx5IGEgbGl0dGxlIHdyb25nIHNvIGFzIHRvIGJlIG1vcmUgdXNlZnVsLFxuLy8gYXMgaXQgZG9lcyBub3QgY292ZXIgdW50eXBhYmxlIGVtcHR5IG5vbi1zdHJpbmcgaXRlcmFibGVzIChlLmcuIFtdKS5cbmNvbnN0IGlzRW1wdHlQYXRoID0gKHBhdGgpID0+IHBhdGggPT0gbnVsbCB8fFxuICAgICh0eXBlb2YgcGF0aCA9PT0gJ29iamVjdCcgJiYgISFwYXRoW1N5bWJvbC5pdGVyYXRvcl0oKS5uZXh0KCkuZG9uZSk7XG5jbGFzcyBDb2xsZWN0aW9uIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHNjaGVtYSkge1xuICAgICAgICBzdXBlcih0eXBlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY2hlbWEnLCB7XG4gICAgICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY29weSBvZiB0aGlzIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2NoZW1hIC0gSWYgZGVmaW5lZCwgb3ZlcndyaXRlcyB0aGUgb3JpZ2luYWwncyBzY2hlbWFcbiAgICAgKi9cbiAgICBjbG9uZShzY2hlbWEpIHtcbiAgICAgICAgY29uc3QgY29weSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0aGlzKSk7XG4gICAgICAgIGlmIChzY2hlbWEpXG4gICAgICAgICAgICBjb3B5LnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgY29weS5pdGVtcyA9IGNvcHkuaXRlbXMubWFwKGl0ID0+IGlzTm9kZShpdCkgfHwgaXNQYWlyKGl0KSA/IGl0LmNsb25lKHNjaGVtYSkgOiBpdCk7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlKVxuICAgICAgICAgICAgY29weS5yYW5nZSA9IHRoaXMucmFuZ2Uuc2xpY2UoKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB2YWx1ZSB0byB0aGUgY29sbGVjdGlvbi4gRm9yIGAhIW1hcGAgYW5kIGAhIW9tYXBgIHRoZSB2YWx1ZSBtdXN0XG4gICAgICogYmUgYSBQYWlyIGluc3RhbmNlIG9yIGEgYHsga2V5LCB2YWx1ZSB9YCBvYmplY3QsIHdoaWNoIG1heSBub3QgaGF2ZSBhIGtleVxuICAgICAqIHRoYXQgYWxyZWFkeSBleGlzdHMgaW4gdGhlIG1hcC5cbiAgICAgKi9cbiAgICBhZGRJbihwYXRoLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNFbXB0eVBhdGgocGF0aCkpXG4gICAgICAgICAgICB0aGlzLmFkZCh2YWx1ZSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgW2tleSwgLi4ucmVzdF0gPSBwYXRoO1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoaXNDb2xsZWN0aW9uKG5vZGUpKVxuICAgICAgICAgICAgICAgIG5vZGUuYWRkSW4ocmVzdCwgdmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAobm9kZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuc2NoZW1hKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgY29sbGVjdGlvbkZyb21QYXRoKHRoaXMuc2NoZW1hLCByZXN0LCB2YWx1ZSkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgWUFNTCBjb2xsZWN0aW9uIGF0ICR7a2V5fS4gUmVtYWluaW5nIHBhdGg6ICR7cmVzdH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgdmFsdWUgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGl0ZW0gd2FzIGZvdW5kIGFuZCByZW1vdmVkLlxuICAgICAqL1xuICAgIGRlbGV0ZUluKHBhdGgpIHtcbiAgICAgICAgY29uc3QgW2tleSwgLi4ucmVzdF0gPSBwYXRoO1xuICAgICAgICBpZiAocmVzdC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxldGUoa2V5KTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgIGlmIChpc0NvbGxlY3Rpb24obm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5kZWxldGVJbihyZXN0KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBZQU1MIGNvbGxlY3Rpb24gYXQgJHtrZXl9LiBSZW1haW5pbmcgcGF0aDogJHtyZXN0fWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGl0ZW0gYXQgYGtleWAsIG9yIGB1bmRlZmluZWRgIGlmIG5vdCBmb3VuZC4gQnkgZGVmYXVsdCB1bndyYXBzXG4gICAgICogc2NhbGFyIHZhbHVlcyBmcm9tIHRoZWlyIHN1cnJvdW5kaW5nIG5vZGU7IHRvIGRpc2FibGUgc2V0IGBrZWVwU2NhbGFyYCB0b1xuICAgICAqIGB0cnVlYCAoY29sbGVjdGlvbnMgYXJlIGFsd2F5cyByZXR1cm5lZCBpbnRhY3QpLlxuICAgICAqL1xuICAgIGdldEluKHBhdGgsIGtlZXBTY2FsYXIpIHtcbiAgICAgICAgY29uc3QgW2tleSwgLi4ucmVzdF0gPSBwYXRoO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgaWYgKHJlc3QubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuICFrZWVwU2NhbGFyICYmIGlzU2NhbGFyKG5vZGUpID8gbm9kZS52YWx1ZSA6IG5vZGU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBpc0NvbGxlY3Rpb24obm9kZSkgPyBub2RlLmdldEluKHJlc3QsIGtlZXBTY2FsYXIpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBoYXNBbGxOdWxsVmFsdWVzKGFsbG93U2NhbGFyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmV2ZXJ5KG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc1BhaXIobm9kZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgbiA9IG5vZGUudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gKG4gPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIChhbGxvd1NjYWxhciAmJlxuICAgICAgICAgICAgICAgICAgICBpc1NjYWxhcihuKSAmJlxuICAgICAgICAgICAgICAgICAgICBuLnZhbHVlID09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgIW4uY29tbWVudEJlZm9yZSAmJlxuICAgICAgICAgICAgICAgICAgICAhbi5jb21tZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICFuLnRhZykpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjb2xsZWN0aW9uIGluY2x1ZGVzIGEgdmFsdWUgd2l0aCB0aGUga2V5IGBrZXlgLlxuICAgICAqL1xuICAgIGhhc0luKHBhdGgpIHtcbiAgICAgICAgY29uc3QgW2tleSwgLi4ucmVzdF0gPSBwYXRoO1xuICAgICAgICBpZiAocmVzdC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXMoa2V5KTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBpc0NvbGxlY3Rpb24obm9kZSkgPyBub2RlLmhhc0luKHJlc3QpIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSB2YWx1ZSBpbiB0aGlzIGNvbGxlY3Rpb24uIEZvciBgISFzZXRgLCBgdmFsdWVgIG5lZWRzIHRvIGJlIGFcbiAgICAgKiBib29sZWFuIHRvIGFkZC9yZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgc2V0LlxuICAgICAqL1xuICAgIHNldEluKHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IFtrZXksIC4uLnJlc3RdID0gcGF0aDtcbiAgICAgICAgaWYgKHJlc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgICAgICAgICAgaWYgKGlzQ29sbGVjdGlvbihub2RlKSlcbiAgICAgICAgICAgICAgICBub2RlLnNldEluKHJlc3QsIHZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnNjaGVtYSlcbiAgICAgICAgICAgICAgICB0aGlzLnNldChrZXksIGNvbGxlY3Rpb25Gcm9tUGF0aCh0aGlzLnNjaGVtYSwgcmVzdCwgdmFsdWUpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFlBTUwgY29sbGVjdGlvbiBhdCAke2tleX0uIFJlbWFpbmluZyBwYXRoOiAke3Jlc3R9YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5Db2xsZWN0aW9uLm1heEZsb3dTdHJpbmdTaW5nbGVMaW5lTGVuZ3RoID0gNjA7XG5cbmV4cG9ydCB7IENvbGxlY3Rpb24sIGNvbGxlY3Rpb25Gcm9tUGF0aCwgaXNFbXB0eVBhdGggfTtcbiIsICIvKipcbiAqIFN0cmluZ2lmaWVzIGEgY29tbWVudC5cbiAqXG4gKiBFbXB0eSBjb21tZW50IGxpbmVzIGFyZSBsZWZ0IGVtcHR5LFxuICogbGluZXMgY29uc2lzdGluZyBvZiBhIHNpbmdsZSBzcGFjZSBhcmUgcmVwbGFjZWQgYnkgYCNgLFxuICogYW5kIGFsbCBvdGhlciBsaW5lcyBhcmUgcHJlZml4ZWQgd2l0aCBhIGAjYC5cbiAqL1xuY29uc3Qgc3RyaW5naWZ5Q29tbWVudCA9IChzdHIpID0+IHN0ci5yZXBsYWNlKC9eKD8hJCkoPzogJCk/L2dtLCAnIycpO1xuZnVuY3Rpb24gaW5kZW50Q29tbWVudChjb21tZW50LCBpbmRlbnQpIHtcbiAgICBpZiAoL15cXG4rJC8udGVzdChjb21tZW50KSlcbiAgICAgICAgcmV0dXJuIGNvbW1lbnQuc3Vic3RyaW5nKDEpO1xuICAgIHJldHVybiBpbmRlbnQgPyBjb21tZW50LnJlcGxhY2UoL14oPyEgKiQpL2dtLCBpbmRlbnQpIDogY29tbWVudDtcbn1cbmNvbnN0IGxpbmVDb21tZW50ID0gKHN0ciwgaW5kZW50LCBjb21tZW50KSA9PiBzdHIuZW5kc1dpdGgoJ1xcbicpXG4gICAgPyBpbmRlbnRDb21tZW50KGNvbW1lbnQsIGluZGVudClcbiAgICA6IGNvbW1lbnQuaW5jbHVkZXMoJ1xcbicpXG4gICAgICAgID8gJ1xcbicgKyBpbmRlbnRDb21tZW50KGNvbW1lbnQsIGluZGVudClcbiAgICAgICAgOiAoc3RyLmVuZHNXaXRoKCcgJykgPyAnJyA6ICcgJykgKyBjb21tZW50O1xuXG5leHBvcnQgeyBpbmRlbnRDb21tZW50LCBsaW5lQ29tbWVudCwgc3RyaW5naWZ5Q29tbWVudCB9O1xuIiwgImNvbnN0IEZPTERfRkxPVyA9ICdmbG93JztcbmNvbnN0IEZPTERfQkxPQ0sgPSAnYmxvY2snO1xuY29uc3QgRk9MRF9RVU9URUQgPSAncXVvdGVkJztcbi8qKlxuICogVHJpZXMgdG8ga2VlcCBpbnB1dCBhdCB1cCB0byBgbGluZVdpZHRoYCBjaGFyYWN0ZXJzLCBzcGxpdHRpbmcgb25seSBvbiBzcGFjZXNcbiAqIG5vdCBmb2xsb3dlZCBieSBuZXdsaW5lcyBvciBzcGFjZXMgdW5sZXNzIGBtb2RlYCBpcyBgJ3F1b3RlZCdgLiBMaW5lcyBhcmVcbiAqIHRlcm1pbmF0ZWQgd2l0aCBgXFxuYCBhbmQgc3RhcnRlZCB3aXRoIGBpbmRlbnRgLlxuICovXG5mdW5jdGlvbiBmb2xkRmxvd0xpbmVzKHRleHQsIGluZGVudCwgbW9kZSA9ICdmbG93JywgeyBpbmRlbnRBdFN0YXJ0LCBsaW5lV2lkdGggPSA4MCwgbWluQ29udGVudFdpZHRoID0gMjAsIG9uRm9sZCwgb25PdmVyZmxvdyB9ID0ge30pIHtcbiAgICBpZiAoIWxpbmVXaWR0aCB8fCBsaW5lV2lkdGggPCAwKVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICBjb25zdCBlbmRTdGVwID0gTWF0aC5tYXgoMSArIG1pbkNvbnRlbnRXaWR0aCwgMSArIGxpbmVXaWR0aCAtIGluZGVudC5sZW5ndGgpO1xuICAgIGlmICh0ZXh0Lmxlbmd0aCA8PSBlbmRTdGVwKVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICBjb25zdCBmb2xkcyA9IFtdO1xuICAgIGNvbnN0IGVzY2FwZWRGb2xkcyA9IHt9O1xuICAgIGxldCBlbmQgPSBsaW5lV2lkdGggLSBpbmRlbnQubGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgaW5kZW50QXRTdGFydCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGluZGVudEF0U3RhcnQgPiBsaW5lV2lkdGggLSBNYXRoLm1heCgyLCBtaW5Db250ZW50V2lkdGgpKVxuICAgICAgICAgICAgZm9sZHMucHVzaCgwKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZW5kID0gbGluZVdpZHRoIC0gaW5kZW50QXRTdGFydDtcbiAgICB9XG4gICAgbGV0IHNwbGl0ID0gdW5kZWZpbmVkO1xuICAgIGxldCBwcmV2ID0gdW5kZWZpbmVkO1xuICAgIGxldCBvdmVyZmxvdyA9IGZhbHNlO1xuICAgIGxldCBpID0gLTE7XG4gICAgbGV0IGVzY1N0YXJ0ID0gLTE7XG4gICAgbGV0IGVzY0VuZCA9IC0xO1xuICAgIGlmIChtb2RlID09PSBGT0xEX0JMT0NLKSB7XG4gICAgICAgIGkgPSBjb25zdW1lTW9yZUluZGVudGVkTGluZXModGV4dCwgaSk7XG4gICAgICAgIGlmIChpICE9PSAtMSlcbiAgICAgICAgICAgIGVuZCA9IGkgKyBlbmRTdGVwO1xuICAgIH1cbiAgICBmb3IgKGxldCBjaDsgKGNoID0gdGV4dFsoaSArPSAxKV0pOykge1xuICAgICAgICBpZiAobW9kZSA9PT0gRk9MRF9RVU9URUQgJiYgY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgZXNjU3RhcnQgPSBpO1xuICAgICAgICAgICAgc3dpdGNoICh0ZXh0W2kgKyAxXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICAgICAgICBpICs9IDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgICAgICAgICBpICs9IDU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1UnOlxuICAgICAgICAgICAgICAgICAgICBpICs9IDk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVzY0VuZCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgICAgICAgaWYgKG1vZGUgPT09IEZPTERfQkxPQ0spXG4gICAgICAgICAgICAgICAgaSA9IGNvbnN1bWVNb3JlSW5kZW50ZWRMaW5lcyh0ZXh0LCBpKTtcbiAgICAgICAgICAgIGVuZCA9IGkgKyBlbmRTdGVwO1xuICAgICAgICAgICAgc3BsaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICcgJyAmJlxuICAgICAgICAgICAgICAgIHByZXYgJiZcbiAgICAgICAgICAgICAgICBwcmV2ICE9PSAnICcgJiZcbiAgICAgICAgICAgICAgICBwcmV2ICE9PSAnXFxuJyAmJlxuICAgICAgICAgICAgICAgIHByZXYgIT09ICdcXHQnKSB7XG4gICAgICAgICAgICAgICAgLy8gc3BhY2Ugc3Vycm91bmRlZCBieSBub24tc3BhY2UgY2FuIGJlIHJlcGxhY2VkIHdpdGggbmV3bGluZSArIGluZGVudFxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0ZXh0W2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0ICE9PSAnICcgJiYgbmV4dCAhPT0gJ1xcbicgJiYgbmV4dCAhPT0gJ1xcdCcpXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID49IGVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChzcGxpdCkge1xuICAgICAgICAgICAgICAgICAgICBmb2xkcy5wdXNoKHNwbGl0KTtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gc3BsaXQgKyBlbmRTdGVwO1xuICAgICAgICAgICAgICAgICAgICBzcGxpdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gRk9MRF9RVU9URUQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hpdGUtc3BhY2UgY29sbGVjdGVkIGF0IGVuZCBtYXkgc3RyZXRjaCBwYXN0IGxpbmVXaWR0aFxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocHJldiA9PT0gJyAnIHx8IHByZXYgPT09ICdcXHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ID0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9IHRleHRbKGkgKz0gMSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFjY291bnQgZm9yIG5ld2xpbmUgZXNjYXBlLCBidXQgZG9uJ3QgYnJlYWsgcHJlY2VkaW5nIGVzY2FwZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBqID0gaSA+IGVzY0VuZCArIDEgPyBpIC0gMiA6IGVzY1N0YXJ0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmFpbCBvdXQgaWYgbGluZVdpZHRoICYgbWluQ29udGVudFdpZHRoIGFyZSBzaG9ydGVyIHRoYW4gYW4gZXNjYXBlIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXNjYXBlZEZvbGRzW2pdKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGZvbGRzLnB1c2goaik7XG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZWRGb2xkc1tqXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGogKyBlbmRTdGVwO1xuICAgICAgICAgICAgICAgICAgICBzcGxpdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJldiA9IGNoO1xuICAgIH1cbiAgICBpZiAob3ZlcmZsb3cgJiYgb25PdmVyZmxvdylcbiAgICAgICAgb25PdmVyZmxvdygpO1xuICAgIGlmIChmb2xkcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIGlmIChvbkZvbGQpXG4gICAgICAgIG9uRm9sZCgpO1xuICAgIGxldCByZXMgPSB0ZXh0LnNsaWNlKDAsIGZvbGRzWzBdKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvbGRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGZvbGQgPSBmb2xkc1tpXTtcbiAgICAgICAgY29uc3QgZW5kID0gZm9sZHNbaSArIDFdIHx8IHRleHQubGVuZ3RoO1xuICAgICAgICBpZiAoZm9sZCA9PT0gMClcbiAgICAgICAgICAgIHJlcyA9IGBcXG4ke2luZGVudH0ke3RleHQuc2xpY2UoMCwgZW5kKX1gO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBGT0xEX1FVT1RFRCAmJiBlc2NhcGVkRm9sZHNbZm9sZF0pXG4gICAgICAgICAgICAgICAgcmVzICs9IGAke3RleHRbZm9sZF19XFxcXGA7XG4gICAgICAgICAgICByZXMgKz0gYFxcbiR7aW5kZW50fSR7dGV4dC5zbGljZShmb2xkICsgMSwgZW5kKX1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIFByZXN1bWVzIGBpICsgMWAgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgbGluZVxuICogQHJldHVybnMgaW5kZXggb2YgbGFzdCBuZXdsaW5lIGluIG1vcmUtaW5kZW50ZWQgYmxvY2tcbiAqL1xuZnVuY3Rpb24gY29uc3VtZU1vcmVJbmRlbnRlZExpbmVzKHRleHQsIGkpIHtcbiAgICBsZXQgY2ggPSB0ZXh0W2kgKyAxXTtcbiAgICB3aGlsZSAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY2ggPSB0ZXh0WyhpICs9IDEpXTtcbiAgICAgICAgfSB3aGlsZSAoY2ggJiYgY2ggIT09ICdcXG4nKTtcbiAgICAgICAgY2ggPSB0ZXh0W2kgKyAxXTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG59XG5cbmV4cG9ydCB7IEZPTERfQkxPQ0ssIEZPTERfRkxPVywgRk9MRF9RVU9URUQsIGZvbGRGbG93TGluZXMgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgZm9sZEZsb3dMaW5lcywgRk9MRF9RVU9URUQsIEZPTERfRkxPVywgRk9MRF9CTE9DSyB9IGZyb20gJy4vZm9sZEZsb3dMaW5lcy5qcyc7XG5cbmNvbnN0IGdldEZvbGRPcHRpb25zID0gKGN0eCkgPT4gKHtcbiAgICBpbmRlbnRBdFN0YXJ0OiBjdHguaW5kZW50QXRTdGFydCxcbiAgICBsaW5lV2lkdGg6IGN0eC5vcHRpb25zLmxpbmVXaWR0aCxcbiAgICBtaW5Db250ZW50V2lkdGg6IGN0eC5vcHRpb25zLm1pbkNvbnRlbnRXaWR0aFxufSk7XG4vLyBBbHNvIGNoZWNrcyBmb3IgbGluZXMgc3RhcnRpbmcgd2l0aCAlLCBhcyBwYXJzaW5nIHRoZSBvdXRwdXQgYXMgWUFNTCAxLjEgd2lsbFxuLy8gcHJlc3VtZSB0aGF0J3Mgc3RhcnRpbmcgYSBuZXcgZG9jdW1lbnQuXG5jb25zdCBjb250YWluc0RvY3VtZW50TWFya2VyID0gKHN0cikgPT4gL14oJXwtLS18XFwuXFwuXFwuKS9tLnRlc3Qoc3RyKTtcbmZ1bmN0aW9uIGxpbmVMZW5ndGhPdmVyTGltaXQoc3RyLCBsaW5lV2lkdGgsIGluZGVudExlbmd0aCkge1xuICAgIGlmICghbGluZVdpZHRoIHx8IGxpbmVXaWR0aCA8IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBsaW1pdCA9IGxpbmVXaWR0aCAtIGluZGVudExlbmd0aDtcbiAgICBjb25zdCBzdHJMZW4gPSBzdHIubGVuZ3RoO1xuICAgIGlmIChzdHJMZW4gPD0gbGltaXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMCwgc3RhcnQgPSAwOyBpIDwgc3RyTGVuOyArK2kpIHtcbiAgICAgICAgaWYgKHN0cltpXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIGlmIChpIC0gc3RhcnQgPiBsaW1pdClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICBpZiAoc3RyTGVuIC0gc3RhcnQgPD0gbGltaXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZG91YmxlUXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpIHtcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIGlmIChjdHgub3B0aW9ucy5kb3VibGVRdW90ZWRBc0pTT04pXG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIGNvbnN0IHsgaW1wbGljaXRLZXkgfSA9IGN0eDtcbiAgICBjb25zdCBtaW5NdWx0aUxpbmVMZW5ndGggPSBjdHgub3B0aW9ucy5kb3VibGVRdW90ZWRNaW5NdWx0aUxpbmVMZW5ndGg7XG4gICAgY29uc3QgaW5kZW50ID0gY3R4LmluZGVudCB8fCAoY29udGFpbnNEb2N1bWVudE1hcmtlcih2YWx1ZSkgPyAnICAnIDogJycpO1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBjaCA9IGpzb25baV07IGNoOyBjaCA9IGpzb25bKytpXSkge1xuICAgICAgICBpZiAoY2ggPT09ICcgJyAmJiBqc29uW2kgKyAxXSA9PT0gJ1xcXFwnICYmIGpzb25baSArIDJdID09PSAnbicpIHtcbiAgICAgICAgICAgIC8vIHNwYWNlIGJlZm9yZSBuZXdsaW5lIG5lZWRzIHRvIGJlIGVzY2FwZWQgdG8gbm90IGJlIGZvbGRlZFxuICAgICAgICAgICAgc3RyICs9IGpzb24uc2xpY2Uoc3RhcnQsIGkpICsgJ1xcXFwgJztcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIHN0YXJ0ID0gaTtcbiAgICAgICAgICAgIGNoID0gJ1xcXFwnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnKVxuICAgICAgICAgICAgc3dpdGNoIChqc29uW2kgKyAxXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0ganNvbi5zbGljZShzdGFydCwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0ganNvbi5zdWJzdHIoaSArIDIsIDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMDAwMCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXDAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwMDA3JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcYSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAwMGInOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFx2JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMDAxYic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwMDg1JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcTic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAwYTAnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxfJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMjAyOCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXEwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcyMDI5JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcUCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLnN1YnN0cigwLCAyKSA9PT0gJzAwJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXHgnICsgY29kZS5zdWJzdHIoMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBqc29uLnN1YnN0cihpLCA2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbXBsaWNpdEtleSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAganNvbltpICsgMl0gPT09ICdcIicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb24ubGVuZ3RoIDwgbWluTXVsdGlMaW5lTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb2xkaW5nIHdpbGwgZWF0IGZpcnN0IG5ld2xpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBqc29uLnNsaWNlKHN0YXJ0LCBpKSArICdcXG5cXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGpzb25baSArIDJdID09PSAnXFxcXCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uW2kgKyAzXSA9PT0gJ24nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbltpICsgNF0gIT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGluZGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwYWNlIGFmdGVyIG5ld2xpbmUgbmVlZHMgdG8gYmUgZXNjYXBlZCB0byBub3QgYmUgZm9sZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbltpICsgMl0gPT09ICcgJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHN0ciA9IHN0YXJ0ID8gc3RyICsganNvbi5zbGljZShzdGFydCkgOiBqc29uO1xuICAgIHJldHVybiBpbXBsaWNpdEtleVxuICAgICAgICA/IHN0clxuICAgICAgICA6IGZvbGRGbG93TGluZXMoc3RyLCBpbmRlbnQsIEZPTERfUVVPVEVELCBnZXRGb2xkT3B0aW9ucyhjdHgpKTtcbn1cbmZ1bmN0aW9uIHNpbmdsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KSB7XG4gICAgaWYgKGN0eC5vcHRpb25zLnNpbmdsZVF1b3RlID09PSBmYWxzZSB8fFxuICAgICAgICAoY3R4LmltcGxpY2l0S2V5ICYmIHZhbHVlLmluY2x1ZGVzKCdcXG4nKSkgfHxcbiAgICAgICAgL1sgXFx0XVxcbnxcXG5bIFxcdF0vLnRlc3QodmFsdWUpIC8vIHNpbmdsZSBxdW90ZWQgc3RyaW5nIGNhbid0IGhhdmUgbGVhZGluZyBvciB0cmFpbGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBuZXdsaW5lXG4gICAgKVxuICAgICAgICByZXR1cm4gZG91YmxlUXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpO1xuICAgIGNvbnN0IGluZGVudCA9IGN0eC5pbmRlbnQgfHwgKGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpID8gJyAgJyA6ICcnKTtcbiAgICBjb25zdCByZXMgPSBcIidcIiArIHZhbHVlLnJlcGxhY2UoLycvZywgXCInJ1wiKS5yZXBsYWNlKC9cXG4rL2csIGAkJlxcbiR7aW5kZW50fWApICsgXCInXCI7XG4gICAgcmV0dXJuIGN0eC5pbXBsaWNpdEtleVxuICAgICAgICA/IHJlc1xuICAgICAgICA6IGZvbGRGbG93TGluZXMocmVzLCBpbmRlbnQsIEZPTERfRkxPVywgZ2V0Rm9sZE9wdGlvbnMoY3R4KSk7XG59XG5mdW5jdGlvbiBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eCkge1xuICAgIGNvbnN0IHsgc2luZ2xlUXVvdGUgfSA9IGN0eC5vcHRpb25zO1xuICAgIGxldCBxcztcbiAgICBpZiAoc2luZ2xlUXVvdGUgPT09IGZhbHNlKVxuICAgICAgICBxcyA9IGRvdWJsZVF1b3RlZFN0cmluZztcbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgaGFzRG91YmxlID0gdmFsdWUuaW5jbHVkZXMoJ1wiJyk7XG4gICAgICAgIGNvbnN0IGhhc1NpbmdsZSA9IHZhbHVlLmluY2x1ZGVzKFwiJ1wiKTtcbiAgICAgICAgaWYgKGhhc0RvdWJsZSAmJiAhaGFzU2luZ2xlKVxuICAgICAgICAgICAgcXMgPSBzaW5nbGVRdW90ZWRTdHJpbmc7XG4gICAgICAgIGVsc2UgaWYgKGhhc1NpbmdsZSAmJiAhaGFzRG91YmxlKVxuICAgICAgICAgICAgcXMgPSBkb3VibGVRdW90ZWRTdHJpbmc7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHFzID0gc2luZ2xlUXVvdGUgPyBzaW5nbGVRdW90ZWRTdHJpbmcgOiBkb3VibGVRdW90ZWRTdHJpbmc7XG4gICAgfVxuICAgIHJldHVybiBxcyh2YWx1ZSwgY3R4KTtcbn1cbmZ1bmN0aW9uIGJsb2NrU3RyaW5nKHsgY29tbWVudCwgdHlwZSwgdmFsdWUgfSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgY29uc3QgeyBibG9ja1F1b3RlLCBjb21tZW50U3RyaW5nLCBsaW5lV2lkdGggfSA9IGN0eC5vcHRpb25zO1xuICAgIC8vIDEuIEJsb2NrIGNhbid0IGVuZCBpbiB3aGl0ZXNwYWNlIHVubGVzcyB0aGUgbGFzdCBsaW5lIGlzIG5vbi1lbXB0eS5cbiAgICAvLyAyLiBTdHJpbmdzIGNvbnNpc3Rpbmcgb2Ygb25seSB3aGl0ZXNwYWNlIGFyZSBiZXN0IHJlbmRlcmVkIGV4cGxpY2l0bHkuXG4gICAgaWYgKCFibG9ja1F1b3RlIHx8IC9cXG5bXFx0IF0rJC8udGVzdCh2YWx1ZSkgfHwgL15cXHMqJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgICB9XG4gICAgY29uc3QgaW5kZW50ID0gY3R4LmluZGVudCB8fFxuICAgICAgICAoY3R4LmZvcmNlQmxvY2tJbmRlbnQgfHwgY29udGFpbnNEb2N1bWVudE1hcmtlcih2YWx1ZSkgPyAnICAnIDogJycpO1xuICAgIGNvbnN0IGxpdGVyYWwgPSBibG9ja1F1b3RlID09PSAnbGl0ZXJhbCdcbiAgICAgICAgPyB0cnVlXG4gICAgICAgIDogYmxvY2tRdW90ZSA9PT0gJ2ZvbGRlZCcgfHwgdHlwZSA9PT0gU2NhbGFyLkJMT0NLX0ZPTERFRFxuICAgICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgICAgOiB0eXBlID09PSBTY2FsYXIuQkxPQ0tfTElURVJBTFxuICAgICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICAgIDogIWxpbmVMZW5ndGhPdmVyTGltaXQodmFsdWUsIGxpbmVXaWR0aCwgaW5kZW50Lmxlbmd0aCk7XG4gICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgcmV0dXJuIGxpdGVyYWwgPyAnfFxcbicgOiAnPlxcbic7XG4gICAgLy8gZGV0ZXJtaW5lIGNob21waW5nIGZyb20gd2hpdGVzcGFjZSBhdCB2YWx1ZSBlbmRcbiAgICBsZXQgY2hvbXA7XG4gICAgbGV0IGVuZFN0YXJ0O1xuICAgIGZvciAoZW5kU3RhcnQgPSB2YWx1ZS5sZW5ndGg7IGVuZFN0YXJ0ID4gMDsgLS1lbmRTdGFydCkge1xuICAgICAgICBjb25zdCBjaCA9IHZhbHVlW2VuZFN0YXJ0IC0gMV07XG4gICAgICAgIGlmIChjaCAhPT0gJ1xcbicgJiYgY2ggIT09ICdcXHQnICYmIGNoICE9PSAnICcpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IGVuZCA9IHZhbHVlLnN1YnN0cmluZyhlbmRTdGFydCk7XG4gICAgY29uc3QgZW5kTmxQb3MgPSBlbmQuaW5kZXhPZignXFxuJyk7XG4gICAgaWYgKGVuZE5sUG9zID09PSAtMSkge1xuICAgICAgICBjaG9tcCA9ICctJzsgLy8gc3RyaXBcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgPT09IGVuZCB8fCBlbmRObFBvcyAhPT0gZW5kLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgY2hvbXAgPSAnKyc7IC8vIGtlZXBcbiAgICAgICAgaWYgKG9uQ2hvbXBLZWVwKVxuICAgICAgICAgICAgb25DaG9tcEtlZXAoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNob21wID0gJyc7IC8vIGNsaXBcbiAgICB9XG4gICAgaWYgKGVuZCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIC1lbmQubGVuZ3RoKTtcbiAgICAgICAgaWYgKGVuZFtlbmQubGVuZ3RoIC0gMV0gPT09ICdcXG4nKVxuICAgICAgICAgICAgZW5kID0gZW5kLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgZW5kID0gZW5kLnJlcGxhY2UoL1xcbisoPyFcXG58JCkvZywgYCQmJHtpbmRlbnR9YCk7XG4gICAgfVxuICAgIC8vIGRldGVybWluZSBpbmRlbnQgaW5kaWNhdG9yIGZyb20gd2hpdGVzcGFjZSBhdCB2YWx1ZSBzdGFydFxuICAgIGxldCBzdGFydFdpdGhTcGFjZSA9IGZhbHNlO1xuICAgIGxldCBzdGFydEVuZDtcbiAgICBsZXQgc3RhcnRObFBvcyA9IC0xO1xuICAgIGZvciAoc3RhcnRFbmQgPSAwOyBzdGFydEVuZCA8IHZhbHVlLmxlbmd0aDsgKytzdGFydEVuZCkge1xuICAgICAgICBjb25zdCBjaCA9IHZhbHVlW3N0YXJ0RW5kXTtcbiAgICAgICAgaWYgKGNoID09PSAnICcpXG4gICAgICAgICAgICBzdGFydFdpdGhTcGFjZSA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnXFxuJylcbiAgICAgICAgICAgIHN0YXJ0TmxQb3MgPSBzdGFydEVuZDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCBzdGFydCA9IHZhbHVlLnN1YnN0cmluZygwLCBzdGFydE5sUG9zIDwgc3RhcnRFbmQgPyBzdGFydE5sUG9zICsgMSA6IHN0YXJ0RW5kKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoc3RhcnQubGVuZ3RoKTtcbiAgICAgICAgc3RhcnQgPSBzdGFydC5yZXBsYWNlKC9cXG4rL2csIGAkJiR7aW5kZW50fWApO1xuICAgIH1cbiAgICBjb25zdCBpbmRlbnRTaXplID0gaW5kZW50ID8gJzInIDogJzEnOyAvLyByb290IGlzIGF0IC0xXG4gICAgbGV0IGhlYWRlciA9IChsaXRlcmFsID8gJ3wnIDogJz4nKSArIChzdGFydFdpdGhTcGFjZSA/IGluZGVudFNpemUgOiAnJykgKyBjaG9tcDtcbiAgICBpZiAoY29tbWVudCkge1xuICAgICAgICBoZWFkZXIgKz0gJyAnICsgY29tbWVudFN0cmluZyhjb21tZW50LnJlcGxhY2UoLyA/W1xcclxcbl0rL2csICcgJykpO1xuICAgICAgICBpZiAob25Db21tZW50KVxuICAgICAgICAgICAgb25Db21tZW50KCk7XG4gICAgfVxuICAgIGlmIChsaXRlcmFsKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxuKy9nLCBgJCYke2luZGVudH1gKTtcbiAgICAgICAgcmV0dXJuIGAke2hlYWRlcn1cXG4ke2luZGVudH0ke3N0YXJ0fSR7dmFsdWV9JHtlbmR9YDtcbiAgICB9XG4gICAgdmFsdWUgPSB2YWx1ZVxuICAgICAgICAucmVwbGFjZSgvXFxuKy9nLCAnXFxuJCYnKVxuICAgICAgICAucmVwbGFjZSgvKD86XnxcXG4pKFtcXHQgXS4qKSg/OihbXFxuXFx0IF0qKVxcbig/IVtcXG5cXHQgXSkpPy9nLCAnJDEkMicpIC8vIG1vcmUtaW5kZW50ZWQgbGluZXMgYXJlbid0IGZvbGRlZFxuICAgICAgICAvLyAgICAgICAgICAgICAgICBeIG1vcmUtaW5kLiBeIGVtcHR5ICAgICBeIGNhcHR1cmUgbmV4dCBlbXB0eSBsaW5lcyBvbmx5IGF0IGVuZCBvZiBpbmRlbnRcbiAgICAgICAgLnJlcGxhY2UoL1xcbisvZywgYCQmJHtpbmRlbnR9YCk7XG4gICAgY29uc3QgYm9keSA9IGZvbGRGbG93TGluZXMoYCR7c3RhcnR9JHt2YWx1ZX0ke2VuZH1gLCBpbmRlbnQsIEZPTERfQkxPQ0ssIGdldEZvbGRPcHRpb25zKGN0eCkpO1xuICAgIHJldHVybiBgJHtoZWFkZXJ9XFxuJHtpbmRlbnR9JHtib2R5fWA7XG59XG5mdW5jdGlvbiBwbGFpblN0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICBjb25zdCB7IHR5cGUsIHZhbHVlIH0gPSBpdGVtO1xuICAgIGNvbnN0IHsgYWN0dWFsU3RyaW5nLCBpbXBsaWNpdEtleSwgaW5kZW50LCBpbkZsb3cgfSA9IGN0eDtcbiAgICBpZiAoKGltcGxpY2l0S2V5ICYmIC9bXFxuW1xcXXt9LF0vLnRlc3QodmFsdWUpKSB8fFxuICAgICAgICAoaW5GbG93ICYmIC9bW1xcXXt9LF0vLnRlc3QodmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gcXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpO1xuICAgIH1cbiAgICBpZiAoIXZhbHVlIHx8XG4gICAgICAgIC9eW1xcblxcdCAsW1xcXXt9IyYqIXw+J1wiJUBgXXxeWz8tXSR8Xls/LV1bIFxcdF18W1xcbjpdWyBcXHRdfFsgXFx0XVxcbnxbXFxuXFx0IF0jfFtcXG5cXHQgOl0kLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAvLyBub3QgYWxsb3dlZDpcbiAgICAgICAgLy8gLSBlbXB0eSBzdHJpbmcsICctJyBvciAnPydcbiAgICAgICAgLy8gLSBzdGFydCB3aXRoIGFuIGluZGljYXRvciBjaGFyYWN0ZXIgKGV4Y2VwdCBbPzotXSkgb3IgL1s/LV0gL1xuICAgICAgICAvLyAtICdcXG4gJywgJzogJyBvciAnIFxcbicgYW55d2hlcmVcbiAgICAgICAgLy8gLSAnIycgbm90IHByZWNlZGVkIGJ5IGEgbm9uLXNwYWNlIGNoYXJcbiAgICAgICAgLy8gLSBlbmQgd2l0aCAnICcgb3IgJzonXG4gICAgICAgIHJldHVybiBpbXBsaWNpdEtleSB8fCBpbkZsb3cgfHwgIXZhbHVlLmluY2x1ZGVzKCdcXG4nKVxuICAgICAgICAgICAgPyBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eClcbiAgICAgICAgICAgIDogYmxvY2tTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICB9XG4gICAgaWYgKCFpbXBsaWNpdEtleSAmJlxuICAgICAgICAhaW5GbG93ICYmXG4gICAgICAgIHR5cGUgIT09IFNjYWxhci5QTEFJTiAmJlxuICAgICAgICB2YWx1ZS5pbmNsdWRlcygnXFxuJykpIHtcbiAgICAgICAgLy8gV2hlcmUgYWxsb3dlZCAmIHR5cGUgbm90IHNldCBleHBsaWNpdGx5LCBwcmVmZXIgYmxvY2sgc3R5bGUgZm9yIG11bHRpbGluZSBzdHJpbmdzXG4gICAgICAgIHJldHVybiBibG9ja1N0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIH1cbiAgICBpZiAoaW5kZW50ID09PSAnJyAmJiBjb250YWluc0RvY3VtZW50TWFya2VyKHZhbHVlKSkge1xuICAgICAgICBjdHguZm9yY2VCbG9ja0luZGVudCA9IHRydWU7XG4gICAgICAgIHJldHVybiBibG9ja1N0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIH1cbiAgICBjb25zdCBzdHIgPSB2YWx1ZS5yZXBsYWNlKC9cXG4rL2csIGAkJlxcbiR7aW5kZW50fWApO1xuICAgIC8vIFZlcmlmeSB0aGF0IG91dHB1dCB3aWxsIGJlIHBhcnNlZCBhcyBhIHN0cmluZywgYXMgZS5nLiBwbGFpbiBudW1iZXJzIGFuZFxuICAgIC8vIGJvb2xlYW5zIGdldCBwYXJzZWQgd2l0aCB0aG9zZSB0eXBlcyBpbiB2MS4yIChlLmcuICc0MicsICd0cnVlJyAmICcwLjllLTMnKSxcbiAgICAvLyBhbmQgb3RoZXJzIGluIHYxLjEuXG4gICAgaWYgKGFjdHVhbFN0cmluZykge1xuICAgICAgICBjb25zdCB0ZXN0ID0gKHRhZykgPT4gdGFnLmRlZmF1bHQgJiYgdGFnLnRhZyAhPT0gJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicgJiYgdGFnLnRlc3Q/LnRlc3Qoc3RyKTtcbiAgICAgICAgY29uc3QgeyBjb21wYXQsIHRhZ3MgfSA9IGN0eC5kb2Muc2NoZW1hO1xuICAgICAgICBpZiAodGFncy5zb21lKHRlc3QpIHx8IGNvbXBhdD8uc29tZSh0ZXN0KSlcbiAgICAgICAgICAgIHJldHVybiBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gICAgfVxuICAgIHJldHVybiBpbXBsaWNpdEtleVxuICAgICAgICA/IHN0clxuICAgICAgICA6IGZvbGRGbG93TGluZXMoc3RyLCBpbmRlbnQsIEZPTERfRkxPVywgZ2V0Rm9sZE9wdGlvbnMoY3R4KSk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgY29uc3QgeyBpbXBsaWNpdEtleSwgaW5GbG93IH0gPSBjdHg7XG4gICAgY29uc3Qgc3MgPSB0eXBlb2YgaXRlbS52YWx1ZSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBpdGVtXG4gICAgICAgIDogT2JqZWN0LmFzc2lnbih7fSwgaXRlbSwgeyB2YWx1ZTogU3RyaW5nKGl0ZW0udmFsdWUpIH0pO1xuICAgIGxldCB7IHR5cGUgfSA9IGl0ZW07XG4gICAgaWYgKHR5cGUgIT09IFNjYWxhci5RVU9URV9ET1VCTEUpIHtcbiAgICAgICAgLy8gZm9yY2UgZG91YmxlIHF1b3RlcyBvbiBjb250cm9sIGNoYXJhY3RlcnMgJiB1bnBhaXJlZCBzdXJyb2dhdGVzXG4gICAgICAgIGlmICgvW1xceDAwLVxceDA4XFx4MGItXFx4MWZcXHg3Zi1cXHg5ZlxcdXtEODAwfS1cXHV7REZGRn1dL3UudGVzdChzcy52YWx1ZSkpXG4gICAgICAgICAgICB0eXBlID0gU2NhbGFyLlFVT1RFX0RPVUJMRTtcbiAgICB9XG4gICAgY29uc3QgX3N0cmluZ2lmeSA9IChfdHlwZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKF90eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFNjYWxhci5CTE9DS19GT0xERUQ6XG4gICAgICAgICAgICBjYXNlIFNjYWxhci5CTE9DS19MSVRFUkFMOlxuICAgICAgICAgICAgICAgIHJldHVybiBpbXBsaWNpdEtleSB8fCBpbkZsb3dcbiAgICAgICAgICAgICAgICAgICAgPyBxdW90ZWRTdHJpbmcoc3MudmFsdWUsIGN0eCkgLy8gYmxvY2tzIGFyZSBub3QgdmFsaWQgaW5zaWRlIGZsb3cgY29udGFpbmVyc1xuICAgICAgICAgICAgICAgICAgICA6IGJsb2NrU3RyaW5nKHNzLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXIuUVVPVEVfRE9VQkxFOlxuICAgICAgICAgICAgICAgIHJldHVybiBkb3VibGVRdW90ZWRTdHJpbmcoc3MudmFsdWUsIGN0eCk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhci5RVU9URV9TSU5HTEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpbmdsZVF1b3RlZFN0cmluZyhzcy52YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyLlBMQUlOOlxuICAgICAgICAgICAgICAgIHJldHVybiBwbGFpblN0cmluZyhzcywgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCByZXMgPSBfc3RyaW5naWZ5KHR5cGUpO1xuICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0S2V5VHlwZSwgZGVmYXVsdFN0cmluZ1R5cGUgfSA9IGN0eC5vcHRpb25zO1xuICAgICAgICBjb25zdCB0ID0gKGltcGxpY2l0S2V5ICYmIGRlZmF1bHRLZXlUeXBlKSB8fCBkZWZhdWx0U3RyaW5nVHlwZTtcbiAgICAgICAgcmVzID0gX3N0cmluZ2lmeSh0KTtcbiAgICAgICAgaWYgKHJlcyA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVmYXVsdCBzdHJpbmcgdHlwZSAke3R9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmV4cG9ydCB7IHN0cmluZ2lmeVN0cmluZyB9O1xuIiwgImltcG9ydCB7IGFuY2hvcklzVmFsaWQgfSBmcm9tICcuLi9kb2MvYW5jaG9ycy5qcyc7XG5pbXBvcnQgeyBpc1BhaXIsIGlzQWxpYXMsIGlzTm9kZSwgaXNTY2FsYXIsIGlzQ29sbGVjdGlvbiB9IGZyb20gJy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5Q29tbWVudCB9IGZyb20gJy4vc3RyaW5naWZ5Q29tbWVudC5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnlTdHJpbmcgfSBmcm9tICcuL3N0cmluZ2lmeVN0cmluZy5qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0cmluZ2lmeUNvbnRleHQoZG9jLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGJsb2NrUXVvdGU6IHRydWUsXG4gICAgICAgIGNvbW1lbnRTdHJpbmc6IHN0cmluZ2lmeUNvbW1lbnQsXG4gICAgICAgIGRlZmF1bHRLZXlUeXBlOiBudWxsLFxuICAgICAgICBkZWZhdWx0U3RyaW5nVHlwZTogJ1BMQUlOJyxcbiAgICAgICAgZGlyZWN0aXZlczogbnVsbCxcbiAgICAgICAgZG91YmxlUXVvdGVkQXNKU09OOiBmYWxzZSxcbiAgICAgICAgZG91YmxlUXVvdGVkTWluTXVsdGlMaW5lTGVuZ3RoOiA0MCxcbiAgICAgICAgZmFsc2VTdHI6ICdmYWxzZScsXG4gICAgICAgIGluZGVudFNlcTogdHJ1ZSxcbiAgICAgICAgbGluZVdpZHRoOiA4MCxcbiAgICAgICAgbWluQ29udGVudFdpZHRoOiAyMCxcbiAgICAgICAgbnVsbFN0cjogJ251bGwnLFxuICAgICAgICBzaW1wbGVLZXlzOiBmYWxzZSxcbiAgICAgICAgc2luZ2xlUXVvdGU6IG51bGwsXG4gICAgICAgIHRydWVTdHI6ICd0cnVlJyxcbiAgICAgICAgdmVyaWZ5QWxpYXNPcmRlcjogdHJ1ZVxuICAgIH0sIGRvYy5zY2hlbWEudG9TdHJpbmdPcHRpb25zLCBvcHRpb25zKTtcbiAgICBsZXQgaW5GbG93O1xuICAgIHN3aXRjaCAob3B0LmNvbGxlY3Rpb25TdHlsZSkge1xuICAgICAgICBjYXNlICdibG9jayc6XG4gICAgICAgICAgICBpbkZsb3cgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmbG93JzpcbiAgICAgICAgICAgIGluRmxvdyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGluRmxvdyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGFuY2hvcnM6IG5ldyBTZXQoKSxcbiAgICAgICAgZG9jLFxuICAgICAgICBpbmRlbnQ6ICcnLFxuICAgICAgICBpbmRlbnRTdGVwOiB0eXBlb2Ygb3B0LmluZGVudCA9PT0gJ251bWJlcicgPyAnICcucmVwZWF0KG9wdC5pbmRlbnQpIDogJyAgJyxcbiAgICAgICAgaW5GbG93LFxuICAgICAgICBvcHRpb25zOiBvcHRcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0VGFnT2JqZWN0KHRhZ3MsIGl0ZW0pIHtcbiAgICBpZiAoaXRlbS50YWcpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0YWdzLmZpbHRlcih0ID0+IHQudGFnID09PSBpdGVtLnRhZyk7XG4gICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAwKVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoLmZpbmQodCA9PiB0LmZvcm1hdCA9PT0gaXRlbS5mb3JtYXQpID8/IG1hdGNoWzBdO1xuICAgIH1cbiAgICBsZXQgdGFnT2JqID0gdW5kZWZpbmVkO1xuICAgIGxldCBvYmo7XG4gICAgaWYgKGlzU2NhbGFyKGl0ZW0pKSB7XG4gICAgICAgIG9iaiA9IGl0ZW0udmFsdWU7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGFncy5maWx0ZXIodCA9PiB0LmlkZW50aWZ5Py4ob2JqKSk7XG4gICAgICAgIHRhZ09iaiA9XG4gICAgICAgICAgICBtYXRjaC5maW5kKHQgPT4gdC5mb3JtYXQgPT09IGl0ZW0uZm9ybWF0KSA/PyBtYXRjaC5maW5kKHQgPT4gIXQuZm9ybWF0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9iaiA9IGl0ZW07XG4gICAgICAgIHRhZ09iaiA9IHRhZ3MuZmluZCh0ID0+IHQubm9kZUNsYXNzICYmIG9iaiBpbnN0YW5jZW9mIHQubm9kZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKCF0YWdPYmopIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IG9iaj8uY29uc3RydWN0b3I/Lm5hbWUgPz8gdHlwZW9mIG9iajtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYWcgbm90IHJlc29sdmVkIGZvciAke25hbWV9IHZhbHVlYCk7XG4gICAgfVxuICAgIHJldHVybiB0YWdPYmo7XG59XG4vLyBuZWVkcyB0byBiZSBjYWxsZWQgYmVmb3JlIHZhbHVlIHN0cmluZ2lmaWVyIHRvIGFsbG93IGZvciBjaXJjdWxhciBhbmNob3IgcmVmc1xuZnVuY3Rpb24gc3RyaW5naWZ5UHJvcHMobm9kZSwgdGFnT2JqLCB7IGFuY2hvcnMsIGRvYyB9KSB7XG4gICAgaWYgKCFkb2MuZGlyZWN0aXZlcylcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGNvbnN0IHByb3BzID0gW107XG4gICAgY29uc3QgYW5jaG9yID0gKGlzU2NhbGFyKG5vZGUpIHx8IGlzQ29sbGVjdGlvbihub2RlKSkgJiYgbm9kZS5hbmNob3I7XG4gICAgaWYgKGFuY2hvciAmJiBhbmNob3JJc1ZhbGlkKGFuY2hvcikpIHtcbiAgICAgICAgYW5jaG9ycy5hZGQoYW5jaG9yKTtcbiAgICAgICAgcHJvcHMucHVzaChgJiR7YW5jaG9yfWApO1xuICAgIH1cbiAgICBjb25zdCB0YWcgPSBub2RlLnRhZyA/IG5vZGUudGFnIDogdGFnT2JqLmRlZmF1bHQgPyBudWxsIDogdGFnT2JqLnRhZztcbiAgICBpZiAodGFnKVxuICAgICAgICBwcm9wcy5wdXNoKGRvYy5kaXJlY3RpdmVzLnRhZ1N0cmluZyh0YWcpKTtcbiAgICByZXR1cm4gcHJvcHMuam9pbignICcpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGlmIChpc1BhaXIoaXRlbSkpXG4gICAgICAgIHJldHVybiBpdGVtLnRvU3RyaW5nKGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gICAgaWYgKGlzQWxpYXMoaXRlbSkpIHtcbiAgICAgICAgaWYgKGN0eC5kb2MuZGlyZWN0aXZlcylcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnRvU3RyaW5nKGN0eCk7XG4gICAgICAgIGlmIChjdHgucmVzb2x2ZWRBbGlhc2VzPy5oYXMoaXRlbSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbm5vdCBzdHJpbmdpZnkgY2lyY3VsYXIgc3RydWN0dXJlIHdpdGhvdXQgYWxpYXMgbm9kZXNgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdHgucmVzb2x2ZWRBbGlhc2VzKVxuICAgICAgICAgICAgICAgIGN0eC5yZXNvbHZlZEFsaWFzZXMuYWRkKGl0ZW0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGN0eC5yZXNvbHZlZEFsaWFzZXMgPSBuZXcgU2V0KFtpdGVtXSk7XG4gICAgICAgICAgICBpdGVtID0gaXRlbS5yZXNvbHZlKGN0eC5kb2MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCB0YWdPYmogPSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgbm9kZSA9IGlzTm9kZShpdGVtKVxuICAgICAgICA/IGl0ZW1cbiAgICAgICAgOiBjdHguZG9jLmNyZWF0ZU5vZGUoaXRlbSwgeyBvblRhZ09iajogbyA9PiAodGFnT2JqID0gbykgfSk7XG4gICAgaWYgKCF0YWdPYmopXG4gICAgICAgIHRhZ09iaiA9IGdldFRhZ09iamVjdChjdHguZG9jLnNjaGVtYS50YWdzLCBub2RlKTtcbiAgICBjb25zdCBwcm9wcyA9IHN0cmluZ2lmeVByb3BzKG5vZGUsIHRhZ09iaiwgY3R4KTtcbiAgICBpZiAocHJvcHMubGVuZ3RoID4gMClcbiAgICAgICAgY3R4LmluZGVudEF0U3RhcnQgPSAoY3R4LmluZGVudEF0U3RhcnQgPz8gMCkgKyBwcm9wcy5sZW5ndGggKyAxO1xuICAgIGNvbnN0IHN0ciA9IHR5cGVvZiB0YWdPYmouc3RyaW5naWZ5ID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gdGFnT2JqLnN0cmluZ2lmeShub2RlLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApXG4gICAgICAgIDogaXNTY2FsYXIobm9kZSlcbiAgICAgICAgICAgID8gc3RyaW5naWZ5U3RyaW5nKG5vZGUsIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcClcbiAgICAgICAgICAgIDogbm9kZS50b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIGlmICghcHJvcHMpXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgcmV0dXJuIGlzU2NhbGFyKG5vZGUpIHx8IHN0clswXSA9PT0gJ3snIHx8IHN0clswXSA9PT0gJ1snXG4gICAgICAgID8gYCR7cHJvcHN9ICR7c3RyfWBcbiAgICAgICAgOiBgJHtwcm9wc31cXG4ke2N0eC5pbmRlbnR9JHtzdHJ9YDtcbn1cblxuZXhwb3J0IHsgY3JlYXRlU3RyaW5naWZ5Q29udGV4dCwgc3RyaW5naWZ5IH07XG4iLCAiaW1wb3J0IHsgaXNDb2xsZWN0aW9uLCBpc05vZGUsIGlzU2NhbGFyLCBpc1NlcSB9IGZyb20gJy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmltcG9ydCB7IGxpbmVDb21tZW50LCBpbmRlbnRDb21tZW50IH0gZnJvbSAnLi9zdHJpbmdpZnlDb21tZW50LmpzJztcblxuZnVuY3Rpb24gc3RyaW5naWZ5UGFpcih7IGtleSwgdmFsdWUgfSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgY29uc3QgeyBhbGxOdWxsVmFsdWVzLCBkb2MsIGluZGVudCwgaW5kZW50U3RlcCwgb3B0aW9uczogeyBjb21tZW50U3RyaW5nLCBpbmRlbnRTZXEsIHNpbXBsZUtleXMgfSB9ID0gY3R4O1xuICAgIGxldCBrZXlDb21tZW50ID0gKGlzTm9kZShrZXkpICYmIGtleS5jb21tZW50KSB8fCBudWxsO1xuICAgIGlmIChzaW1wbGVLZXlzKSB7XG4gICAgICAgIGlmIChrZXlDb21tZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpdGggc2ltcGxlIGtleXMsIGtleSBub2RlcyBjYW5ub3QgaGF2ZSBjb21tZW50cycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NvbGxlY3Rpb24oa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gJ1dpdGggc2ltcGxlIGtleXMsIGNvbGxlY3Rpb24gY2Fubm90IGJlIHVzZWQgYXMgYSBrZXkgdmFsdWUnO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGV4cGxpY2l0S2V5ID0gIXNpbXBsZUtleXMgJiZcbiAgICAgICAgKCFrZXkgfHxcbiAgICAgICAgICAgIChrZXlDb21tZW50ICYmIHZhbHVlID09IG51bGwgJiYgIWN0eC5pbkZsb3cpIHx8XG4gICAgICAgICAgICBpc0NvbGxlY3Rpb24oa2V5KSB8fFxuICAgICAgICAgICAgKGlzU2NhbGFyKGtleSlcbiAgICAgICAgICAgICAgICA/IGtleS50eXBlID09PSBTY2FsYXIuQkxPQ0tfRk9MREVEIHx8IGtleS50eXBlID09PSBTY2FsYXIuQkxPQ0tfTElURVJBTFxuICAgICAgICAgICAgICAgIDogdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpKTtcbiAgICBjdHggPSBPYmplY3QuYXNzaWduKHt9LCBjdHgsIHtcbiAgICAgICAgYWxsTnVsbFZhbHVlczogZmFsc2UsXG4gICAgICAgIGltcGxpY2l0S2V5OiAhZXhwbGljaXRLZXkgJiYgKHNpbXBsZUtleXMgfHwgIWFsbE51bGxWYWx1ZXMpLFxuICAgICAgICBpbmRlbnQ6IGluZGVudCArIGluZGVudFN0ZXBcbiAgICB9KTtcbiAgICBsZXQga2V5Q29tbWVudERvbmUgPSBmYWxzZTtcbiAgICBsZXQgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgbGV0IHN0ciA9IHN0cmluZ2lmeShrZXksIGN0eCwgKCkgPT4gKGtleUNvbW1lbnREb25lID0gdHJ1ZSksICgpID0+IChjaG9tcEtlZXAgPSB0cnVlKSk7XG4gICAgaWYgKCFleHBsaWNpdEtleSAmJiAhY3R4LmluRmxvdyAmJiBzdHIubGVuZ3RoID4gMTAyNCkge1xuICAgICAgICBpZiAoc2ltcGxlS2V5cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2l0aCBzaW1wbGUga2V5cywgc2luZ2xlIGxpbmUgc2NhbGFyIG11c3Qgbm90IHNwYW4gbW9yZSB0aGFuIDEwMjQgY2hhcmFjdGVycycpO1xuICAgICAgICBleHBsaWNpdEtleSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjdHguaW5GbG93KSB7XG4gICAgICAgIGlmIChhbGxOdWxsVmFsdWVzIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChrZXlDb21tZW50RG9uZSAmJiBvbkNvbW1lbnQpXG4gICAgICAgICAgICAgICAgb25Db21tZW50KCk7XG4gICAgICAgICAgICByZXR1cm4gc3RyID09PSAnJyA/ICc/JyA6IGV4cGxpY2l0S2V5ID8gYD8gJHtzdHJ9YCA6IHN0cjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgoYWxsTnVsbFZhbHVlcyAmJiAhc2ltcGxlS2V5cykgfHwgKHZhbHVlID09IG51bGwgJiYgZXhwbGljaXRLZXkpKSB7XG4gICAgICAgIHN0ciA9IGA/ICR7c3RyfWA7XG4gICAgICAgIGlmIChrZXlDb21tZW50ICYmICFrZXlDb21tZW50RG9uZSkge1xuICAgICAgICAgICAgc3RyICs9IGxpbmVDb21tZW50KHN0ciwgY3R4LmluZGVudCwgY29tbWVudFN0cmluZyhrZXlDb21tZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hvbXBLZWVwICYmIG9uQ2hvbXBLZWVwKVxuICAgICAgICAgICAgb25DaG9tcEtlZXAoKTtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgaWYgKGtleUNvbW1lbnREb25lKVxuICAgICAgICBrZXlDb21tZW50ID0gbnVsbDtcbiAgICBpZiAoZXhwbGljaXRLZXkpIHtcbiAgICAgICAgaWYgKGtleUNvbW1lbnQpXG4gICAgICAgICAgICBzdHIgKz0gbGluZUNvbW1lbnQoc3RyLCBjdHguaW5kZW50LCBjb21tZW50U3RyaW5nKGtleUNvbW1lbnQpKTtcbiAgICAgICAgc3RyID0gYD8gJHtzdHJ9XFxuJHtpbmRlbnR9OmA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdHIgPSBgJHtzdHJ9OmA7XG4gICAgICAgIGlmIChrZXlDb21tZW50KVxuICAgICAgICAgICAgc3RyICs9IGxpbmVDb21tZW50KHN0ciwgY3R4LmluZGVudCwgY29tbWVudFN0cmluZyhrZXlDb21tZW50KSk7XG4gICAgfVxuICAgIGxldCB2Y2IgPSAnJztcbiAgICBsZXQgdmFsdWVDb21tZW50ID0gbnVsbDtcbiAgICBpZiAoaXNOb2RlKHZhbHVlKSkge1xuICAgICAgICBpZiAodmFsdWUuc3BhY2VCZWZvcmUpXG4gICAgICAgICAgICB2Y2IgPSAnXFxuJztcbiAgICAgICAgaWYgKHZhbHVlLmNvbW1lbnRCZWZvcmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNzID0gY29tbWVudFN0cmluZyh2YWx1ZS5jb21tZW50QmVmb3JlKTtcbiAgICAgICAgICAgIHZjYiArPSBgXFxuJHtpbmRlbnRDb21tZW50KGNzLCBjdHguaW5kZW50KX1gO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlQ29tbWVudCA9IHZhbHVlLmNvbW1lbnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFsdWUgPSBkb2MuY3JlYXRlTm9kZSh2YWx1ZSk7XG4gICAgfVxuICAgIGN0eC5pbXBsaWNpdEtleSA9IGZhbHNlO1xuICAgIGlmICghZXhwbGljaXRLZXkgJiYgIWtleUNvbW1lbnQgJiYgaXNTY2FsYXIodmFsdWUpKVxuICAgICAgICBjdHguaW5kZW50QXRTdGFydCA9IHN0ci5sZW5ndGggKyAxO1xuICAgIGNob21wS2VlcCA9IGZhbHNlO1xuICAgIGlmICghaW5kZW50U2VxICYmXG4gICAgICAgIGluZGVudFN0ZXAubGVuZ3RoID49IDIgJiZcbiAgICAgICAgIWN0eC5pbkZsb3cgJiZcbiAgICAgICAgIWV4cGxpY2l0S2V5ICYmXG4gICAgICAgIGlzU2VxKHZhbHVlKSAmJlxuICAgICAgICAhdmFsdWUuZmxvdyAmJlxuICAgICAgICAhdmFsdWUudGFnICYmXG4gICAgICAgICF2YWx1ZS5hbmNob3IpIHtcbiAgICAgICAgLy8gSWYgaW5kZW50U2VxID09PSBmYWxzZSwgY29uc2lkZXIgJy0gJyBhcyBwYXJ0IG9mIGluZGVudGF0aW9uIHdoZXJlIHBvc3NpYmxlXG4gICAgICAgIGN0eC5pbmRlbnQgPSBjdHguaW5kZW50LnN1YnN0cigyKTtcbiAgICB9XG4gICAgbGV0IHZhbHVlQ29tbWVudERvbmUgPSBmYWxzZTtcbiAgICBjb25zdCB2YWx1ZVN0ciA9IHN0cmluZ2lmeSh2YWx1ZSwgY3R4LCAoKSA9PiAodmFsdWVDb21tZW50RG9uZSA9IHRydWUpLCAoKSA9PiAoY2hvbXBLZWVwID0gdHJ1ZSkpO1xuICAgIGxldCB3cyA9ICcgJztcbiAgICBpZiAodmNiIHx8IGtleUNvbW1lbnQpIHtcbiAgICAgICAgaWYgKHZhbHVlU3RyID09PSAnJyAmJiAhY3R4LmluRmxvdylcbiAgICAgICAgICAgIHdzID0gdmNiID09PSAnXFxuJyA/ICdcXG5cXG4nIDogdmNiO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB3cyA9IGAke3ZjYn1cXG4ke2N0eC5pbmRlbnR9YDtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWV4cGxpY2l0S2V5ICYmIGlzQ29sbGVjdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgZmxvdyA9IHZhbHVlU3RyWzBdID09PSAnWycgfHwgdmFsdWVTdHJbMF0gPT09ICd7JztcbiAgICAgICAgaWYgKCFmbG93IHx8IHZhbHVlU3RyLmluY2x1ZGVzKCdcXG4nKSlcbiAgICAgICAgICAgIHdzID0gYFxcbiR7Y3R4LmluZGVudH1gO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZVN0ciA9PT0gJycgfHwgdmFsdWVTdHJbMF0gPT09ICdcXG4nKVxuICAgICAgICB3cyA9ICcnO1xuICAgIHN0ciArPSB3cyArIHZhbHVlU3RyO1xuICAgIGlmIChjdHguaW5GbG93KSB7XG4gICAgICAgIGlmICh2YWx1ZUNvbW1lbnREb25lICYmIG9uQ29tbWVudClcbiAgICAgICAgICAgIG9uQ29tbWVudCgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZUNvbW1lbnQgJiYgIXZhbHVlQ29tbWVudERvbmUpIHtcbiAgICAgICAgc3RyICs9IGxpbmVDb21tZW50KHN0ciwgY3R4LmluZGVudCwgY29tbWVudFN0cmluZyh2YWx1ZUNvbW1lbnQpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hvbXBLZWVwICYmIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIG9uQ2hvbXBLZWVwKCk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5cbmV4cG9ydCB7IHN0cmluZ2lmeVBhaXIgfTtcbiIsICJmdW5jdGlvbiBkZWJ1Zyhsb2dMZXZlbCwgLi4ubWVzc2FnZXMpIHtcbiAgICBpZiAobG9nTGV2ZWwgPT09ICdkZWJ1ZycpXG4gICAgICAgIGNvbnNvbGUubG9nKC4uLm1lc3NhZ2VzKTtcbn1cbmZ1bmN0aW9uIHdhcm4obG9nTGV2ZWwsIHdhcm5pbmcpIHtcbiAgICBpZiAobG9nTGV2ZWwgPT09ICdkZWJ1ZycgfHwgbG9nTGV2ZWwgPT09ICd3YXJuJykge1xuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW1pdFdhcm5pbmcpXG4gICAgICAgICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKHdhcm5pbmcpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4od2FybmluZyk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBkZWJ1Zywgd2FybiB9O1xuIiwgImltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi9sb2cuanMnO1xuaW1wb3J0IHsgY3JlYXRlU3RyaW5naWZ5Q29udGV4dCB9IGZyb20gJy4uL3N0cmluZ2lmeS9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHsgaXNBbGlhcywgaXNTZXEsIGlzU2NhbGFyLCBpc01hcCwgaXNOb2RlIH0gZnJvbSAnLi9Ob2RlLmpzJztcbmltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4vU2NhbGFyLmpzJztcbmltcG9ydCB7IHRvSlMgfSBmcm9tICcuL3RvSlMuanMnO1xuXG5jb25zdCBNRVJHRV9LRVkgPSAnPDwnO1xuZnVuY3Rpb24gYWRkUGFpclRvSlNNYXAoY3R4LCBtYXAsIHsga2V5LCB2YWx1ZSB9KSB7XG4gICAgaWYgKGN0eD8uZG9jLnNjaGVtYS5tZXJnZSAmJiBpc01lcmdlS2V5KGtleSkpIHtcbiAgICAgICAgdmFsdWUgPSBpc0FsaWFzKHZhbHVlKSA/IHZhbHVlLnJlc29sdmUoY3R4LmRvYykgOiB2YWx1ZTtcbiAgICAgICAgaWYgKGlzU2VxKHZhbHVlKSlcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXQgb2YgdmFsdWUuaXRlbXMpXG4gICAgICAgICAgICAgICAgbWVyZ2VUb0pTTWFwKGN0eCwgbWFwLCBpdCk7XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgZm9yIChjb25zdCBpdCBvZiB2YWx1ZSlcbiAgICAgICAgICAgICAgICBtZXJnZVRvSlNNYXAoY3R4LCBtYXAsIGl0KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbWVyZ2VUb0pTTWFwKGN0eCwgbWFwLCB2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBqc0tleSA9IHRvSlMoa2V5LCAnJywgY3R4KTtcbiAgICAgICAgaWYgKG1hcCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgbWFwLnNldChqc0tleSwgdG9KUyh2YWx1ZSwganNLZXksIGN0eCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hcCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgbWFwLmFkZChqc0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzdHJpbmdLZXkgPSBzdHJpbmdpZnlLZXkoa2V5LCBqc0tleSwgY3R4KTtcbiAgICAgICAgICAgIGNvbnN0IGpzVmFsdWUgPSB0b0pTKHZhbHVlLCBzdHJpbmdLZXksIGN0eCk7XG4gICAgICAgICAgICBpZiAoc3RyaW5nS2V5IGluIG1hcClcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWFwLCBzdHJpbmdLZXksIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGpzVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtYXBbc3RyaW5nS2V5XSA9IGpzVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbn1cbmNvbnN0IGlzTWVyZ2VLZXkgPSAoa2V5KSA9PiBrZXkgPT09IE1FUkdFX0tFWSB8fFxuICAgIChpc1NjYWxhcihrZXkpICYmXG4gICAgICAgIGtleS52YWx1ZSA9PT0gTUVSR0VfS0VZICYmXG4gICAgICAgICgha2V5LnR5cGUgfHwga2V5LnR5cGUgPT09IFNjYWxhci5QTEFJTikpO1xuLy8gSWYgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBhIG1lcmdlIGtleSBpcyBhIHNpbmdsZSBtYXBwaW5nIG5vZGUsIGVhY2ggb2Zcbi8vIGl0cyBrZXkvdmFsdWUgcGFpcnMgaXMgaW5zZXJ0ZWQgaW50byB0aGUgY3VycmVudCBtYXBwaW5nLCB1bmxlc3MgdGhlIGtleVxuLy8gYWxyZWFkeSBleGlzdHMgaW4gaXQuIElmIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIG1lcmdlIGtleSBpcyBhXG4vLyBzZXF1ZW5jZSwgdGhlbiB0aGlzIHNlcXVlbmNlIGlzIGV4cGVjdGVkIHRvIGNvbnRhaW4gbWFwcGluZyBub2RlcyBhbmQgZWFjaFxuLy8gb2YgdGhlc2Ugbm9kZXMgaXMgbWVyZ2VkIGluIHR1cm4gYWNjb3JkaW5nIHRvIGl0cyBvcmRlciBpbiB0aGUgc2VxdWVuY2UuXG4vLyBLZXlzIGluIG1hcHBpbmcgbm9kZXMgZWFybGllciBpbiB0aGUgc2VxdWVuY2Ugb3ZlcnJpZGUga2V5cyBzcGVjaWZpZWQgaW5cbi8vIGxhdGVyIG1hcHBpbmcgbm9kZXMuIC0tIGh0dHA6Ly95YW1sLm9yZy90eXBlL21lcmdlLmh0bWxcbmZ1bmN0aW9uIG1lcmdlVG9KU01hcChjdHgsIG1hcCwgdmFsdWUpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBjdHggJiYgaXNBbGlhcyh2YWx1ZSkgPyB2YWx1ZS5yZXNvbHZlKGN0eC5kb2MpIDogdmFsdWU7XG4gICAgaWYgKCFpc01hcChzb3VyY2UpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lcmdlIHNvdXJjZXMgbXVzdCBiZSBtYXBzIG9yIG1hcCBhbGlhc2VzJyk7XG4gICAgY29uc3Qgc3JjTWFwID0gc291cmNlLnRvSlNPTihudWxsLCBjdHgsIE1hcCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3JjTWFwKSB7XG4gICAgICAgIGlmIChtYXAgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIGlmICghbWFwLmhhcyhrZXkpKVxuICAgICAgICAgICAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWFwIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICBtYXAuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIGtleSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtYXAsIGtleSwge1xuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5S2V5KGtleSwganNLZXksIGN0eCkge1xuICAgIGlmIChqc0tleSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGlmICh0eXBlb2YganNLZXkgIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gU3RyaW5nKGpzS2V5KTtcbiAgICBpZiAoaXNOb2RlKGtleSkgJiYgY3R4ICYmIGN0eC5kb2MpIHtcbiAgICAgICAgY29uc3Qgc3RyQ3R4ID0gY3JlYXRlU3RyaW5naWZ5Q29udGV4dChjdHguZG9jLCB7fSk7XG4gICAgICAgIHN0ckN0eC5hbmNob3JzID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgY3R4LmFuY2hvcnMua2V5cygpKVxuICAgICAgICAgICAgc3RyQ3R4LmFuY2hvcnMuYWRkKG5vZGUuYW5jaG9yKTtcbiAgICAgICAgc3RyQ3R4LmluRmxvdyA9IHRydWU7XG4gICAgICAgIHN0ckN0eC5pblN0cmluZ2lmeUtleSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHN0cktleSA9IGtleS50b1N0cmluZyhzdHJDdHgpO1xuICAgICAgICBpZiAoIWN0eC5tYXBLZXlXYXJuZWQpIHtcbiAgICAgICAgICAgIGxldCBqc29uU3RyID0gSlNPTi5zdHJpbmdpZnkoc3RyS2V5KTtcbiAgICAgICAgICAgIGlmIChqc29uU3RyLmxlbmd0aCA+IDQwKVxuICAgICAgICAgICAgICAgIGpzb25TdHIgPSBqc29uU3RyLnN1YnN0cmluZygwLCAzNikgKyAnLi4uXCInO1xuICAgICAgICAgICAgd2FybihjdHguZG9jLm9wdGlvbnMubG9nTGV2ZWwsIGBLZXlzIHdpdGggY29sbGVjdGlvbiB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZCBkdWUgdG8gSlMgT2JqZWN0IHJlc3RyaWN0aW9uczogJHtqc29uU3RyfS4gU2V0IG1hcEFzTWFwOiB0cnVlIHRvIHVzZSBvYmplY3Qga2V5cy5gKTtcbiAgICAgICAgICAgIGN0eC5tYXBLZXlXYXJuZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJLZXk7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShqc0tleSk7XG59XG5cbmV4cG9ydCB7IGFkZFBhaXJUb0pTTWFwIH07XG4iLCAiaW1wb3J0IHsgY3JlYXRlTm9kZSB9IGZyb20gJy4uL2RvYy9jcmVhdGVOb2RlLmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeVBhaXIgfSBmcm9tICcuLi9zdHJpbmdpZnkvc3RyaW5naWZ5UGFpci5qcyc7XG5pbXBvcnQgeyBhZGRQYWlyVG9KU01hcCB9IGZyb20gJy4vYWRkUGFpclRvSlNNYXAuanMnO1xuaW1wb3J0IHsgTk9ERV9UWVBFLCBQQUlSLCBpc05vZGUgfSBmcm9tICcuL05vZGUuanMnO1xuXG5mdW5jdGlvbiBjcmVhdGVQYWlyKGtleSwgdmFsdWUsIGN0eCkge1xuICAgIGNvbnN0IGsgPSBjcmVhdGVOb2RlKGtleSwgdW5kZWZpbmVkLCBjdHgpO1xuICAgIGNvbnN0IHYgPSBjcmVhdGVOb2RlKHZhbHVlLCB1bmRlZmluZWQsIGN0eCk7XG4gICAgcmV0dXJuIG5ldyBQYWlyKGssIHYpO1xufVxuY2xhc3MgUGFpciB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCB2YWx1ZSA9IG51bGwpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIE5PREVfVFlQRSwgeyB2YWx1ZTogUEFJUiB9KTtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgY2xvbmUoc2NoZW1hKSB7XG4gICAgICAgIGxldCB7IGtleSwgdmFsdWUgfSA9IHRoaXM7XG4gICAgICAgIGlmIChpc05vZGUoa2V5KSlcbiAgICAgICAgICAgIGtleSA9IGtleS5jbG9uZShzY2hlbWEpO1xuICAgICAgICBpZiAoaXNOb2RlKHZhbHVlKSlcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuY2xvbmUoc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYWlyKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICB0b0pTT04oXywgY3R4KSB7XG4gICAgICAgIGNvbnN0IHBhaXIgPSBjdHg/Lm1hcEFzTWFwID8gbmV3IE1hcCgpIDoge307XG4gICAgICAgIHJldHVybiBhZGRQYWlyVG9KU01hcChjdHgsIHBhaXIsIHRoaXMpO1xuICAgIH1cbiAgICB0b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICAgICAgcmV0dXJuIGN0eD8uZG9jXG4gICAgICAgICAgICA/IHN0cmluZ2lmeVBhaXIodGhpcywgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKVxuICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IFBhaXIsIGNyZWF0ZVBhaXIgfTtcbiIsICJpbXBvcnQgeyBDb2xsZWN0aW9uIH0gZnJvbSAnLi4vbm9kZXMvQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBpc05vZGUsIGlzUGFpciB9IGZyb20gJy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHsgbGluZUNvbW1lbnQsIGluZGVudENvbW1lbnQgfSBmcm9tICcuL3N0cmluZ2lmeUNvbW1lbnQuanMnO1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlDb2xsZWN0aW9uKGNvbGxlY3Rpb24sIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZsb3cgPSBjdHguaW5GbG93ID8/IGNvbGxlY3Rpb24uZmxvdztcbiAgICBjb25zdCBzdHJpbmdpZnkgPSBmbG93ID8gc3RyaW5naWZ5Rmxvd0NvbGxlY3Rpb24gOiBzdHJpbmdpZnlCbG9ja0NvbGxlY3Rpb247XG4gICAgcmV0dXJuIHN0cmluZ2lmeShjb2xsZWN0aW9uLCBjdHgsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5QmxvY2tDb2xsZWN0aW9uKHsgY29tbWVudCwgaXRlbXMgfSwgY3R4LCB7IGJsb2NrSXRlbVByZWZpeCwgZmxvd0NoYXJzLCBpdGVtSW5kZW50LCBvbkNob21wS2VlcCwgb25Db21tZW50IH0pIHtcbiAgICBjb25zdCB7IGluZGVudCwgb3B0aW9uczogeyBjb21tZW50U3RyaW5nIH0gfSA9IGN0eDtcbiAgICBjb25zdCBpdGVtQ3R4ID0gT2JqZWN0LmFzc2lnbih7fSwgY3R4LCB7IGluZGVudDogaXRlbUluZGVudCwgdHlwZTogbnVsbCB9KTtcbiAgICBsZXQgY2hvbXBLZWVwID0gZmFsc2U7IC8vIGZsYWcgZm9yIHRoZSBwcmVjZWRpbmcgbm9kZSdzIHN0YXR1c1xuICAgIGNvbnN0IGxpbmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGxldCBjb21tZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKGlzTm9kZShpdGVtKSkge1xuICAgICAgICAgICAgaWYgKCFjaG9tcEtlZXAgJiYgaXRlbS5zcGFjZUJlZm9yZSlcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgICAgIGFkZENvbW1lbnRCZWZvcmUoY3R4LCBsaW5lcywgaXRlbS5jb21tZW50QmVmb3JlLCBjaG9tcEtlZXApO1xuICAgICAgICAgICAgaWYgKGl0ZW0uY29tbWVudClcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gaXRlbS5jb21tZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGFpcihpdGVtKSkge1xuICAgICAgICAgICAgY29uc3QgaWsgPSBpc05vZGUoaXRlbS5rZXkpID8gaXRlbS5rZXkgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGlrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjaG9tcEtlZXAgJiYgaWsuc3BhY2VCZWZvcmUpXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goJycpO1xuICAgICAgICAgICAgICAgIGFkZENvbW1lbnRCZWZvcmUoY3R4LCBsaW5lcywgaWsuY29tbWVudEJlZm9yZSwgY2hvbXBLZWVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaG9tcEtlZXAgPSBmYWxzZTtcbiAgICAgICAgbGV0IHN0ciA9IHN0cmluZ2lmeShpdGVtLCBpdGVtQ3R4LCAoKSA9PiAoY29tbWVudCA9IG51bGwpLCAoKSA9PiAoY2hvbXBLZWVwID0gdHJ1ZSkpO1xuICAgICAgICBpZiAoY29tbWVudClcbiAgICAgICAgICAgIHN0ciArPSBsaW5lQ29tbWVudChzdHIsIGl0ZW1JbmRlbnQsIGNvbW1lbnRTdHJpbmcoY29tbWVudCkpO1xuICAgICAgICBpZiAoY2hvbXBLZWVwICYmIGNvbW1lbnQpXG4gICAgICAgICAgICBjaG9tcEtlZXAgPSBmYWxzZTtcbiAgICAgICAgbGluZXMucHVzaChibG9ja0l0ZW1QcmVmaXggKyBzdHIpO1xuICAgIH1cbiAgICBsZXQgc3RyO1xuICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc3RyID0gZmxvd0NoYXJzLnN0YXJ0ICsgZmxvd0NoYXJzLmVuZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0ciA9IGxpbmVzWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lID0gbGluZXNbaV07XG4gICAgICAgICAgICBzdHIgKz0gbGluZSA/IGBcXG4ke2luZGVudH0ke2xpbmV9YCA6ICdcXG4nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb21tZW50KSB7XG4gICAgICAgIHN0ciArPSAnXFxuJyArIGluZGVudENvbW1lbnQoY29tbWVudFN0cmluZyhjb21tZW50KSwgaW5kZW50KTtcbiAgICAgICAgaWYgKG9uQ29tbWVudClcbiAgICAgICAgICAgIG9uQ29tbWVudCgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaG9tcEtlZXAgJiYgb25DaG9tcEtlZXApXG4gICAgICAgIG9uQ2hvbXBLZWVwKCk7XG4gICAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUZsb3dDb2xsZWN0aW9uKHsgY29tbWVudCwgaXRlbXMgfSwgY3R4LCB7IGZsb3dDaGFycywgaXRlbUluZGVudCwgb25Db21tZW50IH0pIHtcbiAgICBjb25zdCB7IGluZGVudCwgaW5kZW50U3RlcCwgb3B0aW9uczogeyBjb21tZW50U3RyaW5nIH0gfSA9IGN0eDtcbiAgICBpdGVtSW5kZW50ICs9IGluZGVudFN0ZXA7XG4gICAgY29uc3QgaXRlbUN0eCA9IE9iamVjdC5hc3NpZ24oe30sIGN0eCwge1xuICAgICAgICBpbmRlbnQ6IGl0ZW1JbmRlbnQsXG4gICAgICAgIGluRmxvdzogdHJ1ZSxcbiAgICAgICAgdHlwZTogbnVsbFxuICAgIH0pO1xuICAgIGxldCByZXFOZXdsaW5lID0gZmFsc2U7XG4gICAgbGV0IGxpbmVzQXRWYWx1ZSA9IDA7XG4gICAgY29uc3QgbGluZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgbGV0IGNvbW1lbnQgPSBudWxsO1xuICAgICAgICBpZiAoaXNOb2RlKGl0ZW0pKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5zcGFjZUJlZm9yZSlcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgICAgIGFkZENvbW1lbnRCZWZvcmUoY3R4LCBsaW5lcywgaXRlbS5jb21tZW50QmVmb3JlLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoaXRlbS5jb21tZW50KVxuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBpdGVtLmNvbW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQYWlyKGl0ZW0pKSB7XG4gICAgICAgICAgICBjb25zdCBpayA9IGlzTm9kZShpdGVtLmtleSkgPyBpdGVtLmtleSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoaWspIHtcbiAgICAgICAgICAgICAgICBpZiAoaWsuc3BhY2VCZWZvcmUpXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goJycpO1xuICAgICAgICAgICAgICAgIGFkZENvbW1lbnRCZWZvcmUoY3R4LCBsaW5lcywgaWsuY29tbWVudEJlZm9yZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChpay5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICByZXFOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGl2ID0gaXNOb2RlKGl0ZW0udmFsdWUpID8gaXRlbS52YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoaXYpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXYuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGl2LmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGl2LmNvbW1lbnRCZWZvcmUpXG4gICAgICAgICAgICAgICAgICAgIHJlcU5ld2xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS52YWx1ZSA9PSBudWxsICYmIGlrICYmIGlrLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gaWsuY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWVudClcbiAgICAgICAgICAgIHJlcU5ld2xpbmUgPSB0cnVlO1xuICAgICAgICBsZXQgc3RyID0gc3RyaW5naWZ5KGl0ZW0sIGl0ZW1DdHgsICgpID0+IChjb21tZW50ID0gbnVsbCkpO1xuICAgICAgICBpZiAoaSA8IGl0ZW1zLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICBzdHIgKz0gJywnO1xuICAgICAgICBpZiAoY29tbWVudClcbiAgICAgICAgICAgIHN0ciArPSBsaW5lQ29tbWVudChzdHIsIGl0ZW1JbmRlbnQsIGNvbW1lbnRTdHJpbmcoY29tbWVudCkpO1xuICAgICAgICBpZiAoIXJlcU5ld2xpbmUgJiYgKGxpbmVzLmxlbmd0aCA+IGxpbmVzQXRWYWx1ZSB8fCBzdHIuaW5jbHVkZXMoJ1xcbicpKSlcbiAgICAgICAgICAgIHJlcU5ld2xpbmUgPSB0cnVlO1xuICAgICAgICBsaW5lcy5wdXNoKHN0cik7XG4gICAgICAgIGxpbmVzQXRWYWx1ZSA9IGxpbmVzLmxlbmd0aDtcbiAgICB9XG4gICAgbGV0IHN0cjtcbiAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IGZsb3dDaGFycztcbiAgICBpZiAobGluZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN0ciA9IHN0YXJ0ICsgZW5kO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFyZXFOZXdsaW5lKSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBsaW5lcy5yZWR1Y2UoKHN1bSwgbGluZSkgPT4gc3VtICsgbGluZS5sZW5ndGggKyAyLCAyKTtcbiAgICAgICAgICAgIHJlcU5ld2xpbmUgPSBsZW4gPiBDb2xsZWN0aW9uLm1heEZsb3dTdHJpbmdTaW5nbGVMaW5lTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXFOZXdsaW5lKSB7XG4gICAgICAgICAgICBzdHIgPSBzdGFydDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcylcbiAgICAgICAgICAgICAgICBzdHIgKz0gbGluZSA/IGBcXG4ke2luZGVudFN0ZXB9JHtpbmRlbnR9JHtsaW5lfWAgOiAnXFxuJztcbiAgICAgICAgICAgIHN0ciArPSBgXFxuJHtpbmRlbnR9JHtlbmR9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0ciA9IGAke3N0YXJ0fSAke2xpbmVzLmpvaW4oJyAnKX0gJHtlbmR9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tbWVudCkge1xuICAgICAgICBzdHIgKz0gbGluZUNvbW1lbnQoc3RyLCBjb21tZW50U3RyaW5nKGNvbW1lbnQpLCBpbmRlbnQpO1xuICAgICAgICBpZiAob25Db21tZW50KVxuICAgICAgICAgICAgb25Db21tZW50KCk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBhZGRDb21tZW50QmVmb3JlKHsgaW5kZW50LCBvcHRpb25zOiB7IGNvbW1lbnRTdHJpbmcgfSB9LCBsaW5lcywgY29tbWVudCwgY2hvbXBLZWVwKSB7XG4gICAgaWYgKGNvbW1lbnQgJiYgY2hvbXBLZWVwKVxuICAgICAgICBjb21tZW50ID0gY29tbWVudC5yZXBsYWNlKC9eXFxuKy8sICcnKTtcbiAgICBpZiAoY29tbWVudCkge1xuICAgICAgICBjb25zdCBpYyA9IGluZGVudENvbW1lbnQoY29tbWVudFN0cmluZyhjb21tZW50KSwgaW5kZW50KTtcbiAgICAgICAgbGluZXMucHVzaChpYy50cmltU3RhcnQoKSk7IC8vIEF2b2lkIGRvdWJsZSBpbmRlbnQgb24gZmlyc3QgbGluZVxuICAgIH1cbn1cblxuZXhwb3J0IHsgc3RyaW5naWZ5Q29sbGVjdGlvbiB9O1xuIiwgImltcG9ydCB7IHN0cmluZ2lmeUNvbGxlY3Rpb24gfSBmcm9tICcuLi9zdHJpbmdpZnkvc3RyaW5naWZ5Q29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBhZGRQYWlyVG9KU01hcCB9IGZyb20gJy4vYWRkUGFpclRvSlNNYXAuanMnO1xuaW1wb3J0IHsgQ29sbGVjdGlvbiB9IGZyb20gJy4vQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBpc1BhaXIsIGlzU2NhbGFyLCBNQVAgfSBmcm9tICcuL05vZGUuanMnO1xuaW1wb3J0IHsgUGFpciB9IGZyb20gJy4vUGFpci5qcyc7XG5pbXBvcnQgeyBpc1NjYWxhclZhbHVlIH0gZnJvbSAnLi9TY2FsYXIuanMnO1xuXG5mdW5jdGlvbiBmaW5kUGFpcihpdGVtcywga2V5KSB7XG4gICAgY29uc3QgayA9IGlzU2NhbGFyKGtleSkgPyBrZXkudmFsdWUgOiBrZXk7XG4gICAgZm9yIChjb25zdCBpdCBvZiBpdGVtcykge1xuICAgICAgICBpZiAoaXNQYWlyKGl0KSkge1xuICAgICAgICAgICAgaWYgKGl0LmtleSA9PT0ga2V5IHx8IGl0LmtleSA9PT0gaylcbiAgICAgICAgICAgICAgICByZXR1cm4gaXQ7XG4gICAgICAgICAgICBpZiAoaXNTY2FsYXIoaXQua2V5KSAmJiBpdC5rZXkudmFsdWUgPT09IGspXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5jbGFzcyBZQU1MTWFwIGV4dGVuZHMgQ29sbGVjdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hKSB7XG4gICAgICAgIHN1cGVyKE1BUCwgc2NoZW1hKTtcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IHRhZ05hbWUoKSB7XG4gICAgICAgIHJldHVybiAndGFnOnlhbWwub3JnLDIwMDI6bWFwJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHZhbHVlIHRvIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG92ZXJ3cml0ZSAtIElmIG5vdCBzZXQgYHRydWVgLCB1c2luZyBhIGtleSB0aGF0IGlzIGFscmVhZHkgaW4gdGhlXG4gICAgICogICBjb2xsZWN0aW9uIHdpbGwgdGhyb3cuIE90aGVyd2lzZSwgb3ZlcndyaXRlcyB0aGUgcHJldmlvdXMgdmFsdWUuXG4gICAgICovXG4gICAgYWRkKHBhaXIsIG92ZXJ3cml0ZSkge1xuICAgICAgICBsZXQgX3BhaXI7XG4gICAgICAgIGlmIChpc1BhaXIocGFpcikpXG4gICAgICAgICAgICBfcGFpciA9IHBhaXI7XG4gICAgICAgIGVsc2UgaWYgKCFwYWlyIHx8IHR5cGVvZiBwYWlyICE9PSAnb2JqZWN0JyB8fCAhKCdrZXknIGluIHBhaXIpKSB7XG4gICAgICAgICAgICAvLyBJbiBUeXBlU2NyaXB0LCB0aGlzIG5ldmVyIGhhcHBlbnMuXG4gICAgICAgICAgICBfcGFpciA9IG5ldyBQYWlyKHBhaXIsIHBhaXI/LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBfcGFpciA9IG5ldyBQYWlyKHBhaXIua2V5LCBwYWlyLnZhbHVlKTtcbiAgICAgICAgY29uc3QgcHJldiA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIF9wYWlyLmtleSk7XG4gICAgICAgIGNvbnN0IHNvcnRFbnRyaWVzID0gdGhpcy5zY2hlbWE/LnNvcnRNYXBFbnRyaWVzO1xuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgaWYgKCFvdmVyd3JpdGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXkgJHtfcGFpci5rZXl9IGFscmVhZHkgc2V0YCk7XG4gICAgICAgICAgICAvLyBGb3Igc2NhbGFycywga2VlcCB0aGUgb2xkIG5vZGUgJiBpdHMgY29tbWVudHMgYW5kIGFuY2hvcnNcbiAgICAgICAgICAgIGlmIChpc1NjYWxhcihwcmV2LnZhbHVlKSAmJiBpc1NjYWxhclZhbHVlKF9wYWlyLnZhbHVlKSlcbiAgICAgICAgICAgICAgICBwcmV2LnZhbHVlLnZhbHVlID0gX3BhaXIudmFsdWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcHJldi52YWx1ZSA9IF9wYWlyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNvcnRFbnRyaWVzKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gdGhpcy5pdGVtcy5maW5kSW5kZXgoaXRlbSA9PiBzb3J0RW50cmllcyhfcGFpciwgaXRlbSkgPCAwKTtcbiAgICAgICAgICAgIGlmIChpID09PSAtMSlcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2goX3BhaXIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGksIDAsIF9wYWlyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChfcGFpcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCBpdCA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIGtleSk7XG4gICAgICAgIGlmICghaXQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGRlbCA9IHRoaXMuaXRlbXMuc3BsaWNlKHRoaXMuaXRlbXMuaW5kZXhPZihpdCksIDEpO1xuICAgICAgICByZXR1cm4gZGVsLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGdldChrZXksIGtlZXBTY2FsYXIpIHtcbiAgICAgICAgY29uc3QgaXQgPSBmaW5kUGFpcih0aGlzLml0ZW1zLCBrZXkpO1xuICAgICAgICBjb25zdCBub2RlID0gaXQ/LnZhbHVlO1xuICAgICAgICByZXR1cm4gKCFrZWVwU2NhbGFyICYmIGlzU2NhbGFyKG5vZGUpID8gbm9kZS52YWx1ZSA6IG5vZGUpID8/IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gISFmaW5kUGFpcih0aGlzLml0ZW1zLCBrZXkpO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmFkZChuZXcgUGFpcihrZXksIHZhbHVlKSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjdHggLSBDb252ZXJzaW9uIGNvbnRleHQsIG9yaWdpbmFsbHkgc2V0IGluIERvY3VtZW50I3RvSlMoKVxuICAgICAqIEBwYXJhbSB7Q2xhc3N9IFR5cGUgLSBJZiBzZXQsIGZvcmNlcyB0aGUgcmV0dXJuZWQgY29sbGVjdGlvbiB0eXBlXG4gICAgICogQHJldHVybnMgSW5zdGFuY2Ugb2YgVHlwZSwgTWFwLCBvciBPYmplY3RcbiAgICAgKi9cbiAgICB0b0pTT04oXywgY3R4LCBUeXBlKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IFR5cGUgPyBuZXcgVHlwZSgpIDogY3R4Py5tYXBBc01hcCA/IG5ldyBNYXAoKSA6IHt9O1xuICAgICAgICBpZiAoY3R4Py5vbkNyZWF0ZSlcbiAgICAgICAgICAgIGN0eC5vbkNyZWF0ZShtYXApO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5pdGVtcylcbiAgICAgICAgICAgIGFkZFBhaXJUb0pTTWFwKGN0eCwgbWFwLCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIGlmICghY3R4KVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5pdGVtcykge1xuICAgICAgICAgICAgaWYgKCFpc1BhaXIoaXRlbSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNYXAgaXRlbXMgbXVzdCBhbGwgYmUgcGFpcnM7IGZvdW5kICR7SlNPTi5zdHJpbmdpZnkoaXRlbSl9IGluc3RlYWRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN0eC5hbGxOdWxsVmFsdWVzICYmIHRoaXMuaGFzQWxsTnVsbFZhbHVlcyhmYWxzZSkpXG4gICAgICAgICAgICBjdHggPSBPYmplY3QuYXNzaWduKHt9LCBjdHgsIHsgYWxsTnVsbFZhbHVlczogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUNvbGxlY3Rpb24odGhpcywgY3R4LCB7XG4gICAgICAgICAgICBibG9ja0l0ZW1QcmVmaXg6ICcnLFxuICAgICAgICAgICAgZmxvd0NoYXJzOiB7IHN0YXJ0OiAneycsIGVuZDogJ30nIH0sXG4gICAgICAgICAgICBpdGVtSW5kZW50OiBjdHguaW5kZW50IHx8ICcnLFxuICAgICAgICAgICAgb25DaG9tcEtlZXAsXG4gICAgICAgICAgICBvbkNvbW1lbnRcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBZQU1MTWFwLCBmaW5kUGFpciB9O1xuIiwgImltcG9ydCB7IGlzTWFwIH0gZnJvbSAnLi4vLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVQYWlyIH0gZnJvbSAnLi4vLi4vbm9kZXMvUGFpci5qcyc7XG5pbXBvcnQgeyBZQU1MTWFwIH0gZnJvbSAnLi4vLi4vbm9kZXMvWUFNTE1hcC5qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcChzY2hlbWEsIG9iaiwgY3R4KSB7XG4gICAgY29uc3QgeyBrZWVwVW5kZWZpbmVkLCByZXBsYWNlciB9ID0gY3R4O1xuICAgIGNvbnN0IG1hcCA9IG5ldyBZQU1MTWFwKHNjaGVtYSk7XG4gICAgY29uc3QgYWRkID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHZhbHVlID0gcmVwbGFjZXIuY2FsbChvYmosIGtleSwgdmFsdWUpO1xuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlcGxhY2VyKSAmJiAhcmVwbGFjZXIuaW5jbHVkZXMoa2V5KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgfHwga2VlcFVuZGVmaW5lZClcbiAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKGNyZWF0ZVBhaXIoa2V5LCB2YWx1ZSwgY3R4KSk7XG4gICAgfTtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG9iailcbiAgICAgICAgICAgIGFkZChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpXG4gICAgICAgICAgICBhZGQoa2V5LCBvYmpba2V5XSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2NoZW1hLnNvcnRNYXBFbnRyaWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG1hcC5pdGVtcy5zb3J0KHNjaGVtYS5zb3J0TWFwRW50cmllcyk7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG59XG5jb25zdCBtYXAgPSB7XG4gICAgY29sbGVjdGlvbjogJ21hcCcsXG4gICAgY3JlYXRlTm9kZTogY3JlYXRlTWFwLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgbm9kZUNsYXNzOiBZQU1MTWFwLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsXG4gICAgcmVzb2x2ZShtYXAsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKCFpc01hcChtYXApKVxuICAgICAgICAgICAgb25FcnJvcignRXhwZWN0ZWQgYSBtYXBwaW5nIGZvciB0aGlzIHRhZycpO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IG1hcCB9O1xuIiwgImltcG9ydCB7IHN0cmluZ2lmeUNvbGxlY3Rpb24gfSBmcm9tICcuLi9zdHJpbmdpZnkvc3RyaW5naWZ5Q29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBDb2xsZWN0aW9uIH0gZnJvbSAnLi9Db2xsZWN0aW9uLmpzJztcbmltcG9ydCB7IFNFUSwgaXNTY2FsYXIgfSBmcm9tICcuL05vZGUuanMnO1xuaW1wb3J0IHsgaXNTY2FsYXJWYWx1ZSB9IGZyb20gJy4vU2NhbGFyLmpzJztcbmltcG9ydCB7IHRvSlMgfSBmcm9tICcuL3RvSlMuanMnO1xuXG5jbGFzcyBZQU1MU2VxIGV4dGVuZHMgQ29sbGVjdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hKSB7XG4gICAgICAgIHN1cGVyKFNFUSwgc2NoZW1hKTtcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IHRhZ05hbWUoKSB7XG4gICAgICAgIHJldHVybiAndGFnOnlhbWwub3JnLDIwMDI6c2VxJztcbiAgICB9XG4gICAgYWRkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaXRlbXMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogYGtleWAgbXVzdCBjb250YWluIGEgcmVwcmVzZW50YXRpb24gb2YgYW4gaW50ZWdlciBmb3IgdGhpcyB0byBzdWNjZWVkLlxuICAgICAqIEl0IG1heSBiZSB3cmFwcGVkIGluIGEgYFNjYWxhcmAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGl0ZW0gd2FzIGZvdW5kIGFuZCByZW1vdmVkLlxuICAgICAqL1xuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gYXNJdGVtSW5kZXgoa2V5KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpZHggIT09ICdudW1iZXInKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBkZWwgPSB0aGlzLml0ZW1zLnNwbGljZShpZHgsIDEpO1xuICAgICAgICByZXR1cm4gZGVsLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGdldChrZXksIGtlZXBTY2FsYXIpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gYXNJdGVtSW5kZXgoa2V5KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpZHggIT09ICdudW1iZXInKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgaXQgPSB0aGlzLml0ZW1zW2lkeF07XG4gICAgICAgIHJldHVybiAha2VlcFNjYWxhciAmJiBpc1NjYWxhcihpdCkgPyBpdC52YWx1ZSA6IGl0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGNvbGxlY3Rpb24gaW5jbHVkZXMgYSB2YWx1ZSB3aXRoIHRoZSBrZXkgYGtleWAuXG4gICAgICpcbiAgICAgKiBga2V5YCBtdXN0IGNvbnRhaW4gYSByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyIGZvciB0aGlzIHRvIHN1Y2NlZWQuXG4gICAgICogSXQgbWF5IGJlIHdyYXBwZWQgaW4gYSBgU2NhbGFyYC5cbiAgICAgKi9cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGFzSXRlbUluZGV4KGtleSk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaWR4ID09PSAnbnVtYmVyJyAmJiBpZHggPCB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluIHRoaXMgY29sbGVjdGlvbi4gRm9yIGAhIXNldGAsIGB2YWx1ZWAgbmVlZHMgdG8gYmUgYVxuICAgICAqIGJvb2xlYW4gdG8gYWRkL3JlbW92ZSB0aGUgaXRlbSBmcm9tIHRoZSBzZXQuXG4gICAgICpcbiAgICAgKiBJZiBga2V5YCBkb2VzIG5vdCBjb250YWluIGEgcmVwcmVzZW50YXRpb24gb2YgYW4gaW50ZWdlciwgdGhpcyB3aWxsIHRocm93LlxuICAgICAqIEl0IG1heSBiZSB3cmFwcGVkIGluIGEgYFNjYWxhcmAuXG4gICAgICovXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gYXNJdGVtSW5kZXgoa2V5KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpZHggIT09ICdudW1iZXInKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIHZhbGlkIGluZGV4LCBub3QgJHtrZXl9LmApO1xuICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5pdGVtc1tpZHhdO1xuICAgICAgICBpZiAoaXNTY2FsYXIocHJldikgJiYgaXNTY2FsYXJWYWx1ZSh2YWx1ZSkpXG4gICAgICAgICAgICBwcmV2LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuaXRlbXNbaWR4XSA9IHZhbHVlO1xuICAgIH1cbiAgICB0b0pTT04oXywgY3R4KSB7XG4gICAgICAgIGNvbnN0IHNlcSA9IFtdO1xuICAgICAgICBpZiAoY3R4Py5vbkNyZWF0ZSlcbiAgICAgICAgICAgIGN0eC5vbkNyZWF0ZShzZXEpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLml0ZW1zKVxuICAgICAgICAgICAgc2VxLnB1c2godG9KUyhpdGVtLCBTdHJpbmcoaSsrKSwgY3R4KSk7XG4gICAgICAgIHJldHVybiBzZXE7XG4gICAgfVxuICAgIHRvU3RyaW5nKGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgICAgICBpZiAoIWN0eClcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUNvbGxlY3Rpb24odGhpcywgY3R4LCB7XG4gICAgICAgICAgICBibG9ja0l0ZW1QcmVmaXg6ICctICcsXG4gICAgICAgICAgICBmbG93Q2hhcnM6IHsgc3RhcnQ6ICdbJywgZW5kOiAnXScgfSxcbiAgICAgICAgICAgIGl0ZW1JbmRlbnQ6IChjdHguaW5kZW50IHx8ICcnKSArICcgICcsXG4gICAgICAgICAgICBvbkNob21wS2VlcCxcbiAgICAgICAgICAgIG9uQ29tbWVudFxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc0l0ZW1JbmRleChrZXkpIHtcbiAgICBsZXQgaWR4ID0gaXNTY2FsYXIoa2V5KSA/IGtleS52YWx1ZSA6IGtleTtcbiAgICBpZiAoaWR4ICYmIHR5cGVvZiBpZHggPT09ICdzdHJpbmcnKVxuICAgICAgICBpZHggPSBOdW1iZXIoaWR4KTtcbiAgICByZXR1cm4gdHlwZW9mIGlkeCA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzSW50ZWdlcihpZHgpICYmIGlkeCA+PSAwXG4gICAgICAgID8gaWR4XG4gICAgICAgIDogbnVsbDtcbn1cblxuZXhwb3J0IHsgWUFNTFNlcSB9O1xuIiwgImltcG9ydCB7IGNyZWF0ZU5vZGUgfSBmcm9tICcuLi8uLi9kb2MvY3JlYXRlTm9kZS5qcyc7XG5pbXBvcnQgeyBpc1NlcSB9IGZyb20gJy4uLy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgWUFNTFNlcSB9IGZyb20gJy4uLy4uL25vZGVzL1lBTUxTZXEuanMnO1xuXG5mdW5jdGlvbiBjcmVhdGVTZXEoc2NoZW1hLCBvYmosIGN0eCkge1xuICAgIGNvbnN0IHsgcmVwbGFjZXIgfSA9IGN0eDtcbiAgICBjb25zdCBzZXEgPSBuZXcgWUFNTFNlcShzY2hlbWEpO1xuICAgIGlmIChvYmogJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChvYmopKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgaXQgb2Ygb2JqKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gb2JqIGluc3RhbmNlb2YgU2V0ID8gaXQgOiBTdHJpbmcoaSsrKTtcbiAgICAgICAgICAgICAgICBpdCA9IHJlcGxhY2VyLmNhbGwob2JqLCBrZXksIGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcS5pdGVtcy5wdXNoKGNyZWF0ZU5vZGUoaXQsIHVuZGVmaW5lZCwgY3R4KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcTtcbn1cbmNvbnN0IHNlcSA9IHtcbiAgICBjb2xsZWN0aW9uOiAnc2VxJyxcbiAgICBjcmVhdGVOb2RlOiBjcmVhdGVTZXEsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICBub2RlQ2xhc3M6IFlBTUxTZXEsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6c2VxJyxcbiAgICByZXNvbHZlKHNlcSwgb25FcnJvcikge1xuICAgICAgICBpZiAoIWlzU2VxKHNlcSkpXG4gICAgICAgICAgICBvbkVycm9yKCdFeHBlY3RlZCBhIHNlcXVlbmNlIGZvciB0aGlzIHRhZycpO1xuICAgICAgICByZXR1cm4gc2VxO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IHNlcSB9O1xuIiwgImltcG9ydCB7IHN0cmluZ2lmeVN0cmluZyB9IGZyb20gJy4uLy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlTdHJpbmcuanMnO1xuXG5jb25zdCBzdHJpbmcgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLFxuICAgIHJlc29sdmU6IHN0ciA9PiBzdHIsXG4gICAgc3RyaW5naWZ5KGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgICAgICBjdHggPSBPYmplY3QuYXNzaWduKHsgYWN0dWFsU3RyaW5nOiB0cnVlIH0sIGN0eCk7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICB9XG59O1xuXG5leHBvcnQgeyBzdHJpbmcgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuXG5jb25zdCBudWxsVGFnID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSA9PSBudWxsLFxuICAgIGNyZWF0ZU5vZGU6ICgpID0+IG5ldyBTY2FsYXIobnVsbCksXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJyxcbiAgICB0ZXN0OiAvXig/On58W05uXXVsbHxOVUxMKT8kLyxcbiAgICByZXNvbHZlOiAoKSA9PiBuZXcgU2NhbGFyKG51bGwpLFxuICAgIHN0cmluZ2lmeTogKHsgc291cmNlIH0sIGN0eCkgPT4gdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgJiYgbnVsbFRhZy50ZXN0LnRlc3Qoc291cmNlKVxuICAgICAgICA/IHNvdXJjZVxuICAgICAgICA6IGN0eC5vcHRpb25zLm51bGxTdHJcbn07XG5cbmV4cG9ydCB7IG51bGxUYWcgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuXG5jb25zdCBib29sVGFnID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICAgIHRlc3Q6IC9eKD86W1R0XXJ1ZXxUUlVFfFtGZl1hbHNlfEZBTFNFKSQvLFxuICAgIHJlc29sdmU6IHN0ciA9PiBuZXcgU2NhbGFyKHN0clswXSA9PT0gJ3QnIHx8IHN0clswXSA9PT0gJ1QnKSxcbiAgICBzdHJpbmdpZnkoeyBzb3VyY2UsIHZhbHVlIH0sIGN0eCkge1xuICAgICAgICBpZiAoc291cmNlICYmIGJvb2xUYWcudGVzdC50ZXN0KHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN2ID0gc291cmNlWzBdID09PSAndCcgfHwgc291cmNlWzBdID09PSAnVCc7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHN2KVxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlID8gY3R4Lm9wdGlvbnMudHJ1ZVN0ciA6IGN0eC5vcHRpb25zLmZhbHNlU3RyO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IGJvb2xUYWcgfTtcbiIsICJmdW5jdGlvbiBzdHJpbmdpZnlOdW1iZXIoeyBmb3JtYXQsIG1pbkZyYWN0aW9uRGlnaXRzLCB0YWcsIHZhbHVlIH0pIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JylcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgY29uc3QgbnVtID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHZhbHVlIDogTnVtYmVyKHZhbHVlKTtcbiAgICBpZiAoIWlzRmluaXRlKG51bSkpXG4gICAgICAgIHJldHVybiBpc05hTihudW0pID8gJy5uYW4nIDogbnVtIDwgMCA/ICctLmluZicgOiAnLmluZic7XG4gICAgbGV0IG4gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgaWYgKCFmb3JtYXQgJiZcbiAgICAgICAgbWluRnJhY3Rpb25EaWdpdHMgJiZcbiAgICAgICAgKCF0YWcgfHwgdGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnKSAmJlxuICAgICAgICAvXlxcZC8udGVzdChuKSkge1xuICAgICAgICBsZXQgaSA9IG4uaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgIGkgPSBuLmxlbmd0aDtcbiAgICAgICAgICAgIG4gKz0gJy4nO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkID0gbWluRnJhY3Rpb25EaWdpdHMgLSAobi5sZW5ndGggLSBpIC0gMSk7XG4gICAgICAgIHdoaWxlIChkLS0gPiAwKVxuICAgICAgICAgICAgbiArPSAnMCc7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuXG5leHBvcnQgeyBzdHJpbmdpZnlOdW1iZXIgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5TnVtYmVyIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyc7XG5cbmNvbnN0IGZsb2F0TmFOID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIHRlc3Q6IC9eKD86Wy0rXT9cXC4oPzppbmZ8SW5mfElORnxuYW58TmFOfE5BTikpJC8sXG4gICAgcmVzb2x2ZTogc3RyID0+IHN0ci5zbGljZSgtMykudG9Mb3dlckNhc2UoKSA9PT0gJ25hbidcbiAgICAgICAgPyBOYU5cbiAgICAgICAgOiBzdHJbMF0gPT09ICctJ1xuICAgICAgICAgICAgPyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcbiAgICAgICAgICAgIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyXG59O1xuY29uc3QgZmxvYXRFeHAgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gICAgZm9ybWF0OiAnRVhQJyxcbiAgICB0ZXN0OiAvXlstK10/KD86XFwuWzAtOV0rfFswLTldKyg/OlxcLlswLTldKik/KVtlRV1bLStdP1swLTldKyQvLFxuICAgIHJlc29sdmU6IHN0ciA9PiBwYXJzZUZsb2F0KHN0ciksXG4gICAgc3RyaW5naWZ5KG5vZGUpIHtcbiAgICAgICAgY29uc3QgbnVtID0gTnVtYmVyKG5vZGUudmFsdWUpO1xuICAgICAgICByZXR1cm4gaXNGaW5pdGUobnVtKSA/IG51bS50b0V4cG9uZW50aWFsKCkgOiBzdHJpbmdpZnlOdW1iZXIobm9kZSk7XG4gICAgfVxufTtcbmNvbnN0IGZsb2F0ID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIHRlc3Q6IC9eWy0rXT8oPzpcXC5bMC05XSt8WzAtOV0rXFwuWzAtOV0qKSQvLFxuICAgIHJlc29sdmUoc3RyKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgU2NhbGFyKHBhcnNlRmxvYXQoc3RyKSk7XG4gICAgICAgIGNvbnN0IGRvdCA9IHN0ci5pbmRleE9mKCcuJyk7XG4gICAgICAgIGlmIChkb3QgIT09IC0xICYmIHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICcwJylcbiAgICAgICAgICAgIG5vZGUubWluRnJhY3Rpb25EaWdpdHMgPSBzdHIubGVuZ3RoIC0gZG90IC0gMTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlclxufTtcblxuZXhwb3J0IHsgZmxvYXQsIGZsb2F0RXhwLCBmbG9hdE5hTiB9O1xuIiwgImltcG9ydCB7IHN0cmluZ2lmeU51bWJlciB9IGZyb20gJy4uLy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlOdW1iZXIuanMnO1xuXG5jb25zdCBpbnRJZGVudGlmeSA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyB8fCBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKTtcbmNvbnN0IGludFJlc29sdmUgPSAoc3RyLCBvZmZzZXQsIHJhZGl4LCB7IGludEFzQmlnSW50IH0pID0+IChpbnRBc0JpZ0ludCA/IEJpZ0ludChzdHIpIDogcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhvZmZzZXQpLCByYWRpeCkpO1xuZnVuY3Rpb24gaW50U3RyaW5naWZ5KG5vZGUsIHJhZGl4LCBwcmVmaXgpIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSBub2RlO1xuICAgIGlmIChpbnRJZGVudGlmeSh2YWx1ZSkgJiYgdmFsdWUgPj0gMClcbiAgICAgICAgcmV0dXJuIHByZWZpeCArIHZhbHVlLnRvU3RyaW5nKHJhZGl4KTtcbiAgICByZXR1cm4gc3RyaW5naWZ5TnVtYmVyKG5vZGUpO1xufVxuY29uc3QgaW50T2N0ID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiBpbnRJZGVudGlmeSh2YWx1ZSkgJiYgdmFsdWUgPj0gMCxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgZm9ybWF0OiAnT0NUJyxcbiAgICB0ZXN0OiAvXjBvWzAtN10rJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDIsIDgsIG9wdCksXG4gICAgc3RyaW5naWZ5OiBub2RlID0+IGludFN0cmluZ2lmeShub2RlLCA4LCAnMG8nKVxufTtcbmNvbnN0IGludCA9IHtcbiAgICBpZGVudGlmeTogaW50SWRlbnRpZnksXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICAgIHRlc3Q6IC9eWy0rXT9bMC05XSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMCwgMTAsIG9wdCksXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlOdW1iZXJcbn07XG5jb25zdCBpbnRIZXggPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IGludElkZW50aWZ5KHZhbHVlKSAmJiB2YWx1ZSA+PSAwLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICBmb3JtYXQ6ICdIRVgnLFxuICAgIHRlc3Q6IC9eMHhbMC05YS1mQS1GXSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMiwgMTYsIG9wdCksXG4gICAgc3RyaW5naWZ5OiBub2RlID0+IGludFN0cmluZ2lmeShub2RlLCAxNiwgJzB4Jylcbn07XG5cbmV4cG9ydCB7IGludCwgaW50SGV4LCBpbnRPY3QgfTtcbiIsICJpbXBvcnQgeyBtYXAgfSBmcm9tICcuLi9jb21tb24vbWFwLmpzJztcbmltcG9ydCB7IG51bGxUYWcgfSBmcm9tICcuLi9jb21tb24vbnVsbC5qcyc7XG5pbXBvcnQgeyBzZXEgfSBmcm9tICcuLi9jb21tb24vc2VxLmpzJztcbmltcG9ydCB7IHN0cmluZyB9IGZyb20gJy4uL2NvbW1vbi9zdHJpbmcuanMnO1xuaW1wb3J0IHsgYm9vbFRhZyB9IGZyb20gJy4vYm9vbC5qcyc7XG5pbXBvcnQgeyBmbG9hdE5hTiwgZmxvYXRFeHAsIGZsb2F0IH0gZnJvbSAnLi9mbG9hdC5qcyc7XG5pbXBvcnQgeyBpbnRPY3QsIGludCwgaW50SGV4IH0gZnJvbSAnLi9pbnQuanMnO1xuXG5jb25zdCBzY2hlbWEgPSBbXG4gICAgbWFwLFxuICAgIHNlcSxcbiAgICBzdHJpbmcsXG4gICAgbnVsbFRhZyxcbiAgICBib29sVGFnLFxuICAgIGludE9jdCxcbiAgICBpbnQsXG4gICAgaW50SGV4LFxuICAgIGZsb2F0TmFOLFxuICAgIGZsb2F0RXhwLFxuICAgIGZsb2F0XG5dO1xuXG5leHBvcnQgeyBzY2hlbWEgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi4vY29tbW9uL21hcC5qcyc7XG5pbXBvcnQgeyBzZXEgfSBmcm9tICcuLi9jb21tb24vc2VxLmpzJztcblxuZnVuY3Rpb24gaW50SWRlbnRpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyB8fCBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKTtcbn1cbmNvbnN0IHN0cmluZ2lmeUpTT04gPSAoeyB2YWx1ZSB9KSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG5jb25zdCBqc29uU2NhbGFycyA9IFtcbiAgICB7XG4gICAgICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLFxuICAgICAgICByZXNvbHZlOiBzdHIgPT4gc3RyLFxuICAgICAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeUpTT05cbiAgICB9LFxuICAgIHtcbiAgICAgICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09IG51bGwsXG4gICAgICAgIGNyZWF0ZU5vZGU6ICgpID0+IG5ldyBTY2FsYXIobnVsbCksXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLFxuICAgICAgICB0ZXN0OiAvXm51bGwkLyxcbiAgICAgICAgcmVzb2x2ZTogKCkgPT4gbnVsbCxcbiAgICAgICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlKU09OXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsXG4gICAgICAgIHRlc3Q6IC9edHJ1ZXxmYWxzZSQvLFxuICAgICAgICByZXNvbHZlOiBzdHIgPT4gc3RyID09PSAndHJ1ZScsXG4gICAgICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5SlNPTlxuICAgIH0sXG4gICAge1xuICAgICAgICBpZGVudGlmeTogaW50SWRlbnRpZnksXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgICAgIHRlc3Q6IC9eLT8oPzowfFsxLTldWzAtOV0qKSQvLFxuICAgICAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgeyBpbnRBc0JpZ0ludCB9KSA9PiBpbnRBc0JpZ0ludCA/IEJpZ0ludChzdHIpIDogcGFyc2VJbnQoc3RyLCAxMCksXG4gICAgICAgIHN0cmluZ2lmeTogKHsgdmFsdWUgfSkgPT4gaW50SWRlbnRpZnkodmFsdWUpID8gdmFsdWUudG9TdHJpbmcoKSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKVxuICAgIH0sXG4gICAge1xuICAgICAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgICAgICB0ZXN0OiAvXi0/KD86MHxbMS05XVswLTldKikoPzpcXC5bMC05XSopPyg/OltlRV1bLStdP1swLTldKyk/JC8sXG4gICAgICAgIHJlc29sdmU6IHN0ciA9PiBwYXJzZUZsb2F0KHN0ciksXG4gICAgICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5SlNPTlxuICAgIH1cbl07XG5jb25zdCBqc29uRXJyb3IgPSB7XG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICcnLFxuICAgIHRlc3Q6IC9eLyxcbiAgICByZXNvbHZlKHN0ciwgb25FcnJvcikge1xuICAgICAgICBvbkVycm9yKGBVbnJlc29sdmVkIHBsYWluIHNjYWxhciAke0pTT04uc3RyaW5naWZ5KHN0cil9YCk7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxufTtcbmNvbnN0IHNjaGVtYSA9IFttYXAsIHNlcV0uY29uY2F0KGpzb25TY2FsYXJzLCBqc29uRXJyb3IpO1xuXG5leHBvcnQgeyBzY2hlbWEgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5U3RyaW5nIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeVN0cmluZy5qcyc7XG5cbmNvbnN0IGJpbmFyeSA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeScsXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEJ1ZmZlciBpbiBub2RlIGFuZCBhbiBVaW50OEFycmF5IGluIGJyb3dzZXJzXG4gICAgICpcbiAgICAgKiBUbyB1c2UgdGhlIHJlc3VsdGluZyBidWZmZXIgYXMgYW4gaW1hZ2UsIHlvdSdsbCB3YW50IHRvIGRvIHNvbWV0aGluZyBsaWtlOlxuICAgICAqXG4gICAgICogICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2J1ZmZlcl0sIHsgdHlwZTogJ2ltYWdlL2pwZWcnIH0pXG4gICAgICogICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcGhvdG8nKS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gICAgICovXG4gICAgcmVzb2x2ZShzcmMsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzcmMsICdiYXNlNjQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gT24gSUUgMTEsIGF0b2IoKSBjYW4ndCBoYW5kbGUgbmV3bGluZXNcbiAgICAgICAgICAgIGNvbnN0IHN0ciA9IGF0b2Ioc3JjLnJlcGxhY2UoL1tcXG5cXHJdL2csICcnKSk7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIGJ1ZmZlcltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9uRXJyb3IoJ1RoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCByZWFkaW5nIGJpbmFyeSB0YWdzOyBlaXRoZXIgQnVmZmVyIG9yIGF0b2IgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBzcmM7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHN0cmluZ2lmeSh7IGNvbW1lbnQsIHR5cGUsIHZhbHVlIH0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgICAgICBjb25zdCBidWYgPSB2YWx1ZTsgLy8gY2hlY2tlZCBlYXJsaWVyIGJ5IGJpbmFyeS5pZGVudGlmeSgpXG4gICAgICAgIGxldCBzdHI7XG4gICAgICAgIGlmICh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdHIgPVxuICAgICAgICAgICAgICAgIGJ1ZiBpbnN0YW5jZW9mIEJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICA/IGJ1Zi50b1N0cmluZygnYmFzZTY0JylcbiAgICAgICAgICAgICAgICAgICAgOiBCdWZmZXIuZnJvbShidWYuYnVmZmVyKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGxldCBzID0gJyc7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgICAgICAgICAgIHN0ciA9IGJ0b2Eocyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCB3cml0aW5nIGJpbmFyeSB0YWdzOyBlaXRoZXIgQnVmZmVyIG9yIGJ0b2EgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXR5cGUpXG4gICAgICAgICAgICB0eXBlID0gU2NhbGFyLkJMT0NLX0xJVEVSQUw7XG4gICAgICAgIGlmICh0eXBlICE9PSBTY2FsYXIuUVVPVEVfRE9VQkxFKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lV2lkdGggPSBNYXRoLm1heChjdHgub3B0aW9ucy5saW5lV2lkdGggLSBjdHguaW5kZW50Lmxlbmd0aCwgY3R4Lm9wdGlvbnMubWluQ29udGVudFdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLmNlaWwoc3RyLmxlbmd0aCAvIGxpbmVXaWR0aCk7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBvID0gMDsgaSA8IG47ICsraSwgbyArPSBsaW5lV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBsaW5lc1tpXSA9IHN0ci5zdWJzdHIobywgbGluZVdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0ciA9IGxpbmVzLmpvaW4odHlwZSA9PT0gU2NhbGFyLkJMT0NLX0xJVEVSQUwgPyAnXFxuJyA6ICcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeVN0cmluZyh7IGNvbW1lbnQsIHR5cGUsIHZhbHVlOiBzdHIgfSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICB9XG59O1xuXG5leHBvcnQgeyBiaW5hcnkgfTtcbiIsICJpbXBvcnQgeyBpc1NlcSwgaXNQYWlyLCBpc01hcCB9IGZyb20gJy4uLy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgUGFpciwgY3JlYXRlUGFpciB9IGZyb20gJy4uLy4uL25vZGVzL1BhaXIuanMnO1xuaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IFlBTUxTZXEgfSBmcm9tICcuLi8uLi9ub2Rlcy9ZQU1MU2VxLmpzJztcblxuZnVuY3Rpb24gcmVzb2x2ZVBhaXJzKHNlcSwgb25FcnJvcikge1xuICAgIGlmIChpc1NlcShzZXEpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VxLml0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IHNlcS5pdGVtc1tpXTtcbiAgICAgICAgICAgIGlmIChpc1BhaXIoaXRlbSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlIGlmIChpc01hcChpdGVtKSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLml0ZW1zLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoJ0VhY2ggcGFpciBtdXN0IGhhdmUgaXRzIG93biBzZXF1ZW5jZSBpbmRpY2F0b3InKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWlyID0gaXRlbS5pdGVtc1swXSB8fCBuZXcgUGFpcihuZXcgU2NhbGFyKG51bGwpKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5jb21tZW50QmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICBwYWlyLmtleS5jb21tZW50QmVmb3JlID0gcGFpci5rZXkuY29tbWVudEJlZm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgJHtpdGVtLmNvbW1lbnRCZWZvcmV9XFxuJHtwYWlyLmtleS5jb21tZW50QmVmb3JlfWBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaXRlbS5jb21tZW50QmVmb3JlO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY24gPSBwYWlyLnZhbHVlID8/IHBhaXIua2V5O1xuICAgICAgICAgICAgICAgICAgICBjbi5jb21tZW50ID0gY24uY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgJHtpdGVtLmNvbW1lbnR9XFxuJHtjbi5jb21tZW50fWBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaXRlbS5jb21tZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtID0gcGFpcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcS5pdGVtc1tpXSA9IGlzUGFpcihpdGVtKSA/IGl0ZW0gOiBuZXcgUGFpcihpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIG9uRXJyb3IoJ0V4cGVjdGVkIGEgc2VxdWVuY2UgZm9yIHRoaXMgdGFnJyk7XG4gICAgcmV0dXJuIHNlcTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhaXJzKHNjaGVtYSwgaXRlcmFibGUsIGN0eCkge1xuICAgIGNvbnN0IHsgcmVwbGFjZXIgfSA9IGN0eDtcbiAgICBjb25zdCBwYWlycyA9IG5ldyBZQU1MU2VxKHNjaGVtYSk7XG4gICAgcGFpcnMudGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJztcbiAgICBsZXQgaSA9IDA7XG4gICAgaWYgKGl0ZXJhYmxlICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcmFibGUpKVxuICAgICAgICBmb3IgKGxldCBpdCBvZiBpdGVyYWJsZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICBpdCA9IHJlcGxhY2VyLmNhbGwoaXRlcmFibGUsIFN0cmluZyhpKyspLCBpdCk7XG4gICAgICAgICAgICBsZXQga2V5LCB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0KSkge1xuICAgICAgICAgICAgICAgIGlmIChpdC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gaXRbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaXRbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgW2tleSwgdmFsdWVdIHR1cGxlOiAke2l0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXQgJiYgaXQgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaXQpO1xuICAgICAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXlzWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGl0W2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgeyBrZXk6IHZhbHVlIH0gdHVwbGU6ICR7aXR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBpdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhaXJzLml0ZW1zLnB1c2goY3JlYXRlUGFpcihrZXksIHZhbHVlLCBjdHgpKTtcbiAgICAgICAgfVxuICAgIHJldHVybiBwYWlycztcbn1cbmNvbnN0IHBhaXJzID0ge1xuICAgIGNvbGxlY3Rpb246ICdzZXEnLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJyxcbiAgICByZXNvbHZlOiByZXNvbHZlUGFpcnMsXG4gICAgY3JlYXRlTm9kZTogY3JlYXRlUGFpcnNcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZVBhaXJzLCBwYWlycywgcmVzb2x2ZVBhaXJzIH07XG4iLCAiaW1wb3J0IHsgWUFNTFNlcSB9IGZyb20gJy4uLy4uL25vZGVzL1lBTUxTZXEuanMnO1xuaW1wb3J0IHsgdG9KUyB9IGZyb20gJy4uLy4uL25vZGVzL3RvSlMuanMnO1xuaW1wb3J0IHsgaXNTY2FsYXIsIGlzUGFpciB9IGZyb20gJy4uLy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgWUFNTE1hcCB9IGZyb20gJy4uLy4uL25vZGVzL1lBTUxNYXAuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZVBhaXJzLCBjcmVhdGVQYWlycyB9IGZyb20gJy4vcGFpcnMuanMnO1xuXG5jbGFzcyBZQU1MT01hcCBleHRlbmRzIFlBTUxTZXEge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFkZCA9IFlBTUxNYXAucHJvdG90eXBlLmFkZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlbGV0ZSA9IFlBTUxNYXAucHJvdG90eXBlLmRlbGV0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldCA9IFlBTUxNYXAucHJvdG90eXBlLmdldC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhcyA9IFlBTUxNYXAucHJvdG90eXBlLmhhcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldCA9IFlBTUxNYXAucHJvdG90eXBlLnNldC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRhZyA9IFlBTUxPTWFwLnRhZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgYGN0eGAgaXMgZ2l2ZW4sIHRoZSByZXR1cm4gdHlwZSBpcyBhY3R1YWxseSBgTWFwPHVua25vd24sIHVua25vd24+YCxcbiAgICAgKiBidXQgVHlwZVNjcmlwdCB3b24ndCBhbGxvdyB3aWRlbmluZyB0aGUgc2lnbmF0dXJlIG9mIGEgY2hpbGQgbWV0aG9kLlxuICAgICAqL1xuICAgIHRvSlNPTihfLCBjdHgpIHtcbiAgICAgICAgaWYgKCFjdHgpXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIudG9KU09OKF8pO1xuICAgICAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmIChjdHg/Lm9uQ3JlYXRlKVxuICAgICAgICAgICAgY3R4Lm9uQ3JlYXRlKG1hcCk7XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICBsZXQga2V5LCB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChpc1BhaXIocGFpcikpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSB0b0pTKHBhaXIua2V5LCAnJywgY3R4KTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvSlMocGFpci52YWx1ZSwga2V5LCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAga2V5ID0gdG9KUyhwYWlyLCAnJywgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXAuaGFzKGtleSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcmRlcmVkIG1hcHMgbXVzdCBub3QgaW5jbHVkZSBkdXBsaWNhdGUga2V5cycpO1xuICAgICAgICAgICAgbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbn1cbllBTUxPTWFwLnRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjpvbWFwJztcbmNvbnN0IG9tYXAgPSB7XG4gICAgY29sbGVjdGlvbjogJ3NlcScsXG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgTWFwLFxuICAgIG5vZGVDbGFzczogWUFNTE9NYXAsXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6b21hcCcsXG4gICAgcmVzb2x2ZShzZXEsIG9uRXJyb3IpIHtcbiAgICAgICAgY29uc3QgcGFpcnMgPSByZXNvbHZlUGFpcnMoc2VxLCBvbkVycm9yKTtcbiAgICAgICAgY29uc3Qgc2VlbktleXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB7IGtleSB9IG9mIHBhaXJzLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaXNTY2FsYXIoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWVuS2V5cy5pbmNsdWRlcyhrZXkudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoYE9yZGVyZWQgbWFwcyBtdXN0IG5vdCBpbmNsdWRlIGR1cGxpY2F0ZSBrZXlzOiAke2tleS52YWx1ZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZW5LZXlzLnB1c2goa2V5LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFlBTUxPTWFwKCksIHBhaXJzKTtcbiAgICB9LFxuICAgIGNyZWF0ZU5vZGUoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KSB7XG4gICAgICAgIGNvbnN0IHBhaXJzID0gY3JlYXRlUGFpcnMoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KTtcbiAgICAgICAgY29uc3Qgb21hcCA9IG5ldyBZQU1MT01hcCgpO1xuICAgICAgICBvbWFwLml0ZW1zID0gcGFpcnMuaXRlbXM7XG4gICAgICAgIHJldHVybiBvbWFwO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IFlBTUxPTWFwLCBvbWFwIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJztcblxuZnVuY3Rpb24gYm9vbFN0cmluZ2lmeSh7IHZhbHVlLCBzb3VyY2UgfSwgY3R4KSB7XG4gICAgY29uc3QgYm9vbE9iaiA9IHZhbHVlID8gdHJ1ZVRhZyA6IGZhbHNlVGFnO1xuICAgIGlmIChzb3VyY2UgJiYgYm9vbE9iai50ZXN0LnRlc3Qoc291cmNlKSlcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICByZXR1cm4gdmFsdWUgPyBjdHgub3B0aW9ucy50cnVlU3RyIDogY3R4Lm9wdGlvbnMuZmFsc2VTdHI7XG59XG5jb25zdCB0cnVlVGFnID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSA9PT0gdHJ1ZSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICAgIHRlc3Q6IC9eKD86WXx5fFtZeV1lc3xZRVN8W1R0XXJ1ZXxUUlVFfFtPb11ufE9OKSQvLFxuICAgIHJlc29sdmU6ICgpID0+IG5ldyBTY2FsYXIodHJ1ZSksXG4gICAgc3RyaW5naWZ5OiBib29sU3RyaW5naWZ5XG59O1xuY29uc3QgZmFsc2VUYWcgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09PSBmYWxzZSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICAgIHRlc3Q6IC9eKD86TnxufFtObl1vfE5PfFtGZl1hbHNlfEZBTFNFfFtPb11mZnxPRkYpJC9pLFxuICAgIHJlc29sdmU6ICgpID0+IG5ldyBTY2FsYXIoZmFsc2UpLFxuICAgIHN0cmluZ2lmeTogYm9vbFN0cmluZ2lmeVxufTtcblxuZXhwb3J0IHsgZmFsc2VUYWcsIHRydWVUYWcgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5TnVtYmVyIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyc7XG5cbmNvbnN0IGZsb2F0TmFOID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIHRlc3Q6IC9eWy0rXT9cXC4oPzppbmZ8SW5mfElORnxuYW58TmFOfE5BTikkLyxcbiAgICByZXNvbHZlOiAoc3RyKSA9PiBzdHIuc2xpY2UoLTMpLnRvTG93ZXJDYXNlKCkgPT09ICduYW4nXG4gICAgICAgID8gTmFOXG4gICAgICAgIDogc3RyWzBdID09PSAnLSdcbiAgICAgICAgICAgID8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4gICAgICAgICAgICA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlclxufTtcbmNvbnN0IGZsb2F0RXhwID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIGZvcm1hdDogJ0VYUCcsXG4gICAgdGVzdDogL15bLStdPyg/OlswLTldWzAtOV9dKik/KD86XFwuWzAtOV9dKik/W2VFXVstK10/WzAtOV0rJC8sXG4gICAgcmVzb2x2ZTogKHN0cikgPT4gcGFyc2VGbG9hdChzdHIucmVwbGFjZSgvXy9nLCAnJykpLFxuICAgIHN0cmluZ2lmeShub2RlKSB7XG4gICAgICAgIGNvbnN0IG51bSA9IE51bWJlcihub2RlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGlzRmluaXRlKG51bSkgPyBudW0udG9FeHBvbmVudGlhbCgpIDogc3RyaW5naWZ5TnVtYmVyKG5vZGUpO1xuICAgIH1cbn07XG5jb25zdCBmbG9hdCA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICB0ZXN0OiAvXlstK10/KD86WzAtOV1bMC05X10qKT9cXC5bMC05X10qJC8sXG4gICAgcmVzb2x2ZShzdHIpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBTY2FsYXIocGFyc2VGbG9hdChzdHIucmVwbGFjZSgvXy9nLCAnJykpKTtcbiAgICAgICAgY29uc3QgZG90ID0gc3RyLmluZGV4T2YoJy4nKTtcbiAgICAgICAgaWYgKGRvdCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBzdHIuc3Vic3RyaW5nKGRvdCArIDEpLnJlcGxhY2UoL18vZywgJycpO1xuICAgICAgICAgICAgaWYgKGZbZi5sZW5ndGggLSAxXSA9PT0gJzAnKVxuICAgICAgICAgICAgICAgIG5vZGUubWluRnJhY3Rpb25EaWdpdHMgPSBmLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyXG59O1xuXG5leHBvcnQgeyBmbG9hdCwgZmxvYXRFeHAsIGZsb2F0TmFOIH07XG4iLCAiaW1wb3J0IHsgc3RyaW5naWZ5TnVtYmVyIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyc7XG5cbmNvbnN0IGludElkZW50aWZ5ID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnIHx8IE51bWJlci5pc0ludGVnZXIodmFsdWUpO1xuZnVuY3Rpb24gaW50UmVzb2x2ZShzdHIsIG9mZnNldCwgcmFkaXgsIHsgaW50QXNCaWdJbnQgfSkge1xuICAgIGNvbnN0IHNpZ24gPSBzdHJbMF07XG4gICAgaWYgKHNpZ24gPT09ICctJyB8fCBzaWduID09PSAnKycpXG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcob2Zmc2V0KS5yZXBsYWNlKC9fL2csICcnKTtcbiAgICBpZiAoaW50QXNCaWdJbnQpIHtcbiAgICAgICAgc3dpdGNoIChyYWRpeCkge1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHN0ciA9IGAwYiR7c3RyfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgc3RyID0gYDBvJHtzdHJ9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgc3RyID0gYDB4JHtzdHJ9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuID0gQmlnSW50KHN0cik7XG4gICAgICAgIHJldHVybiBzaWduID09PSAnLScgPyBCaWdJbnQoLTEpICogbiA6IG47XG4gICAgfVxuICAgIGNvbnN0IG4gPSBwYXJzZUludChzdHIsIHJhZGl4KTtcbiAgICByZXR1cm4gc2lnbiA9PT0gJy0nID8gLTEgKiBuIDogbjtcbn1cbmZ1bmN0aW9uIGludFN0cmluZ2lmeShub2RlLCByYWRpeCwgcHJlZml4KSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gbm9kZTtcbiAgICBpZiAoaW50SWRlbnRpZnkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHN0ciA9IHZhbHVlLnRvU3RyaW5nKHJhZGl4KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlIDwgMCA/ICctJyArIHByZWZpeCArIHN0ci5zdWJzdHIoMSkgOiBwcmVmaXggKyBzdHI7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdpZnlOdW1iZXIobm9kZSk7XG59XG5jb25zdCBpbnRCaW4gPSB7XG4gICAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICBmb3JtYXQ6ICdCSU4nLFxuICAgIHRlc3Q6IC9eWy0rXT8wYlswLTFfXSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMiwgMiwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5KG5vZGUsIDIsICcwYicpXG59O1xuY29uc3QgaW50T2N0ID0ge1xuICAgIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgZm9ybWF0OiAnT0NUJyxcbiAgICB0ZXN0OiAvXlstK10/MFswLTdfXSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMSwgOCwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5KG5vZGUsIDgsICcwJylcbn07XG5jb25zdCBpbnQgPSB7XG4gICAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICB0ZXN0OiAvXlstK10/WzAtOV1bMC05X10qJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDAsIDEwLCBvcHQpLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyXG59O1xuY29uc3QgaW50SGV4ID0ge1xuICAgIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgZm9ybWF0OiAnSEVYJyxcbiAgICB0ZXN0OiAvXlstK10/MHhbMC05YS1mQS1GX10rJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDIsIDE2LCBvcHQpLFxuICAgIHN0cmluZ2lmeTogbm9kZSA9PiBpbnRTdHJpbmdpZnkobm9kZSwgMTYsICcweCcpXG59O1xuXG5leHBvcnQgeyBpbnQsIGludEJpbiwgaW50SGV4LCBpbnRPY3QgfTtcbiIsICJpbXBvcnQgeyBpc01hcCwgaXNQYWlyLCBpc1NjYWxhciB9IGZyb20gJy4uLy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgY3JlYXRlUGFpciwgUGFpciB9IGZyb20gJy4uLy4uL25vZGVzL1BhaXIuanMnO1xuaW1wb3J0IHsgWUFNTE1hcCwgZmluZFBhaXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9ZQU1MTWFwLmpzJztcblxuY2xhc3MgWUFNTFNldCBleHRlbmRzIFlBTUxNYXAge1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSkge1xuICAgICAgICBzdXBlcihzY2hlbWEpO1xuICAgICAgICB0aGlzLnRhZyA9IFlBTUxTZXQudGFnO1xuICAgIH1cbiAgICBhZGQoa2V5KSB7XG4gICAgICAgIGxldCBwYWlyO1xuICAgICAgICBpZiAoaXNQYWlyKGtleSkpXG4gICAgICAgICAgICBwYWlyID0ga2V5O1xuICAgICAgICBlbHNlIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgJ2tleScgaW4ga2V5ICYmXG4gICAgICAgICAgICAndmFsdWUnIGluIGtleSAmJlxuICAgICAgICAgICAga2V5LnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcGFpciA9IG5ldyBQYWlyKGtleS5rZXksIG51bGwpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBwYWlyID0gbmV3IFBhaXIoa2V5LCBudWxsKTtcbiAgICAgICAgY29uc3QgcHJldiA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIHBhaXIua2V5KTtcbiAgICAgICAgaWYgKCFwcmV2KVxuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHBhaXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBga2VlcFBhaXJgIGlzIGB0cnVlYCwgcmV0dXJucyB0aGUgUGFpciBtYXRjaGluZyBga2V5YC5cbiAgICAgKiBPdGhlcndpc2UsIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoYXQgUGFpcidzIGtleS5cbiAgICAgKi9cbiAgICBnZXQoa2V5LCBrZWVwUGFpcikge1xuICAgICAgICBjb25zdCBwYWlyID0gZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICAgICAgcmV0dXJuICFrZWVwUGFpciAmJiBpc1BhaXIocGFpcilcbiAgICAgICAgICAgID8gaXNTY2FsYXIocGFpci5rZXkpXG4gICAgICAgICAgICAgICAgPyBwYWlyLmtleS52YWx1ZVxuICAgICAgICAgICAgICAgIDogcGFpci5rZXlcbiAgICAgICAgICAgIDogcGFpcjtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuIHZhbHVlIGZvciBzZXQoa2V5LCB2YWx1ZSkgaW4gYSBZQU1MIHNldCwgbm90ICR7dHlwZW9mIHZhbHVlfWApO1xuICAgICAgICBjb25zdCBwcmV2ID0gZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICAgICAgaWYgKHByZXYgJiYgIXZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnNwbGljZSh0aGlzLml0ZW1zLmluZGV4T2YocHJldiksIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFwcmV2ICYmIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2gobmV3IFBhaXIoa2V5KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKF8sIGN0eCkge1xuICAgICAgICByZXR1cm4gc3VwZXIudG9KU09OKF8sIGN0eCwgU2V0KTtcbiAgICB9XG4gICAgdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIGlmICghY3R4KVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5oYXNBbGxOdWxsVmFsdWVzKHRydWUpKVxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnRvU3RyaW5nKE9iamVjdC5hc3NpZ24oe30sIGN0eCwgeyBhbGxOdWxsVmFsdWVzOiB0cnVlIH0pLCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXQgaXRlbXMgbXVzdCBhbGwgaGF2ZSBudWxsIHZhbHVlcycpO1xuICAgIH1cbn1cbllBTUxTZXQudGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOnNldCc7XG5jb25zdCBzZXQgPSB7XG4gICAgY29sbGVjdGlvbjogJ21hcCcsXG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgU2V0LFxuICAgIG5vZGVDbGFzczogWUFNTFNldCxcbiAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnLFxuICAgIHJlc29sdmUobWFwLCBvbkVycm9yKSB7XG4gICAgICAgIGlmIChpc01hcChtYXApKSB7XG4gICAgICAgICAgICBpZiAobWFwLmhhc0FsbE51bGxWYWx1ZXModHJ1ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFlBTUxTZXQoKSwgbWFwKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvbkVycm9yKCdTZXQgaXRlbXMgbXVzdCBhbGwgaGF2ZSBudWxsIHZhbHVlcycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9uRXJyb3IoJ0V4cGVjdGVkIGEgbWFwcGluZyBmb3IgdGhpcyB0YWcnKTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LFxuICAgIGNyZWF0ZU5vZGUoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgcmVwbGFjZXIgfSA9IGN0eDtcbiAgICAgICAgY29uc3Qgc2V0ID0gbmV3IFlBTUxTZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKGl0ZXJhYmxlICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcmFibGUpKVxuICAgICAgICAgICAgZm9yIChsZXQgdmFsdWUgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlcGxhY2VyLmNhbGwoaXRlcmFibGUsIHZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgc2V0Lml0ZW1zLnB1c2goY3JlYXRlUGFpcih2YWx1ZSwgbnVsbCwgY3R4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgWUFNTFNldCwgc2V0IH07XG4iLCAiaW1wb3J0IHsgc3RyaW5naWZ5TnVtYmVyIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyc7XG5cbi8qKiBJbnRlcm5hbCB0eXBlcyBoYW5kbGUgYmlnaW50IGFzIG51bWJlciwgYmVjYXVzZSBUUyBjYW4ndCBmaWd1cmUgaXQgb3V0LiAqL1xuZnVuY3Rpb24gcGFyc2VTZXhhZ2VzaW1hbChzdHIsIGFzQmlnSW50KSB7XG4gICAgY29uc3Qgc2lnbiA9IHN0clswXTtcbiAgICBjb25zdCBwYXJ0cyA9IHNpZ24gPT09ICctJyB8fCBzaWduID09PSAnKycgPyBzdHIuc3Vic3RyaW5nKDEpIDogc3RyO1xuICAgIGNvbnN0IG51bSA9IChuKSA9PiBhc0JpZ0ludCA/IEJpZ0ludChuKSA6IE51bWJlcihuKTtcbiAgICBjb25zdCByZXMgPSBwYXJ0c1xuICAgICAgICAucmVwbGFjZSgvXy9nLCAnJylcbiAgICAgICAgLnNwbGl0KCc6JylcbiAgICAgICAgLnJlZHVjZSgocmVzLCBwKSA9PiByZXMgKiBudW0oNjApICsgbnVtKHApLCBudW0oMCkpO1xuICAgIHJldHVybiAoc2lnbiA9PT0gJy0nID8gbnVtKC0xKSAqIHJlcyA6IHJlcyk7XG59XG4vKipcbiAqIGhoaGg6bW06c3Muc3NzXG4gKlxuICogSW50ZXJuYWwgdHlwZXMgaGFuZGxlIGJpZ2ludCBhcyBudW1iZXIsIGJlY2F1c2UgVFMgY2FuJ3QgZmlndXJlIGl0IG91dC5cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5U2V4YWdlc2ltYWwobm9kZSkge1xuICAgIGxldCB7IHZhbHVlIH0gPSBub2RlO1xuICAgIGxldCBudW0gPSAobikgPT4gbjtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JylcbiAgICAgICAgbnVtID0gbiA9PiBCaWdJbnQobik7XG4gICAgZWxzZSBpZiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpXG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlOdW1iZXIobm9kZSk7XG4gICAgbGV0IHNpZ24gPSAnJztcbiAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgIHZhbHVlICo9IG51bSgtMSk7XG4gICAgfVxuICAgIGNvbnN0IF82MCA9IG51bSg2MCk7XG4gICAgY29uc3QgcGFydHMgPSBbdmFsdWUgJSBfNjBdOyAvLyBzZWNvbmRzLCBpbmNsdWRpbmcgbXNcbiAgICBpZiAodmFsdWUgPCA2MCkge1xuICAgICAgICBwYXJ0cy51bnNoaWZ0KDApOyAvLyBhdCBsZWFzdCBvbmUgOiBpcyByZXF1aXJlZFxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgLSBwYXJ0c1swXSkgLyBfNjA7XG4gICAgICAgIHBhcnRzLnVuc2hpZnQodmFsdWUgJSBfNjApOyAvLyBtaW51dGVzXG4gICAgICAgIGlmICh2YWx1ZSA+PSA2MCkge1xuICAgICAgICAgICAgdmFsdWUgPSAodmFsdWUgLSBwYXJ0c1swXSkgLyBfNjA7XG4gICAgICAgICAgICBwYXJ0cy51bnNoaWZ0KHZhbHVlKTsgLy8gaG91cnNcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKHNpZ24gK1xuICAgICAgICBwYXJ0c1xuICAgICAgICAgICAgLm1hcChuID0+IChuIDwgMTAgPyAnMCcgKyBTdHJpbmcobikgOiBTdHJpbmcobikpKVxuICAgICAgICAgICAgLmpvaW4oJzonKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzAwMDAwMFxcZCokLywgJycpIC8vICUgNjAgbWF5IGludHJvZHVjZSBlcnJvclxuICAgICk7XG59XG5jb25zdCBpbnRUaW1lID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnIHx8IE51bWJlci5pc0ludGVnZXIodmFsdWUpLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICBmb3JtYXQ6ICdUSU1FJyxcbiAgICB0ZXN0OiAvXlstK10/WzAtOV1bMC05X10qKD86OlswLTVdP1swLTldKSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgeyBpbnRBc0JpZ0ludCB9KSA9PiBwYXJzZVNleGFnZXNpbWFsKHN0ciwgaW50QXNCaWdJbnQpLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5U2V4YWdlc2ltYWxcbn07XG5jb25zdCBmbG9hdFRpbWUgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gICAgZm9ybWF0OiAnVElNRScsXG4gICAgdGVzdDogL15bLStdP1swLTldWzAtOV9dKig/OjpbMC01XT9bMC05XSkrXFwuWzAtOV9dKiQvLFxuICAgIHJlc29sdmU6IHN0ciA9PiBwYXJzZVNleGFnZXNpbWFsKHN0ciwgZmFsc2UpLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5U2V4YWdlc2ltYWxcbn07XG5jb25zdCB0aW1lc3RhbXAgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCcsXG4gICAgLy8gSWYgdGhlIHRpbWUgem9uZSBpcyBvbWl0dGVkLCB0aGUgdGltZXN0YW1wIGlzIGFzc3VtZWQgdG8gYmUgc3BlY2lmaWVkIGluIFVUQy4gVGhlIHRpbWUgcGFydFxuICAgIC8vIG1heSBiZSBvbWl0dGVkIGFsdG9nZXRoZXIsIHJlc3VsdGluZyBpbiBhIGRhdGUgZm9ybWF0LiBJbiBzdWNoIGEgY2FzZSwgdGhlIHRpbWUgcGFydCBpc1xuICAgIC8vIGFzc3VtZWQgdG8gYmUgMDA6MDA6MDBaIChzdGFydCBvZiBkYXksIFVUQykuXG4gICAgdGVzdDogUmVnRXhwKCdeKFswLTldezR9KS0oWzAtOV17MSwyfSktKFswLTldezEsMn0pJyArIC8vIFlZWVktTW0tRGRcbiAgICAgICAgJyg/OicgKyAvLyB0aW1lIGlzIG9wdGlvbmFsXG4gICAgICAgICcoPzp0fFR8WyBcXFxcdF0rKScgKyAvLyB0IHwgVCB8IHdoaXRlc3BhY2VcbiAgICAgICAgJyhbMC05XXsxLDJ9KTooWzAtOV17MSwyfSk6KFswLTldezEsMn0oXFxcXC5bMC05XSspPyknICsgLy8gSGg6TW06U3MoLnNzKT9cbiAgICAgICAgJyg/OlsgXFxcXHRdKihafFstK11bMDEyXT9bMC05XSg/OjpbMC05XXsyfSk/KSk/JyArIC8vIFogfCArNSB8IC0wMzozMFxuICAgICAgICAnKT8kJyksXG4gICAgcmVzb2x2ZShzdHIpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBzdHIubWF0Y2godGltZXN0YW1wLnRlc3QpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCchIXRpbWVzdGFtcCBleHBlY3RzIGEgZGF0ZSwgc3RhcnRpbmcgd2l0aCB5eXl5LW1tLWRkJyk7XG4gICAgICAgIGNvbnN0IFssIHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kXSA9IG1hdGNoLm1hcChOdW1iZXIpO1xuICAgICAgICBjb25zdCBtaWxsaXNlYyA9IG1hdGNoWzddID8gTnVtYmVyKChtYXRjaFs3XSArICcwMCcpLnN1YnN0cigxLCAzKSkgOiAwO1xuICAgICAgICBsZXQgZGF0ZSA9IERhdGUuVVRDKHllYXIsIG1vbnRoIC0gMSwgZGF5LCBob3VyIHx8IDAsIG1pbnV0ZSB8fCAwLCBzZWNvbmQgfHwgMCwgbWlsbGlzZWMpO1xuICAgICAgICBjb25zdCB0eiA9IG1hdGNoWzhdO1xuICAgICAgICBpZiAodHogJiYgdHogIT09ICdaJykge1xuICAgICAgICAgICAgbGV0IGQgPSBwYXJzZVNleGFnZXNpbWFsKHR6LCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZCkgPCAzMClcbiAgICAgICAgICAgICAgICBkICo9IDYwO1xuICAgICAgICAgICAgZGF0ZSAtPSA2MDAwMCAqIGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUpO1xuICAgIH0sXG4gICAgc3RyaW5naWZ5OiAoeyB2YWx1ZSB9KSA9PiB2YWx1ZS50b0lTT1N0cmluZygpLnJlcGxhY2UoLygoVDAwOjAwKT86MDApP1xcLjAwMFokLywgJycpXG59O1xuXG5leHBvcnQgeyBmbG9hdFRpbWUsIGludFRpbWUsIHRpbWVzdGFtcCB9O1xuIiwgImltcG9ydCB7IG1hcCB9IGZyb20gJy4uL2NvbW1vbi9tYXAuanMnO1xuaW1wb3J0IHsgbnVsbFRhZyB9IGZyb20gJy4uL2NvbW1vbi9udWxsLmpzJztcbmltcG9ydCB7IHNlcSB9IGZyb20gJy4uL2NvbW1vbi9zZXEuanMnO1xuaW1wb3J0IHsgc3RyaW5nIH0gZnJvbSAnLi4vY29tbW9uL3N0cmluZy5qcyc7XG5pbXBvcnQgeyBiaW5hcnkgfSBmcm9tICcuL2JpbmFyeS5qcyc7XG5pbXBvcnQgeyB0cnVlVGFnLCBmYWxzZVRhZyB9IGZyb20gJy4vYm9vbC5qcyc7XG5pbXBvcnQgeyBmbG9hdE5hTiwgZmxvYXRFeHAsIGZsb2F0IH0gZnJvbSAnLi9mbG9hdC5qcyc7XG5pbXBvcnQgeyBpbnRCaW4sIGludE9jdCwgaW50LCBpbnRIZXggfSBmcm9tICcuL2ludC5qcyc7XG5pbXBvcnQgeyBvbWFwIH0gZnJvbSAnLi9vbWFwLmpzJztcbmltcG9ydCB7IHBhaXJzIH0gZnJvbSAnLi9wYWlycy5qcyc7XG5pbXBvcnQgeyBzZXQgfSBmcm9tICcuL3NldC5qcyc7XG5pbXBvcnQgeyBpbnRUaW1lLCBmbG9hdFRpbWUsIHRpbWVzdGFtcCB9IGZyb20gJy4vdGltZXN0YW1wLmpzJztcblxuY29uc3Qgc2NoZW1hID0gW1xuICAgIG1hcCxcbiAgICBzZXEsXG4gICAgc3RyaW5nLFxuICAgIG51bGxUYWcsXG4gICAgdHJ1ZVRhZyxcbiAgICBmYWxzZVRhZyxcbiAgICBpbnRCaW4sXG4gICAgaW50T2N0LFxuICAgIGludCxcbiAgICBpbnRIZXgsXG4gICAgZmxvYXROYU4sXG4gICAgZmxvYXRFeHAsXG4gICAgZmxvYXQsXG4gICAgYmluYXJ5LFxuICAgIG9tYXAsXG4gICAgcGFpcnMsXG4gICAgc2V0LFxuICAgIGludFRpbWUsXG4gICAgZmxvYXRUaW1lLFxuICAgIHRpbWVzdGFtcFxuXTtcblxuZXhwb3J0IHsgc2NoZW1hIH07XG4iLCAiaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi9jb21tb24vbWFwLmpzJztcbmltcG9ydCB7IG51bGxUYWcgfSBmcm9tICcuL2NvbW1vbi9udWxsLmpzJztcbmltcG9ydCB7IHNlcSB9IGZyb20gJy4vY29tbW9uL3NlcS5qcyc7XG5pbXBvcnQgeyBzdHJpbmcgfSBmcm9tICcuL2NvbW1vbi9zdHJpbmcuanMnO1xuaW1wb3J0IHsgYm9vbFRhZyB9IGZyb20gJy4vY29yZS9ib29sLmpzJztcbmltcG9ydCB7IGZsb2F0LCBmbG9hdEV4cCwgZmxvYXROYU4gfSBmcm9tICcuL2NvcmUvZmxvYXQuanMnO1xuaW1wb3J0IHsgaW50LCBpbnRIZXgsIGludE9jdCB9IGZyb20gJy4vY29yZS9pbnQuanMnO1xuaW1wb3J0IHsgc2NoZW1hIH0gZnJvbSAnLi9jb3JlL3NjaGVtYS5qcyc7XG5pbXBvcnQgeyBzY2hlbWEgYXMgc2NoZW1hJDEgfSBmcm9tICcuL2pzb24vc2NoZW1hLmpzJztcbmltcG9ydCB7IGJpbmFyeSB9IGZyb20gJy4veWFtbC0xLjEvYmluYXJ5LmpzJztcbmltcG9ydCB7IG9tYXAgfSBmcm9tICcuL3lhbWwtMS4xL29tYXAuanMnO1xuaW1wb3J0IHsgcGFpcnMgfSBmcm9tICcuL3lhbWwtMS4xL3BhaXJzLmpzJztcbmltcG9ydCB7IHNjaGVtYSBhcyBzY2hlbWEkMiB9IGZyb20gJy4veWFtbC0xLjEvc2NoZW1hLmpzJztcbmltcG9ydCB7IHNldCB9IGZyb20gJy4veWFtbC0xLjEvc2V0LmpzJztcbmltcG9ydCB7IGZsb2F0VGltZSwgaW50VGltZSwgdGltZXN0YW1wIH0gZnJvbSAnLi95YW1sLTEuMS90aW1lc3RhbXAuanMnO1xuXG5jb25zdCBzY2hlbWFzID0gbmV3IE1hcChbXG4gICAgWydjb3JlJywgc2NoZW1hXSxcbiAgICBbJ2ZhaWxzYWZlJywgW21hcCwgc2VxLCBzdHJpbmddXSxcbiAgICBbJ2pzb24nLCBzY2hlbWEkMV0sXG4gICAgWyd5YW1sMTEnLCBzY2hlbWEkMl0sXG4gICAgWyd5YW1sLTEuMScsIHNjaGVtYSQyXVxuXSk7XG5jb25zdCB0YWdzQnlOYW1lID0ge1xuICAgIGJpbmFyeSxcbiAgICBib29sOiBib29sVGFnLFxuICAgIGZsb2F0LFxuICAgIGZsb2F0RXhwLFxuICAgIGZsb2F0TmFOLFxuICAgIGZsb2F0VGltZSxcbiAgICBpbnQsXG4gICAgaW50SGV4LFxuICAgIGludE9jdCxcbiAgICBpbnRUaW1lLFxuICAgIG1hcCxcbiAgICBudWxsOiBudWxsVGFnLFxuICAgIG9tYXAsXG4gICAgcGFpcnMsXG4gICAgc2VxLFxuICAgIHNldCxcbiAgICB0aW1lc3RhbXBcbn07XG5jb25zdCBjb3JlS25vd25UYWdzID0ge1xuICAgICd0YWc6eWFtbC5vcmcsMjAwMjpiaW5hcnknOiBiaW5hcnksXG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnOiBvbWFwLFxuICAgICd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycyc6IHBhaXJzLFxuICAgICd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnOiBzZXQsXG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCc6IHRpbWVzdGFtcFxufTtcbmZ1bmN0aW9uIGdldFRhZ3MoY3VzdG9tVGFncywgc2NoZW1hTmFtZSkge1xuICAgIGxldCB0YWdzID0gc2NoZW1hcy5nZXQoc2NoZW1hTmFtZSk7XG4gICAgaWYgKCF0YWdzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1c3RvbVRhZ3MpKVxuICAgICAgICAgICAgdGFncyA9IFtdO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBBcnJheS5mcm9tKHNjaGVtYXMua2V5cygpKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoa2V5ID0+IGtleSAhPT0gJ3lhbWwxMScpXG4gICAgICAgICAgICAgICAgLm1hcChrZXkgPT4gSlNPTi5zdHJpbmdpZnkoa2V5KSlcbiAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzY2hlbWEgXCIke3NjaGVtYU5hbWV9XCI7IHVzZSBvbmUgb2YgJHtrZXlzfSBvciBkZWZpbmUgY3VzdG9tVGFncyBhcnJheWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGN1c3RvbVRhZ3MpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdGFnIG9mIGN1c3RvbVRhZ3MpXG4gICAgICAgICAgICB0YWdzID0gdGFncy5jb25jYXQodGFnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGN1c3RvbVRhZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGFncyA9IGN1c3RvbVRhZ3ModGFncy5zbGljZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhZ3MubWFwKHRhZyA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdGFnICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgICAgIGNvbnN0IHRhZ09iaiA9IHRhZ3NCeU5hbWVbdGFnXTtcbiAgICAgICAgaWYgKHRhZ09iailcbiAgICAgICAgICAgIHJldHVybiB0YWdPYmo7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0YWdzQnlOYW1lKVxuICAgICAgICAgICAgLm1hcChrZXkgPT4gSlNPTi5zdHJpbmdpZnkoa2V5KSlcbiAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY3VzdG9tIHRhZyBcIiR7dGFnfVwiOyB1c2Ugb25lIG9mICR7a2V5c31gKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgY29yZUtub3duVGFncywgZ2V0VGFncyB9O1xuIiwgImltcG9ydCB7IE1BUCwgU0NBTEFSLCBTRVEgfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJy4vY29tbW9uL21hcC5qcyc7XG5pbXBvcnQgeyBzZXEgfSBmcm9tICcuL2NvbW1vbi9zZXEuanMnO1xuaW1wb3J0IHsgc3RyaW5nIH0gZnJvbSAnLi9jb21tb24vc3RyaW5nLmpzJztcbmltcG9ydCB7IGdldFRhZ3MsIGNvcmVLbm93blRhZ3MgfSBmcm9tICcuL3RhZ3MuanMnO1xuXG5jb25zdCBzb3J0TWFwRW50cmllc0J5S2V5ID0gKGEsIGIpID0+IGEua2V5IDwgYi5rZXkgPyAtMSA6IGEua2V5ID4gYi5rZXkgPyAxIDogMDtcbmNsYXNzIFNjaGVtYSB7XG4gICAgY29uc3RydWN0b3IoeyBjb21wYXQsIGN1c3RvbVRhZ3MsIG1lcmdlLCByZXNvbHZlS25vd25UYWdzLCBzY2hlbWEsIHNvcnRNYXBFbnRyaWVzLCB0b1N0cmluZ0RlZmF1bHRzIH0pIHtcbiAgICAgICAgdGhpcy5jb21wYXQgPSBBcnJheS5pc0FycmF5KGNvbXBhdClcbiAgICAgICAgICAgID8gZ2V0VGFncyhjb21wYXQsICdjb21wYXQnKVxuICAgICAgICAgICAgOiBjb21wYXRcbiAgICAgICAgICAgICAgICA/IGdldFRhZ3MobnVsbCwgY29tcGF0KVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgdGhpcy5tZXJnZSA9ICEhbWVyZ2U7XG4gICAgICAgIHRoaXMubmFtZSA9ICh0eXBlb2Ygc2NoZW1hID09PSAnc3RyaW5nJyAmJiBzY2hlbWEpIHx8ICdjb3JlJztcbiAgICAgICAgdGhpcy5rbm93blRhZ3MgPSByZXNvbHZlS25vd25UYWdzID8gY29yZUtub3duVGFncyA6IHt9O1xuICAgICAgICB0aGlzLnRhZ3MgPSBnZXRUYWdzKGN1c3RvbVRhZ3MsIHRoaXMubmFtZSk7XG4gICAgICAgIHRoaXMudG9TdHJpbmdPcHRpb25zID0gdG9TdHJpbmdEZWZhdWx0cyA/PyBudWxsO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgTUFQLCB7IHZhbHVlOiBtYXAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBTQ0FMQVIsIHsgdmFsdWU6IHN0cmluZyB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFNFUSwgeyB2YWx1ZTogc2VxIH0pO1xuICAgICAgICAvLyBVc2VkIGJ5IGNyZWF0ZU1hcCgpXG4gICAgICAgIHRoaXMuc29ydE1hcEVudHJpZXMgPVxuICAgICAgICAgICAgdHlwZW9mIHNvcnRNYXBFbnRyaWVzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgPyBzb3J0TWFwRW50cmllc1xuICAgICAgICAgICAgICAgIDogc29ydE1hcEVudHJpZXMgPT09IHRydWVcbiAgICAgICAgICAgICAgICAgICAgPyBzb3J0TWFwRW50cmllc0J5S2V5XG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuY3JlYXRlKFNjaGVtYS5wcm90b3R5cGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRoaXMpKTtcbiAgICAgICAgY29weS50YWdzID0gdGhpcy50YWdzLnNsaWNlKCk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbn1cblxuZXhwb3J0IHsgU2NoZW1hIH07XG4iLCAiaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTdHJpbmdpZnlDb250ZXh0LCBzdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgeyBpbmRlbnRDb21tZW50LCBsaW5lQ29tbWVudCB9IGZyb20gJy4vc3RyaW5naWZ5Q29tbWVudC5qcyc7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeURvY3VtZW50KGRvYywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxpbmVzID0gW107XG4gICAgbGV0IGhhc0RpcmVjdGl2ZXMgPSBvcHRpb25zLmRpcmVjdGl2ZXMgPT09IHRydWU7XG4gICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcyAhPT0gZmFsc2UgJiYgZG9jLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgY29uc3QgZGlyID0gZG9jLmRpcmVjdGl2ZXMudG9TdHJpbmcoZG9jKTtcbiAgICAgICAgaWYgKGRpcikge1xuICAgICAgICAgICAgbGluZXMucHVzaChkaXIpO1xuICAgICAgICAgICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9jLmRpcmVjdGl2ZXMuZG9jU3RhcnQpXG4gICAgICAgICAgICBoYXNEaXJlY3RpdmVzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGhhc0RpcmVjdGl2ZXMpXG4gICAgICAgIGxpbmVzLnB1c2goJy0tLScpO1xuICAgIGNvbnN0IGN0eCA9IGNyZWF0ZVN0cmluZ2lmeUNvbnRleHQoZG9jLCBvcHRpb25zKTtcbiAgICBjb25zdCB7IGNvbW1lbnRTdHJpbmcgfSA9IGN0eC5vcHRpb25zO1xuICAgIGlmIChkb2MuY29tbWVudEJlZm9yZSkge1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoICE9PSAxKVxuICAgICAgICAgICAgbGluZXMudW5zaGlmdCgnJyk7XG4gICAgICAgIGNvbnN0IGNzID0gY29tbWVudFN0cmluZyhkb2MuY29tbWVudEJlZm9yZSk7XG4gICAgICAgIGxpbmVzLnVuc2hpZnQoaW5kZW50Q29tbWVudChjcywgJycpKTtcbiAgICB9XG4gICAgbGV0IGNob21wS2VlcCA9IGZhbHNlO1xuICAgIGxldCBjb250ZW50Q29tbWVudCA9IG51bGw7XG4gICAgaWYgKGRvYy5jb250ZW50cykge1xuICAgICAgICBpZiAoaXNOb2RlKGRvYy5jb250ZW50cykpIHtcbiAgICAgICAgICAgIGlmIChkb2MuY29udGVudHMuc3BhY2VCZWZvcmUgJiYgaGFzRGlyZWN0aXZlcylcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgICAgIGlmIChkb2MuY29udGVudHMuY29tbWVudEJlZm9yZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNzID0gY29tbWVudFN0cmluZyhkb2MuY29udGVudHMuY29tbWVudEJlZm9yZSk7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChpbmRlbnRDb21tZW50KGNzLCAnJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdG9wLWxldmVsIGJsb2NrIHNjYWxhcnMgbmVlZCB0byBiZSBpbmRlbnRlZCBpZiBmb2xsb3dlZCBieSBhIGNvbW1lbnRcbiAgICAgICAgICAgIGN0eC5mb3JjZUJsb2NrSW5kZW50ID0gISFkb2MuY29tbWVudDtcbiAgICAgICAgICAgIGNvbnRlbnRDb21tZW50ID0gZG9jLmNvbnRlbnRzLmNvbW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb25DaG9tcEtlZXAgPSBjb250ZW50Q29tbWVudCA/IHVuZGVmaW5lZCA6ICgpID0+IChjaG9tcEtlZXAgPSB0cnVlKTtcbiAgICAgICAgbGV0IGJvZHkgPSBzdHJpbmdpZnkoZG9jLmNvbnRlbnRzLCBjdHgsICgpID0+IChjb250ZW50Q29tbWVudCA9IG51bGwpLCBvbkNob21wS2VlcCk7XG4gICAgICAgIGlmIChjb250ZW50Q29tbWVudClcbiAgICAgICAgICAgIGJvZHkgKz0gbGluZUNvbW1lbnQoYm9keSwgJycsIGNvbW1lbnRTdHJpbmcoY29udGVudENvbW1lbnQpKTtcbiAgICAgICAgaWYgKChib2R5WzBdID09PSAnfCcgfHwgYm9keVswXSA9PT0gJz4nKSAmJlxuICAgICAgICAgICAgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0gPT09ICctLS0nKSB7XG4gICAgICAgICAgICAvLyBUb3AtbGV2ZWwgYmxvY2sgc2NhbGFycyB3aXRoIGEgcHJlY2VkaW5nIGRvYyBtYXJrZXIgb3VnaHQgdG8gdXNlIHRoZVxuICAgICAgICAgICAgLy8gc2FtZSBsaW5lIGZvciB0aGVpciBoZWFkZXIuXG4gICAgICAgICAgICBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSA9IGAtLS0gJHtib2R5fWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGluZXMucHVzaChib2R5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxpbmVzLnB1c2goc3RyaW5naWZ5KGRvYy5jb250ZW50cywgY3R4KSk7XG4gICAgfVxuICAgIGlmIChkb2MuZGlyZWN0aXZlcz8uZG9jRW5kKSB7XG4gICAgICAgIGlmIChkb2MuY29tbWVudCkge1xuICAgICAgICAgICAgY29uc3QgY3MgPSBjb21tZW50U3RyaW5nKGRvYy5jb21tZW50KTtcbiAgICAgICAgICAgIGlmIChjcy5pbmNsdWRlcygnXFxuJykpIHtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcuLi4nKTtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGluZGVudENvbW1lbnQoY3MsICcnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGAuLi4gJHtjc31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goJy4uLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgZGMgPSBkb2MuY29tbWVudDtcbiAgICAgICAgaWYgKGRjICYmIGNob21wS2VlcClcbiAgICAgICAgICAgIGRjID0gZGMucmVwbGFjZSgvXlxcbisvLCAnJyk7XG4gICAgICAgIGlmIChkYykge1xuICAgICAgICAgICAgaWYgKCghY2hvbXBLZWVwIHx8IGNvbnRlbnRDb21tZW50KSAmJiBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSAhPT0gJycpXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGluZGVudENvbW1lbnQoY29tbWVudFN0cmluZyhkYyksICcnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpICsgJ1xcbic7XG59XG5cbmV4cG9ydCB7IHN0cmluZ2lmeURvY3VtZW50IH07XG4iLCAiLyoqXG4gKiBBcHBsaWVzIHRoZSBKU09OLnBhcnNlIHJldml2ZXIgYWxnb3JpdGhtIGFzIGRlZmluZWQgaW4gdGhlIEVDTUEtMjYyIHNwZWMsXG4gKiBpbiBzZWN0aW9uIDI0LjUuMS4xIFwiUnVudGltZSBTZW1hbnRpY3M6IEludGVybmFsaXplSlNPTlByb3BlcnR5XCIgb2YgdGhlXG4gKiAyMDIxIGVkaXRpb246IGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtanNvbi5wYXJzZVxuICpcbiAqIEluY2x1ZGVzIGV4dGVuc2lvbnMgZm9yIGhhbmRsaW5nIE1hcCBhbmQgU2V0IG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5UmV2aXZlcihyZXZpdmVyLCBvYmosIGtleSwgdmFsKSB7XG4gICAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdjAgPSB2YWxbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgdjEgPSBhcHBseVJldml2ZXIocmV2aXZlciwgdmFsLCBTdHJpbmcoaSksIHYwKTtcbiAgICAgICAgICAgICAgICBpZiAodjEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHZhbFtpXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2MSAhPT0gdjApXG4gICAgICAgICAgICAgICAgICAgIHZhbFtpXSA9IHYxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIEFycmF5LmZyb20odmFsLmtleXMoKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2MCA9IHZhbC5nZXQoayk7XG4gICAgICAgICAgICAgICAgY29uc3QgdjEgPSBhcHBseVJldml2ZXIocmV2aXZlciwgdmFsLCBrLCB2MCk7XG4gICAgICAgICAgICAgICAgaWYgKHYxID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHZhbC5kZWxldGUoayk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodjEgIT09IHYwKVxuICAgICAgICAgICAgICAgICAgICB2YWwuc2V0KGssIHYxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdjAgb2YgQXJyYXkuZnJvbSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdjEgPSBhcHBseVJldml2ZXIocmV2aXZlciwgdmFsLCB2MCwgdjApO1xuICAgICAgICAgICAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB2YWwuZGVsZXRlKHYwKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2MSAhPT0gdjApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsLmRlbGV0ZSh2MCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbC5hZGQodjEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ssIHYwXSBvZiBPYmplY3QuZW50cmllcyh2YWwpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdjEgPSBhcHBseVJldml2ZXIocmV2aXZlciwgdmFsLCBrLCB2MCk7XG4gICAgICAgICAgICAgICAgaWYgKHYxID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWxba107XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodjEgIT09IHYwKVxuICAgICAgICAgICAgICAgICAgICB2YWxba10gPSB2MTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV2aXZlci5jYWxsKG9iaiwga2V5LCB2YWwpO1xufVxuXG5leHBvcnQgeyBhcHBseVJldml2ZXIgfTtcbiIsICJpbXBvcnQgeyBBbGlhcyB9IGZyb20gJy4uL25vZGVzL0FsaWFzLmpzJztcbmltcG9ydCB7IGlzRW1wdHlQYXRoLCBjb2xsZWN0aW9uRnJvbVBhdGggfSBmcm9tICcuLi9ub2Rlcy9Db2xsZWN0aW9uLmpzJztcbmltcG9ydCB7IE5PREVfVFlQRSwgRE9DLCBpc05vZGUsIGlzQ29sbGVjdGlvbiwgaXNTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IFBhaXIgfSBmcm9tICcuLi9ub2Rlcy9QYWlyLmpzJztcbmltcG9ydCB7IHRvSlMgfSBmcm9tICcuLi9ub2Rlcy90b0pTLmpzJztcbmltcG9ydCB7IFNjaGVtYSB9IGZyb20gJy4uL3NjaGVtYS9TY2hlbWEuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5IH0gZnJvbSAnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnlEb2N1bWVudCB9IGZyb20gJy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlEb2N1bWVudC5qcyc7XG5pbXBvcnQgeyBhbmNob3JOYW1lcywgZmluZE5ld0FuY2hvciwgY3JlYXRlTm9kZUFuY2hvcnMgfSBmcm9tICcuL2FuY2hvcnMuanMnO1xuaW1wb3J0IHsgYXBwbHlSZXZpdmVyIH0gZnJvbSAnLi9hcHBseVJldml2ZXIuanMnO1xuaW1wb3J0IHsgY3JlYXRlTm9kZSB9IGZyb20gJy4vY3JlYXRlTm9kZS5qcyc7XG5pbXBvcnQgeyBEaXJlY3RpdmVzIH0gZnJvbSAnLi9kaXJlY3RpdmVzLmpzJztcblxuY2xhc3MgRG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCByZXBsYWNlciwgb3B0aW9ucykge1xuICAgICAgICAvKiogQSBjb21tZW50IGJlZm9yZSB0aGlzIERvY3VtZW50ICovXG4gICAgICAgIHRoaXMuY29tbWVudEJlZm9yZSA9IG51bGw7XG4gICAgICAgIC8qKiBBIGNvbW1lbnQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhpcyBEb2N1bWVudCAqL1xuICAgICAgICB0aGlzLmNvbW1lbnQgPSBudWxsO1xuICAgICAgICAvKiogRXJyb3JzIGVuY291bnRlcmVkIGR1cmluZyBwYXJzaW5nLiAqL1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICAvKiogV2FybmluZ3MgZW5jb3VudGVyZWQgZHVyaW5nIHBhcnNpbmcuICovXG4gICAgICAgIHRoaXMud2FybmluZ3MgPSBbXTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIE5PREVfVFlQRSwgeyB2YWx1ZTogRE9DIH0pO1xuICAgICAgICBsZXQgX3JlcGxhY2VyID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJyB8fCBBcnJheS5pc0FycmF5KHJlcGxhY2VyKSkge1xuICAgICAgICAgICAgX3JlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkICYmIHJlcGxhY2VyKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gcmVwbGFjZXI7XG4gICAgICAgICAgICByZXBsYWNlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHQgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGludEFzQmlnSW50OiBmYWxzZSxcbiAgICAgICAgICAgIGtlZXBTb3VyY2VUb2tlbnM6IGZhbHNlLFxuICAgICAgICAgICAgbG9nTGV2ZWw6ICd3YXJuJyxcbiAgICAgICAgICAgIHByZXR0eUVycm9yczogdHJ1ZSxcbiAgICAgICAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgICAgICAgIHVuaXF1ZUtleXM6IHRydWUsXG4gICAgICAgICAgICB2ZXJzaW9uOiAnMS4yJ1xuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0O1xuICAgICAgICBsZXQgeyB2ZXJzaW9uIH0gPSBvcHQ7XG4gICAgICAgIGlmIChvcHRpb25zPy5fZGlyZWN0aXZlcykge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gb3B0aW9ucy5fZGlyZWN0aXZlcy5hdERvY3VtZW50KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXJlY3RpdmVzLnlhbWwuZXhwbGljaXQpXG4gICAgICAgICAgICAgICAgdmVyc2lvbiA9IHRoaXMuZGlyZWN0aXZlcy55YW1sLnZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gbmV3IERpcmVjdGl2ZXMoeyB2ZXJzaW9uIH0pO1xuICAgICAgICB0aGlzLnNldFNjaGVtYSh2ZXJzaW9uLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzID0gbnVsbDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzID0gdGhpcy5jcmVhdGVOb2RlKHZhbHVlLCBfcmVwbGFjZXIsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGRlZXAgY29weSBvZiB0aGlzIERvY3VtZW50IGFuZCBpdHMgY29udGVudHMuXG4gICAgICpcbiAgICAgKiBDdXN0b20gTm9kZSB2YWx1ZXMgdGhhdCBpbmhlcml0IGZyb20gYE9iamVjdGAgc3RpbGwgcmVmZXIgdG8gdGhlaXIgb3JpZ2luYWwgaW5zdGFuY2VzLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShEb2N1bWVudC5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIFtOT0RFX1RZUEVdOiB7IHZhbHVlOiBET0MgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29weS5jb21tZW50QmVmb3JlID0gdGhpcy5jb21tZW50QmVmb3JlO1xuICAgICAgICBjb3B5LmNvbW1lbnQgPSB0aGlzLmNvbW1lbnQ7XG4gICAgICAgIGNvcHkuZXJyb3JzID0gdGhpcy5lcnJvcnMuc2xpY2UoKTtcbiAgICAgICAgY29weS53YXJuaW5ncyA9IHRoaXMud2FybmluZ3Muc2xpY2UoKTtcbiAgICAgICAgY29weS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuZGlyZWN0aXZlcylcbiAgICAgICAgICAgIGNvcHkuZGlyZWN0aXZlcyA9IHRoaXMuZGlyZWN0aXZlcy5jbG9uZSgpO1xuICAgICAgICBjb3B5LnNjaGVtYSA9IHRoaXMuc2NoZW1hLmNsb25lKCk7XG4gICAgICAgIGNvcHkuY29udGVudHMgPSBpc05vZGUodGhpcy5jb250ZW50cylcbiAgICAgICAgICAgID8gdGhpcy5jb250ZW50cy5jbG9uZShjb3B5LnNjaGVtYSlcbiAgICAgICAgICAgIDogdGhpcy5jb250ZW50cztcbiAgICAgICAgaWYgKHRoaXMucmFuZ2UpXG4gICAgICAgICAgICBjb3B5LnJhbmdlID0gdGhpcy5yYW5nZS5zbGljZSgpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqIEFkZHMgYSB2YWx1ZSB0byB0aGUgZG9jdW1lbnQuICovXG4gICAgYWRkKHZhbHVlKSB7XG4gICAgICAgIGlmIChhc3NlcnRDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpKVxuICAgICAgICAgICAgdGhpcy5jb250ZW50cy5hZGQodmFsdWUpO1xuICAgIH1cbiAgICAvKiogQWRkcyBhIHZhbHVlIHRvIHRoZSBkb2N1bWVudC4gKi9cbiAgICBhZGRJbihwYXRoLCB2YWx1ZSkge1xuICAgICAgICBpZiAoYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSlcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMuYWRkSW4ocGF0aCwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYEFsaWFzYCBub2RlLCBlbnN1cmluZyB0aGF0IHRoZSB0YXJnZXQgYG5vZGVgIGhhcyB0aGUgcmVxdWlyZWQgYW5jaG9yLlxuICAgICAqXG4gICAgICogSWYgYG5vZGVgIGFscmVhZHkgaGFzIGFuIGFuY2hvciwgYG5hbWVgIGlzIGlnbm9yZWQuXG4gICAgICogT3RoZXJ3aXNlLCB0aGUgYG5vZGUuYW5jaG9yYCB2YWx1ZSB3aWxsIGJlIHNldCB0byBgbmFtZWAsXG4gICAgICogb3IgaWYgYW4gYW5jaG9yIHdpdGggdGhhdCBuYW1lIGlzIGFscmVhZHkgcHJlc2VudCBpbiB0aGUgZG9jdW1lbnQsXG4gICAgICogYG5hbWVgIHdpbGwgYmUgdXNlZCBhcyBhIHByZWZpeCBmb3IgYSBuZXcgdW5pcXVlIGFuY2hvci5cbiAgICAgKiBJZiBgbmFtZWAgaXMgdW5kZWZpbmVkLCB0aGUgZ2VuZXJhdGVkIGFuY2hvciB3aWxsIHVzZSAnYScgYXMgYSBwcmVmaXguXG4gICAgICovXG4gICAgY3JlYXRlQWxpYXMobm9kZSwgbmFtZSkge1xuICAgICAgICBpZiAoIW5vZGUuYW5jaG9yKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gYW5jaG9yTmFtZXModGhpcyk7XG4gICAgICAgICAgICBub2RlLmFuY2hvciA9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItbnVsbGlzaC1jb2FsZXNjaW5nXG4gICAgICAgICAgICAgICAgIW5hbWUgfHwgcHJldi5oYXMobmFtZSkgPyBmaW5kTmV3QW5jaG9yKG5hbWUgfHwgJ2EnLCBwcmV2KSA6IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBbGlhcyhub2RlLmFuY2hvcik7XG4gICAgfVxuICAgIGNyZWF0ZU5vZGUodmFsdWUsIHJlcGxhY2VyLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBfcmVwbGFjZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmVwbGFjZXIuY2FsbCh7ICcnOiB2YWx1ZSB9LCAnJywgdmFsdWUpO1xuICAgICAgICAgICAgX3JlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXBsYWNlcikpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleVRvU3RyID0gKHYpID0+IHR5cGVvZiB2ID09PSAnbnVtYmVyJyB8fCB2IGluc3RhbmNlb2YgU3RyaW5nIHx8IHYgaW5zdGFuY2VvZiBOdW1iZXI7XG4gICAgICAgICAgICBjb25zdCBhc1N0ciA9IHJlcGxhY2VyLmZpbHRlcihrZXlUb1N0cikubWFwKFN0cmluZyk7XG4gICAgICAgICAgICBpZiAoYXNTdHIubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICByZXBsYWNlciA9IHJlcGxhY2VyLmNvbmNhdChhc1N0cik7XG4gICAgICAgICAgICBfcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgJiYgcmVwbGFjZXIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZXBsYWNlcjtcbiAgICAgICAgICAgIHJlcGxhY2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYWxpYXNEdXBsaWNhdGVPYmplY3RzLCBhbmNob3JQcmVmaXgsIGZsb3csIGtlZXBVbmRlZmluZWQsIG9uVGFnT2JqLCB0YWcgfSA9IG9wdGlvbnMgPz8ge307XG4gICAgICAgIGNvbnN0IHsgb25BbmNob3IsIHNldEFuY2hvcnMsIHNvdXJjZU9iamVjdHMgfSA9IGNyZWF0ZU5vZGVBbmNob3JzKHRoaXMsIFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1udWxsaXNoLWNvYWxlc2NpbmdcbiAgICAgICAgYW5jaG9yUHJlZml4IHx8ICdhJyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGFsaWFzRHVwbGljYXRlT2JqZWN0czogYWxpYXNEdXBsaWNhdGVPYmplY3RzID8/IHRydWUsXG4gICAgICAgICAgICBrZWVwVW5kZWZpbmVkOiBrZWVwVW5kZWZpbmVkID8/IGZhbHNlLFxuICAgICAgICAgICAgb25BbmNob3IsXG4gICAgICAgICAgICBvblRhZ09iaixcbiAgICAgICAgICAgIHJlcGxhY2VyOiBfcmVwbGFjZXIsXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICAgICAgc291cmNlT2JqZWN0c1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBub2RlID0gY3JlYXRlTm9kZSh2YWx1ZSwgdGFnLCBjdHgpO1xuICAgICAgICBpZiAoZmxvdyAmJiBpc0NvbGxlY3Rpb24obm9kZSkpXG4gICAgICAgICAgICBub2RlLmZsb3cgPSB0cnVlO1xuICAgICAgICBzZXRBbmNob3JzKCk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEga2V5IGFuZCBhIHZhbHVlIGludG8gYSBgUGFpcmAgdXNpbmcgdGhlIGN1cnJlbnQgc2NoZW1hLFxuICAgICAqIHJlY3Vyc2l2ZWx5IHdyYXBwaW5nIGFsbCB2YWx1ZXMgYXMgYFNjYWxhcmAgb3IgYENvbGxlY3Rpb25gIG5vZGVzLlxuICAgICAqL1xuICAgIGNyZWF0ZVBhaXIoa2V5LCB2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGsgPSB0aGlzLmNyZWF0ZU5vZGUoa2V5LCBudWxsLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMuY3JlYXRlTm9kZSh2YWx1ZSwgbnVsbCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgUGFpcihrLCB2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gdGhlIGRvY3VtZW50LlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgaXRlbSB3YXMgZm91bmQgYW5kIHJlbW92ZWQuXG4gICAgICovXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICByZXR1cm4gYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSA/IHRoaXMuY29udGVudHMuZGVsZXRlKGtleSkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gdGhlIGRvY3VtZW50LlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgaXRlbSB3YXMgZm91bmQgYW5kIHJlbW92ZWQuXG4gICAgICovXG4gICAgZGVsZXRlSW4ocGF0aCkge1xuICAgICAgICBpZiAoaXNFbXB0eVBhdGgocGF0aCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnRzID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50cyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKVxuICAgICAgICAgICAgPyB0aGlzLmNvbnRlbnRzLmRlbGV0ZUluKHBhdGgpXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGl0ZW0gYXQgYGtleWAsIG9yIGB1bmRlZmluZWRgIGlmIG5vdCBmb3VuZC4gQnkgZGVmYXVsdCB1bndyYXBzXG4gICAgICogc2NhbGFyIHZhbHVlcyBmcm9tIHRoZWlyIHN1cnJvdW5kaW5nIG5vZGU7IHRvIGRpc2FibGUgc2V0IGBrZWVwU2NhbGFyYCB0b1xuICAgICAqIGB0cnVlYCAoY29sbGVjdGlvbnMgYXJlIGFsd2F5cyByZXR1cm5lZCBpbnRhY3QpLlxuICAgICAqL1xuICAgIGdldChrZXksIGtlZXBTY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzQ29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKVxuICAgICAgICAgICAgPyB0aGlzLmNvbnRlbnRzLmdldChrZXksIGtlZXBTY2FsYXIpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpdGVtIGF0IGBwYXRoYCwgb3IgYHVuZGVmaW5lZGAgaWYgbm90IGZvdW5kLiBCeSBkZWZhdWx0IHVud3JhcHNcbiAgICAgKiBzY2FsYXIgdmFsdWVzIGZyb20gdGhlaXIgc3Vycm91bmRpbmcgbm9kZTsgdG8gZGlzYWJsZSBzZXQgYGtlZXBTY2FsYXJgIHRvXG4gICAgICogYHRydWVgIChjb2xsZWN0aW9ucyBhcmUgYWx3YXlzIHJldHVybmVkIGludGFjdCkuXG4gICAgICovXG4gICAgZ2V0SW4ocGF0aCwga2VlcFNjYWxhcikge1xuICAgICAgICBpZiAoaXNFbXB0eVBhdGgocGF0aCkpXG4gICAgICAgICAgICByZXR1cm4gIWtlZXBTY2FsYXIgJiYgaXNTY2FsYXIodGhpcy5jb250ZW50cylcbiAgICAgICAgICAgICAgICA/IHRoaXMuY29udGVudHMudmFsdWVcbiAgICAgICAgICAgICAgICA6IHRoaXMuY29udGVudHM7XG4gICAgICAgIHJldHVybiBpc0NvbGxlY3Rpb24odGhpcy5jb250ZW50cylcbiAgICAgICAgICAgID8gdGhpcy5jb250ZW50cy5nZXRJbihwYXRoLCBrZWVwU2NhbGFyKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZG9jdW1lbnQgaW5jbHVkZXMgYSB2YWx1ZSB3aXRoIHRoZSBrZXkgYGtleWAuXG4gICAgICovXG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gaXNDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpID8gdGhpcy5jb250ZW50cy5oYXMoa2V5KSA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGRvY3VtZW50IGluY2x1ZGVzIGEgdmFsdWUgYXQgYHBhdGhgLlxuICAgICAqL1xuICAgIGhhc0luKHBhdGgpIHtcbiAgICAgICAgaWYgKGlzRW1wdHlQYXRoKHBhdGgpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudHMgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGlzQ29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSA/IHRoaXMuY29udGVudHMuaGFzSW4ocGF0aCkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluIHRoaXMgZG9jdW1lbnQuIEZvciBgISFzZXRgLCBgdmFsdWVgIG5lZWRzIHRvIGJlIGFcbiAgICAgKiBib29sZWFuIHRvIGFkZC9yZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgc2V0LlxuICAgICAqL1xuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMgPSBjb2xsZWN0aW9uRnJvbVBhdGgodGhpcy5zY2hlbWEsIFtrZXldLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50cy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluIHRoaXMgZG9jdW1lbnQuIEZvciBgISFzZXRgLCBgdmFsdWVgIG5lZWRzIHRvIGJlIGFcbiAgICAgKiBib29sZWFuIHRvIGFkZC9yZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgc2V0LlxuICAgICAqL1xuICAgIHNldEluKHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0VtcHR5UGF0aChwYXRoKSlcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMgPSB2YWx1ZTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb250ZW50cyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzID0gY29sbGVjdGlvbkZyb21QYXRoKHRoaXMuc2NoZW1hLCBBcnJheS5mcm9tKHBhdGgpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50cy5zZXRJbihwYXRoLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBZQU1MIHZlcnNpb24gYW5kIHNjaGVtYSB1c2VkIGJ5IHRoZSBkb2N1bWVudC5cbiAgICAgKiBBIGBudWxsYCB2ZXJzaW9uIGRpc2FibGVzIHN1cHBvcnQgZm9yIGRpcmVjdGl2ZXMsIGV4cGxpY2l0IHRhZ3MsIGFuY2hvcnMsIGFuZCBhbGlhc2VzLlxuICAgICAqIEl0IGFsc28gcmVxdWlyZXMgdGhlIGBzY2hlbWFgIG9wdGlvbiB0byBiZSBnaXZlbiBhcyBhIGBTY2hlbWFgIGluc3RhbmNlIHZhbHVlLlxuICAgICAqXG4gICAgICogT3ZlcnJpZGVzIGFsbCBwcmV2aW91c2x5IHNldCBzY2hlbWEgb3B0aW9ucy5cbiAgICAgKi9cbiAgICBzZXRTY2hlbWEodmVyc2lvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICB2ZXJzaW9uID0gU3RyaW5nKHZlcnNpb24pO1xuICAgICAgICBsZXQgb3B0O1xuICAgICAgICBzd2l0Y2ggKHZlcnNpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJzEuMSc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aXZlcylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLnlhbWwudmVyc2lvbiA9ICcxLjEnO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gbmV3IERpcmVjdGl2ZXMoeyB2ZXJzaW9uOiAnMS4xJyB9KTtcbiAgICAgICAgICAgICAgICBvcHQgPSB7IG1lcmdlOiB0cnVlLCByZXNvbHZlS25vd25UYWdzOiBmYWxzZSwgc2NoZW1hOiAneWFtbC0xLjEnIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcxLjInOlxuICAgICAgICAgICAgY2FzZSAnbmV4dCc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aXZlcylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLnlhbWwudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBuZXcgRGlyZWN0aXZlcyh7IHZlcnNpb24gfSk7XG4gICAgICAgICAgICAgICAgb3B0ID0geyBtZXJnZTogZmFsc2UsIHJlc29sdmVLbm93blRhZ3M6IHRydWUsIHNjaGVtYTogJ2NvcmUnIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aXZlcylcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGlyZWN0aXZlcztcbiAgICAgICAgICAgICAgICBvcHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gSlNPTi5zdHJpbmdpZnkodmVyc2lvbik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAnMS4xJywgJzEuMicgb3IgbnVsbCBhcyBmaXJzdCBhcmd1bWVudCwgYnV0IGZvdW5kOiAke3N2fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vdCB1c2luZyBgaW5zdGFuY2VvZiBTY2hlbWFgIHRvIGFsbG93IGZvciBkdWNrIHR5cGluZ1xuICAgICAgICBpZiAob3B0aW9ucy5zY2hlbWEgaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgICAgICAgICB0aGlzLnNjaGVtYSA9IG9wdGlvbnMuc2NoZW1hO1xuICAgICAgICBlbHNlIGlmIChvcHQpXG4gICAgICAgICAgICB0aGlzLnNjaGVtYSA9IG5ldyBTY2hlbWEoT2JqZWN0LmFzc2lnbihvcHQsIG9wdGlvbnMpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXaXRoIGEgbnVsbCBZQU1MIHZlcnNpb24sIHRoZSB7IHNjaGVtYTogU2NoZW1hIH0gb3B0aW9uIGlzIHJlcXVpcmVkYCk7XG4gICAgfVxuICAgIC8vIGpzb24gJiBqc29uQXJnIGFyZSBvbmx5IHVzZWQgZnJvbSB0b0pTT04oKVxuICAgIHRvSlMoeyBqc29uLCBqc29uQXJnLCBtYXBBc01hcCwgbWF4QWxpYXNDb3VudCwgb25BbmNob3IsIHJldml2ZXIgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGFuY2hvcnM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIGRvYzogdGhpcyxcbiAgICAgICAgICAgIGtlZXA6ICFqc29uLFxuICAgICAgICAgICAgbWFwQXNNYXA6IG1hcEFzTWFwID09PSB0cnVlLFxuICAgICAgICAgICAgbWFwS2V5V2FybmVkOiBmYWxzZSxcbiAgICAgICAgICAgIG1heEFsaWFzQ291bnQ6IHR5cGVvZiBtYXhBbGlhc0NvdW50ID09PSAnbnVtYmVyJyA/IG1heEFsaWFzQ291bnQgOiAxMDAsXG4gICAgICAgICAgICBzdHJpbmdpZnlcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzID0gdG9KUyh0aGlzLmNvbnRlbnRzLCBqc29uQXJnID8/ICcnLCBjdHgpO1xuICAgICAgICBpZiAodHlwZW9mIG9uQW5jaG9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgZm9yIChjb25zdCB7IGNvdW50LCByZXMgfSBvZiBjdHguYW5jaG9ycy52YWx1ZXMoKSlcbiAgICAgICAgICAgICAgICBvbkFuY2hvcihyZXMsIGNvdW50KTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGFwcGx5UmV2aXZlcihyZXZpdmVyLCB7ICcnOiByZXMgfSwgJycsIHJlcylcbiAgICAgICAgICAgIDogcmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIGRvY3VtZW50IGBjb250ZW50c2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ganNvbkFyZyBVc2VkIGJ5IGBKU09OLnN0cmluZ2lmeWAgdG8gaW5kaWNhdGUgdGhlIGFycmF5IGluZGV4IG9yXG4gICAgICogICBwcm9wZXJ0eSBuYW1lLlxuICAgICAqL1xuICAgIHRvSlNPTihqc29uQXJnLCBvbkFuY2hvcikge1xuICAgICAgICByZXR1cm4gdGhpcy50b0pTKHsganNvbjogdHJ1ZSwganNvbkFyZywgbWFwQXNNYXA6IGZhbHNlLCBvbkFuY2hvciB9KTtcbiAgICB9XG4gICAgLyoqIEEgWUFNTCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZG9jdW1lbnQuICovXG4gICAgdG9TdHJpbmcob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEb2N1bWVudCB3aXRoIGVycm9ycyBjYW5ub3QgYmUgc3RyaW5naWZpZWQnKTtcbiAgICAgICAgaWYgKCdpbmRlbnQnIGluIG9wdGlvbnMgJiZcbiAgICAgICAgICAgICghTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmluZGVudCkgfHwgTnVtYmVyKG9wdGlvbnMuaW5kZW50KSA8PSAwKSkge1xuICAgICAgICAgICAgY29uc3QgcyA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuaW5kZW50KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJpbmRlbnRcIiBvcHRpb24gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIG5vdCAke3N9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeURvY3VtZW50KHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydENvbGxlY3Rpb24oY29udGVudHMpIHtcbiAgICBpZiAoaXNDb2xsZWN0aW9uKGNvbnRlbnRzKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIFlBTUwgY29sbGVjdGlvbiBhcyBkb2N1bWVudCBjb250ZW50cycpO1xufVxuXG5leHBvcnQgeyBEb2N1bWVudCB9O1xuIiwgImNsYXNzIFlBTUxFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBwb3MsIGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgfVxufVxuY2xhc3MgWUFNTFBhcnNlRXJyb3IgZXh0ZW5kcyBZQU1MRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHBvcywgY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcignWUFNTFBhcnNlRXJyb3InLCBwb3MsIGNvZGUsIG1lc3NhZ2UpO1xuICAgIH1cbn1cbmNsYXNzIFlBTUxXYXJuaW5nIGV4dGVuZHMgWUFNTEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3MsIGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoJ1lBTUxXYXJuaW5nJywgcG9zLCBjb2RlLCBtZXNzYWdlKTtcbiAgICB9XG59XG5jb25zdCBwcmV0dGlmeUVycm9yID0gKHNyYywgbGMpID0+IChlcnJvcikgPT4ge1xuICAgIGlmIChlcnJvci5wb3NbMF0gPT09IC0xKVxuICAgICAgICByZXR1cm47XG4gICAgZXJyb3IubGluZVBvcyA9IGVycm9yLnBvcy5tYXAocG9zID0+IGxjLmxpbmVQb3MocG9zKSk7XG4gICAgY29uc3QgeyBsaW5lLCBjb2wgfSA9IGVycm9yLmxpbmVQb3NbMF07XG4gICAgZXJyb3IubWVzc2FnZSArPSBgIGF0IGxpbmUgJHtsaW5lfSwgY29sdW1uICR7Y29sfWA7XG4gICAgbGV0IGNpID0gY29sIC0gMTtcbiAgICBsZXQgbGluZVN0ciA9IHNyY1xuICAgICAgICAuc3Vic3RyaW5nKGxjLmxpbmVTdGFydHNbbGluZSAtIDFdLCBsYy5saW5lU3RhcnRzW2xpbmVdKVxuICAgICAgICAucmVwbGFjZSgvW1xcblxccl0rJC8sICcnKTtcbiAgICAvLyBUcmltIHRvIG1heCA4MCBjaGFycywga2VlcGluZyBjb2wgcG9zaXRpb24gbmVhciB0aGUgbWlkZGxlXG4gICAgaWYgKGNpID49IDYwICYmIGxpbmVTdHIubGVuZ3RoID4gODApIHtcbiAgICAgICAgY29uc3QgdHJpbVN0YXJ0ID0gTWF0aC5taW4oY2kgLSAzOSwgbGluZVN0ci5sZW5ndGggLSA3OSk7XG4gICAgICAgIGxpbmVTdHIgPSAnXHUyMDI2JyArIGxpbmVTdHIuc3Vic3RyaW5nKHRyaW1TdGFydCk7XG4gICAgICAgIGNpIC09IHRyaW1TdGFydCAtIDE7XG4gICAgfVxuICAgIGlmIChsaW5lU3RyLmxlbmd0aCA+IDgwKVxuICAgICAgICBsaW5lU3RyID0gbGluZVN0ci5zdWJzdHJpbmcoMCwgNzkpICsgJ1x1MjAyNic7XG4gICAgLy8gSW5jbHVkZSBwcmV2aW91cyBsaW5lIGluIGNvbnRleHQgaWYgcG9pbnRpbmcgYXQgbGluZSBzdGFydFxuICAgIGlmIChsaW5lID4gMSAmJiAvXiAqJC8udGVzdChsaW5lU3RyLnN1YnN0cmluZygwLCBjaSkpKSB7XG4gICAgICAgIC8vIFJlZ2V4cCB3b24ndCBtYXRjaCBpZiBzdGFydCBpcyB0cmltbWVkXG4gICAgICAgIGxldCBwcmV2ID0gc3JjLnN1YnN0cmluZyhsYy5saW5lU3RhcnRzW2xpbmUgLSAyXSwgbGMubGluZVN0YXJ0c1tsaW5lIC0gMV0pO1xuICAgICAgICBpZiAocHJldi5sZW5ndGggPiA4MClcbiAgICAgICAgICAgIHByZXYgPSBwcmV2LnN1YnN0cmluZygwLCA3OSkgKyAnXHUyMDI2XFxuJztcbiAgICAgICAgbGluZVN0ciA9IHByZXYgKyBsaW5lU3RyO1xuICAgIH1cbiAgICBpZiAoL1teIF0vLnRlc3QobGluZVN0cikpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMTtcbiAgICAgICAgY29uc3QgZW5kID0gZXJyb3IubGluZVBvc1sxXTtcbiAgICAgICAgaWYgKGVuZCAmJiBlbmQubGluZSA9PT0gbGluZSAmJiBlbmQuY29sID4gY29sKSB7XG4gICAgICAgICAgICBjb3VudCA9IE1hdGgubWluKGVuZC5jb2wgLSBjb2wsIDgwIC0gY2kpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvaW50ZXIgPSAnICcucmVwZWF0KGNpKSArICdeJy5yZXBlYXQoY291bnQpO1xuICAgICAgICBlcnJvci5tZXNzYWdlICs9IGA6XFxuXFxuJHtsaW5lU3RyfVxcbiR7cG9pbnRlcn1cXG5gO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IFlBTUxFcnJvciwgWUFNTFBhcnNlRXJyb3IsIFlBTUxXYXJuaW5nLCBwcmV0dGlmeUVycm9yIH07XG4iLCAiZnVuY3Rpb24gcmVzb2x2ZVByb3BzKHRva2VucywgeyBmbG93LCBpbmRpY2F0b3IsIG5leHQsIG9mZnNldCwgb25FcnJvciwgc3RhcnRPbk5ld2xpbmUgfSkge1xuICAgIGxldCBzcGFjZUJlZm9yZSA9IGZhbHNlO1xuICAgIGxldCBhdE5ld2xpbmUgPSBzdGFydE9uTmV3bGluZTtcbiAgICBsZXQgaGFzU3BhY2UgPSBzdGFydE9uTmV3bGluZTtcbiAgICBsZXQgY29tbWVudCA9ICcnO1xuICAgIGxldCBjb21tZW50U2VwID0gJyc7XG4gICAgbGV0IGhhc05ld2xpbmUgPSBmYWxzZTtcbiAgICBsZXQgaGFzTmV3bGluZUFmdGVyUHJvcCA9IGZhbHNlO1xuICAgIGxldCByZXFTcGFjZSA9IGZhbHNlO1xuICAgIGxldCBhbmNob3IgPSBudWxsO1xuICAgIGxldCB0YWcgPSBudWxsO1xuICAgIGxldCBjb21tYSA9IG51bGw7XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICBsZXQgc3RhcnQgPSBudWxsO1xuICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgIGlmIChyZXFTcGFjZSkge1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09ICdzcGFjZScgJiZcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlICE9PSAnbmV3bGluZScgJiZcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlICE9PSAnY29tbWEnKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4ub2Zmc2V0LCAnTUlTU0lOR19DSEFSJywgJ1RhZ3MgYW5kIGFuY2hvcnMgbXVzdCBiZSBzZXBhcmF0ZWQgZnJvbSB0aGUgbmV4dCB0b2tlbiBieSB3aGl0ZSBzcGFjZScpO1xuICAgICAgICAgICAgcmVxU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICAvLyBBdCB0aGUgZG9jIGxldmVsLCB0YWJzIGF0IGxpbmUgc3RhcnQgbWF5IGJlIHBhcnNlZFxuICAgICAgICAgICAgICAgIC8vIGFzIGxlYWRpbmcgd2hpdGUgc3BhY2UgcmF0aGVyIHRoYW4gaW5kZW50YXRpb24uXG4gICAgICAgICAgICAgICAgLy8gSW4gYSBmbG93IGNvbGxlY3Rpb24sIG9ubHkgdGhlIHBhcnNlciBoYW5kbGVzIGluZGVudC5cbiAgICAgICAgICAgICAgICBpZiAoIWZsb3cgJiZcbiAgICAgICAgICAgICAgICAgICAgYXROZXdsaW5lICYmXG4gICAgICAgICAgICAgICAgICAgIGluZGljYXRvciAhPT0gJ2RvYy1zdGFydCcgJiZcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4uc291cmNlWzBdID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1RBQl9BU19JTkRFTlQnLCAnVGFicyBhcmUgbm90IGFsbG93ZWQgYXMgaW5kZW50YXRpb24nKTtcbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb21tZW50Jzoge1xuICAgICAgICAgICAgICAgIGlmICghaGFzU3BhY2UpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNSVNTSU5HX0NIQVInLCAnQ29tbWVudHMgbXVzdCBiZSBzZXBhcmF0ZWQgZnJvbSBvdGhlciB0b2tlbnMgYnkgd2hpdGUgc3BhY2UgY2hhcmFjdGVycycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gdG9rZW4uc291cmNlLnN1YnN0cmluZygxKSB8fCAnICc7XG4gICAgICAgICAgICAgICAgaWYgKCFjb21tZW50KVxuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gY2I7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjb21tZW50ICs9IGNvbW1lbnRTZXAgKyBjYjtcbiAgICAgICAgICAgICAgICBjb21tZW50U2VwID0gJyc7XG4gICAgICAgICAgICAgICAgYXROZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBpZiAoYXROZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCArPSB0b2tlbi5zb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNlQmVmb3JlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjb21tZW50U2VwICs9IHRva2VuLnNvdXJjZTtcbiAgICAgICAgICAgICAgICBhdE5ld2xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGhhc05ld2xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChhbmNob3IgfHwgdGFnKVxuICAgICAgICAgICAgICAgICAgICBoYXNOZXdsaW5lQWZ0ZXJQcm9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhbmNob3InOlxuICAgICAgICAgICAgICAgIGlmIChhbmNob3IpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNVUxUSVBMRV9BTkNIT1JTJywgJ0Egbm9kZSBjYW4gaGF2ZSBhdCBtb3N0IG9uZSBhbmNob3InKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4uc291cmNlLmVuZHNXaXRoKCc6JykpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4ub2Zmc2V0ICsgdG9rZW4uc291cmNlLmxlbmd0aCAtIDEsICdCQURfQUxJQVMnLCAnQW5jaG9yIGVuZGluZyBpbiA6IGlzIGFtYmlndW91cycsIHRydWUpO1xuICAgICAgICAgICAgICAgIGFuY2hvciA9IHRva2VuO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0b2tlbi5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgYXROZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXFTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0YWcnOiB7XG4gICAgICAgICAgICAgICAgaWYgKHRhZylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ01VTFRJUExFX1RBR1MnLCAnQSBub2RlIGNhbiBoYXZlIGF0IG1vc3Qgb25lIHRhZycpO1xuICAgICAgICAgICAgICAgIHRhZyA9IHRva2VuO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0b2tlbi5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgYXROZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXFTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGluZGljYXRvcjpcbiAgICAgICAgICAgICAgICAvLyBDb3VsZCBoZXJlIGhhbmRsZSBwcmVjZWRpbmcgY29tbWVudHMgZGlmZmVyZW50bHlcbiAgICAgICAgICAgICAgICBpZiAoYW5jaG9yIHx8IHRhZylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ0JBRF9QUk9QX09SREVSJywgYEFuY2hvcnMgYW5kIHRhZ3MgbXVzdCBiZSBhZnRlciB0aGUgJHt0b2tlbi5zb3VyY2V9IGluZGljYXRvcmApO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1VORVhQRUNURURfVE9LRU4nLCBgVW5leHBlY3RlZCAke3Rva2VuLnNvdXJjZX0gaW4gJHtmbG93ID8/ICdjb2xsZWN0aW9uJ31gKTtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb21tYSc6XG4gICAgICAgICAgICAgICAgaWYgKGZsb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1hKVxuICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1VORVhQRUNURURfVE9LRU4nLCBgVW5leHBlY3RlZCAsIGluICR7Zmxvd31gKTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWEgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgYXROZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVsc2UgZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1VORVhQRUNURURfVE9LRU4nLCBgVW5leHBlY3RlZCAke3Rva2VuLnR5cGV9IHRva2VuYCk7XG4gICAgICAgICAgICAgICAgYXROZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsYXN0ID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBlbmQgPSBsYXN0ID8gbGFzdC5vZmZzZXQgKyBsYXN0LnNvdXJjZS5sZW5ndGggOiBvZmZzZXQ7XG4gICAgaWYgKHJlcVNwYWNlICYmXG4gICAgICAgIG5leHQgJiZcbiAgICAgICAgbmV4dC50eXBlICE9PSAnc3BhY2UnICYmXG4gICAgICAgIG5leHQudHlwZSAhPT0gJ25ld2xpbmUnICYmXG4gICAgICAgIG5leHQudHlwZSAhPT0gJ2NvbW1hJyAmJlxuICAgICAgICAobmV4dC50eXBlICE9PSAnc2NhbGFyJyB8fCBuZXh0LnNvdXJjZSAhPT0gJycpKVxuICAgICAgICBvbkVycm9yKG5leHQub2Zmc2V0LCAnTUlTU0lOR19DSEFSJywgJ1RhZ3MgYW5kIGFuY2hvcnMgbXVzdCBiZSBzZXBhcmF0ZWQgZnJvbSB0aGUgbmV4dCB0b2tlbiBieSB3aGl0ZSBzcGFjZScpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbW1hLFxuICAgICAgICBmb3VuZCxcbiAgICAgICAgc3BhY2VCZWZvcmUsXG4gICAgICAgIGNvbW1lbnQsXG4gICAgICAgIGhhc05ld2xpbmUsXG4gICAgICAgIGhhc05ld2xpbmVBZnRlclByb3AsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgdGFnLFxuICAgICAgICBlbmQsXG4gICAgICAgIHN0YXJ0OiBzdGFydCA/PyBlbmRcbiAgICB9O1xufVxuXG5leHBvcnQgeyByZXNvbHZlUHJvcHMgfTtcbiIsICJmdW5jdGlvbiBjb250YWluc05ld2xpbmUoa2V5KSB7XG4gICAgaWYgKCFrZXkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHN3aXRjaCAoa2V5LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnYWxpYXMnOlxuICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgIGlmIChrZXkuc291cmNlLmluY2x1ZGVzKCdcXG4nKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChrZXkuZW5kKVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3Qgb2Yga2V5LmVuZClcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0LnR5cGUgPT09ICduZXdsaW5lJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjYXNlICdmbG93LWNvbGxlY3Rpb24nOlxuICAgICAgICAgICAgZm9yIChjb25zdCBpdCBvZiBrZXkuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0IG9mIGl0LnN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3QudHlwZSA9PT0gJ25ld2xpbmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGl0LnNlcClcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdCBvZiBpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3QudHlwZSA9PT0gJ25ld2xpbmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChjb250YWluc05ld2xpbmUoaXQua2V5KSB8fCBjb250YWluc05ld2xpbmUoaXQudmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgY29udGFpbnNOZXdsaW5lIH07XG4iLCAiaW1wb3J0IHsgY29udGFpbnNOZXdsaW5lIH0gZnJvbSAnLi91dGlsLWNvbnRhaW5zLW5ld2xpbmUuanMnO1xuXG5mdW5jdGlvbiBmbG93SW5kZW50Q2hlY2soaW5kZW50LCBmYywgb25FcnJvcikge1xuICAgIGlmIChmYz8udHlwZSA9PT0gJ2Zsb3ctY29sbGVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgZW5kID0gZmMuZW5kWzBdO1xuICAgICAgICBpZiAoZW5kLmluZGVudCA9PT0gaW5kZW50ICYmXG4gICAgICAgICAgICAoZW5kLnNvdXJjZSA9PT0gJ10nIHx8IGVuZC5zb3VyY2UgPT09ICd9JykgJiZcbiAgICAgICAgICAgIGNvbnRhaW5zTmV3bGluZShmYykpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdGbG93IGVuZCBpbmRpY2F0b3Igc2hvdWxkIGJlIG1vcmUgaW5kZW50ZWQgdGhhbiBwYXJlbnQnO1xuICAgICAgICAgICAgb25FcnJvcihlbmQsICdCQURfSU5ERU5UJywgbXNnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgZmxvd0luZGVudENoZWNrIH07XG4iLCAiaW1wb3J0IHsgaXNTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcblxuZnVuY3Rpb24gbWFwSW5jbHVkZXMoY3R4LCBpdGVtcywgc2VhcmNoKSB7XG4gICAgY29uc3QgeyB1bmlxdWVLZXlzIH0gPSBjdHgub3B0aW9ucztcbiAgICBpZiAodW5pcXVlS2V5cyA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBpc0VxdWFsID0gdHlwZW9mIHVuaXF1ZUtleXMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyB1bmlxdWVLZXlzXG4gICAgICAgIDogKGEsIGIpID0+IGEgPT09IGIgfHxcbiAgICAgICAgICAgIChpc1NjYWxhcihhKSAmJlxuICAgICAgICAgICAgICAgIGlzU2NhbGFyKGIpICYmXG4gICAgICAgICAgICAgICAgYS52YWx1ZSA9PT0gYi52YWx1ZSAmJlxuICAgICAgICAgICAgICAgICEoYS52YWx1ZSA9PT0gJzw8JyAmJiBjdHguc2NoZW1hLm1lcmdlKSk7XG4gICAgcmV0dXJuIGl0ZW1zLnNvbWUocGFpciA9PiBpc0VxdWFsKHBhaXIua2V5LCBzZWFyY2gpKTtcbn1cblxuZXhwb3J0IHsgbWFwSW5jbHVkZXMgfTtcbiIsICJpbXBvcnQgeyBQYWlyIH0gZnJvbSAnLi4vbm9kZXMvUGFpci5qcyc7XG5pbXBvcnQgeyBZQU1MTWFwIH0gZnJvbSAnLi4vbm9kZXMvWUFNTE1hcC5qcyc7XG5pbXBvcnQgeyByZXNvbHZlUHJvcHMgfSBmcm9tICcuL3Jlc29sdmUtcHJvcHMuanMnO1xuaW1wb3J0IHsgY29udGFpbnNOZXdsaW5lIH0gZnJvbSAnLi91dGlsLWNvbnRhaW5zLW5ld2xpbmUuanMnO1xuaW1wb3J0IHsgZmxvd0luZGVudENoZWNrIH0gZnJvbSAnLi91dGlsLWZsb3ctaW5kZW50LWNoZWNrLmpzJztcbmltcG9ydCB7IG1hcEluY2x1ZGVzIH0gZnJvbSAnLi91dGlsLW1hcC1pbmNsdWRlcy5qcyc7XG5cbmNvbnN0IHN0YXJ0Q29sTXNnID0gJ0FsbCBtYXBwaW5nIGl0ZW1zIG11c3Qgc3RhcnQgYXQgdGhlIHNhbWUgY29sdW1uJztcbmZ1bmN0aW9uIHJlc29sdmVCbG9ja01hcCh7IGNvbXBvc2VOb2RlLCBjb21wb3NlRW1wdHlOb2RlIH0sIGN0eCwgYm0sIG9uRXJyb3IpIHtcbiAgICBjb25zdCBtYXAgPSBuZXcgWUFNTE1hcChjdHguc2NoZW1hKTtcbiAgICBpZiAoY3R4LmF0Um9vdClcbiAgICAgICAgY3R4LmF0Um9vdCA9IGZhbHNlO1xuICAgIGxldCBvZmZzZXQgPSBibS5vZmZzZXQ7XG4gICAgZm9yIChjb25zdCBjb2xsSXRlbSBvZiBibS5pdGVtcykge1xuICAgICAgICBjb25zdCB7IHN0YXJ0LCBrZXksIHNlcCwgdmFsdWUgfSA9IGNvbGxJdGVtO1xuICAgICAgICAvLyBrZXkgcHJvcGVydGllc1xuICAgICAgICBjb25zdCBrZXlQcm9wcyA9IHJlc29sdmVQcm9wcyhzdGFydCwge1xuICAgICAgICAgICAgaW5kaWNhdG9yOiAnZXhwbGljaXQta2V5LWluZCcsXG4gICAgICAgICAgICBuZXh0OiBrZXkgPz8gc2VwPy5bMF0sXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgc3RhcnRPbk5ld2xpbmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGltcGxpY2l0S2V5ID0gIWtleVByb3BzLmZvdW5kO1xuICAgICAgICBpZiAoaW1wbGljaXRLZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnR5cGUgPT09ICdibG9jay1zZXEnKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKG9mZnNldCwgJ0JMT0NLX0FTX0lNUExJQ0lUX0tFWScsICdBIGJsb2NrIHNlcXVlbmNlIG1heSBub3QgYmUgdXNlZCBhcyBhbiBpbXBsaWNpdCBtYXAga2V5Jyk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoJ2luZGVudCcgaW4ga2V5ICYmIGtleS5pbmRlbnQgIT09IGJtLmluZGVudClcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihvZmZzZXQsICdCQURfSU5ERU5UJywgc3RhcnRDb2xNc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFrZXlQcm9wcy5hbmNob3IgJiYgIWtleVByb3BzLnRhZyAmJiAhc2VwKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogYXNzZXJ0IGJlaW5nIGF0IGxhc3QgaXRlbT9cbiAgICAgICAgICAgICAgICBpZiAoa2V5UHJvcHMuY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFwLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuY29tbWVudCArPSAnXFxuJyArIGtleVByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5jb21tZW50ID0ga2V5UHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5UHJvcHMuaGFzTmV3bGluZUFmdGVyUHJvcCB8fCBjb250YWluc05ld2xpbmUoa2V5KSkge1xuICAgICAgICAgICAgICAgIG9uRXJyb3Ioa2V5ID8/IHN0YXJ0W3N0YXJ0Lmxlbmd0aCAtIDFdLCAnTVVMVElMSU5FX0lNUExJQ0lUX0tFWScsICdJbXBsaWNpdCBrZXlzIG5lZWQgdG8gYmUgb24gYSBzaW5nbGUgbGluZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleVByb3BzLmZvdW5kPy5pbmRlbnQgIT09IGJtLmluZGVudCkge1xuICAgICAgICAgICAgb25FcnJvcihvZmZzZXQsICdCQURfSU5ERU5UJywgc3RhcnRDb2xNc2cpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGtleSB2YWx1ZVxuICAgICAgICBjb25zdCBrZXlTdGFydCA9IGtleVByb3BzLmVuZDtcbiAgICAgICAgY29uc3Qga2V5Tm9kZSA9IGtleVxuICAgICAgICAgICAgPyBjb21wb3NlTm9kZShjdHgsIGtleSwga2V5UHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICA6IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCBrZXlTdGFydCwgc3RhcnQsIG51bGwsIGtleVByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgaWYgKGN0eC5zY2hlbWEuY29tcGF0KVxuICAgICAgICAgICAgZmxvd0luZGVudENoZWNrKGJtLmluZGVudCwga2V5LCBvbkVycm9yKTtcbiAgICAgICAgaWYgKG1hcEluY2x1ZGVzKGN0eCwgbWFwLml0ZW1zLCBrZXlOb2RlKSlcbiAgICAgICAgICAgIG9uRXJyb3Ioa2V5U3RhcnQsICdEVVBMSUNBVEVfS0VZJywgJ01hcCBrZXlzIG11c3QgYmUgdW5pcXVlJyk7XG4gICAgICAgIC8vIHZhbHVlIHByb3BlcnRpZXNcbiAgICAgICAgY29uc3QgdmFsdWVQcm9wcyA9IHJlc29sdmVQcm9wcyhzZXAgPz8gW10sIHtcbiAgICAgICAgICAgIGluZGljYXRvcjogJ21hcC12YWx1ZS1pbmQnLFxuICAgICAgICAgICAgbmV4dDogdmFsdWUsXG4gICAgICAgICAgICBvZmZzZXQ6IGtleU5vZGUucmFuZ2VbMl0sXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgc3RhcnRPbk5ld2xpbmU6ICFrZXkgfHwga2V5LnR5cGUgPT09ICdibG9jay1zY2FsYXInXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZzZXQgPSB2YWx1ZVByb3BzLmVuZDtcbiAgICAgICAgaWYgKHZhbHVlUHJvcHMuZm91bmQpIHtcbiAgICAgICAgICAgIGlmIChpbXBsaWNpdEtleSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZT8udHlwZSA9PT0gJ2Jsb2NrLW1hcCcgJiYgIXZhbHVlUHJvcHMuaGFzTmV3bGluZSlcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihvZmZzZXQsICdCTE9DS19BU19JTVBMSUNJVF9LRVknLCAnTmVzdGVkIG1hcHBpbmdzIGFyZSBub3QgYWxsb3dlZCBpbiBjb21wYWN0IG1hcHBpbmdzJyk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5vcHRpb25zLnN0cmljdCAmJlxuICAgICAgICAgICAgICAgICAgICBrZXlQcm9wcy5zdGFydCA8IHZhbHVlUHJvcHMuZm91bmQub2Zmc2V0IC0gMTAyNClcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihrZXlOb2RlLnJhbmdlLCAnS0VZX09WRVJfMTAyNF9DSEFSUycsICdUaGUgOiBpbmRpY2F0b3IgbXVzdCBiZSBhdCBtb3N0IDEwMjQgY2hhcnMgYWZ0ZXIgdGhlIHN0YXJ0IG9mIGFuIGltcGxpY2l0IGJsb2NrIG1hcHBpbmcga2V5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB2YWx1ZSB2YWx1ZVxuICAgICAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gdmFsdWVcbiAgICAgICAgICAgICAgICA/IGNvbXBvc2VOb2RlKGN0eCwgdmFsdWUsIHZhbHVlUHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICAgICAgOiBjb21wb3NlRW1wdHlOb2RlKGN0eCwgb2Zmc2V0LCBzZXAsIG51bGwsIHZhbHVlUHJvcHMsIG9uRXJyb3IpO1xuICAgICAgICAgICAgaWYgKGN0eC5zY2hlbWEuY29tcGF0KVxuICAgICAgICAgICAgICAgIGZsb3dJbmRlbnRDaGVjayhibS5pbmRlbnQsIHZhbHVlLCBvbkVycm9yKTtcbiAgICAgICAgICAgIG9mZnNldCA9IHZhbHVlTm9kZS5yYW5nZVsyXTtcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBuZXcgUGFpcihrZXlOb2RlLCB2YWx1ZU5vZGUpO1xuICAgICAgICAgICAgaWYgKGN0eC5vcHRpb25zLmtlZXBTb3VyY2VUb2tlbnMpXG4gICAgICAgICAgICAgICAgcGFpci5zcmNUb2tlbiA9IGNvbGxJdGVtO1xuICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2gocGFpcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBrZXkgd2l0aCBubyB2YWx1ZVxuICAgICAgICAgICAgaWYgKGltcGxpY2l0S2V5KVxuICAgICAgICAgICAgICAgIG9uRXJyb3Ioa2V5Tm9kZS5yYW5nZSwgJ01JU1NJTkdfQ0hBUicsICdJbXBsaWNpdCBtYXAga2V5cyBuZWVkIHRvIGJlIGZvbGxvd2VkIGJ5IG1hcCB2YWx1ZXMnKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZVByb3BzLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5Tm9kZS5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICBrZXlOb2RlLmNvbW1lbnQgKz0gJ1xcbicgKyB2YWx1ZVByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBrZXlOb2RlLmNvbW1lbnQgPSB2YWx1ZVByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYWlyID0gbmV3IFBhaXIoa2V5Tm9kZSk7XG4gICAgICAgICAgICBpZiAoY3R4Lm9wdGlvbnMua2VlcFNvdXJjZVRva2VucylcbiAgICAgICAgICAgICAgICBwYWlyLnNyY1Rva2VuID0gY29sbEl0ZW07XG4gICAgICAgICAgICBtYXAuaXRlbXMucHVzaChwYWlyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXAucmFuZ2UgPSBbYm0ub2Zmc2V0LCBvZmZzZXQsIG9mZnNldF07XG4gICAgcmV0dXJuIG1hcDtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUJsb2NrTWFwIH07XG4iLCAiaW1wb3J0IHsgWUFNTFNlcSB9IGZyb20gJy4uL25vZGVzL1lBTUxTZXEuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZVByb3BzIH0gZnJvbSAnLi9yZXNvbHZlLXByb3BzLmpzJztcbmltcG9ydCB7IGZsb3dJbmRlbnRDaGVjayB9IGZyb20gJy4vdXRpbC1mbG93LWluZGVudC1jaGVjay5qcyc7XG5cbmZ1bmN0aW9uIHJlc29sdmVCbG9ja1NlcSh7IGNvbXBvc2VOb2RlLCBjb21wb3NlRW1wdHlOb2RlIH0sIGN0eCwgYnMsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBzZXEgPSBuZXcgWUFNTFNlcShjdHguc2NoZW1hKTtcbiAgICBpZiAoY3R4LmF0Um9vdClcbiAgICAgICAgY3R4LmF0Um9vdCA9IGZhbHNlO1xuICAgIGxldCBvZmZzZXQgPSBicy5vZmZzZXQ7XG4gICAgZm9yIChjb25zdCB7IHN0YXJ0LCB2YWx1ZSB9IG9mIGJzLml0ZW1zKSB7XG4gICAgICAgIGNvbnN0IHByb3BzID0gcmVzb2x2ZVByb3BzKHN0YXJ0LCB7XG4gICAgICAgICAgICBpbmRpY2F0b3I6ICdzZXEtaXRlbS1pbmQnLFxuICAgICAgICAgICAgbmV4dDogdmFsdWUsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgc3RhcnRPbk5ld2xpbmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIG9mZnNldCA9IHByb3BzLmVuZDtcbiAgICAgICAgaWYgKCFwcm9wcy5mb3VuZCkge1xuICAgICAgICAgICAgaWYgKHByb3BzLmFuY2hvciB8fCBwcm9wcy50YWcgfHwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUudHlwZSA9PT0gJ2Jsb2NrLXNlcScpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnQkFEX0lOREVOVCcsICdBbGwgc2VxdWVuY2UgaXRlbXMgbXVzdCBzdGFydCBhdCB0aGUgc2FtZSBjb2x1bW4nKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnTUlTU0lOR19DSEFSJywgJ1NlcXVlbmNlIGl0ZW0gd2l0aG91dCAtIGluZGljYXRvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogYXNzZXJ0IGJlaW5nIGF0IGxhc3QgaXRlbT9cbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgc2VxLmNvbW1lbnQgPSBwcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGUgPSB2YWx1ZVxuICAgICAgICAgICAgPyBjb21wb3NlTm9kZShjdHgsIHZhbHVlLCBwcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgIDogY29tcG9zZUVtcHR5Tm9kZShjdHgsIG9mZnNldCwgc3RhcnQsIG51bGwsIHByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgaWYgKGN0eC5zY2hlbWEuY29tcGF0KVxuICAgICAgICAgICAgZmxvd0luZGVudENoZWNrKGJzLmluZGVudCwgdmFsdWUsIG9uRXJyb3IpO1xuICAgICAgICBvZmZzZXQgPSBub2RlLnJhbmdlWzJdO1xuICAgICAgICBzZXEuaXRlbXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgc2VxLnJhbmdlID0gW2JzLm9mZnNldCwgb2Zmc2V0LCBvZmZzZXRdO1xuICAgIHJldHVybiBzZXE7XG59XG5cbmV4cG9ydCB7IHJlc29sdmVCbG9ja1NlcSB9O1xuIiwgImZ1bmN0aW9uIHJlc29sdmVFbmQoZW5kLCBvZmZzZXQsIHJlcVNwYWNlLCBvbkVycm9yKSB7XG4gICAgbGV0IGNvbW1lbnQgPSAnJztcbiAgICBpZiAoZW5kKSB7XG4gICAgICAgIGxldCBoYXNTcGFjZSA9IGZhbHNlO1xuICAgICAgICBsZXQgc2VwID0gJyc7XG4gICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNvdXJjZSwgdHlwZSB9ID0gdG9rZW47XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcVNwYWNlICYmICFoYXNTcGFjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNSVNTSU5HX0NIQVInLCAnQ29tbWVudHMgbXVzdCBiZSBzZXBhcmF0ZWQgZnJvbSBvdGhlciB0b2tlbnMgYnkgd2hpdGUgc3BhY2UgY2hhcmFjdGVycycpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYiA9IHNvdXJjZS5zdWJzdHJpbmcoMSkgfHwgJyAnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gY2I7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgKz0gc2VwICsgY2I7XG4gICAgICAgICAgICAgICAgICAgIHNlcCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VwICs9IHNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgaGFzU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbmV4cGVjdGVkICR7dHlwZX0gYXQgbm9kZSBlbmRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCArPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGNvbW1lbnQsIG9mZnNldCB9O1xufVxuXG5leHBvcnQgeyByZXNvbHZlRW5kIH07XG4iLCAiaW1wb3J0IHsgaXNQYWlyIH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBQYWlyIH0gZnJvbSAnLi4vbm9kZXMvUGFpci5qcyc7XG5pbXBvcnQgeyBZQU1MTWFwIH0gZnJvbSAnLi4vbm9kZXMvWUFNTE1hcC5qcyc7XG5pbXBvcnQgeyBZQU1MU2VxIH0gZnJvbSAnLi4vbm9kZXMvWUFNTFNlcS5qcyc7XG5pbXBvcnQgeyByZXNvbHZlRW5kIH0gZnJvbSAnLi9yZXNvbHZlLWVuZC5qcyc7XG5pbXBvcnQgeyByZXNvbHZlUHJvcHMgfSBmcm9tICcuL3Jlc29sdmUtcHJvcHMuanMnO1xuaW1wb3J0IHsgY29udGFpbnNOZXdsaW5lIH0gZnJvbSAnLi91dGlsLWNvbnRhaW5zLW5ld2xpbmUuanMnO1xuaW1wb3J0IHsgbWFwSW5jbHVkZXMgfSBmcm9tICcuL3V0aWwtbWFwLWluY2x1ZGVzLmpzJztcblxuY29uc3QgYmxvY2tNc2cgPSAnQmxvY2sgY29sbGVjdGlvbnMgYXJlIG5vdCBhbGxvd2VkIHdpdGhpbiBmbG93IGNvbGxlY3Rpb25zJztcbmNvbnN0IGlzQmxvY2sgPSAodG9rZW4pID0+IHRva2VuICYmICh0b2tlbi50eXBlID09PSAnYmxvY2stbWFwJyB8fCB0b2tlbi50eXBlID09PSAnYmxvY2stc2VxJyk7XG5mdW5jdGlvbiByZXNvbHZlRmxvd0NvbGxlY3Rpb24oeyBjb21wb3NlTm9kZSwgY29tcG9zZUVtcHR5Tm9kZSB9LCBjdHgsIGZjLCBvbkVycm9yKSB7XG4gICAgY29uc3QgaXNNYXAgPSBmYy5zdGFydC5zb3VyY2UgPT09ICd7JztcbiAgICBjb25zdCBmY05hbWUgPSBpc01hcCA/ICdmbG93IG1hcCcgOiAnZmxvdyBzZXF1ZW5jZSc7XG4gICAgY29uc3QgY29sbCA9IGlzTWFwXG4gICAgICAgID8gbmV3IFlBTUxNYXAoY3R4LnNjaGVtYSlcbiAgICAgICAgOiBuZXcgWUFNTFNlcShjdHguc2NoZW1hKTtcbiAgICBjb2xsLmZsb3cgPSB0cnVlO1xuICAgIGNvbnN0IGF0Um9vdCA9IGN0eC5hdFJvb3Q7XG4gICAgaWYgKGF0Um9vdClcbiAgICAgICAgY3R4LmF0Um9vdCA9IGZhbHNlO1xuICAgIGxldCBvZmZzZXQgPSBmYy5vZmZzZXQgKyBmYy5zdGFydC5zb3VyY2UubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmMuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgY29sbEl0ZW0gPSBmYy5pdGVtc1tpXTtcbiAgICAgICAgY29uc3QgeyBzdGFydCwga2V5LCBzZXAsIHZhbHVlIH0gPSBjb2xsSXRlbTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSByZXNvbHZlUHJvcHMoc3RhcnQsIHtcbiAgICAgICAgICAgIGZsb3c6IGZjTmFtZSxcbiAgICAgICAgICAgIGluZGljYXRvcjogJ2V4cGxpY2l0LWtleS1pbmQnLFxuICAgICAgICAgICAgbmV4dDoga2V5ID8/IHNlcD8uWzBdLFxuICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgIHN0YXJ0T25OZXdsaW5lOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFwcm9wcy5mb3VuZCkge1xuICAgICAgICAgICAgaWYgKCFwcm9wcy5hbmNob3IgJiYgIXByb3BzLnRhZyAmJiAhc2VwICYmICF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwICYmIHByb3BzLmNvbW1hKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHByb3BzLmNvbW1hLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbmV4cGVjdGVkICwgaW4gJHtmY05hbWV9YCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA8IGZjLml0ZW1zLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuc3RhcnQsICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgZW1wdHkgaXRlbSBpbiAke2ZjTmFtZX1gKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sbC5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbC5jb21tZW50ICs9ICdcXG4nICsgcHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbC5jb21tZW50ID0gcHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gcHJvcHMuZW5kO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc01hcCAmJiBjdHgub3B0aW9ucy5zdHJpY3QgJiYgY29udGFpbnNOZXdsaW5lKGtleSkpXG4gICAgICAgICAgICAgICAgb25FcnJvcihrZXksIC8vIGNoZWNrZWQgYnkgY29udGFpbnNOZXdsaW5lKClcbiAgICAgICAgICAgICAgICAnTVVMVElMSU5FX0lNUExJQ0lUX0tFWScsICdJbXBsaWNpdCBrZXlzIG9mIGZsb3cgc2VxdWVuY2UgcGFpcnMgbmVlZCB0byBiZSBvbiBhIHNpbmdsZSBsaW5lJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy5jb21tYSlcbiAgICAgICAgICAgICAgICBvbkVycm9yKHByb3BzLmNvbW1hLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbmV4cGVjdGVkICwgaW4gJHtmY05hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXByb3BzLmNvbW1hKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuc3RhcnQsICdNSVNTSU5HX0NIQVInLCBgTWlzc2luZyAsIGJldHdlZW4gJHtmY05hbWV9IGl0ZW1zYCk7XG4gICAgICAgICAgICBpZiAocHJvcHMuY29tbWVudCkge1xuICAgICAgICAgICAgICAgIGxldCBwcmV2SXRlbUNvbW1lbnQgPSAnJztcbiAgICAgICAgICAgICAgICBsb29wOiBmb3IgKGNvbnN0IHN0IG9mIHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3QudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29tbWEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldkl0ZW1Db21tZW50ID0gc3Quc291cmNlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcmV2SXRlbUNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXYgPSBjb2xsLml0ZW1zW2NvbGwuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1BhaXIocHJldikpXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ID0gcHJldi52YWx1ZSA/PyBwcmV2LmtleTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYuY29tbWVudCArPSAnXFxuJyArIHByZXZJdGVtQ29tbWVudDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldi5jb21tZW50ID0gcHJldkl0ZW1Db21tZW50O1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5jb21tZW50ID0gcHJvcHMuY29tbWVudC5zdWJzdHJpbmcocHJldkl0ZW1Db21tZW50Lmxlbmd0aCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzTWFwICYmICFzZXAgJiYgIXByb3BzLmZvdW5kKSB7XG4gICAgICAgICAgICAvLyBpdGVtIGlzIGEgdmFsdWUgaW4gYSBzZXFcbiAgICAgICAgICAgIC8vIFx1MjE5MiBrZXkgJiBzZXAgYXJlIGVtcHR5LCBzdGFydCBkb2VzIG5vdCBpbmNsdWRlID8gb3IgOlxuICAgICAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gdmFsdWVcbiAgICAgICAgICAgICAgICA/IGNvbXBvc2VOb2RlKGN0eCwgdmFsdWUsIHByb3BzLCBvbkVycm9yKVxuICAgICAgICAgICAgICAgIDogY29tcG9zZUVtcHR5Tm9kZShjdHgsIHByb3BzLmVuZCwgc2VwLCBudWxsLCBwcm9wcywgb25FcnJvcik7XG4gICAgICAgICAgICBjb2xsLml0ZW1zLnB1c2godmFsdWVOb2RlKTtcbiAgICAgICAgICAgIG9mZnNldCA9IHZhbHVlTm9kZS5yYW5nZVsyXTtcbiAgICAgICAgICAgIGlmIChpc0Jsb2NrKHZhbHVlKSlcbiAgICAgICAgICAgICAgICBvbkVycm9yKHZhbHVlTm9kZS5yYW5nZSwgJ0JMT0NLX0lOX0ZMT1cnLCBibG9ja01zZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpdGVtIGlzIGEga2V5K3ZhbHVlIHBhaXJcbiAgICAgICAgICAgIC8vIGtleSB2YWx1ZVxuICAgICAgICAgICAgY29uc3Qga2V5U3RhcnQgPSBwcm9wcy5lbmQ7XG4gICAgICAgICAgICBjb25zdCBrZXlOb2RlID0ga2V5XG4gICAgICAgICAgICAgICAgPyBjb21wb3NlTm9kZShjdHgsIGtleSwgcHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICAgICAgOiBjb21wb3NlRW1wdHlOb2RlKGN0eCwga2V5U3RhcnQsIHN0YXJ0LCBudWxsLCBwcm9wcywgb25FcnJvcik7XG4gICAgICAgICAgICBpZiAoaXNCbG9jayhrZXkpKVxuICAgICAgICAgICAgICAgIG9uRXJyb3Ioa2V5Tm9kZS5yYW5nZSwgJ0JMT0NLX0lOX0ZMT1cnLCBibG9ja01zZyk7XG4gICAgICAgICAgICAvLyB2YWx1ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBjb25zdCB2YWx1ZVByb3BzID0gcmVzb2x2ZVByb3BzKHNlcCA/PyBbXSwge1xuICAgICAgICAgICAgICAgIGZsb3c6IGZjTmFtZSxcbiAgICAgICAgICAgICAgICBpbmRpY2F0b3I6ICdtYXAtdmFsdWUtaW5kJyxcbiAgICAgICAgICAgICAgICBuZXh0OiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGtleU5vZGUucmFuZ2VbMl0sXG4gICAgICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgICAgICBzdGFydE9uTmV3bGluZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHZhbHVlUHJvcHMuZm91bmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTWFwICYmICFwcm9wcy5mb3VuZCAmJiBjdHgub3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3Qgb2Ygc2VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0ID09PSB2YWx1ZVByb3BzLmZvdW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3QudHlwZSA9PT0gJ25ld2xpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3Ioc3QsICdNVUxUSUxJTkVfSU1QTElDSVRfS0VZJywgJ0ltcGxpY2l0IGtleXMgb2YgZmxvdyBzZXF1ZW5jZSBwYWlycyBuZWVkIHRvIGJlIG9uIGEgc2luZ2xlIGxpbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMuc3RhcnQgPCB2YWx1ZVByb3BzLmZvdW5kLm9mZnNldCAtIDEwMjQpXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHZhbHVlUHJvcHMuZm91bmQsICdLRVlfT1ZFUl8xMDI0X0NIQVJTJywgJ1RoZSA6IGluZGljYXRvciBtdXN0IGJlIGF0IG1vc3QgMTAyNCBjaGFycyBhZnRlciB0aGUgc3RhcnQgb2YgYW4gaW1wbGljaXQgZmxvdyBzZXF1ZW5jZSBrZXknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICgnc291cmNlJyBpbiB2YWx1ZSAmJiB2YWx1ZS5zb3VyY2UgJiYgdmFsdWUuc291cmNlWzBdID09PSAnOicpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodmFsdWUsICdNSVNTSU5HX0NIQVInLCBgTWlzc2luZyBzcGFjZSBhZnRlciA6IGluICR7ZmNOYW1lfWApO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih2YWx1ZVByb3BzLnN0YXJ0LCAnTUlTU0lOR19DSEFSJywgYE1pc3NpbmcgLCBvciA6IGJldHdlZW4gJHtmY05hbWV9IGl0ZW1zYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB2YWx1ZSB2YWx1ZVxuICAgICAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gdmFsdWVcbiAgICAgICAgICAgICAgICA/IGNvbXBvc2VOb2RlKGN0eCwgdmFsdWUsIHZhbHVlUHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICAgICAgOiB2YWx1ZVByb3BzLmZvdW5kXG4gICAgICAgICAgICAgICAgICAgID8gY29tcG9zZUVtcHR5Tm9kZShjdHgsIHZhbHVlUHJvcHMuZW5kLCBzZXAsIG51bGwsIHZhbHVlUHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIGlmICh2YWx1ZU5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNCbG9jayh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodmFsdWVOb2RlLnJhbmdlLCAnQkxPQ0tfSU5fRkxPVycsIGJsb2NrTXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlUHJvcHMuY29tbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXlOb2RlLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGtleU5vZGUuY29tbWVudCArPSAnXFxuJyArIHZhbHVlUHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGtleU5vZGUuY29tbWVudCA9IHZhbHVlUHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBuZXcgUGFpcihrZXlOb2RlLCB2YWx1ZU5vZGUpO1xuICAgICAgICAgICAgaWYgKGN0eC5vcHRpb25zLmtlZXBTb3VyY2VUb2tlbnMpXG4gICAgICAgICAgICAgICAgcGFpci5zcmNUb2tlbiA9IGNvbGxJdGVtO1xuICAgICAgICAgICAgaWYgKGlzTWFwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFwID0gY29sbDtcbiAgICAgICAgICAgICAgICBpZiAobWFwSW5jbHVkZXMoY3R4LCBtYXAuaXRlbXMsIGtleU5vZGUpKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGtleVN0YXJ0LCAnRFVQTElDQVRFX0tFWScsICdNYXAga2V5cyBtdXN0IGJlIHVuaXF1ZScpO1xuICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHBhaXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFwID0gbmV3IFlBTUxNYXAoY3R4LnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgbWFwLmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHBhaXIpO1xuICAgICAgICAgICAgICAgIGNvbGwuaXRlbXMucHVzaChtYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gdmFsdWVOb2RlID8gdmFsdWVOb2RlLnJhbmdlWzJdIDogdmFsdWVQcm9wcy5lbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXhwZWN0ZWRFbmQgPSBpc01hcCA/ICd9JyA6ICddJztcbiAgICBjb25zdCBbY2UsIC4uLmVlXSA9IGZjLmVuZDtcbiAgICBsZXQgY2VQb3MgPSBvZmZzZXQ7XG4gICAgaWYgKGNlICYmIGNlLnNvdXJjZSA9PT0gZXhwZWN0ZWRFbmQpXG4gICAgICAgIGNlUG9zID0gY2Uub2Zmc2V0ICsgY2Uuc291cmNlLmxlbmd0aDtcbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZjTmFtZVswXS50b1VwcGVyQ2FzZSgpICsgZmNOYW1lLnN1YnN0cmluZygxKTtcbiAgICAgICAgY29uc3QgbXNnID0gYXRSb290XG4gICAgICAgICAgICA/IGAke25hbWV9IG11c3QgZW5kIHdpdGggYSAke2V4cGVjdGVkRW5kfWBcbiAgICAgICAgICAgIDogYCR7bmFtZX0gaW4gYmxvY2sgY29sbGVjdGlvbiBtdXN0IGJlIHN1ZmZpY2llbnRseSBpbmRlbnRlZCBhbmQgZW5kIHdpdGggYSAke2V4cGVjdGVkRW5kfWA7XG4gICAgICAgIG9uRXJyb3Iob2Zmc2V0LCBhdFJvb3QgPyAnTUlTU0lOR19DSEFSJyA6ICdCQURfSU5ERU5UJywgbXNnKTtcbiAgICAgICAgaWYgKGNlICYmIGNlLnNvdXJjZS5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICBlZS51bnNoaWZ0KGNlKTtcbiAgICB9XG4gICAgaWYgKGVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgZW5kID0gcmVzb2x2ZUVuZChlZSwgY2VQb3MsIGN0eC5vcHRpb25zLnN0cmljdCwgb25FcnJvcik7XG4gICAgICAgIGlmIChlbmQuY29tbWVudCkge1xuICAgICAgICAgICAgaWYgKGNvbGwuY29tbWVudClcbiAgICAgICAgICAgICAgICBjb2xsLmNvbW1lbnQgKz0gJ1xcbicgKyBlbmQuY29tbWVudDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjb2xsLmNvbW1lbnQgPSBlbmQuY29tbWVudDtcbiAgICAgICAgfVxuICAgICAgICBjb2xsLnJhbmdlID0gW2ZjLm9mZnNldCwgY2VQb3MsIGVuZC5vZmZzZXRdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29sbC5yYW5nZSA9IFtmYy5vZmZzZXQsIGNlUG9zLCBjZVBvc107XG4gICAgfVxuICAgIHJldHVybiBjb2xsO1xufVxuXG5leHBvcnQgeyByZXNvbHZlRmxvd0NvbGxlY3Rpb24gfTtcbiIsICJpbXBvcnQgeyBpc05vZGUsIGlzTWFwIH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUJsb2NrTWFwIH0gZnJvbSAnLi9yZXNvbHZlLWJsb2NrLW1hcC5qcyc7XG5pbXBvcnQgeyByZXNvbHZlQmxvY2tTZXEgfSBmcm9tICcuL3Jlc29sdmUtYmxvY2stc2VxLmpzJztcbmltcG9ydCB7IHJlc29sdmVGbG93Q29sbGVjdGlvbiB9IGZyb20gJy4vcmVzb2x2ZS1mbG93LWNvbGxlY3Rpb24uanMnO1xuXG5mdW5jdGlvbiBjb21wb3NlQ29sbGVjdGlvbihDTiwgY3R4LCB0b2tlbiwgdGFnVG9rZW4sIG9uRXJyb3IpIHtcbiAgICBsZXQgY29sbDtcbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnYmxvY2stbWFwJzoge1xuICAgICAgICAgICAgY29sbCA9IHJlc29sdmVCbG9ja01hcChDTiwgY3R4LCB0b2tlbiwgb25FcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdibG9jay1zZXEnOiB7XG4gICAgICAgICAgICBjb2xsID0gcmVzb2x2ZUJsb2NrU2VxKENOLCBjdHgsIHRva2VuLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2Zsb3ctY29sbGVjdGlvbic6IHtcbiAgICAgICAgICAgIGNvbGwgPSByZXNvbHZlRmxvd0NvbGxlY3Rpb24oQ04sIGN0eCwgdG9rZW4sIG9uRXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0YWdUb2tlbilcbiAgICAgICAgcmV0dXJuIGNvbGw7XG4gICAgY29uc3QgdGFnTmFtZSA9IGN0eC5kaXJlY3RpdmVzLnRhZ05hbWUodGFnVG9rZW4uc291cmNlLCBtc2cgPT4gb25FcnJvcih0YWdUb2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIG1zZykpO1xuICAgIGlmICghdGFnTmFtZSlcbiAgICAgICAgcmV0dXJuIGNvbGw7XG4gICAgLy8gQ2FzdCBuZWVkZWQgZHVlIHRvOiBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzM4NDFcbiAgICBjb25zdCBDb2xsID0gY29sbC5jb25zdHJ1Y3RvcjtcbiAgICBpZiAodGFnTmFtZSA9PT0gJyEnIHx8IHRhZ05hbWUgPT09IENvbGwudGFnTmFtZSkge1xuICAgICAgICBjb2xsLnRhZyA9IENvbGwudGFnTmFtZTtcbiAgICAgICAgcmV0dXJuIGNvbGw7XG4gICAgfVxuICAgIGNvbnN0IGV4cFR5cGUgPSBpc01hcChjb2xsKSA/ICdtYXAnIDogJ3NlcSc7XG4gICAgbGV0IHRhZyA9IGN0eC5zY2hlbWEudGFncy5maW5kKHQgPT4gdC5jb2xsZWN0aW9uID09PSBleHBUeXBlICYmIHQudGFnID09PSB0YWdOYW1lKTtcbiAgICBpZiAoIXRhZykge1xuICAgICAgICBjb25zdCBrdCA9IGN0eC5zY2hlbWEua25vd25UYWdzW3RhZ05hbWVdO1xuICAgICAgICBpZiAoa3QgJiYga3QuY29sbGVjdGlvbiA9PT0gZXhwVHlwZSkge1xuICAgICAgICAgICAgY3R4LnNjaGVtYS50YWdzLnB1c2goT2JqZWN0LmFzc2lnbih7fSwga3QsIHsgZGVmYXVsdDogZmFsc2UgfSkpO1xuICAgICAgICAgICAgdGFnID0ga3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvbkVycm9yKHRhZ1Rva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgYFVucmVzb2x2ZWQgdGFnOiAke3RhZ05hbWV9YCwgdHJ1ZSk7XG4gICAgICAgICAgICBjb2xsLnRhZyA9IHRhZ05hbWU7XG4gICAgICAgICAgICByZXR1cm4gY29sbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXMgPSB0YWcucmVzb2x2ZShjb2xsLCBtc2cgPT4gb25FcnJvcih0YWdUb2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIG1zZyksIGN0eC5vcHRpb25zKTtcbiAgICBjb25zdCBub2RlID0gaXNOb2RlKHJlcylcbiAgICAgICAgPyByZXNcbiAgICAgICAgOiBuZXcgU2NhbGFyKHJlcyk7XG4gICAgbm9kZS5yYW5nZSA9IGNvbGwucmFuZ2U7XG4gICAgbm9kZS50YWcgPSB0YWdOYW1lO1xuICAgIGlmICh0YWc/LmZvcm1hdClcbiAgICAgICAgbm9kZS5mb3JtYXQgPSB0YWcuZm9ybWF0O1xuICAgIHJldHVybiBub2RlO1xufVxuXG5leHBvcnQgeyBjb21wb3NlQ29sbGVjdGlvbiB9O1xuIiwgImltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uL25vZGVzL1NjYWxhci5qcyc7XG5cbmZ1bmN0aW9uIHJlc29sdmVCbG9ja1NjYWxhcihzY2FsYXIsIHN0cmljdCwgb25FcnJvcikge1xuICAgIGNvbnN0IHN0YXJ0ID0gc2NhbGFyLm9mZnNldDtcbiAgICBjb25zdCBoZWFkZXIgPSBwYXJzZUJsb2NrU2NhbGFySGVhZGVyKHNjYWxhciwgc3RyaWN0LCBvbkVycm9yKTtcbiAgICBpZiAoIWhlYWRlcilcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6ICcnLCB0eXBlOiBudWxsLCBjb21tZW50OiAnJywgcmFuZ2U6IFtzdGFydCwgc3RhcnQsIHN0YXJ0XSB9O1xuICAgIGNvbnN0IHR5cGUgPSBoZWFkZXIubW9kZSA9PT0gJz4nID8gU2NhbGFyLkJMT0NLX0ZPTERFRCA6IFNjYWxhci5CTE9DS19MSVRFUkFMO1xuICAgIGNvbnN0IGxpbmVzID0gc2NhbGFyLnNvdXJjZSA/IHNwbGl0TGluZXMoc2NhbGFyLnNvdXJjZSkgOiBbXTtcbiAgICAvLyBkZXRlcm1pbmUgdGhlIGVuZCBvZiBjb250ZW50ICYgc3RhcnQgb2YgY2hvbXBpbmdcbiAgICBsZXQgY2hvbXBTdGFydCA9IGxpbmVzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gbGluZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGxpbmVzW2ldWzFdO1xuICAgICAgICBpZiAoY29udGVudCA9PT0gJycgfHwgY29udGVudCA9PT0gJ1xccicpXG4gICAgICAgICAgICBjaG9tcFN0YXJ0ID0gaTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIHNob3J0Y3V0IGZvciBlbXB0eSBjb250ZW50c1xuICAgIGlmIChjaG9tcFN0YXJ0ID09PSAwKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaGVhZGVyLmNob21wID09PSAnKycgJiYgbGluZXMubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyAnXFxuJy5yZXBlYXQoTWF0aC5tYXgoMSwgbGluZXMubGVuZ3RoIC0gMSkpXG4gICAgICAgICAgICA6ICcnO1xuICAgICAgICBsZXQgZW5kID0gc3RhcnQgKyBoZWFkZXIubGVuZ3RoO1xuICAgICAgICBpZiAoc2NhbGFyLnNvdXJjZSlcbiAgICAgICAgICAgIGVuZCArPSBzY2FsYXIuc291cmNlLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWUsIHR5cGUsIGNvbW1lbnQ6IGhlYWRlci5jb21tZW50LCByYW5nZTogW3N0YXJ0LCBlbmQsIGVuZF0gfTtcbiAgICB9XG4gICAgLy8gZmluZCB0aGUgaW5kZW50YXRpb24gbGV2ZWwgdG8gdHJpbSBmcm9tIHN0YXJ0XG4gICAgbGV0IHRyaW1JbmRlbnQgPSBzY2FsYXIuaW5kZW50ICsgaGVhZGVyLmluZGVudDtcbiAgICBsZXQgb2Zmc2V0ID0gc2NhbGFyLm9mZnNldCArIGhlYWRlci5sZW5ndGg7XG4gICAgbGV0IGNvbnRlbnRTdGFydCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaG9tcFN0YXJ0OyArK2kpIHtcbiAgICAgICAgY29uc3QgW2luZGVudCwgY29udGVudF0gPSBsaW5lc1tpXTtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT09ICcnIHx8IGNvbnRlbnQgPT09ICdcXHInKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVyLmluZGVudCA9PT0gMCAmJiBpbmRlbnQubGVuZ3RoID4gdHJpbUluZGVudClcbiAgICAgICAgICAgICAgICB0cmltSW5kZW50ID0gaW5kZW50Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbmRlbnQubGVuZ3RoIDwgdHJpbUluZGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnQmxvY2sgc2NhbGFycyB3aXRoIG1vcmUtaW5kZW50ZWQgbGVhZGluZyBlbXB0eSBsaW5lcyBtdXN0IHVzZSBhbiBleHBsaWNpdCBpbmRlbnRhdGlvbiBpbmRpY2F0b3InO1xuICAgICAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0ICsgaW5kZW50Lmxlbmd0aCwgJ01JU1NJTkdfQ0hBUicsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlYWRlci5pbmRlbnQgPT09IDApXG4gICAgICAgICAgICAgICAgdHJpbUluZGVudCA9IGluZGVudC5sZW5ndGg7XG4gICAgICAgICAgICBjb250ZW50U3RhcnQgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IGluZGVudC5sZW5ndGggKyBjb250ZW50Lmxlbmd0aCArIDE7XG4gICAgfVxuICAgIC8vIGluY2x1ZGUgdHJhaWxpbmcgbW9yZS1pbmRlbnRlZCBlbXB0eSBsaW5lcyBpbiBjb250ZW50XG4gICAgZm9yIChsZXQgaSA9IGxpbmVzLmxlbmd0aCAtIDE7IGkgPj0gY2hvbXBTdGFydDsgLS1pKSB7XG4gICAgICAgIGlmIChsaW5lc1tpXVswXS5sZW5ndGggPiB0cmltSW5kZW50KVxuICAgICAgICAgICAgY2hvbXBTdGFydCA9IGkgKyAxO1xuICAgIH1cbiAgICBsZXQgdmFsdWUgPSAnJztcbiAgICBsZXQgc2VwID0gJyc7XG4gICAgbGV0IHByZXZNb3JlSW5kZW50ZWQgPSBmYWxzZTtcbiAgICAvLyBsZWFkaW5nIHdoaXRlc3BhY2UgaXMga2VwdCBpbnRhY3RcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnRTdGFydDsgKytpKVxuICAgICAgICB2YWx1ZSArPSBsaW5lc1tpXVswXS5zbGljZSh0cmltSW5kZW50KSArICdcXG4nO1xuICAgIGZvciAobGV0IGkgPSBjb250ZW50U3RhcnQ7IGkgPCBjaG9tcFN0YXJ0OyArK2kpIHtcbiAgICAgICAgbGV0IFtpbmRlbnQsIGNvbnRlbnRdID0gbGluZXNbaV07XG4gICAgICAgIG9mZnNldCArPSBpbmRlbnQubGVuZ3RoICsgY29udGVudC5sZW5ndGggKyAxO1xuICAgICAgICBjb25zdCBjcmxmID0gY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdID09PSAnXFxyJztcbiAgICAgICAgaWYgKGNybGYpXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgwLCAtMSk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiBhbHJlYWR5IGNhdWdodCBpbiBsZXhlciAqL1xuICAgICAgICBpZiAoY29udGVudCAmJiBpbmRlbnQubGVuZ3RoIDwgdHJpbUluZGVudCkge1xuICAgICAgICAgICAgY29uc3Qgc3JjID0gaGVhZGVyLmluZGVudFxuICAgICAgICAgICAgICAgID8gJ2V4cGxpY2l0IGluZGVudGF0aW9uIGluZGljYXRvcidcbiAgICAgICAgICAgICAgICA6ICdmaXJzdCBsaW5lJztcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgQmxvY2sgc2NhbGFyIGxpbmVzIG11c3Qgbm90IGJlIGxlc3MgaW5kZW50ZWQgdGhhbiB0aGVpciAke3NyY31gO1xuICAgICAgICAgICAgb25FcnJvcihvZmZzZXQgLSBjb250ZW50Lmxlbmd0aCAtIChjcmxmID8gMiA6IDEpLCAnQkFEX0lOREVOVCcsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgaW5kZW50ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFNjYWxhci5CTE9DS19MSVRFUkFMKSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBzZXAgKyBpbmRlbnQuc2xpY2UodHJpbUluZGVudCkgKyBjb250ZW50O1xuICAgICAgICAgICAgc2VwID0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kZW50Lmxlbmd0aCA+IHRyaW1JbmRlbnQgfHwgY29udGVudFswXSA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgIC8vIG1vcmUtaW5kZW50ZWQgY29udGVudCB3aXRoaW4gYSBmb2xkZWQgYmxvY2tcbiAgICAgICAgICAgIGlmIChzZXAgPT09ICcgJylcbiAgICAgICAgICAgICAgICBzZXAgPSAnXFxuJztcbiAgICAgICAgICAgIGVsc2UgaWYgKCFwcmV2TW9yZUluZGVudGVkICYmIHNlcCA9PT0gJ1xcbicpXG4gICAgICAgICAgICAgICAgc2VwID0gJ1xcblxcbic7XG4gICAgICAgICAgICB2YWx1ZSArPSBzZXAgKyBpbmRlbnQuc2xpY2UodHJpbUluZGVudCkgKyBjb250ZW50O1xuICAgICAgICAgICAgc2VwID0gJ1xcbic7XG4gICAgICAgICAgICBwcmV2TW9yZUluZGVudGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250ZW50ID09PSAnJykge1xuICAgICAgICAgICAgLy8gZW1wdHkgbGluZVxuICAgICAgICAgICAgaWYgKHNlcCA9PT0gJ1xcbicpXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gJ1xcbic7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VwID0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBzZXAgKyBjb250ZW50O1xuICAgICAgICAgICAgc2VwID0gJyAnO1xuICAgICAgICAgICAgcHJldk1vcmVJbmRlbnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAoaGVhZGVyLmNob21wKSB7XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNob21wU3RhcnQ7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAnXFxuJyArIGxpbmVzW2ldWzBdLnNsaWNlKHRyaW1JbmRlbnQpO1xuICAgICAgICAgICAgaWYgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdICE9PSAnXFxuJylcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAnXFxuJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFsdWUgKz0gJ1xcbic7XG4gICAgfVxuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgaGVhZGVyLmxlbmd0aCArIHNjYWxhci5zb3VyY2UubGVuZ3RoO1xuICAgIHJldHVybiB7IHZhbHVlLCB0eXBlLCBjb21tZW50OiBoZWFkZXIuY29tbWVudCwgcmFuZ2U6IFtzdGFydCwgZW5kLCBlbmRdIH07XG59XG5mdW5jdGlvbiBwYXJzZUJsb2NrU2NhbGFySGVhZGVyKHsgb2Zmc2V0LCBwcm9wcyB9LCBzdHJpY3QsIG9uRXJyb3IpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICBpZiAocHJvcHNbMF0udHlwZSAhPT0gJ2Jsb2NrLXNjYWxhci1oZWFkZXInKSB7XG4gICAgICAgIG9uRXJyb3IocHJvcHNbMF0sICdJTVBPU1NJQkxFJywgJ0Jsb2NrIHNjYWxhciBoZWFkZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7IHNvdXJjZSB9ID0gcHJvcHNbMF07XG4gICAgY29uc3QgbW9kZSA9IHNvdXJjZVswXTtcbiAgICBsZXQgaW5kZW50ID0gMDtcbiAgICBsZXQgY2hvbXAgPSAnJztcbiAgICBsZXQgZXJyb3IgPSAtMTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjaCA9IHNvdXJjZVtpXTtcbiAgICAgICAgaWYgKCFjaG9tcCAmJiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSlcbiAgICAgICAgICAgIGNob21wID0gY2g7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbiA9IE51bWJlcihjaCk7XG4gICAgICAgICAgICBpZiAoIWluZGVudCAmJiBuKVxuICAgICAgICAgICAgICAgIGluZGVudCA9IG47XG4gICAgICAgICAgICBlbHNlIGlmIChlcnJvciA9PT0gLTEpXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBvZmZzZXQgKyBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlcnJvciAhPT0gLTEpXG4gICAgICAgIG9uRXJyb3IoZXJyb3IsICdVTkVYUEVDVEVEX1RPS0VOJywgYEJsb2NrIHNjYWxhciBoZWFkZXIgaW5jbHVkZXMgZXh0cmEgY2hhcmFjdGVyczogJHtzb3VyY2V9YCk7XG4gICAgbGV0IGhhc1NwYWNlID0gZmFsc2U7XG4gICAgbGV0IGNvbW1lbnQgPSAnJztcbiAgICBsZXQgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHByb3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gcHJvcHNbaV07XG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gdG9rZW4uc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIWhhc1NwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnQ29tbWVudHMgbXVzdCBiZSBzZXBhcmF0ZWQgZnJvbSBvdGhlciB0b2tlbnMgYnkgd2hpdGUgc3BhY2UgY2hhcmFjdGVycyc7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNSVNTSU5HX0NIQVInLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGVuZ3RoICs9IHRva2VuLnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29tbWVudCA9IHRva2VuLnNvdXJjZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1VORVhQRUNURURfVE9LRU4nLCB0b2tlbi5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gdG9rZW4uc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBVbmV4cGVjdGVkIHRva2VuIGluIGJsb2NrIHNjYWxhciBoZWFkZXI6ICR7dG9rZW4udHlwZX1gO1xuICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdVTkVYUEVDVEVEX1RPS0VOJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHMgPSB0b2tlbi5zb3VyY2U7XG4gICAgICAgICAgICAgICAgaWYgKHRzICYmIHR5cGVvZiB0cyA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCArPSB0cy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbW9kZSwgaW5kZW50LCBjaG9tcCwgY29tbWVudCwgbGVuZ3RoIH07XG59XG4vKiogQHJldHVybnMgQXJyYXkgb2YgbGluZXMgc3BsaXQgdXAgYXMgYFtpbmRlbnQsIGNvbnRlbnRdYCAqL1xuZnVuY3Rpb24gc3BsaXRMaW5lcyhzb3VyY2UpIHtcbiAgICBjb25zdCBzcGxpdCA9IHNvdXJjZS5zcGxpdCgvXFxuKCAqKS8pO1xuICAgIGNvbnN0IGZpcnN0ID0gc3BsaXRbMF07XG4gICAgY29uc3QgbSA9IGZpcnN0Lm1hdGNoKC9eKCAqKS8pO1xuICAgIGNvbnN0IGxpbmUwID0gbT8uWzFdXG4gICAgICAgID8gW21bMV0sIGZpcnN0LnNsaWNlKG1bMV0ubGVuZ3RoKV1cbiAgICAgICAgOiBbJycsIGZpcnN0XTtcbiAgICBjb25zdCBsaW5lcyA9IFtsaW5lMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzcGxpdC5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgbGluZXMucHVzaChbc3BsaXRbaV0sIHNwbGl0W2kgKyAxXV0pO1xuICAgIHJldHVybiBsaW5lcztcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUJsb2NrU2NhbGFyIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IHJlc29sdmVFbmQgfSBmcm9tICcuL3Jlc29sdmUtZW5kLmpzJztcblxuZnVuY3Rpb24gcmVzb2x2ZUZsb3dTY2FsYXIoc2NhbGFyLCBzdHJpY3QsIG9uRXJyb3IpIHtcbiAgICBjb25zdCB7IG9mZnNldCwgdHlwZSwgc291cmNlLCBlbmQgfSA9IHNjYWxhcjtcbiAgICBsZXQgX3R5cGU7XG4gICAgbGV0IHZhbHVlO1xuICAgIGNvbnN0IF9vbkVycm9yID0gKHJlbCwgY29kZSwgbXNnKSA9PiBvbkVycm9yKG9mZnNldCArIHJlbCwgY29kZSwgbXNnKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgIF90eXBlID0gU2NhbGFyLlBMQUlOO1xuICAgICAgICAgICAgdmFsdWUgPSBwbGFpblZhbHVlKHNvdXJjZSwgX29uRXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgIF90eXBlID0gU2NhbGFyLlFVT1RFX1NJTkdMRTtcbiAgICAgICAgICAgIHZhbHVlID0gc2luZ2xlUXVvdGVkVmFsdWUoc291cmNlLCBfb25FcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgX3R5cGUgPSBTY2FsYXIuUVVPVEVfRE9VQkxFO1xuICAgICAgICAgICAgdmFsdWUgPSBkb3VibGVRdW90ZWRWYWx1ZShzb3VyY2UsIF9vbkVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgb25FcnJvcihzY2FsYXIsICdVTkVYUEVDVEVEX1RPS0VOJywgYEV4cGVjdGVkIGEgZmxvdyBzY2FsYXIgdmFsdWUsIGJ1dCBmb3VuZDogJHt0eXBlfWApO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogJycsXG4gICAgICAgICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgICBjb21tZW50OiAnJyxcbiAgICAgICAgICAgICAgICByYW5nZTogW29mZnNldCwgb2Zmc2V0ICsgc291cmNlLmxlbmd0aCwgb2Zmc2V0ICsgc291cmNlLmxlbmd0aF1cbiAgICAgICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlRW5kID0gb2Zmc2V0ICsgc291cmNlLmxlbmd0aDtcbiAgICBjb25zdCByZSA9IHJlc29sdmVFbmQoZW5kLCB2YWx1ZUVuZCwgc3RyaWN0LCBvbkVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdHlwZTogX3R5cGUsXG4gICAgICAgIGNvbW1lbnQ6IHJlLmNvbW1lbnQsXG4gICAgICAgIHJhbmdlOiBbb2Zmc2V0LCB2YWx1ZUVuZCwgcmUub2Zmc2V0XVxuICAgIH07XG59XG5mdW5jdGlvbiBwbGFpblZhbHVlKHNvdXJjZSwgb25FcnJvcikge1xuICAgIGxldCBiYWRDaGFyID0gJyc7XG4gICAgc3dpdGNoIChzb3VyY2VbMF0pIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgY2FzZSAnXFx0JzpcbiAgICAgICAgICAgIGJhZENoYXIgPSAnYSB0YWIgY2hhcmFjdGVyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgIGJhZENoYXIgPSAnZmxvdyBpbmRpY2F0b3IgY2hhcmFjdGVyICwnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgYmFkQ2hhciA9ICdkaXJlY3RpdmUgaW5kaWNhdG9yIGNoYXJhY3RlciAlJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd8JzpcbiAgICAgICAgY2FzZSAnPic6IHtcbiAgICAgICAgICAgIGJhZENoYXIgPSBgYmxvY2sgc2NhbGFyIGluZGljYXRvciAke3NvdXJjZVswXX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnQCc6XG4gICAgICAgIGNhc2UgJ2AnOiB7XG4gICAgICAgICAgICBiYWRDaGFyID0gYHJlc2VydmVkIGNoYXJhY3RlciAke3NvdXJjZVswXX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJhZENoYXIpXG4gICAgICAgIG9uRXJyb3IoMCwgJ0JBRF9TQ0FMQVJfU1RBUlQnLCBgUGxhaW4gdmFsdWUgY2Fubm90IHN0YXJ0IHdpdGggJHtiYWRDaGFyfWApO1xuICAgIHJldHVybiBmb2xkTGluZXMoc291cmNlKTtcbn1cbmZ1bmN0aW9uIHNpbmdsZVF1b3RlZFZhbHVlKHNvdXJjZSwgb25FcnJvcikge1xuICAgIGlmIChzb3VyY2Vbc291cmNlLmxlbmd0aCAtIDFdICE9PSBcIidcIiB8fCBzb3VyY2UubGVuZ3RoID09PSAxKVxuICAgICAgICBvbkVycm9yKHNvdXJjZS5sZW5ndGgsICdNSVNTSU5HX0NIQVInLCBcIk1pc3NpbmcgY2xvc2luZyAncXVvdGVcIik7XG4gICAgcmV0dXJuIGZvbGRMaW5lcyhzb3VyY2Uuc2xpY2UoMSwgLTEpKS5yZXBsYWNlKC8nJy9nLCBcIidcIik7XG59XG5mdW5jdGlvbiBmb2xkTGluZXMoc291cmNlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG5lZ2F0aXZlIGxvb2tiZWhpbmQgaGVyZSBhbmQgaW4gdGhlIGByZWAgUmVnRXhwIGlzIHRvXG4gICAgICogcHJldmVudCBjYXVzaW5nIGEgcG9seW5vbWlhbCBzZWFyY2ggdGltZSBpbiBjZXJ0YWluIGNhc2VzLlxuICAgICAqXG4gICAgICogVGhlIHRyeS1jYXRjaCBpcyBmb3IgU2FmYXJpLCB3aGljaCBkb2Vzbid0IHN1cHBvcnQgdGhpcyB5ZXQ6XG4gICAgICogaHR0cHM6Ly9jYW5pdXNlLmNvbS9qcy1yZWdleHAtbG9va2JlaGluZFxuICAgICAqL1xuICAgIGxldCBmaXJzdCwgbGluZTtcbiAgICB0cnkge1xuICAgICAgICBmaXJzdCA9IG5ldyBSZWdFeHAoJyguKj8pKD88IVsgXFx0XSlbIFxcdF0qXFxyP1xcbicsICdzeScpO1xuICAgICAgICBsaW5lID0gbmV3IFJlZ0V4cCgnWyBcXHRdKiguKj8pKD86KD88IVsgXFx0XSlbIFxcdF0qKT9cXHI/XFxuJywgJ3N5Jyk7XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIGZpcnN0ID0gLyguKj8pWyBcXHRdKlxccj9cXG4vc3k7XG4gICAgICAgIGxpbmUgPSAvWyBcXHRdKiguKj8pWyBcXHRdKlxccj9cXG4vc3k7XG4gICAgfVxuICAgIGxldCBtYXRjaCA9IGZpcnN0LmV4ZWMoc291cmNlKTtcbiAgICBpZiAoIW1hdGNoKVxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIGxldCByZXMgPSBtYXRjaFsxXTtcbiAgICBsZXQgc2VwID0gJyAnO1xuICAgIGxldCBwb3MgPSBmaXJzdC5sYXN0SW5kZXg7XG4gICAgbGluZS5sYXN0SW5kZXggPSBwb3M7XG4gICAgd2hpbGUgKChtYXRjaCA9IGxpbmUuZXhlYyhzb3VyY2UpKSkge1xuICAgICAgICBpZiAobWF0Y2hbMV0gPT09ICcnKSB7XG4gICAgICAgICAgICBpZiAoc2VwID09PSAnXFxuJylcbiAgICAgICAgICAgICAgICByZXMgKz0gc2VwO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlcCA9ICdcXG4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzICs9IHNlcCArIG1hdGNoWzFdO1xuICAgICAgICAgICAgc2VwID0gJyAnO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IGxpbmUubGFzdEluZGV4O1xuICAgIH1cbiAgICBjb25zdCBsYXN0ID0gL1sgXFx0XSooLiopL3N5O1xuICAgIGxhc3QubGFzdEluZGV4ID0gcG9zO1xuICAgIG1hdGNoID0gbGFzdC5leGVjKHNvdXJjZSk7XG4gICAgcmV0dXJuIHJlcyArIHNlcCArIChtYXRjaD8uWzFdID8/ICcnKTtcbn1cbmZ1bmN0aW9uIGRvdWJsZVF1b3RlZFZhbHVlKHNvdXJjZSwgb25FcnJvcikge1xuICAgIGxldCByZXMgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNvdXJjZS5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgY29uc3QgY2ggPSBzb3VyY2VbaV07XG4gICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgc291cmNlW2kgKyAxXSA9PT0gJ1xcbicpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgICAgICAgY29uc3QgeyBmb2xkLCBvZmZzZXQgfSA9IGZvbGROZXdsaW5lKHNvdXJjZSwgaSk7XG4gICAgICAgICAgICByZXMgKz0gZm9sZDtcbiAgICAgICAgICAgIGkgPSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBzb3VyY2VbKytpXTtcbiAgICAgICAgICAgIGNvbnN0IGNjID0gZXNjYXBlQ29kZXNbbmV4dF07XG4gICAgICAgICAgICBpZiAoY2MpXG4gICAgICAgICAgICAgICAgcmVzICs9IGNjO1xuICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAvLyBza2lwIGVzY2FwZWQgbmV3bGluZXMsIGJ1dCBzdGlsbCB0cmltIHRoZSBmb2xsb3dpbmcgbGluZVxuICAgICAgICAgICAgICAgIG5leHQgPSBzb3VyY2VbaSArIDFdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0ID09PSAnICcgfHwgbmV4dCA9PT0gJ1xcdCcpXG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBzb3VyY2VbKytpICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAnXFxyJyAmJiBzb3VyY2VbaSArIDFdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgZXNjYXBlZCBDUkxGIG5ld2xpbmVzLCBidXQgc3RpbGwgdHJpbSB0aGUgZm9sbG93aW5nIGxpbmVcbiAgICAgICAgICAgICAgICBuZXh0ID0gc291cmNlWysraSArIDFdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0ID09PSAnICcgfHwgbmV4dCA9PT0gJ1xcdCcpXG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBzb3VyY2VbKytpICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAneCcgfHwgbmV4dCA9PT0gJ3UnIHx8IG5leHQgPT09ICdVJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHsgeDogMiwgdTogNCwgVTogOCB9W25leHRdO1xuICAgICAgICAgICAgICAgIHJlcyArPSBwYXJzZUNoYXJDb2RlKHNvdXJjZSwgaSArIDEsIGxlbmd0aCwgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgaSArPSBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYXcgPSBzb3VyY2Uuc3Vic3RyKGkgLSAxLCAyKTtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGkgLSAxLCAnQkFEX0RRX0VTQ0FQRScsIGBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZSAke3Jhd31gKTtcbiAgICAgICAgICAgICAgICByZXMgKz0gcmF3O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKSB7XG4gICAgICAgICAgICAvLyB0cmltIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIGNvbnN0IHdzU3RhcnQgPSBpO1xuICAgICAgICAgICAgbGV0IG5leHQgPSBzb3VyY2VbaSArIDFdO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQgPT09ICcgJyB8fCBuZXh0ID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICBuZXh0ID0gc291cmNlWysraSArIDFdO1xuICAgICAgICAgICAgaWYgKG5leHQgIT09ICdcXG4nICYmICEobmV4dCA9PT0gJ1xccicgJiYgc291cmNlW2kgKyAyXSA9PT0gJ1xcbicpKVxuICAgICAgICAgICAgICAgIHJlcyArPSBpID4gd3NTdGFydCA/IHNvdXJjZS5zbGljZSh3c1N0YXJ0LCBpICsgMSkgOiBjaDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcyArPSBjaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc291cmNlW3NvdXJjZS5sZW5ndGggLSAxXSAhPT0gJ1wiJyB8fCBzb3VyY2UubGVuZ3RoID09PSAxKVxuICAgICAgICBvbkVycm9yKHNvdXJjZS5sZW5ndGgsICdNSVNTSU5HX0NIQVInLCAnTWlzc2luZyBjbG9zaW5nIFwicXVvdGUnKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBGb2xkIGEgc2luZ2xlIG5ld2xpbmUgaW50byBhIHNwYWNlLCBtdWx0aXBsZSBuZXdsaW5lcyB0byBOIC0gMSBuZXdsaW5lcy5cbiAqIFByZXN1bWVzIGBzb3VyY2Vbb2Zmc2V0XSA9PT0gJ1xcbidgXG4gKi9cbmZ1bmN0aW9uIGZvbGROZXdsaW5lKHNvdXJjZSwgb2Zmc2V0KSB7XG4gICAgbGV0IGZvbGQgPSAnJztcbiAgICBsZXQgY2ggPSBzb3VyY2Vbb2Zmc2V0ICsgMV07XG4gICAgd2hpbGUgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnIHx8IGNoID09PSAnXFxuJyB8fCBjaCA9PT0gJ1xccicpIHtcbiAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2Vbb2Zmc2V0ICsgMl0gIT09ICdcXG4nKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChjaCA9PT0gJ1xcbicpXG4gICAgICAgICAgICBmb2xkICs9ICdcXG4nO1xuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgY2ggPSBzb3VyY2Vbb2Zmc2V0ICsgMV07XG4gICAgfVxuICAgIGlmICghZm9sZClcbiAgICAgICAgZm9sZCA9ICcgJztcbiAgICByZXR1cm4geyBmb2xkLCBvZmZzZXQgfTtcbn1cbmNvbnN0IGVzY2FwZUNvZGVzID0ge1xuICAgICcwJzogJ1xcMCcsXG4gICAgYTogJ1xceDA3JyxcbiAgICBiOiAnXFxiJyxcbiAgICBlOiAnXFx4MWInLFxuICAgIGY6ICdcXGYnLFxuICAgIG46ICdcXG4nLFxuICAgIHI6ICdcXHInLFxuICAgIHQ6ICdcXHQnLFxuICAgIHY6ICdcXHYnLFxuICAgIE46ICdcXHUwMDg1JyxcbiAgICBfOiAnXFx1MDBhMCcsXG4gICAgTDogJ1xcdTIwMjgnLFxuICAgIFA6ICdcXHUyMDI5JyxcbiAgICAnICc6ICcgJyxcbiAgICAnXCInOiAnXCInLFxuICAgICcvJzogJy8nLFxuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICdcXHQnOiAnXFx0J1xufTtcbmZ1bmN0aW9uIHBhcnNlQ2hhckNvZGUoc291cmNlLCBvZmZzZXQsIGxlbmd0aCwgb25FcnJvcikge1xuICAgIGNvbnN0IGNjID0gc291cmNlLnN1YnN0cihvZmZzZXQsIGxlbmd0aCk7XG4gICAgY29uc3Qgb2sgPSBjYy5sZW5ndGggPT09IGxlbmd0aCAmJiAvXlswLTlhLWZBLUZdKyQvLnRlc3QoY2MpO1xuICAgIGNvbnN0IGNvZGUgPSBvayA/IHBhcnNlSW50KGNjLCAxNikgOiBOYU47XG4gICAgaWYgKGlzTmFOKGNvZGUpKSB7XG4gICAgICAgIGNvbnN0IHJhdyA9IHNvdXJjZS5zdWJzdHIob2Zmc2V0IC0gMiwgbGVuZ3RoICsgMik7XG4gICAgICAgIG9uRXJyb3Iob2Zmc2V0IC0gMiwgJ0JBRF9EUV9FU0NBUEUnLCBgSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UgJHtyYXd9YCk7XG4gICAgICAgIHJldHVybiByYXc7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlKTtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUZsb3dTY2FsYXIgfTtcbiIsICJpbXBvcnQgeyBTQ0FMQVIsIGlzU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUJsb2NrU2NhbGFyIH0gZnJvbSAnLi9yZXNvbHZlLWJsb2NrLXNjYWxhci5qcyc7XG5pbXBvcnQgeyByZXNvbHZlRmxvd1NjYWxhciB9IGZyb20gJy4vcmVzb2x2ZS1mbG93LXNjYWxhci5qcyc7XG5cbmZ1bmN0aW9uIGNvbXBvc2VTY2FsYXIoY3R4LCB0b2tlbiwgdGFnVG9rZW4sIG9uRXJyb3IpIHtcbiAgICBjb25zdCB7IHZhbHVlLCB0eXBlLCBjb21tZW50LCByYW5nZSB9ID0gdG9rZW4udHlwZSA9PT0gJ2Jsb2NrLXNjYWxhcidcbiAgICAgICAgPyByZXNvbHZlQmxvY2tTY2FsYXIodG9rZW4sIGN0eC5vcHRpb25zLnN0cmljdCwgb25FcnJvcilcbiAgICAgICAgOiByZXNvbHZlRmxvd1NjYWxhcih0b2tlbiwgY3R4Lm9wdGlvbnMuc3RyaWN0LCBvbkVycm9yKTtcbiAgICBjb25zdCB0YWdOYW1lID0gdGFnVG9rZW5cbiAgICAgICAgPyBjdHguZGlyZWN0aXZlcy50YWdOYW1lKHRhZ1Rva2VuLnNvdXJjZSwgbXNnID0+IG9uRXJyb3IodGFnVG9rZW4sICdUQUdfUkVTT0xWRV9GQUlMRUQnLCBtc2cpKVxuICAgICAgICA6IG51bGw7XG4gICAgY29uc3QgdGFnID0gdGFnVG9rZW4gJiYgdGFnTmFtZVxuICAgICAgICA/IGZpbmRTY2FsYXJUYWdCeU5hbWUoY3R4LnNjaGVtYSwgdmFsdWUsIHRhZ05hbWUsIHRhZ1Rva2VuLCBvbkVycm9yKVxuICAgICAgICA6IHRva2VuLnR5cGUgPT09ICdzY2FsYXInXG4gICAgICAgICAgICA/IGZpbmRTY2FsYXJUYWdCeVRlc3QoY3R4LCB2YWx1ZSwgdG9rZW4sIG9uRXJyb3IpXG4gICAgICAgICAgICA6IGN0eC5zY2hlbWFbU0NBTEFSXTtcbiAgICBsZXQgc2NhbGFyO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRhZy5yZXNvbHZlKHZhbHVlLCBtc2cgPT4gb25FcnJvcih0YWdUb2tlbiA/PyB0b2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIG1zZyksIGN0eC5vcHRpb25zKTtcbiAgICAgICAgc2NhbGFyID0gaXNTY2FsYXIocmVzKSA/IHJlcyA6IG5ldyBTY2FsYXIocmVzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgICAgb25FcnJvcih0YWdUb2tlbiA/PyB0b2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIG1zZyk7XG4gICAgICAgIHNjYWxhciA9IG5ldyBTY2FsYXIodmFsdWUpO1xuICAgIH1cbiAgICBzY2FsYXIucmFuZ2UgPSByYW5nZTtcbiAgICBzY2FsYXIuc291cmNlID0gdmFsdWU7XG4gICAgaWYgKHR5cGUpXG4gICAgICAgIHNjYWxhci50eXBlID0gdHlwZTtcbiAgICBpZiAodGFnTmFtZSlcbiAgICAgICAgc2NhbGFyLnRhZyA9IHRhZ05hbWU7XG4gICAgaWYgKHRhZy5mb3JtYXQpXG4gICAgICAgIHNjYWxhci5mb3JtYXQgPSB0YWcuZm9ybWF0O1xuICAgIGlmIChjb21tZW50KVxuICAgICAgICBzY2FsYXIuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgcmV0dXJuIHNjYWxhcjtcbn1cbmZ1bmN0aW9uIGZpbmRTY2FsYXJUYWdCeU5hbWUoc2NoZW1hLCB2YWx1ZSwgdGFnTmFtZSwgdGFnVG9rZW4sIG9uRXJyb3IpIHtcbiAgICBpZiAodGFnTmFtZSA9PT0gJyEnKVxuICAgICAgICByZXR1cm4gc2NoZW1hW1NDQUxBUl07IC8vIG5vbi1zcGVjaWZpYyB0YWdcbiAgICBjb25zdCBtYXRjaFdpdGhUZXN0ID0gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2Ygc2NoZW1hLnRhZ3MpIHtcbiAgICAgICAgaWYgKCF0YWcuY29sbGVjdGlvbiAmJiB0YWcudGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgICAgICBpZiAodGFnLmRlZmF1bHQgJiYgdGFnLnRlc3QpXG4gICAgICAgICAgICAgICAgbWF0Y2hXaXRoVGVzdC5wdXNoKHRhZyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHRhZyBvZiBtYXRjaFdpdGhUZXN0KVxuICAgICAgICBpZiAodGFnLnRlc3Q/LnRlc3QodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIHRhZztcbiAgICBjb25zdCBrdCA9IHNjaGVtYS5rbm93blRhZ3NbdGFnTmFtZV07XG4gICAgaWYgKGt0ICYmICFrdC5jb2xsZWN0aW9uKSB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBrbm93biB0YWcgaXMgYXZhaWxhYmxlIGZvciBzdHJpbmdpZnlpbmcsXG4gICAgICAgIC8vIGJ1dCBkb2VzIG5vdCBnZXQgdXNlZCBieSBkZWZhdWx0LlxuICAgICAgICBzY2hlbWEudGFncy5wdXNoKE9iamVjdC5hc3NpZ24oe30sIGt0LCB7IGRlZmF1bHQ6IGZhbHNlLCB0ZXN0OiB1bmRlZmluZWQgfSkpO1xuICAgICAgICByZXR1cm4ga3Q7XG4gICAgfVxuICAgIG9uRXJyb3IodGFnVG9rZW4sICdUQUdfUkVTT0xWRV9GQUlMRUQnLCBgVW5yZXNvbHZlZCB0YWc6ICR7dGFnTmFtZX1gLCB0YWdOYW1lICE9PSAndGFnOnlhbWwub3JnLDIwMDI6c3RyJyk7XG4gICAgcmV0dXJuIHNjaGVtYVtTQ0FMQVJdO1xufVxuZnVuY3Rpb24gZmluZFNjYWxhclRhZ0J5VGVzdCh7IGRpcmVjdGl2ZXMsIHNjaGVtYSB9LCB2YWx1ZSwgdG9rZW4sIG9uRXJyb3IpIHtcbiAgICBjb25zdCB0YWcgPSBzY2hlbWEudGFncy5maW5kKHRhZyA9PiB0YWcuZGVmYXVsdCAmJiB0YWcudGVzdD8udGVzdCh2YWx1ZSkpIHx8IHNjaGVtYVtTQ0FMQVJdO1xuICAgIGlmIChzY2hlbWEuY29tcGF0KSB7XG4gICAgICAgIGNvbnN0IGNvbXBhdCA9IHNjaGVtYS5jb21wYXQuZmluZCh0YWcgPT4gdGFnLmRlZmF1bHQgJiYgdGFnLnRlc3Q/LnRlc3QodmFsdWUpKSA/P1xuICAgICAgICAgICAgc2NoZW1hW1NDQUxBUl07XG4gICAgICAgIGlmICh0YWcudGFnICE9PSBjb21wYXQudGFnKSB7XG4gICAgICAgICAgICBjb25zdCB0cyA9IGRpcmVjdGl2ZXMudGFnU3RyaW5nKHRhZy50YWcpO1xuICAgICAgICAgICAgY29uc3QgY3MgPSBkaXJlY3RpdmVzLnRhZ1N0cmluZyhjb21wYXQudGFnKTtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBWYWx1ZSBtYXkgYmUgcGFyc2VkIGFzIGVpdGhlciAke3RzfSBvciAke2NzfWA7XG4gICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgbXNnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFnO1xufVxuXG5leHBvcnQgeyBjb21wb3NlU2NhbGFyIH07XG4iLCAiZnVuY3Rpb24gZW1wdHlTY2FsYXJQb3NpdGlvbihvZmZzZXQsIGJlZm9yZSwgcG9zKSB7XG4gICAgaWYgKGJlZm9yZSkge1xuICAgICAgICBpZiAocG9zID09PSBudWxsKVxuICAgICAgICAgICAgcG9zID0gYmVmb3JlLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvcyAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBsZXQgc3QgPSBiZWZvcmVbaV07XG4gICAgICAgICAgICBzd2l0Y2ggKHN0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCAtPSBzdC5zb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRlY2huaWNhbGx5LCBhbiBlbXB0eSBzY2FsYXIgaXMgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGxhc3Qgbm9uLWVtcHR5XG4gICAgICAgICAgICAvLyBub2RlLCBidXQgaXQncyBtb3JlIHVzZWZ1bCB0byBwbGFjZSBpdCBhZnRlciBhbnkgd2hpdGVzcGFjZS5cbiAgICAgICAgICAgIHN0ID0gYmVmb3JlWysraV07XG4gICAgICAgICAgICB3aGlsZSAoc3Q/LnR5cGUgPT09ICdzcGFjZScpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gc3Quc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBzdCA9IGJlZm9yZVsrK2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldDtcbn1cblxuZXhwb3J0IHsgZW1wdHlTY2FsYXJQb3NpdGlvbiB9O1xuIiwgImltcG9ydCB7IEFsaWFzIH0gZnJvbSAnLi4vbm9kZXMvQWxpYXMuanMnO1xuaW1wb3J0IHsgY29tcG9zZUNvbGxlY3Rpb24gfSBmcm9tICcuL2NvbXBvc2UtY29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBjb21wb3NlU2NhbGFyIH0gZnJvbSAnLi9jb21wb3NlLXNjYWxhci5qcyc7XG5pbXBvcnQgeyByZXNvbHZlRW5kIH0gZnJvbSAnLi9yZXNvbHZlLWVuZC5qcyc7XG5pbXBvcnQgeyBlbXB0eVNjYWxhclBvc2l0aW9uIH0gZnJvbSAnLi91dGlsLWVtcHR5LXNjYWxhci1wb3NpdGlvbi5qcyc7XG5cbmNvbnN0IENOID0geyBjb21wb3NlTm9kZSwgY29tcG9zZUVtcHR5Tm9kZSB9O1xuZnVuY3Rpb24gY29tcG9zZU5vZGUoY3R4LCB0b2tlbiwgcHJvcHMsIG9uRXJyb3IpIHtcbiAgICBjb25zdCB7IHNwYWNlQmVmb3JlLCBjb21tZW50LCBhbmNob3IsIHRhZyB9ID0gcHJvcHM7XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGlzU3JjVG9rZW4gPSB0cnVlO1xuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICdhbGlhcyc6XG4gICAgICAgICAgICBub2RlID0gY29tcG9zZUFsaWFzKGN0eCwgdG9rZW4sIG9uRXJyb3IpO1xuICAgICAgICAgICAgaWYgKGFuY2hvciB8fCB0YWcpXG4gICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ0FMSUFTX1BST1BTJywgJ0FuIGFsaWFzIG5vZGUgbXVzdCBub3Qgc3BlY2lmeSBhbnkgcHJvcGVydGllcycpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOlxuICAgICAgICAgICAgbm9kZSA9IGNvbXBvc2VTY2FsYXIoY3R4LCB0b2tlbiwgdGFnLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGlmIChhbmNob3IpXG4gICAgICAgICAgICAgICAgbm9kZS5hbmNob3IgPSBhbmNob3Iuc291cmNlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdibG9jay1tYXAnOlxuICAgICAgICBjYXNlICdibG9jay1zZXEnOlxuICAgICAgICBjYXNlICdmbG93LWNvbGxlY3Rpb24nOlxuICAgICAgICAgICAgbm9kZSA9IGNvbXBvc2VDb2xsZWN0aW9uKENOLCBjdHgsIHRva2VuLCB0YWcsIG9uRXJyb3IpO1xuICAgICAgICAgICAgaWYgKGFuY2hvcilcbiAgICAgICAgICAgICAgICBub2RlLmFuY2hvciA9IGFuY2hvci5zb3VyY2Uuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0b2tlbi50eXBlID09PSAnZXJyb3InXG4gICAgICAgICAgICAgICAgPyB0b2tlbi5tZXNzYWdlXG4gICAgICAgICAgICAgICAgOiBgVW5zdXBwb3J0ZWQgdG9rZW4gKHR5cGU6ICR7dG9rZW4udHlwZX0pYDtcbiAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdVTkVYUEVDVEVEX1RPS0VOJywgbWVzc2FnZSk7XG4gICAgICAgICAgICBub2RlID0gY29tcG9zZUVtcHR5Tm9kZShjdHgsIHRva2VuLm9mZnNldCwgdW5kZWZpbmVkLCBudWxsLCBwcm9wcywgb25FcnJvcik7XG4gICAgICAgICAgICBpc1NyY1Rva2VuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFuY2hvciAmJiBub2RlLmFuY2hvciA9PT0gJycpXG4gICAgICAgIG9uRXJyb3IoYW5jaG9yLCAnQkFEX0FMSUFTJywgJ0FuY2hvciBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nJyk7XG4gICAgaWYgKHNwYWNlQmVmb3JlKVxuICAgICAgICBub2RlLnNwYWNlQmVmb3JlID0gdHJ1ZTtcbiAgICBpZiAoY29tbWVudCkge1xuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3NjYWxhcicgJiYgdG9rZW4uc291cmNlID09PSAnJylcbiAgICAgICAgICAgIG5vZGUuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG5vZGUuY29tbWVudEJlZm9yZSA9IGNvbW1lbnQ7XG4gICAgfVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVHlwZSBjaGVja2luZyBtaXNzZXMgbWVhbmluZyBvZiBpc1NyY1Rva2VuXG4gICAgaWYgKGN0eC5vcHRpb25zLmtlZXBTb3VyY2VUb2tlbnMgJiYgaXNTcmNUb2tlbilcbiAgICAgICAgbm9kZS5zcmNUb2tlbiA9IHRva2VuO1xuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gY29tcG9zZUVtcHR5Tm9kZShjdHgsIG9mZnNldCwgYmVmb3JlLCBwb3MsIHsgc3BhY2VCZWZvcmUsIGNvbW1lbnQsIGFuY2hvciwgdGFnIH0sIG9uRXJyb3IpIHtcbiAgICBjb25zdCB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogJ3NjYWxhcicsXG4gICAgICAgIG9mZnNldDogZW1wdHlTY2FsYXJQb3NpdGlvbihvZmZzZXQsIGJlZm9yZSwgcG9zKSxcbiAgICAgICAgaW5kZW50OiAtMSxcbiAgICAgICAgc291cmNlOiAnJ1xuICAgIH07XG4gICAgY29uc3Qgbm9kZSA9IGNvbXBvc2VTY2FsYXIoY3R4LCB0b2tlbiwgdGFnLCBvbkVycm9yKTtcbiAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgIG5vZGUuYW5jaG9yID0gYW5jaG9yLnNvdXJjZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIGlmIChub2RlLmFuY2hvciA9PT0gJycpXG4gICAgICAgICAgICBvbkVycm9yKGFuY2hvciwgJ0JBRF9BTElBUycsICdBbmNob3IgY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoc3BhY2VCZWZvcmUpXG4gICAgICAgIG5vZGUuc3BhY2VCZWZvcmUgPSB0cnVlO1xuICAgIGlmIChjb21tZW50KVxuICAgICAgICBub2RlLmNvbW1lbnQgPSBjb21tZW50O1xuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gY29tcG9zZUFsaWFzKHsgb3B0aW9ucyB9LCB7IG9mZnNldCwgc291cmNlLCBlbmQgfSwgb25FcnJvcikge1xuICAgIGNvbnN0IGFsaWFzID0gbmV3IEFsaWFzKHNvdXJjZS5zdWJzdHJpbmcoMSkpO1xuICAgIGlmIChhbGlhcy5zb3VyY2UgPT09ICcnKVxuICAgICAgICBvbkVycm9yKG9mZnNldCwgJ0JBRF9BTElBUycsICdBbGlhcyBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nJyk7XG4gICAgaWYgKGFsaWFzLnNvdXJjZS5lbmRzV2l0aCgnOicpKVxuICAgICAgICBvbkVycm9yKG9mZnNldCArIHNvdXJjZS5sZW5ndGggLSAxLCAnQkFEX0FMSUFTJywgJ0FsaWFzIGVuZGluZyBpbiA6IGlzIGFtYmlndW91cycsIHRydWUpO1xuICAgIGNvbnN0IHZhbHVlRW5kID0gb2Zmc2V0ICsgc291cmNlLmxlbmd0aDtcbiAgICBjb25zdCByZSA9IHJlc29sdmVFbmQoZW5kLCB2YWx1ZUVuZCwgb3B0aW9ucy5zdHJpY3QsIG9uRXJyb3IpO1xuICAgIGFsaWFzLnJhbmdlID0gW29mZnNldCwgdmFsdWVFbmQsIHJlLm9mZnNldF07XG4gICAgaWYgKHJlLmNvbW1lbnQpXG4gICAgICAgIGFsaWFzLmNvbW1lbnQgPSByZS5jb21tZW50O1xuICAgIHJldHVybiBhbGlhcztcbn1cblxuZXhwb3J0IHsgY29tcG9zZUVtcHR5Tm9kZSwgY29tcG9zZU5vZGUgfTtcbiIsICJpbXBvcnQgeyBEb2N1bWVudCB9IGZyb20gJy4uL2RvYy9Eb2N1bWVudC5qcyc7XG5pbXBvcnQgeyBjb21wb3NlTm9kZSwgY29tcG9zZUVtcHR5Tm9kZSB9IGZyb20gJy4vY29tcG9zZS1ub2RlLmpzJztcbmltcG9ydCB7IHJlc29sdmVFbmQgfSBmcm9tICcuL3Jlc29sdmUtZW5kLmpzJztcbmltcG9ydCB7IHJlc29sdmVQcm9wcyB9IGZyb20gJy4vcmVzb2x2ZS1wcm9wcy5qcyc7XG5cbmZ1bmN0aW9uIGNvbXBvc2VEb2Mob3B0aW9ucywgZGlyZWN0aXZlcywgeyBvZmZzZXQsIHN0YXJ0LCB2YWx1ZSwgZW5kIH0sIG9uRXJyb3IpIHtcbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7IF9kaXJlY3RpdmVzOiBkaXJlY3RpdmVzIH0sIG9wdGlvbnMpO1xuICAgIGNvbnN0IGRvYyA9IG5ldyBEb2N1bWVudCh1bmRlZmluZWQsIG9wdHMpO1xuICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgYXRSb290OiB0cnVlLFxuICAgICAgICBkaXJlY3RpdmVzOiBkb2MuZGlyZWN0aXZlcyxcbiAgICAgICAgb3B0aW9uczogZG9jLm9wdGlvbnMsXG4gICAgICAgIHNjaGVtYTogZG9jLnNjaGVtYVxuICAgIH07XG4gICAgY29uc3QgcHJvcHMgPSByZXNvbHZlUHJvcHMoc3RhcnQsIHtcbiAgICAgICAgaW5kaWNhdG9yOiAnZG9jLXN0YXJ0JyxcbiAgICAgICAgbmV4dDogdmFsdWUgPz8gZW5kPy5bMF0sXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgb25FcnJvcixcbiAgICAgICAgc3RhcnRPbk5ld2xpbmU6IHRydWVcbiAgICB9KTtcbiAgICBpZiAocHJvcHMuZm91bmQpIHtcbiAgICAgICAgZG9jLmRpcmVjdGl2ZXMuZG9jU3RhcnQgPSB0cnVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgICh2YWx1ZS50eXBlID09PSAnYmxvY2stbWFwJyB8fCB2YWx1ZS50eXBlID09PSAnYmxvY2stc2VxJykgJiZcbiAgICAgICAgICAgICFwcm9wcy5oYXNOZXdsaW5lKVxuICAgICAgICAgICAgb25FcnJvcihwcm9wcy5lbmQsICdNSVNTSU5HX0NIQVInLCAnQmxvY2sgY29sbGVjdGlvbiBjYW5ub3Qgc3RhcnQgb24gc2FtZSBsaW5lIHdpdGggZGlyZWN0aXZlcy1lbmQgbWFya2VyJyk7XG4gICAgfVxuICAgIGRvYy5jb250ZW50cyA9IHZhbHVlXG4gICAgICAgID8gY29tcG9zZU5vZGUoY3R4LCB2YWx1ZSwgcHJvcHMsIG9uRXJyb3IpXG4gICAgICAgIDogY29tcG9zZUVtcHR5Tm9kZShjdHgsIHByb3BzLmVuZCwgc3RhcnQsIG51bGwsIHByb3BzLCBvbkVycm9yKTtcbiAgICBjb25zdCBjb250ZW50RW5kID0gZG9jLmNvbnRlbnRzLnJhbmdlWzJdO1xuICAgIGNvbnN0IHJlID0gcmVzb2x2ZUVuZChlbmQsIGNvbnRlbnRFbmQsIGZhbHNlLCBvbkVycm9yKTtcbiAgICBpZiAocmUuY29tbWVudClcbiAgICAgICAgZG9jLmNvbW1lbnQgPSByZS5jb21tZW50O1xuICAgIGRvYy5yYW5nZSA9IFtvZmZzZXQsIGNvbnRlbnRFbmQsIHJlLm9mZnNldF07XG4gICAgcmV0dXJuIGRvYztcbn1cblxuZXhwb3J0IHsgY29tcG9zZURvYyB9O1xuIiwgImltcG9ydCB7IERpcmVjdGl2ZXMgfSBmcm9tICcuLi9kb2MvZGlyZWN0aXZlcy5qcyc7XG5pbXBvcnQgeyBEb2N1bWVudCB9IGZyb20gJy4uL2RvYy9Eb2N1bWVudC5qcyc7XG5pbXBvcnQgeyBZQU1MV2FybmluZywgWUFNTFBhcnNlRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgaXNDb2xsZWN0aW9uLCBpc1BhaXIgfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IGNvbXBvc2VEb2MgfSBmcm9tICcuL2NvbXBvc2UtZG9jLmpzJztcbmltcG9ydCB7IHJlc29sdmVFbmQgfSBmcm9tICcuL3Jlc29sdmUtZW5kLmpzJztcblxuZnVuY3Rpb24gZ2V0RXJyb3JQb3Moc3JjKSB7XG4gICAgaWYgKHR5cGVvZiBzcmMgPT09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4gW3NyYywgc3JjICsgMV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3JjKSlcbiAgICAgICAgcmV0dXJuIHNyYy5sZW5ndGggPT09IDIgPyBzcmMgOiBbc3JjWzBdLCBzcmNbMV1dO1xuICAgIGNvbnN0IHsgb2Zmc2V0LCBzb3VyY2UgfSA9IHNyYztcbiAgICByZXR1cm4gW29mZnNldCwgb2Zmc2V0ICsgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnID8gc291cmNlLmxlbmd0aCA6IDEpXTtcbn1cbmZ1bmN0aW9uIHBhcnNlUHJlbHVkZShwcmVsdWRlKSB7XG4gICAgbGV0IGNvbW1lbnQgPSAnJztcbiAgICBsZXQgYXRDb21tZW50ID0gZmFsc2U7XG4gICAgbGV0IGFmdGVyRW1wdHlMaW5lID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVsdWRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHByZWx1ZGVbaV07XG4gICAgICAgIHN3aXRjaCAoc291cmNlWzBdKSB7XG4gICAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgICAgICBjb21tZW50ICs9XG4gICAgICAgICAgICAgICAgICAgIChjb21tZW50ID09PSAnJyA/ICcnIDogYWZ0ZXJFbXB0eUxpbmUgPyAnXFxuXFxuJyA6ICdcXG4nKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc291cmNlLnN1YnN0cmluZygxKSB8fCAnICcpO1xuICAgICAgICAgICAgICAgIGF0Q29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYWZ0ZXJFbXB0eUxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgIGlmIChwcmVsdWRlW2kgKyAxXT8uWzBdICE9PSAnIycpXG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICBhdENvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBtYXkgYmUgd3JvbmcgYWZ0ZXIgZG9jLWVuZCwgYnV0IGluIHRoYXQgY2FzZSBpdCBkb2Vzbid0IG1hdHRlclxuICAgICAgICAgICAgICAgIGlmICghYXRDb21tZW50KVxuICAgICAgICAgICAgICAgICAgICBhZnRlckVtcHR5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXRDb21tZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgY29tbWVudCwgYWZ0ZXJFbXB0eUxpbmUgfTtcbn1cbi8qKlxuICogQ29tcG9zZSBhIHN0cmVhbSBvZiBDU1Qgbm9kZXMgaW50byBhIHN0cmVhbSBvZiBZQU1MIERvY3VtZW50cy5cbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29tcG9zZXIsIFBhcnNlciB9IGZyb20gJ3lhbWwnXG4gKlxuICogY29uc3Qgc3JjOiBzdHJpbmcgPSAuLi5cbiAqIGNvbnN0IHRva2VucyA9IG5ldyBQYXJzZXIoKS5wYXJzZShzcmMpXG4gKiBjb25zdCBkb2NzID0gbmV3IENvbXBvc2VyKCkuY29tcG9zZSh0b2tlbnMpXG4gKiBgYGBcbiAqL1xuY2xhc3MgQ29tcG9zZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLmRvYyA9IG51bGw7XG4gICAgICAgIHRoaXMuYXREaXJlY3RpdmVzID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJlbHVkZSA9IFtdO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLndhcm5pbmdzID0gW107XG4gICAgICAgIHRoaXMub25FcnJvciA9IChzb3VyY2UsIGNvZGUsIG1lc3NhZ2UsIHdhcm5pbmcpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IGdldEVycm9yUG9zKHNvdXJjZSk7XG4gICAgICAgICAgICBpZiAod2FybmluZylcbiAgICAgICAgICAgICAgICB0aGlzLndhcm5pbmdzLnB1c2gobmV3IFlBTUxXYXJuaW5nKHBvcywgY29kZSwgbWVzc2FnZSkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFlBTUxQYXJzZUVycm9yKHBvcywgY29kZSwgbWVzc2FnZSkpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1udWxsaXNoLWNvYWxlc2NpbmdcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gbmV3IERpcmVjdGl2ZXMoeyB2ZXJzaW9uOiBvcHRpb25zLnZlcnNpb24gfHwgJzEuMicgfSk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGRlY29yYXRlKGRvYywgYWZ0ZXJEb2MpIHtcbiAgICAgICAgY29uc3QgeyBjb21tZW50LCBhZnRlckVtcHR5TGluZSB9ID0gcGFyc2VQcmVsdWRlKHRoaXMucHJlbHVkZSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coeyBkYzogZG9jLmNvbW1lbnQsIHByZWx1ZGUsIGNvbW1lbnQgfSlcbiAgICAgICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRjID0gZG9jLmNvbnRlbnRzO1xuICAgICAgICAgICAgaWYgKGFmdGVyRG9jKSB7XG4gICAgICAgICAgICAgICAgZG9jLmNvbW1lbnQgPSBkb2MuY29tbWVudCA/IGAke2RvYy5jb21tZW50fVxcbiR7Y29tbWVudH1gIDogY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFmdGVyRW1wdHlMaW5lIHx8IGRvYy5kaXJlY3RpdmVzLmRvY1N0YXJ0IHx8ICFkYykge1xuICAgICAgICAgICAgICAgIGRvYy5jb21tZW50QmVmb3JlID0gY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQ29sbGVjdGlvbihkYykgJiYgIWRjLmZsb3cgJiYgZGMuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBpdCA9IGRjLml0ZW1zWzBdO1xuICAgICAgICAgICAgICAgIGlmIChpc1BhaXIoaXQpKVxuICAgICAgICAgICAgICAgICAgICBpdCA9IGl0LmtleTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYiA9IGl0LmNvbW1lbnRCZWZvcmU7XG4gICAgICAgICAgICAgICAgaXQuY29tbWVudEJlZm9yZSA9IGNiID8gYCR7Y29tbWVudH1cXG4ke2NifWAgOiBjb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2IgPSBkYy5jb21tZW50QmVmb3JlO1xuICAgICAgICAgICAgICAgIGRjLmNvbW1lbnRCZWZvcmUgPSBjYiA/IGAke2NvbW1lbnR9XFxuJHtjYn1gIDogY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWZ0ZXJEb2MpIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGRvYy5lcnJvcnMsIHRoaXMuZXJyb3JzKTtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGRvYy53YXJuaW5ncywgdGhpcy53YXJuaW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb2MuZXJyb3JzID0gdGhpcy5lcnJvcnM7XG4gICAgICAgICAgICBkb2Mud2FybmluZ3MgPSB0aGlzLndhcm5pbmdzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlbHVkZSA9IFtdO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLndhcm5pbmdzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc3RyZWFtIHN0YXR1cyBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIE1vc3RseSB1c2VmdWwgYXQgdGhlIGVuZCBvZiBpbnB1dCBmb3IgYW4gZW1wdHkgc3RyZWFtLlxuICAgICAqL1xuICAgIHN0cmVhbUluZm8oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21tZW50OiBwYXJzZVByZWx1ZGUodGhpcy5wcmVsdWRlKS5jb21tZW50LFxuICAgICAgICAgICAgZGlyZWN0aXZlczogdGhpcy5kaXJlY3RpdmVzLFxuICAgICAgICAgICAgZXJyb3JzOiB0aGlzLmVycm9ycyxcbiAgICAgICAgICAgIHdhcm5pbmdzOiB0aGlzLndhcm5pbmdzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBvc2UgdG9rZW5zIGludG8gZG9jdW1lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcmNlRG9jIC0gSWYgdGhlIHN0cmVhbSBjb250YWlucyBubyBkb2N1bWVudCwgc3RpbGwgZW1pdCBhIGZpbmFsIGRvY3VtZW50IGluY2x1ZGluZyBhbnkgY29tbWVudHMgYW5kIGRpcmVjdGl2ZXMgdGhhdCB3b3VsZCBiZSBhcHBsaWVkIHRvIGEgc3Vic2VxdWVudCBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0gZW5kT2Zmc2V0IC0gU2hvdWxkIGJlIHNldCBpZiBgZm9yY2VEb2NgIGlzIGFsc28gc2V0LCB0byBzZXQgdGhlIGRvY3VtZW50IHJhbmdlIGVuZCBhbmQgdG8gaW5kaWNhdGUgZXJyb3JzIGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICAqY29tcG9zZSh0b2tlbnMsIGZvcmNlRG9jID0gZmFsc2UsIGVuZE9mZnNldCA9IC0xKSB7XG4gICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKVxuICAgICAgICAgICAgeWllbGQqIHRoaXMubmV4dCh0b2tlbik7XG4gICAgICAgIHlpZWxkKiB0aGlzLmVuZChmb3JjZURvYywgZW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIEFkdmFuY2UgdGhlIGNvbXBvc2VyIGJ5IG9uZSBDU1QgdG9rZW4uICovXG4gICAgKm5leHQodG9rZW4pIHtcbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdkaXJlY3RpdmUnOlxuICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcy5hZGQodG9rZW4uc291cmNlLCAob2Zmc2V0LCBtZXNzYWdlLCB3YXJuaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvcyA9IGdldEVycm9yUG9zKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zWzBdICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKHBvcywgJ0JBRF9ESVJFQ1RJVkUnLCBtZXNzYWdlLCB3YXJuaW5nKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByZWx1ZGUucHVzaCh0b2tlbi5zb3VyY2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXREaXJlY3RpdmVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RvY3VtZW50Jzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvYyA9IGNvbXBvc2VEb2ModGhpcy5vcHRpb25zLCB0aGlzLmRpcmVjdGl2ZXMsIHRva2VuLCB0aGlzLm9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0RGlyZWN0aXZlcyAmJiAhZG9jLmRpcmVjdGl2ZXMuZG9jU3RhcnQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcih0b2tlbiwgJ01JU1NJTkdfQ0hBUicsICdNaXNzaW5nIGRpcmVjdGl2ZXMtZW5kL2RvYy1zdGFydCBpbmRpY2F0b3IgbGluZScpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGUoZG9jLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9jKVxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmRvYztcbiAgICAgICAgICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgICAgICAgICB0aGlzLmF0RGlyZWN0aXZlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnYnl0ZS1vcmRlci1tYXJrJzpcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5wcmVsdWRlLnB1c2godG9rZW4uc291cmNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IHRva2VuLnNvdXJjZVxuICAgICAgICAgICAgICAgICAgICA/IGAke3Rva2VuLm1lc3NhZ2V9OiAke0pTT04uc3RyaW5naWZ5KHRva2VuLnNvdXJjZSl9YFxuICAgICAgICAgICAgICAgICAgICA6IHRva2VuLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgWUFNTFBhcnNlRXJyb3IoZ2V0RXJyb3JQb3ModG9rZW4pLCAnVU5FWFBFQ1RFRF9UT0tFTicsIG1zZyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXREaXJlY3RpdmVzIHx8ICF0aGlzLmRvYylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvYy5lcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdkb2MtZW5kJzoge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbXNnID0gJ1VuZXhwZWN0ZWQgZG9jLWVuZCB3aXRob3V0IHByZWNlZGluZyBkb2N1bWVudCc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFlBTUxQYXJzZUVycm9yKGdldEVycm9yUG9zKHRva2VuKSwgJ1VORVhQRUNURURfVE9LRU4nLCBtc2cpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZG9jLmRpcmVjdGl2ZXMuZG9jRW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSByZXNvbHZlRW5kKHRva2VuLmVuZCwgdG9rZW4ub2Zmc2V0ICsgdG9rZW4uc291cmNlLmxlbmd0aCwgdGhpcy5kb2Mub3B0aW9ucy5zdHJpY3QsIHRoaXMub25FcnJvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0ZSh0aGlzLmRvYywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVuZC5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRjID0gdGhpcy5kb2MuY29tbWVudDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2MuY29tbWVudCA9IGRjID8gYCR7ZGN9XFxuJHtlbmQuY29tbWVudH1gIDogZW5kLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZG9jLnJhbmdlWzJdID0gZW5kLm9mZnNldDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgWUFNTFBhcnNlRXJyb3IoZ2V0RXJyb3JQb3ModG9rZW4pLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbnN1cHBvcnRlZCB0b2tlbiAke3Rva2VuLnR5cGV9YCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgYXQgZW5kIG9mIGlucHV0IHRvIHlpZWxkIGFueSByZW1haW5pbmcgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9yY2VEb2MgLSBJZiB0aGUgc3RyZWFtIGNvbnRhaW5zIG5vIGRvY3VtZW50LCBzdGlsbCBlbWl0IGEgZmluYWwgZG9jdW1lbnQgaW5jbHVkaW5nIGFueSBjb21tZW50cyBhbmQgZGlyZWN0aXZlcyB0aGF0IHdvdWxkIGJlIGFwcGxpZWQgdG8gYSBzdWJzZXF1ZW50IGRvY3VtZW50LlxuICAgICAqIEBwYXJhbSBlbmRPZmZzZXQgLSBTaG91bGQgYmUgc2V0IGlmIGBmb3JjZURvY2AgaXMgYWxzbyBzZXQsIHRvIHNldCB0aGUgZG9jdW1lbnQgcmFuZ2UgZW5kIGFuZCB0byBpbmRpY2F0ZSBlcnJvcnMgY29ycmVjdGx5LlxuICAgICAqL1xuICAgICplbmQoZm9yY2VEb2MgPSBmYWxzZSwgZW5kT2Zmc2V0ID0gLTEpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9jKSB7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRlKHRoaXMuZG9jLCB0cnVlKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZG9jO1xuICAgICAgICAgICAgdGhpcy5kb2MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZvcmNlRG9jKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7IF9kaXJlY3RpdmVzOiB0aGlzLmRpcmVjdGl2ZXMgfSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IG5ldyBEb2N1bWVudCh1bmRlZmluZWQsIG9wdHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXREaXJlY3RpdmVzKVxuICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihlbmRPZmZzZXQsICdNSVNTSU5HX0NIQVInLCAnTWlzc2luZyBkaXJlY3RpdmVzLWVuZCBpbmRpY2F0b3IgbGluZScpO1xuICAgICAgICAgICAgZG9jLnJhbmdlID0gWzAsIGVuZE9mZnNldCwgZW5kT2Zmc2V0XTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGUoZG9jLCBmYWxzZSk7XG4gICAgICAgICAgICB5aWVsZCBkb2M7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IENvbXBvc2VyIH07XG4iLCAiY29uc3QgQlJFQUsgPSBTeW1ib2woJ2JyZWFrIHZpc2l0Jyk7XG5jb25zdCBTS0lQID0gU3ltYm9sKCdza2lwIGNoaWxkcmVuJyk7XG5jb25zdCBSRU1PVkUgPSBTeW1ib2woJ3JlbW92ZSBpdGVtJyk7XG4vKipcbiAqIEFwcGx5IGEgdmlzaXRvciB0byBhIENTVCBkb2N1bWVudCBvciBpdGVtLlxuICpcbiAqIFdhbGtzIHRocm91Z2ggdGhlIHRyZWUgKGRlcHRoLWZpcnN0KSBzdGFydGluZyBmcm9tIHRoZSByb290LCBjYWxsaW5nIGFcbiAqIGB2aXNpdG9yYCBmdW5jdGlvbiB3aXRoIHR3byBhcmd1bWVudHMgd2hlbiBlbnRlcmluZyBlYWNoIGl0ZW06XG4gKiAgIC0gYGl0ZW1gOiBUaGUgY3VycmVudCBpdGVtLCB3aGljaCBpbmNsdWRlZCB0aGUgZm9sbG93aW5nIG1lbWJlcnM6XG4gKiAgICAgLSBgc3RhcnQ6IFNvdXJjZVRva2VuW11gIFx1MjAxMyBTb3VyY2UgdG9rZW5zIGJlZm9yZSB0aGUga2V5IG9yIHZhbHVlLFxuICogICAgICAgcG9zc2libHkgaW5jbHVkaW5nIGl0cyBhbmNob3Igb3IgdGFnLlxuICogICAgIC0gYGtleT86IFRva2VuIHwgbnVsbGAgXHUyMDEzIFNldCBmb3IgcGFpciB2YWx1ZXMuIE1heSB0aGVuIGJlIGBudWxsYCwgaWZcbiAqICAgICAgIHRoZSBrZXkgYmVmb3JlIHRoZSBgOmAgc2VwYXJhdG9yIGlzIGVtcHR5LlxuICogICAgIC0gYHNlcD86IFNvdXJjZVRva2VuW11gIFx1MjAxMyBTb3VyY2UgdG9rZW5zIGJldHdlZW4gdGhlIGtleSBhbmQgdGhlIHZhbHVlLFxuICogICAgICAgd2hpY2ggc2hvdWxkIGluY2x1ZGUgdGhlIGA6YCBtYXAgdmFsdWUgaW5kaWNhdG9yIGlmIGB2YWx1ZWAgaXMgc2V0LlxuICogICAgIC0gYHZhbHVlPzogVG9rZW5gIFx1MjAxMyBUaGUgdmFsdWUgb2YgYSBzZXF1ZW5jZSBpdGVtLCBvciBvZiBhIG1hcCBwYWlyLlxuICogICAtIGBwYXRoYDogVGhlIHN0ZXBzIGZyb20gdGhlIHJvb3QgdG8gdGhlIGN1cnJlbnQgbm9kZSwgYXMgYW4gYXJyYXkgb2ZcbiAqICAgICBgWydrZXknIHwgJ3ZhbHVlJywgbnVtYmVyXWAgdHVwbGVzLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHZpc2l0b3IgbWF5IGJlIHVzZWQgdG8gY29udHJvbCB0aGUgdHJhdmVyc2FsOlxuICogICAtIGB1bmRlZmluZWRgIChkZWZhdWx0KTogRG8gbm90aGluZyBhbmQgY29udGludWVcbiAqICAgLSBgdmlzaXQuU0tJUGA6IERvIG5vdCB2aXNpdCB0aGUgY2hpbGRyZW4gb2YgdGhpcyB0b2tlbiwgY29udGludWUgd2l0aFxuICogICAgICBuZXh0IHNpYmxpbmdcbiAqICAgLSBgdmlzaXQuQlJFQUtgOiBUZXJtaW5hdGUgdHJhdmVyc2FsIGNvbXBsZXRlbHlcbiAqICAgLSBgdmlzaXQuUkVNT1ZFYDogUmVtb3ZlIHRoZSBjdXJyZW50IGl0ZW0sIHRoZW4gY29udGludWUgd2l0aCB0aGUgbmV4dCBvbmVcbiAqICAgLSBgbnVtYmVyYDogU2V0IHRoZSBpbmRleCBvZiB0aGUgbmV4dCBzdGVwLiBUaGlzIGlzIHVzZWZ1bCBlc3BlY2lhbGx5IGlmXG4gKiAgICAgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IHRva2VuIGhhcyBjaGFuZ2VkLlxuICogICAtIGBmdW5jdGlvbmA6IERlZmluZSB0aGUgbmV4dCB2aXNpdG9yIGZvciB0aGlzIGl0ZW0uIEFmdGVyIHRoZSBvcmlnaW5hbFxuICogICAgIHZpc2l0b3IgaXMgY2FsbGVkIG9uIGl0ZW0gZW50cnksIG5leHQgdmlzaXRvcnMgYXJlIGNhbGxlZCBhZnRlciBoYW5kbGluZ1xuICogICAgIGEgbm9uLWVtcHR5IGBrZXlgIGFuZCB3aGVuIGV4aXRpbmcgdGhlIGl0ZW0uXG4gKi9cbmZ1bmN0aW9uIHZpc2l0KGNzdCwgdmlzaXRvcikge1xuICAgIGlmICgndHlwZScgaW4gY3N0ICYmIGNzdC50eXBlID09PSAnZG9jdW1lbnQnKVxuICAgICAgICBjc3QgPSB7IHN0YXJ0OiBjc3Quc3RhcnQsIHZhbHVlOiBjc3QudmFsdWUgfTtcbiAgICBfdmlzaXQoT2JqZWN0LmZyZWV6ZShbXSksIGNzdCwgdmlzaXRvcik7XG59XG4vLyBXaXRob3V0IHRoZSBgYXMgc3ltYm9sYCBjYXN0cywgVFMgZGVjbGFyZXMgdGhlc2UgaW4gdGhlIGB2aXNpdGBcbi8vIG5hbWVzcGFjZSB1c2luZyBgdmFyYCwgYnV0IHRoZW4gY29tcGxhaW5zIGFib3V0IHRoYXQgYmVjYXVzZVxuLy8gYHVuaXF1ZSBzeW1ib2xgIG11c3QgYmUgYGNvbnN0YC5cbi8qKiBUZXJtaW5hdGUgdmlzaXQgdHJhdmVyc2FsIGNvbXBsZXRlbHkgKi9cbnZpc2l0LkJSRUFLID0gQlJFQUs7XG4vKiogRG8gbm90IHZpc2l0IHRoZSBjaGlsZHJlbiBvZiB0aGUgY3VycmVudCBpdGVtICovXG52aXNpdC5TS0lQID0gU0tJUDtcbi8qKiBSZW1vdmUgdGhlIGN1cnJlbnQgaXRlbSAqL1xudmlzaXQuUkVNT1ZFID0gUkVNT1ZFO1xuLyoqIEZpbmQgdGhlIGl0ZW0gYXQgYHBhdGhgIGZyb20gYGNzdGAgYXMgdGhlIHJvb3QgKi9cbnZpc2l0Lml0ZW1BdFBhdGggPSAoY3N0LCBwYXRoKSA9PiB7XG4gICAgbGV0IGl0ZW0gPSBjc3Q7XG4gICAgZm9yIChjb25zdCBbZmllbGQsIGluZGV4XSBvZiBwYXRoKSB7XG4gICAgICAgIGNvbnN0IHRvayA9IGl0ZW0/LltmaWVsZF07XG4gICAgICAgIGlmICh0b2sgJiYgJ2l0ZW1zJyBpbiB0b2spIHtcbiAgICAgICAgICAgIGl0ZW0gPSB0b2suaXRlbXNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xufTtcbi8qKlxuICogR2V0IHRoZSBpbW1lZGlhdGUgcGFyZW50IGNvbGxlY3Rpb24gb2YgdGhlIGl0ZW0gYXQgYHBhdGhgIGZyb20gYGNzdGAgYXMgdGhlIHJvb3QuXG4gKlxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBjb2xsZWN0aW9uIGlzIG5vdCBmb3VuZCwgd2hpY2ggc2hvdWxkIG5ldmVyIGhhcHBlbiBpZiB0aGUgaXRlbSBpdHNlbGYgZXhpc3RzLlxuICovXG52aXNpdC5wYXJlbnRDb2xsZWN0aW9uID0gKGNzdCwgcGF0aCkgPT4ge1xuICAgIGNvbnN0IHBhcmVudCA9IHZpc2l0Lml0ZW1BdFBhdGgoY3N0LCBwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgY29uc3QgZmllbGQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV1bMF07XG4gICAgY29uc3QgY29sbCA9IHBhcmVudD8uW2ZpZWxkXTtcbiAgICBpZiAoY29sbCAmJiAnaXRlbXMnIGluIGNvbGwpXG4gICAgICAgIHJldHVybiBjb2xsO1xuICAgIHRocm93IG5ldyBFcnJvcignUGFyZW50IGNvbGxlY3Rpb24gbm90IGZvdW5kJyk7XG59O1xuZnVuY3Rpb24gX3Zpc2l0KHBhdGgsIGl0ZW0sIHZpc2l0b3IpIHtcbiAgICBsZXQgY3RybCA9IHZpc2l0b3IoaXRlbSwgcGF0aCk7XG4gICAgaWYgKHR5cGVvZiBjdHJsID09PSAnc3ltYm9sJylcbiAgICAgICAgcmV0dXJuIGN0cmw7XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBbJ2tleScsICd2YWx1ZSddKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gaXRlbVtmaWVsZF07XG4gICAgICAgIGlmICh0b2tlbiAmJiAnaXRlbXMnIGluIHRva2VuKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuLml0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2kgPSBfdmlzaXQoT2JqZWN0LmZyZWV6ZShwYXRoLmNvbmNhdChbW2ZpZWxkLCBpXV0pKSwgdG9rZW4uaXRlbXNbaV0sIHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2kgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICBpID0gY2kgLSAxO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNpID09PSBCUkVBSylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNpID09PSBSRU1PVkUpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4uaXRlbXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdHJsID09PSAnZnVuY3Rpb24nICYmIGZpZWxkID09PSAna2V5JylcbiAgICAgICAgICAgICAgICBjdHJsID0gY3RybChpdGVtLCBwYXRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIGN0cmwgPT09ICdmdW5jdGlvbicgPyBjdHJsKGl0ZW0sIHBhdGgpIDogY3RybDtcbn1cblxuZXhwb3J0IHsgdmlzaXQgfTtcbiIsICJleHBvcnQgeyBjcmVhdGVTY2FsYXJUb2tlbiwgcmVzb2x2ZUFzU2NhbGFyLCBzZXRTY2FsYXJWYWx1ZSB9IGZyb20gJy4vY3N0LXNjYWxhci5qcyc7XG5leHBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICcuL2NzdC1zdHJpbmdpZnkuanMnO1xuZXhwb3J0IHsgdmlzaXQgfSBmcm9tICcuL2NzdC12aXNpdC5qcyc7XG5cbi8qKiBUaGUgYnl0ZSBvcmRlciBtYXJrICovXG5jb25zdCBCT00gPSAnXFx1e0ZFRkZ9Jztcbi8qKiBTdGFydCBvZiBkb2MtbW9kZSAqL1xuY29uc3QgRE9DVU1FTlQgPSAnXFx4MDInOyAvLyBDMDogU3RhcnQgb2YgVGV4dFxuLyoqIFVuZXhwZWN0ZWQgZW5kIG9mIGZsb3ctbW9kZSAqL1xuY29uc3QgRkxPV19FTkQgPSAnXFx4MTgnOyAvLyBDMDogQ2FuY2VsXG4vKiogTmV4dCB0b2tlbiBpcyBhIHNjYWxhciB2YWx1ZSAqL1xuY29uc3QgU0NBTEFSID0gJ1xceDFmJzsgLy8gQzA6IFVuaXQgU2VwYXJhdG9yXG4vKiogQHJldHVybnMgYHRydWVgIGlmIGB0b2tlbmAgaXMgYSBmbG93IG9yIGJsb2NrIGNvbGxlY3Rpb24gKi9cbmNvbnN0IGlzQ29sbGVjdGlvbiA9ICh0b2tlbikgPT4gISF0b2tlbiAmJiAnaXRlbXMnIGluIHRva2VuO1xuLyoqIEByZXR1cm5zIGB0cnVlYCBpZiBgdG9rZW5gIGlzIGEgZmxvdyBvciBibG9jayBzY2FsYXI7IG5vdCBhbiBhbGlhcyAqL1xuY29uc3QgaXNTY2FsYXIgPSAodG9rZW4pID0+ICEhdG9rZW4gJiZcbiAgICAodG9rZW4udHlwZSA9PT0gJ3NjYWxhcicgfHxcbiAgICAgICAgdG9rZW4udHlwZSA9PT0gJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJyB8fFxuICAgICAgICB0b2tlbi50eXBlID09PSAnZG91YmxlLXF1b3RlZC1zY2FsYXInIHx8XG4gICAgICAgIHRva2VuLnR5cGUgPT09ICdibG9jay1zY2FsYXInKTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKiogR2V0IGEgcHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGEgbGV4ZXIgdG9rZW4gKi9cbmZ1bmN0aW9uIHByZXR0eVRva2VuKHRva2VuKSB7XG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlIEJPTTpcbiAgICAgICAgICAgIHJldHVybiAnPEJPTT4nO1xuICAgICAgICBjYXNlIERPQ1VNRU5UOlxuICAgICAgICAgICAgcmV0dXJuICc8RE9DPic7XG4gICAgICAgIGNhc2UgRkxPV19FTkQ6XG4gICAgICAgICAgICByZXR1cm4gJzxGTE9XX0VORD4nO1xuICAgICAgICBjYXNlIFNDQUxBUjpcbiAgICAgICAgICAgIHJldHVybiAnPFNDQUxBUj4nO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRva2VuKTtcbiAgICB9XG59XG4vKiogSWRlbnRpZnkgdGhlIHR5cGUgb2YgYSBsZXhlciB0b2tlbi4gTWF5IHJldHVybiBgbnVsbGAgZm9yIHVua25vd24gdG9rZW5zLiAqL1xuZnVuY3Rpb24gdG9rZW5UeXBlKHNvdXJjZSkge1xuICAgIHN3aXRjaCAoc291cmNlKSB7XG4gICAgICAgIGNhc2UgQk9NOlxuICAgICAgICAgICAgcmV0dXJuICdieXRlLW9yZGVyLW1hcmsnO1xuICAgICAgICBjYXNlIERPQ1VNRU5UOlxuICAgICAgICAgICAgcmV0dXJuICdkb2MtbW9kZSc7XG4gICAgICAgIGNhc2UgRkxPV19FTkQ6XG4gICAgICAgICAgICByZXR1cm4gJ2Zsb3ctZXJyb3ItZW5kJztcbiAgICAgICAgY2FzZSBTQ0FMQVI6XG4gICAgICAgICAgICByZXR1cm4gJ3NjYWxhcic7XG4gICAgICAgIGNhc2UgJy0tLSc6XG4gICAgICAgICAgICByZXR1cm4gJ2RvYy1zdGFydCc7XG4gICAgICAgIGNhc2UgJy4uLic6XG4gICAgICAgICAgICByZXR1cm4gJ2RvYy1lbmQnO1xuICAgICAgICBjYXNlICcnOlxuICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICBjYXNlICdcXHJcXG4nOlxuICAgICAgICAgICAgcmV0dXJuICduZXdsaW5lJztcbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICByZXR1cm4gJ3NlcS1pdGVtLWluZCc7XG4gICAgICAgIGNhc2UgJz8nOlxuICAgICAgICAgICAgcmV0dXJuICdleHBsaWNpdC1rZXktaW5kJztcbiAgICAgICAgY2FzZSAnOic6XG4gICAgICAgICAgICByZXR1cm4gJ21hcC12YWx1ZS1pbmQnO1xuICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgIHJldHVybiAnZmxvdy1tYXAtc3RhcnQnO1xuICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgIHJldHVybiAnZmxvdy1tYXAtZW5kJztcbiAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICByZXR1cm4gJ2Zsb3ctc2VxLXN0YXJ0JztcbiAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgICByZXR1cm4gJ2Zsb3ctc2VxLWVuZCc7XG4gICAgICAgIGNhc2UgJywnOlxuICAgICAgICAgICAgcmV0dXJuICdjb21tYSc7XG4gICAgfVxuICAgIHN3aXRjaCAoc291cmNlWzBdKSB7XG4gICAgICAgIGNhc2UgJyAnOlxuICAgICAgICBjYXNlICdcXHQnOlxuICAgICAgICAgICAgcmV0dXJuICdzcGFjZSc7XG4gICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgcmV0dXJuICdjb21tZW50JztcbiAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICByZXR1cm4gJ2RpcmVjdGl2ZS1saW5lJztcbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICByZXR1cm4gJ2FsaWFzJztcbiAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICByZXR1cm4gJ2FuY2hvcic7XG4gICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgcmV0dXJuICd0YWcnO1xuICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgcmV0dXJuICdzaW5nbGUtcXVvdGVkLXNjYWxhcic7XG4gICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgIHJldHVybiAnZG91YmxlLXF1b3RlZC1zY2FsYXInO1xuICAgICAgICBjYXNlICd8JzpcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICByZXR1cm4gJ2Jsb2NrLXNjYWxhci1oZWFkZXInO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IHsgQk9NLCBET0NVTUVOVCwgRkxPV19FTkQsIFNDQUxBUiwgaXNDb2xsZWN0aW9uLCBpc1NjYWxhciwgcHJldHR5VG9rZW4sIHRva2VuVHlwZSB9O1xuIiwgImltcG9ydCB7IEJPTSwgRE9DVU1FTlQsIEZMT1dfRU5ELCBTQ0FMQVIgfSBmcm9tICcuL2NzdC5qcyc7XG5cbi8qXG5TVEFSVCAtPiBzdHJlYW1cblxuc3RyZWFtXG4gIGRpcmVjdGl2ZSAtPiBsaW5lLWVuZCAtPiBzdHJlYW1cbiAgaW5kZW50ICsgbGluZS1lbmQgLT4gc3RyZWFtXG4gIFtlbHNlXSAtPiBsaW5lLXN0YXJ0XG5cbmxpbmUtZW5kXG4gIGNvbW1lbnQgLT4gbGluZS1lbmRcbiAgbmV3bGluZSAtPiAuXG4gIGlucHV0LWVuZCAtPiBFTkRcblxubGluZS1zdGFydFxuICBkb2Mtc3RhcnQgLT4gZG9jXG4gIGRvYy1lbmQgLT4gc3RyZWFtXG4gIFtlbHNlXSAtPiBpbmRlbnQgLT4gYmxvY2stc3RhcnRcblxuYmxvY2stc3RhcnRcbiAgc2VxLWl0ZW0tc3RhcnQgLT4gYmxvY2stc3RhcnRcbiAgZXhwbGljaXQta2V5LXN0YXJ0IC0+IGJsb2NrLXN0YXJ0XG4gIG1hcC12YWx1ZS1zdGFydCAtPiBibG9jay1zdGFydFxuICBbZWxzZV0gLT4gZG9jXG5cbmRvY1xuICBsaW5lLWVuZCAtPiBsaW5lLXN0YXJ0XG4gIHNwYWNlcyAtPiBkb2NcbiAgYW5jaG9yIC0+IGRvY1xuICB0YWcgLT4gZG9jXG4gIGZsb3ctc3RhcnQgLT4gZmxvdyAtPiBkb2NcbiAgZmxvdy1lbmQgLT4gZXJyb3IgLT4gZG9jXG4gIHNlcS1pdGVtLXN0YXJ0IC0+IGVycm9yIC0+IGRvY1xuICBleHBsaWNpdC1rZXktc3RhcnQgLT4gZXJyb3IgLT4gZG9jXG4gIG1hcC12YWx1ZS1zdGFydCAtPiBkb2NcbiAgYWxpYXMgLT4gZG9jXG4gIHF1b3RlLXN0YXJ0IC0+IHF1b3RlZC1zY2FsYXIgLT4gZG9jXG4gIGJsb2NrLXNjYWxhci1oZWFkZXIgLT4gbGluZS1lbmQgLT4gYmxvY2stc2NhbGFyKG1pbikgLT4gbGluZS1zdGFydFxuICBbZWxzZV0gLT4gcGxhaW4tc2NhbGFyKGZhbHNlLCBtaW4pIC0+IGRvY1xuXG5mbG93XG4gIGxpbmUtZW5kIC0+IGZsb3dcbiAgc3BhY2VzIC0+IGZsb3dcbiAgYW5jaG9yIC0+IGZsb3dcbiAgdGFnIC0+IGZsb3dcbiAgZmxvdy1zdGFydCAtPiBmbG93IC0+IGZsb3dcbiAgZmxvdy1lbmQgLT4gLlxuICBzZXEtaXRlbS1zdGFydCAtPiBlcnJvciAtPiBmbG93XG4gIGV4cGxpY2l0LWtleS1zdGFydCAtPiBmbG93XG4gIG1hcC12YWx1ZS1zdGFydCAtPiBmbG93XG4gIGFsaWFzIC0+IGZsb3dcbiAgcXVvdGUtc3RhcnQgLT4gcXVvdGVkLXNjYWxhciAtPiBmbG93XG4gIGNvbW1hIC0+IGZsb3dcbiAgW2Vsc2VdIC0+IHBsYWluLXNjYWxhcih0cnVlLCAwKSAtPiBmbG93XG5cbnF1b3RlZC1zY2FsYXJcbiAgcXVvdGUtZW5kIC0+IC5cbiAgW2Vsc2VdIC0+IHF1b3RlZC1zY2FsYXJcblxuYmxvY2stc2NhbGFyKG1pbilcbiAgbmV3bGluZSArIHBlZWsoaW5kZW50IDwgbWluKSAtPiAuXG4gIFtlbHNlXSAtPiBibG9jay1zY2FsYXIobWluKVxuXG5wbGFpbi1zY2FsYXIoaXMtZmxvdywgbWluKVxuICBzY2FsYXItZW5kKGlzLWZsb3cpIC0+IC5cbiAgcGVlayhuZXdsaW5lICsgKGluZGVudCA8IG1pbikpIC0+IC5cbiAgW2Vsc2VdIC0+IHBsYWluLXNjYWxhcihtaW4pXG4qL1xuZnVuY3Rpb24gaXNFbXB0eShjaCkge1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIGNhc2UgJyAnOlxuICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICBjYXNlICdcXHInOlxuICAgICAgICBjYXNlICdcXHQnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY29uc3QgaGV4RGlnaXRzID0gJzAxMjM0NTY3ODlBQkNERUZhYmNkZWYnLnNwbGl0KCcnKTtcbmNvbnN0IHRhZ0NoYXJzID0gXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei0jOy8/OkAmPSskXy4hfionKClcIi5zcGxpdCgnJyk7XG5jb25zdCBpbnZhbGlkRmxvd1NjYWxhckNoYXJzID0gJyxbXXt9Jy5zcGxpdCgnJyk7XG5jb25zdCBpbnZhbGlkQW5jaG9yQ2hhcnMgPSAnICxbXXt9XFxuXFxyXFx0Jy5zcGxpdCgnJyk7XG5jb25zdCBpc05vdEFuY2hvckNoYXIgPSAoY2gpID0+ICFjaCB8fCBpbnZhbGlkQW5jaG9yQ2hhcnMuaW5jbHVkZXMoY2gpO1xuLyoqXG4gKiBTcGxpdHMgYW4gaW5wdXQgc3RyaW5nIGludG8gbGV4aWNhbCB0b2tlbnMsIGkuZS4gc21hbGxlciBzdHJpbmdzIHRoYXQgYXJlXG4gKiBlYXNpbHkgaWRlbnRpZmlhYmxlIGJ5IGB0b2tlbnMudG9rZW5UeXBlKClgLlxuICpcbiAqIExleGluZyBzdGFydHMgYWx3YXlzIGluIGEgXCJzdHJlYW1cIiBjb250ZXh0LiBJbmNvbXBsZXRlIGlucHV0IG1heSBiZSBidWZmZXJlZFxuICogdW50aWwgYSBjb21wbGV0ZSB0b2tlbiBjYW4gYmUgZW1pdHRlZC5cbiAqXG4gKiBJbiBhZGRpdGlvbiB0byBzbGljZXMgb2YgdGhlIG9yaWdpbmFsIGlucHV0LCB0aGUgZm9sbG93aW5nIGNvbnRyb2wgY2hhcmFjdGVyc1xuICogbWF5IGFsc28gYmUgZW1pdHRlZDpcbiAqXG4gKiAtIGBcXHgwMmAgKFN0YXJ0IG9mIFRleHQpOiBBIGRvY3VtZW50IHN0YXJ0cyB3aXRoIHRoZSBuZXh0IHRva2VuXG4gKiAtIGBcXHgxOGAgKENhbmNlbCk6IFVuZXhwZWN0ZWQgZW5kIG9mIGZsb3ctbW9kZSAoaW5kaWNhdGVzIGFuIGVycm9yKVxuICogLSBgXFx4MWZgIChVbml0IFNlcGFyYXRvcik6IE5leHQgdG9rZW4gaXMgYSBzY2FsYXIgdmFsdWVcbiAqIC0gYFxcdXtGRUZGfWAgKEJ5dGUgb3JkZXIgbWFyayk6IEVtaXR0ZWQgc2VwYXJhdGVseSBvdXRzaWRlIGRvY3VtZW50c1xuICovXG5jbGFzcyBMZXhlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJ1ZmZlciBtYXJrcyB0aGUgZW5kIG9mXG4gICAgICAgICAqIGFsbCBpbnB1dFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdEVuZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXhwbGljaXQgaW5kZW50IHNldCBpbiBibG9jayBzY2FsYXIgaGVhZGVyLCBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgY3VycmVudFxuICAgICAgICAgKiBtaW5pbXVtIGluZGVudCwgc28gZS5nLiBzZXQgdG8gMSBmcm9tIGEgaGVhZGVyIGB8MitgLiBTZXQgdG8gLTEgaWYgbm90XG4gICAgICAgICAqIGV4cGxpY2l0bHkgc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ibG9ja1NjYWxhckluZGVudCA9IC0xO1xuICAgICAgICAvKipcbiAgICAgICAgICogQmxvY2sgc2NhbGFycyB0aGF0IGluY2x1ZGUgYSArIChrZWVwKSBjaG9tcGluZyBpbmRpY2F0b3IgaW4gdGhlaXIgaGVhZGVyXG4gICAgICAgICAqIGluY2x1ZGUgdHJhaWxpbmcgZW1wdHkgbGluZXMsIHdoaWNoIGFyZSBvdGhlcndpc2UgZXhjbHVkZWQgZnJvbSB0aGVcbiAgICAgICAgICogc2NhbGFyJ3MgY29udGVudHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJsb2NrU2NhbGFyS2VlcCA9IGZhbHNlO1xuICAgICAgICAvKiogQ3VycmVudCBpbnB1dCAqL1xuICAgICAgICB0aGlzLmJ1ZmZlciA9ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmxhZyBub3Rpbmcgd2hldGhlciB0aGUgbWFwIHZhbHVlIGluZGljYXRvciA6IGNhbiBpbW1lZGlhdGVseSBmb2xsb3cgdGhpc1xuICAgICAgICAgKiBub2RlIHdpdGhpbiBhIGZsb3cgY29udGV4dC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmxvd0tleSA9IGZhbHNlO1xuICAgICAgICAvKiogQ291bnQgb2Ygc3Vycm91bmRpbmcgZmxvdyBjb2xsZWN0aW9uIGxldmVscy4gKi9cbiAgICAgICAgdGhpcy5mbG93TGV2ZWwgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWluaW11bSBsZXZlbCBvZiBpbmRlbnRhdGlvbiByZXF1aXJlZCBmb3IgbmV4dCBsaW5lcyB0byBiZSBwYXJzZWQgYXMgYVxuICAgICAgICAgKiBwYXJ0IG9mIHRoZSBjdXJyZW50IHNjYWxhciB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZW50TmV4dCA9IDA7XG4gICAgICAgIC8qKiBJbmRlbnRhdGlvbiBsZXZlbCBvZiB0aGUgY3VycmVudCBsaW5lLiAqL1xuICAgICAgICB0aGlzLmluZGVudFZhbHVlID0gMDtcbiAgICAgICAgLyoqIFBvc2l0aW9uIG9mIHRoZSBuZXh0IFxcbiBjaGFyYWN0ZXIuICovXG4gICAgICAgIHRoaXMubGluZUVuZFBvcyA9IG51bGw7XG4gICAgICAgIC8qKiBTdG9yZXMgdGhlIHN0YXRlIG9mIHRoZSBsZXhlciBpZiByZWFjaGluZyB0aGUgZW5kIG9mIGluY3BvbXBsZXRlIGlucHV0ICovXG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgICAgIC8qKiBBIHBvaW50ZXIgdG8gYGJ1ZmZlcmA7IHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBsZXhlci4gKi9cbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBZQU1MIHRva2VucyBmcm9tIHRoZSBgc291cmNlYCBzdHJpbmcuIElmIGBpbmNvbXBsZXRlYCxcbiAgICAgKiBhIHBhcnQgb2YgdGhlIGxhc3QgbGluZSBtYXkgYmUgbGVmdCBhcyBhIGJ1ZmZlciBmb3IgdGhlIG5leHQgY2FsbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgZ2VuZXJhdG9yIG9mIGxleGljYWwgdG9rZW5zXG4gICAgICovXG4gICAgKmxleChzb3VyY2UsIGluY29tcGxldGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyID8gdGhpcy5idWZmZXIgKyBzb3VyY2UgOiBzb3VyY2U7XG4gICAgICAgICAgICB0aGlzLmxpbmVFbmRQb3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXRFbmQgPSAhaW5jb21wbGV0ZTtcbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLm5leHQgPz8gJ3N0cmVhbSc7XG4gICAgICAgIHdoaWxlIChuZXh0ICYmIChpbmNvbXBsZXRlIHx8IHRoaXMuaGFzQ2hhcnMoMSkpKVxuICAgICAgICAgICAgbmV4dCA9IHlpZWxkKiB0aGlzLnBhcnNlTmV4dChuZXh0KTtcbiAgICB9XG4gICAgYXRMaW5lRW5kKCkge1xuICAgICAgICBsZXQgaSA9IHRoaXMucG9zO1xuICAgICAgICBsZXQgY2ggPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgd2hpbGUgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKVxuICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICBpZiAoIWNoIHx8IGNoID09PSAnIycgfHwgY2ggPT09ICdcXG4nKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChjaCA9PT0gJ1xccicpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJbaSArIDFdID09PSAnXFxuJztcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjaGFyQXQobikge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5wb3MgKyBuXTtcbiAgICB9XG4gICAgY29udGludWVTY2FsYXIob2Zmc2V0KSB7XG4gICAgICAgIGxldCBjaCA9IHRoaXMuYnVmZmVyW29mZnNldF07XG4gICAgICAgIGlmICh0aGlzLmluZGVudE5leHQgPiAwKSB7XG4gICAgICAgICAgICBsZXQgaW5kZW50ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChjaCA9PT0gJyAnKVxuICAgICAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKytpbmRlbnQgKyBvZmZzZXRdO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmJ1ZmZlcltpbmRlbnQgKyBvZmZzZXQgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gJ1xcbicgfHwgKCFuZXh0ICYmICF0aGlzLmF0RW5kKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldCArIGluZGVudCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2ggPT09ICdcXG4nIHx8IGluZGVudCA+PSB0aGlzLmluZGVudE5leHQgfHwgKCFjaCAmJiAhdGhpcy5hdEVuZClcbiAgICAgICAgICAgICAgICA/IG9mZnNldCArIGluZGVudFxuICAgICAgICAgICAgICAgIDogLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcuJykge1xuICAgICAgICAgICAgY29uc3QgZHQgPSB0aGlzLmJ1ZmZlci5zdWJzdHIob2Zmc2V0LCAzKTtcbiAgICAgICAgICAgIGlmICgoZHQgPT09ICctLS0nIHx8IGR0ID09PSAnLi4uJykgJiYgaXNFbXB0eSh0aGlzLmJ1ZmZlcltvZmZzZXQgKyAzXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICAgIGdldExpbmUoKSB7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLmxpbmVFbmRQb3M7XG4gICAgICAgIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyB8fCAoZW5kICE9PSAtMSAmJiBlbmQgPCB0aGlzLnBvcykpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuYnVmZmVyLmluZGV4T2YoJ1xcbicsIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMubGluZUVuZFBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID09PSAtMSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0RW5kID8gdGhpcy5idWZmZXIuc3Vic3RyaW5nKHRoaXMucG9zKSA6IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlcltlbmQgLSAxXSA9PT0gJ1xccicpXG4gICAgICAgICAgICBlbmQgLT0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnN1YnN0cmluZyh0aGlzLnBvcywgZW5kKTtcbiAgICB9XG4gICAgaGFzQ2hhcnMobikge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgKyBuIDw9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICB9XG4gICAgc2V0TmV4dChzdGF0ZSkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLnN1YnN0cmluZyh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5saW5lRW5kUG9zID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXh0ID0gc3RhdGU7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBwZWVrKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnN1YnN0cih0aGlzLnBvcywgbik7XG4gICAgfVxuICAgICpwYXJzZU5leHQobmV4dCkge1xuICAgICAgICBzd2l0Y2ggKG5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmVhbSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlU3RyZWFtKCk7XG4gICAgICAgICAgICBjYXNlICdsaW5lLXN0YXJ0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VMaW5lU3RhcnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXN0YXJ0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VCbG9ja1N0YXJ0KCk7XG4gICAgICAgICAgICBjYXNlICdkb2MnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZURvY3VtZW50KCk7XG4gICAgICAgICAgICBjYXNlICdmbG93JzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VGbG93Q29sbGVjdGlvbigpO1xuICAgICAgICAgICAgY2FzZSAncXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUXVvdGVkU2NhbGFyKCk7XG4gICAgICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUJsb2NrU2NhbGFyKCk7XG4gICAgICAgICAgICBjYXNlICdwbGFpbi1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZVBsYWluU2NhbGFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKnBhcnNlU3RyZWFtKCkge1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuZ2V0TGluZSgpO1xuICAgICAgICBpZiAobGluZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ3N0cmVhbScpO1xuICAgICAgICBpZiAobGluZVswXSA9PT0gQk9NKSB7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICBsaW5lID0gbGluZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVbMF0gPT09ICclJykge1xuICAgICAgICAgICAgbGV0IGRpckVuZCA9IGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgY3MgPSBsaW5lLmluZGV4T2YoJyMnKTtcbiAgICAgICAgICAgIGlmIChjcyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaCA9IGxpbmVbY3MgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpXG4gICAgICAgICAgICAgICAgICAgIGRpckVuZCA9IGNzIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2ggPSBsaW5lW2RpckVuZCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJyAnIHx8IGNoID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgZGlyRW5kIC09IDE7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG4gPSAoeWllbGQqIHRoaXMucHVzaENvdW50KGRpckVuZCkpICsgKHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSkpO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KGxpbmUubGVuZ3RoIC0gbik7IC8vIHBvc3NpYmxlIGNvbW1lbnRcbiAgICAgICAgICAgIHRoaXMucHVzaE5ld2xpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiAnc3RyZWFtJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdExpbmVFbmQoKSkge1xuICAgICAgICAgICAgY29uc3Qgc3AgPSB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KGxpbmUubGVuZ3RoIC0gc3ApO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaE5ld2xpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiAnc3RyZWFtJztcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBET0NVTUVOVDtcbiAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlTGluZVN0YXJ0KCk7XG4gICAgfVxuICAgICpwYXJzZUxpbmVTdGFydCgpIHtcbiAgICAgICAgY29uc3QgY2ggPSB0aGlzLmNoYXJBdCgwKTtcbiAgICAgICAgaWYgKCFjaCAmJiAhdGhpcy5hdEVuZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ2xpbmUtc3RhcnQnKTtcbiAgICAgICAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcuJykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmF0RW5kICYmICF0aGlzLmhhc0NoYXJzKDQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ2xpbmUtc3RhcnQnKTtcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0aGlzLnBlZWsoMyk7XG4gICAgICAgICAgICBpZiAocyA9PT0gJy0tLScgJiYgaXNFbXB0eSh0aGlzLmNoYXJBdCgzKSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMyk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnROZXh0ID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2RvYyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzID09PSAnLi4uJyAmJiBpc0VtcHR5KHRoaXMuY2hhckF0KDMpKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3N0cmVhbSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRlbnRWYWx1ZSA9IHlpZWxkKiB0aGlzLnB1c2hTcGFjZXMoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5pbmRlbnROZXh0ID4gdGhpcy5pbmRlbnRWYWx1ZSAmJiAhaXNFbXB0eSh0aGlzLmNoYXJBdCgxKSkpXG4gICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPSB0aGlzLmluZGVudFZhbHVlO1xuICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VCbG9ja1N0YXJ0KCk7XG4gICAgfVxuICAgICpwYXJzZUJsb2NrU3RhcnQoKSB7XG4gICAgICAgIGNvbnN0IFtjaDAsIGNoMV0gPSB0aGlzLnBlZWsoMik7XG4gICAgICAgIGlmICghY2gxICYmICF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnYmxvY2stc3RhcnQnKTtcbiAgICAgICAgaWYgKChjaDAgPT09ICctJyB8fCBjaDAgPT09ICc/JyB8fCBjaDAgPT09ICc6JykgJiYgaXNFbXB0eShjaDEpKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gKHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKSkgKyAoeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKSk7XG4gICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPSB0aGlzLmluZGVudFZhbHVlICsgMTtcbiAgICAgICAgICAgIHRoaXMuaW5kZW50VmFsdWUgKz0gbjtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUJsb2NrU3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2RvYyc7XG4gICAgfVxuICAgICpwYXJzZURvY3VtZW50KCkge1xuICAgICAgICB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpO1xuICAgICAgICBjb25zdCBsaW5lID0gdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgIGlmIChsaW5lID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnZG9jJyk7XG4gICAgICAgIGxldCBuID0geWllbGQqIHRoaXMucHVzaEluZGljYXRvcnMoKTtcbiAgICAgICAgc3dpdGNoIChsaW5lW25dKSB7XG4gICAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQobGluZS5sZW5ndGggLSBuKTtcbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoTmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUxpbmVTdGFydCgpO1xuICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93S2V5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93TGV2ZWwgPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZmxvdyc7XG4gICAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgIGNhc2UgJ10nOlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkb2MnO1xuICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaFVudGlsKGlzTm90QW5jaG9yQ2hhcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkb2MnO1xuICAgICAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VRdW90ZWRTY2FsYXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgbiArPSB5aWVsZCogdGhpcy5wYXJzZUJsb2NrU2NhbGFySGVhZGVyKCk7XG4gICAgICAgICAgICAgICAgbiArPSB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudChsaW5lLmxlbmd0aCAtIG4pO1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hOZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlQmxvY2tTY2FsYXIoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUGxhaW5TY2FsYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqcGFyc2VGbG93Q29sbGVjdGlvbigpIHtcbiAgICAgICAgbGV0IG5sLCBzcDtcbiAgICAgICAgbGV0IGluZGVudCA9IC0xO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBubCA9IHlpZWxkKiB0aGlzLnB1c2hOZXdsaW5lKCk7XG4gICAgICAgICAgICBpZiAobmwgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3AgPSB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudFZhbHVlID0gaW5kZW50ID0gc3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzcCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcCArPSB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpO1xuICAgICAgICB9IHdoaWxlIChubCArIHNwID4gMCk7XG4gICAgICAgIGNvbnN0IGxpbmUgPSB0aGlzLmdldExpbmUoKTtcbiAgICAgICAgaWYgKGxpbmUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdmbG93Jyk7XG4gICAgICAgIGlmICgoaW5kZW50ICE9PSAtMSAmJiBpbmRlbnQgPCB0aGlzLmluZGVudE5leHQgJiYgbGluZVswXSAhPT0gJyMnKSB8fFxuICAgICAgICAgICAgKGluZGVudCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIChsaW5lLnN0YXJ0c1dpdGgoJy0tLScpIHx8IGxpbmUuc3RhcnRzV2l0aCgnLi4uJykpICYmXG4gICAgICAgICAgICAgICAgaXNFbXB0eShsaW5lWzNdKSkpIHtcbiAgICAgICAgICAgIC8vIEFsbG93aW5nIGZvciB0aGUgdGVybWluYWwgXSBvciB9IGF0IHRoZSBzYW1lIChyYXRoZXIgdGhhbiBncmVhdGVyKVxuICAgICAgICAgICAgLy8gaW5kZW50IGxldmVsIGFzIHRoZSBpbml0aWFsIFsgb3IgeyBpcyB0ZWNobmljYWxseSBpbnZhbGlkLCBidXRcbiAgICAgICAgICAgIC8vIGZhaWxpbmcgaGVyZSB3b3VsZCBiZSBzdXJwcmlzaW5nIHRvIHVzZXJzLlxuICAgICAgICAgICAgY29uc3QgYXRGbG93RW5kTWFya2VyID0gaW5kZW50ID09PSB0aGlzLmluZGVudE5leHQgLSAxICYmXG4gICAgICAgICAgICAgICAgdGhpcy5mbG93TGV2ZWwgPT09IDEgJiZcbiAgICAgICAgICAgICAgICAobGluZVswXSA9PT0gJ10nIHx8IGxpbmVbMF0gPT09ICd9Jyk7XG4gICAgICAgICAgICBpZiAoIWF0Rmxvd0VuZE1hcmtlcikge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dMZXZlbCA9IDA7XG4gICAgICAgICAgICAgICAgeWllbGQgRkxPV19FTkQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlTGluZVN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICB3aGlsZSAobGluZVtuXSA9PT0gJywnKSB7XG4gICAgICAgICAgICBuICs9IHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgIG4gKz0geWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG4gKz0geWllbGQqIHRoaXMucHVzaEluZGljYXRvcnMoKTtcbiAgICAgICAgc3dpdGNoIChsaW5lW25dKSB7XG4gICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Zsb3cnO1xuICAgICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KGxpbmUubGVuZ3RoIC0gbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdmbG93JztcbiAgICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0xldmVsICs9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdmbG93JztcbiAgICAgICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93TGV2ZWwgLT0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mbG93TGV2ZWwgPyAnZmxvdycgOiAnZG9jJztcbiAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hVbnRpbChpc05vdEFuY2hvckNoYXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZmxvdyc7XG4gICAgICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUXVvdGVkU2NhbGFyKCk7XG4gICAgICAgICAgICBjYXNlICc6Jzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmNoYXJBdCgxKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93S2V5IHx8IGlzRW1wdHkobmV4dCkgfHwgbmV4dCA9PT0gJywnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnZmxvdyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93S2V5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUGxhaW5TY2FsYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqcGFyc2VRdW90ZWRTY2FsYXIoKSB7XG4gICAgICAgIGNvbnN0IHF1b3RlID0gdGhpcy5jaGFyQXQoMCk7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLmJ1ZmZlci5pbmRleE9mKHF1b3RlLCB0aGlzLnBvcyArIDEpO1xuICAgICAgICBpZiAocXVvdGUgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICB3aGlsZSAoZW5kICE9PSAtMSAmJiB0aGlzLmJ1ZmZlcltlbmQgKyAxXSA9PT0gXCInXCIpXG4gICAgICAgICAgICAgICAgZW5kID0gdGhpcy5idWZmZXIuaW5kZXhPZihcIidcIiwgZW5kICsgMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVcbiAgICAgICAgICAgIHdoaWxlIChlbmQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmJ1ZmZlcltlbmQgLSAxIC0gbl0gPT09ICdcXFxcJylcbiAgICAgICAgICAgICAgICAgICAgbiArPSAxO1xuICAgICAgICAgICAgICAgIGlmIChuICUgMiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZW5kID0gdGhpcy5idWZmZXIuaW5kZXhPZignXCInLCBlbmQgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGxvb2tpbmcgZm9yIG5ld2xpbmVzIHdpdGhpbiB0aGUgcXVvdGVzXG4gICAgICAgIGNvbnN0IHFiID0gdGhpcy5idWZmZXIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gICAgICAgIGxldCBubCA9IHFiLmluZGV4T2YoJ1xcbicsIHRoaXMucG9zKTtcbiAgICAgICAgaWYgKG5sICE9PSAtMSkge1xuICAgICAgICAgICAgd2hpbGUgKG5sICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNzID0gdGhpcy5jb250aW51ZVNjYWxhcihubCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChjcyA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIG5sID0gcWIuaW5kZXhPZignXFxuJywgY3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5sICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gZXJyb3IgY2F1c2VkIGJ5IGFuIHVuZXhwZWN0ZWQgdW5pbmRlbnRcbiAgICAgICAgICAgICAgICBlbmQgPSBubCAtIChxYltubCAtIDFdID09PSAnXFxyJyA/IDIgOiAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ3F1b3RlZC1zY2FsYXInKTtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCogdGhpcy5wdXNoVG9JbmRleChlbmQgKyAxLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dMZXZlbCA/ICdmbG93JyA6ICdkb2MnO1xuICAgIH1cbiAgICAqcGFyc2VCbG9ja1NjYWxhckhlYWRlcigpIHtcbiAgICAgICAgdGhpcy5ibG9ja1NjYWxhckluZGVudCA9IC0xO1xuICAgICAgICB0aGlzLmJsb2NrU2NhbGFyS2VlcCA9IGZhbHNlO1xuICAgICAgICBsZXQgaSA9IHRoaXMucG9zO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnKycpXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja1NjYWxhcktlZXAgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPiAnMCcgJiYgY2ggPD0gJzknKVxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tTY2FsYXJJbmRlbnQgPSBOdW1iZXIoY2gpIC0gMTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoICE9PSAnLScpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnB1c2hVbnRpbChjaCA9PiBpc0VtcHR5KGNoKSB8fCBjaCA9PT0gJyMnKTtcbiAgICB9XG4gICAgKnBhcnNlQmxvY2tTY2FsYXIoKSB7XG4gICAgICAgIGxldCBubCA9IHRoaXMucG9zIC0gMTsgLy8gbWF5IGJlIC0xIGlmIHRoaXMucG9zID09PSAwXG4gICAgICAgIGxldCBpbmRlbnQgPSAwO1xuICAgICAgICBsZXQgY2g7XG4gICAgICAgIGxvb3A6IGZvciAobGV0IGkgPSB0aGlzLnBvczsgKGNoID0gdGhpcy5idWZmZXJbaV0pOyArK2kpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgICAgICAgICAgICAgIG5sID0gaTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnXFxyJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5idWZmZXJbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHQgJiYgIXRoaXMuYXRFbmQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdibG9jay1zY2FsYXInKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09ICdcXG4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSAvLyBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaCAmJiAhdGhpcy5hdEVuZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ2Jsb2NrLXNjYWxhcicpO1xuICAgICAgICBpZiAoaW5kZW50ID49IHRoaXMuaW5kZW50TmV4dCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYmxvY2tTY2FsYXJJbmRlbnQgPT09IC0xKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50TmV4dCA9IGluZGVudDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudE5leHQgKz0gdGhpcy5ibG9ja1NjYWxhckluZGVudDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjcyA9IHRoaXMuY29udGludWVTY2FsYXIobmwgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAoY3MgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBubCA9IHRoaXMuYnVmZmVyLmluZGV4T2YoJ1xcbicsIGNzKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKG5sICE9PSAtMSk7XG4gICAgICAgICAgICBpZiAobmwgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdibG9jay1zY2FsYXInKTtcbiAgICAgICAgICAgICAgICBubCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuYmxvY2tTY2FsYXJLZWVwKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSBubCAtIDE7XG4gICAgICAgICAgICAgICAgbGV0IGNoID0gdGhpcy5idWZmZXJbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJylcbiAgICAgICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclstLWldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RDaGFyID0gaTsgLy8gRHJvcCB0aGUgbGluZSBpZiBsYXN0IGNoYXIgbm90IG1vcmUgaW5kZW50ZWRcbiAgICAgICAgICAgICAgICB3aGlsZSAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpXG4gICAgICAgICAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbLS1pXTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXG4nICYmIGkgPj0gdGhpcy5wb3MgJiYgaSArIDEgKyBpbmRlbnQgPiBsYXN0Q2hhcilcbiAgICAgICAgICAgICAgICAgICAgbmwgPSBpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBTQ0FMQVI7XG4gICAgICAgIHlpZWxkKiB0aGlzLnB1c2hUb0luZGV4KG5sICsgMSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUxpbmVTdGFydCgpO1xuICAgIH1cbiAgICAqcGFyc2VQbGFpblNjYWxhcigpIHtcbiAgICAgICAgY29uc3QgaW5GbG93ID0gdGhpcy5mbG93TGV2ZWwgPiAwO1xuICAgICAgICBsZXQgZW5kID0gdGhpcy5wb3MgLSAxO1xuICAgICAgICBsZXQgaSA9IHRoaXMucG9zIC0gMTtcbiAgICAgICAgbGV0IGNoO1xuICAgICAgICB3aGlsZSAoKGNoID0gdGhpcy5idWZmZXJbKytpXSkpIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJzonKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuYnVmZmVyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShuZXh0KSB8fCAoaW5GbG93ICYmIG5leHQgPT09ICcsJykpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0VtcHR5KGNoKSkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5idWZmZXJbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHRoaXMuYnVmZmVyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gJyMnIHx8IChpbkZsb3cgJiYgaW52YWxpZEZsb3dTY2FsYXJDaGFycy5pbmNsdWRlcyhuZXh0KSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3MgPSB0aGlzLmNvbnRpbnVlU2NhbGFyKGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNzID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpID0gTWF0aC5tYXgoaSwgY3MgLSAyKTsgLy8gdG8gYWR2YW5jZSwgYnV0IHN0aWxsIGFjY291bnQgZm9yICcgIydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5GbG93ICYmIGludmFsaWRGbG93U2NhbGFyQ2hhcnMuaW5jbHVkZXMoY2gpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY2ggJiYgIXRoaXMuYXRFbmQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdwbGFpbi1zY2FsYXInKTtcbiAgICAgICAgeWllbGQgU0NBTEFSO1xuICAgICAgICB5aWVsZCogdGhpcy5wdXNoVG9JbmRleChlbmQgKyAxLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGluRmxvdyA/ICdmbG93JyA6ICdkb2MnO1xuICAgIH1cbiAgICAqcHVzaENvdW50KG4pIHtcbiAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmJ1ZmZlci5zdWJzdHIodGhpcy5wb3MsIG4pO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gbjtcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAqcHVzaFRvSW5kZXgoaSwgYWxsb3dFbXB0eSkge1xuICAgICAgICBjb25zdCBzID0gdGhpcy5idWZmZXIuc2xpY2UodGhpcy5wb3MsIGkpO1xuICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgeWllbGQgcztcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHMubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFsbG93RW1wdHkpXG4gICAgICAgICAgICB5aWVsZCAnJztcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgICpwdXNoSW5kaWNhdG9ycygpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoeWllbGQqIHRoaXMucHVzaFRhZygpKSArXG4gICAgICAgICAgICAgICAgICAgICh5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpKSArXG4gICAgICAgICAgICAgICAgICAgICh5aWVsZCogdGhpcy5wdXNoSW5kaWNhdG9ycygpKSk7XG4gICAgICAgICAgICBjYXNlICcmJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKCh5aWVsZCogdGhpcy5wdXNoVW50aWwoaXNOb3RBbmNob3JDaGFyKSkgK1xuICAgICAgICAgICAgICAgICAgICAoeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKSkgK1xuICAgICAgICAgICAgICAgICAgICAoeWllbGQqIHRoaXMucHVzaEluZGljYXRvcnMoKSkpO1xuICAgICAgICAgICAgY2FzZSAnLSc6IC8vIHRoaXMgaXMgYW4gZXJyb3JcbiAgICAgICAgICAgIGNhc2UgJz8nOiAvLyB0aGlzIGlzIGFuIGVycm9yIG91dHNpZGUgZmxvdyBjb2xsZWN0aW9uc1xuICAgICAgICAgICAgY2FzZSAnOic6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbkZsb3cgPSB0aGlzLmZsb3dMZXZlbCA+IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgY2gxID0gdGhpcy5jaGFyQXQoMSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkoY2gxKSB8fCAoaW5GbG93ICYmIGludmFsaWRGbG93U2NhbGFyQ2hhcnMuaW5jbHVkZXMoY2gxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbkZsb3cpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPSB0aGlzLmluZGVudFZhbHVlICsgMTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5mbG93S2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mbG93S2V5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICh5aWVsZCogdGhpcy5wdXNoSW5kaWNhdG9ycygpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAqcHVzaFRhZygpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hhckF0KDEpID09PSAnPCcpIHtcbiAgICAgICAgICAgIGxldCBpID0gdGhpcy5wb3MgKyAyO1xuICAgICAgICAgICAgbGV0IGNoID0gdGhpcy5idWZmZXJbaV07XG4gICAgICAgICAgICB3aGlsZSAoIWlzRW1wdHkoY2gpICYmIGNoICE9PSAnPicpXG4gICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnB1c2hUb0luZGV4KGNoID09PSAnPicgPyBpICsgMSA6IGksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBpID0gdGhpcy5wb3MgKyAxO1xuICAgICAgICAgICAgbGV0IGNoID0gdGhpcy5idWZmZXJbaV07XG4gICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFnQ2hhcnMuaW5jbHVkZXMoY2gpKVxuICAgICAgICAgICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWysraV07XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICclJyAmJlxuICAgICAgICAgICAgICAgICAgICBoZXhEaWdpdHMuaW5jbHVkZXModGhpcy5idWZmZXJbaSArIDFdKSAmJlxuICAgICAgICAgICAgICAgICAgICBoZXhEaWdpdHMuaW5jbHVkZXModGhpcy5idWZmZXJbaSArIDJdKSkge1xuICAgICAgICAgICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWyhpICs9IDMpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wdXNoVG9JbmRleChpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKnB1c2hOZXdsaW5lKCkge1xuICAgICAgICBjb25zdCBjaCA9IHRoaXMuYnVmZmVyW3RoaXMucG9zXTtcbiAgICAgICAgaWYgKGNoID09PSAnXFxuJylcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnXFxyJyAmJiB0aGlzLmNoYXJBdCgxKSA9PT0gJ1xcbicpXG4gICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucHVzaENvdW50KDIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgKnB1c2hTcGFjZXMoYWxsb3dUYWJzKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5wb3MgLSAxO1xuICAgICAgICBsZXQgY2g7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKytpXTtcbiAgICAgICAgfSB3aGlsZSAoY2ggPT09ICcgJyB8fCAoYWxsb3dUYWJzICYmIGNoID09PSAnXFx0JykpO1xuICAgICAgICBjb25zdCBuID0gaSAtIHRoaXMucG9zO1xuICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuYnVmZmVyLnN1YnN0cih0aGlzLnBvcywgbik7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgICpwdXNoVW50aWwodGVzdCkge1xuICAgICAgICBsZXQgaSA9IHRoaXMucG9zO1xuICAgICAgICBsZXQgY2ggPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgd2hpbGUgKCF0ZXN0KGNoKSlcbiAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKytpXTtcbiAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnB1c2hUb0luZGV4KGksIGZhbHNlKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IExleGVyIH07XG4iLCAiLyoqXG4gKiBUcmFja3MgbmV3bGluZXMgZHVyaW5nIHBhcnNpbmcgaW4gb3JkZXIgdG8gcHJvdmlkZSBhbiBlZmZpY2llbnQgQVBJIGZvclxuICogZGV0ZXJtaW5pbmcgdGhlIG9uZS1pbmRleGVkIGB7IGxpbmUsIGNvbCB9YCBwb3NpdGlvbiBmb3IgYW55IG9mZnNldFxuICogd2l0aGluIHRoZSBpbnB1dC5cbiAqL1xuY2xhc3MgTGluZUNvdW50ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmxpbmVTdGFydHMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3VsZCBiZSBjYWxsZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsIGNhbGxcbiAgICAgICAgICogYGxpbmVDb3VudGVyLmxpbmVTdGFydHMuc29ydCgpYCBiZWZvcmUgY2FsbGluZyBgbGluZVBvcygpYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWRkTmV3TGluZSA9IChvZmZzZXQpID0+IHRoaXMubGluZVN0YXJ0cy5wdXNoKG9mZnNldCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggYW5kIHJldHVybnMgdGhlIDEtaW5kZXhlZCB7IGxpbmUsIGNvbCB9XG4gICAgICAgICAqIHBvc2l0aW9uIG9mIGBvZmZzZXRgLiBJZiBgbGluZSA9PT0gMGAsIGBhZGROZXdMaW5lYCBoYXMgbmV2ZXIgYmVlblxuICAgICAgICAgKiBjYWxsZWQgb3IgYG9mZnNldGAgaXMgYmVmb3JlIHRoZSBmaXJzdCBrbm93biBuZXdsaW5lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lUG9zID0gKG9mZnNldCkgPT4ge1xuICAgICAgICAgICAgbGV0IGxvdyA9IDA7XG4gICAgICAgICAgICBsZXQgaGlnaCA9IHRoaXMubGluZVN0YXJ0cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxOyAvLyBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0c1ttaWRdIDwgb2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmVTdGFydHNbbG93XSA9PT0gb2Zmc2V0KVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmU6IGxvdyArIDEsIGNvbDogMSB9O1xuICAgICAgICAgICAgaWYgKGxvdyA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5lOiAwLCBjb2w6IG9mZnNldCB9O1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmxpbmVTdGFydHNbbG93IC0gMV07XG4gICAgICAgICAgICByZXR1cm4geyBsaW5lOiBsb3csIGNvbDogb2Zmc2V0IC0gc3RhcnQgKyAxIH07XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgeyBMaW5lQ291bnRlciB9O1xuIiwgImltcG9ydCB7IHRva2VuVHlwZSB9IGZyb20gJy4vY3N0LmpzJztcbmltcG9ydCB7IExleGVyIH0gZnJvbSAnLi9sZXhlci5qcyc7XG5cbmZ1bmN0aW9uIGluY2x1ZGVzVG9rZW4obGlzdCwgdHlwZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKGxpc3RbaV0udHlwZSA9PT0gdHlwZSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGZpbmROb25FbXB0eUluZGV4KGxpc3QpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgc3dpdGNoIChsaXN0W2ldLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGlzRmxvd1Rva2VuKHRva2VuKSB7XG4gICAgc3dpdGNoICh0b2tlbj8udHlwZSkge1xuICAgICAgICBjYXNlICdhbGlhcyc6XG4gICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICBjYXNlICdmbG93LWNvbGxlY3Rpb24nOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0UHJldlByb3BzKHBhcmVudCkge1xuICAgIHN3aXRjaCAocGFyZW50LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnZG9jdW1lbnQnOlxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5zdGFydDtcbiAgICAgICAgY2FzZSAnYmxvY2stbWFwJzoge1xuICAgICAgICAgICAgY29uc3QgaXQgPSBwYXJlbnQuaXRlbXNbcGFyZW50Lml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgcmV0dXJuIGl0LnNlcCA/PyBpdC5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdibG9jay1zZXEnOlxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5pdGVtc1twYXJlbnQuaXRlbXMubGVuZ3RoIC0gMV0uc3RhcnQ7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuLyoqIE5vdGU6IE1heSBtb2RpZnkgaW5wdXQgYXJyYXkgKi9cbmZ1bmN0aW9uIGdldEZpcnN0S2V5U3RhcnRQcm9wcyhwcmV2KSB7XG4gICAgaWYgKHByZXYubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IGkgPSBwcmV2Lmxlbmd0aDtcbiAgICBsb29wOiB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgc3dpdGNoIChwcmV2W2ldLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RvYy1zdGFydCc6XG4gICAgICAgICAgICBjYXNlICdleHBsaWNpdC1rZXktaW5kJzpcbiAgICAgICAgICAgIGNhc2UgJ21hcC12YWx1ZS1pbmQnOlxuICAgICAgICAgICAgY2FzZSAnc2VxLWl0ZW0taW5kJzpcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKHByZXZbKytpXT8udHlwZSA9PT0gJ3NwYWNlJykge1xuICAgICAgICAvKiBsb29wICovXG4gICAgfVxuICAgIHJldHVybiBwcmV2LnNwbGljZShpLCBwcmV2Lmxlbmd0aCk7XG59XG5mdW5jdGlvbiBmaXhGbG93U2VxSXRlbXMoZmMpIHtcbiAgICBpZiAoZmMuc3RhcnQudHlwZSA9PT0gJ2Zsb3ctc2VxLXN0YXJ0Jykge1xuICAgICAgICBmb3IgKGNvbnN0IGl0IG9mIGZjLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaXQuc2VwICYmXG4gICAgICAgICAgICAgICAgIWl0LnZhbHVlICYmXG4gICAgICAgICAgICAgICAgIWluY2x1ZGVzVG9rZW4oaXQuc3RhcnQsICdleHBsaWNpdC1rZXktaW5kJykgJiZcbiAgICAgICAgICAgICAgICAhaW5jbHVkZXNUb2tlbihpdC5zZXAsICdtYXAtdmFsdWUtaW5kJykpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXQua2V5KVxuICAgICAgICAgICAgICAgICAgICBpdC52YWx1ZSA9IGl0LmtleTtcbiAgICAgICAgICAgICAgICBkZWxldGUgaXQua2V5O1xuICAgICAgICAgICAgICAgIGlmIChpc0Zsb3dUb2tlbihpdC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0LnZhbHVlLmVuZClcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGl0LnZhbHVlLmVuZCwgaXQuc2VwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQudmFsdWUuZW5kID0gaXQuc2VwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGl0LnN0YXJ0LCBpdC5zZXApO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpdC5zZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEEgWUFNTCBjb25jcmV0ZSBzeW50YXggdHJlZSAoQ1NUKSBwYXJzZXJcbiAqXG4gKiBgYGB0c1xuICogY29uc3Qgc3JjOiBzdHJpbmcgPSAuLi5cbiAqIGZvciAoY29uc3QgdG9rZW4gb2YgbmV3IFBhcnNlcigpLnBhcnNlKHNyYykpIHtcbiAqICAgLy8gdG9rZW46IFRva2VuXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBUbyB1c2UgdGhlIHBhcnNlciB3aXRoIGEgdXNlci1wcm92aWRlZCBsZXhlcjpcbiAqXG4gKiBgYGB0c1xuICogZnVuY3Rpb24qIHBhcnNlKHNvdXJjZTogc3RyaW5nLCBsZXhlcjogTGV4ZXIpIHtcbiAqICAgY29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcigpXG4gKiAgIGZvciAoY29uc3QgbGV4ZW1lIG9mIGxleGVyLmxleChzb3VyY2UpKVxuICogICAgIHlpZWxkKiBwYXJzZXIubmV4dChsZXhlbWUpXG4gKiAgIHlpZWxkKiBwYXJzZXIuZW5kKClcbiAqIH1cbiAqXG4gKiBjb25zdCBzcmM6IHN0cmluZyA9IC4uLlxuICogY29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoKVxuICogZm9yIChjb25zdCB0b2tlbiBvZiBwYXJzZShzcmMsIGxleGVyKSkge1xuICogICAvLyB0b2tlbjogVG9rZW5cbiAqIH1cbiAqIGBgYFxuICovXG5jbGFzcyBQYXJzZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbk5ld0xpbmUgLSBJZiBkZWZpbmVkLCBjYWxsZWQgc2VwYXJhdGVseSB3aXRoIHRoZSBzdGFydCBwb3NpdGlvbiBvZlxuICAgICAqICAgZWFjaCBuZXcgbGluZSAoaW4gYHBhcnNlKClgLCBpbmNsdWRpbmcgdGhlIHN0YXJ0IG9mIGlucHV0KS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihvbk5ld0xpbmUpIHtcbiAgICAgICAgLyoqIElmIHRydWUsIHNwYWNlIGFuZCBzZXF1ZW5jZSBpbmRpY2F0b3JzIGNvdW50IGFzIGluZGVudGF0aW9uICovXG4gICAgICAgIHRoaXMuYXROZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgLyoqIElmIHRydWUsIG5leHQgdG9rZW4gaXMgYSBzY2FsYXIgdmFsdWUgKi9cbiAgICAgICAgdGhpcy5hdFNjYWxhciA9IGZhbHNlO1xuICAgICAgICAvKiogQ3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCAqL1xuICAgICAgICB0aGlzLmluZGVudCA9IDA7XG4gICAgICAgIC8qKiBDdXJyZW50IG9mZnNldCBzaW5jZSB0aGUgc3RhcnQgb2YgcGFyc2luZyAqL1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIC8qKiBPbiB0aGUgc2FtZSBsaW5lIHdpdGggYSBibG9jayBtYXAga2V5ICovXG4gICAgICAgIHRoaXMub25LZXlMaW5lID0gZmFsc2U7XG4gICAgICAgIC8qKiBUb3AgaW5kaWNhdGVzIHRoZSBub2RlIHRoYXQncyBjdXJyZW50bHkgYmVpbmcgYnVpbHQgKi9cbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAvKiogVGhlIHNvdXJjZSBvZiB0aGUgY3VycmVudCB0b2tlbiwgc2V0IGluIHBhcnNlKCkgKi9cbiAgICAgICAgdGhpcy5zb3VyY2UgPSAnJztcbiAgICAgICAgLyoqIFRoZSB0eXBlIG9mIHRoZSBjdXJyZW50IHRva2VuLCBzZXQgaW4gcGFyc2UoKSAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnJztcbiAgICAgICAgLy8gTXVzdCBiZSBkZWZpbmVkIGFmdGVyIGBuZXh0KClgXG4gICAgICAgIHRoaXMubGV4ZXIgPSBuZXcgTGV4ZXIoKTtcbiAgICAgICAgdGhpcy5vbk5ld0xpbmUgPSBvbk5ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIGBzb3VyY2VgIGFzIGEgWUFNTCBzdHJlYW0uXG4gICAgICogSWYgYGluY29tcGxldGVgLCBhIHBhcnQgb2YgdGhlIGxhc3QgbGluZSBtYXkgYmUgbGVmdCBhcyBhIGJ1ZmZlciBmb3IgdGhlIG5leHQgY2FsbC5cbiAgICAgKlxuICAgICAqIEVycm9ycyBhcmUgbm90IHRocm93biwgYnV0IHlpZWxkZWQgYXMgYHsgdHlwZTogJ2Vycm9yJywgbWVzc2FnZSB9YCB0b2tlbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIGdlbmVyYXRvciBvZiB0b2tlbnMgcmVwcmVzZW50aW5nIGVhY2ggZGlyZWN0aXZlLCBkb2N1bWVudCwgYW5kIG90aGVyIHN0cnVjdHVyZS5cbiAgICAgKi9cbiAgICAqcGFyc2Uoc291cmNlLCBpbmNvbXBsZXRlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMub25OZXdMaW5lICYmIHRoaXMub2Zmc2V0ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5vbk5ld0xpbmUoMCk7XG4gICAgICAgIGZvciAoY29uc3QgbGV4ZW1lIG9mIHRoaXMubGV4ZXIubGV4KHNvdXJjZSwgaW5jb21wbGV0ZSkpXG4gICAgICAgICAgICB5aWVsZCogdGhpcy5uZXh0KGxleGVtZSk7XG4gICAgICAgIGlmICghaW5jb21wbGV0ZSlcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLmVuZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZHZhbmNlIHRoZSBwYXJzZXIgYnkgdGhlIGBzb3VyY2VgIG9mIG9uZSBsZXhpY2FsIHRva2VuLlxuICAgICAqL1xuICAgICpuZXh0KHNvdXJjZSkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgaWYgKHRoaXMuYXRTY2FsYXIpIHtcbiAgICAgICAgICAgIHRoaXMuYXRTY2FsYXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZSA9IHRva2VuVHlwZShzb3VyY2UpO1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgTm90IGEgWUFNTCB0b2tlbjogJHtzb3VyY2V9YDtcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCh7IHR5cGU6ICdlcnJvcicsIG9mZnNldDogdGhpcy5vZmZzZXQsIG1lc3NhZ2UsIHNvdXJjZSB9KTtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3NjYWxhcicpIHtcbiAgICAgICAgICAgIHRoaXMuYXROZXdMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmF0U2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9ICdzY2FsYXInO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0TmV3TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub25OZXdMaW5lKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk5ld0xpbmUodGhpcy5vZmZzZXQgKyBzb3VyY2UubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdE5ld0xpbmUgJiYgc291cmNlWzBdID09PSAnICcpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGVudCArPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdleHBsaWNpdC1rZXktaW5kJzpcbiAgICAgICAgICAgICAgICBjYXNlICdtYXAtdmFsdWUtaW5kJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzZXEtaXRlbS1pbmQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdE5ld0xpbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGVudCArPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkb2MtbW9kZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZmxvdy1lcnJvci1lbmQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdE5ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIENhbGwgYXQgZW5kIG9mIGlucHV0IHRvIHB1c2ggb3V0IGFueSByZW1haW5pbmcgY29uc3RydWN0aW9ucyAqL1xuICAgICplbmQoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IDApXG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICB9XG4gICAgZ2V0IHNvdXJjZVRva2VuKCkge1xuICAgICAgICBjb25zdCBzdCA9IHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3Q7XG4gICAgfVxuICAgICpzdGVwKCkge1xuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoMSk7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdkb2MtZW5kJyAmJiAoIXRvcCB8fCB0b3AudHlwZSAhPT0gJ2RvYy1lbmQnKSkge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2RvYy1lbmQnLFxuICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0b3ApXG4gICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuc3RyZWFtKCk7XG4gICAgICAgIHN3aXRjaCAodG9wLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RvY3VtZW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuZG9jdW1lbnQodG9wKTtcbiAgICAgICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnNjYWxhcih0b3ApO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stc2NhbGFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuYmxvY2tTY2FsYXIodG9wKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLW1hcCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmJsb2NrTWFwKHRvcCk7XG4gICAgICAgICAgICBjYXNlICdibG9jay1zZXEnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5ibG9ja1NlcXVlbmNlKHRvcCk7XG4gICAgICAgICAgICBjYXNlICdmbG93LWNvbGxlY3Rpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5mbG93Q29sbGVjdGlvbih0b3ApO1xuICAgICAgICAgICAgY2FzZSAnZG9jLWVuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmRvY3VtZW50RW5kKHRvcCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgfVxuICAgIHBlZWsobikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIG5dO1xuICAgIH1cbiAgICAqcG9wKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gZXJyb3IgPz8gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmIHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnVHJpZWQgdG8gcG9wIGFuIGVtcHR5IHN0YWNrJztcbiAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogJ2Vycm9yJywgb2Zmc2V0OiB0aGlzLm9mZnNldCwgc291cmNlOiAnJywgbWVzc2FnZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB5aWVsZCB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygxKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnYmxvY2stc2NhbGFyJykge1xuICAgICAgICAgICAgICAgIC8vIEJsb2NrIHNjYWxhcnMgdXNlIHRoZWlyIHBhcmVudCByYXRoZXIgdGhhbiBoZWFkZXIgaW5kZW50XG4gICAgICAgICAgICAgICAgdG9rZW4uaW5kZW50ID0gJ2luZGVudCcgaW4gdG9wID8gdG9wLmluZGVudCA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSAnZmxvdy1jb2xsZWN0aW9uJyAmJiB0b3AudHlwZSA9PT0gJ2RvY3VtZW50Jykge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBhbGwgaW5kZW50IGZvciB0b3AtbGV2ZWwgZmxvdyBjb2xsZWN0aW9uc1xuICAgICAgICAgICAgICAgIHRva2VuLmluZGVudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2Zsb3ctY29sbGVjdGlvbicpXG4gICAgICAgICAgICAgICAgZml4Rmxvd1NlcUl0ZW1zKHRva2VuKTtcbiAgICAgICAgICAgIHN3aXRjaCAodG9wLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdkb2N1bWVudCc6XG4gICAgICAgICAgICAgICAgICAgIHRvcC52YWx1ZSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOlxuICAgICAgICAgICAgICAgICAgICB0b3AucHJvcHMucHVzaCh0b2tlbik7IC8vIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLW1hcCc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXQgPSB0b3AuaXRlbXNbdG9wLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdLCBrZXk6IHRva2VuLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnNlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQudmFsdWUgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXQsIHsga2V5OiB0b2tlbiwgc2VwOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gIWluY2x1ZGVzVG9rZW4oaXQuc3RhcnQsICdleHBsaWNpdC1rZXktaW5kJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNlcSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXQgPSB0b3AuaXRlbXNbdG9wLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AuaXRlbXMucHVzaCh7IHN0YXJ0OiBbXSwgdmFsdWU6IHRva2VuIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC52YWx1ZSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZmxvdy1jb2xsZWN0aW9uJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdCA9IHRvcC5pdGVtc1t0b3AuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXQgfHwgaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AuaXRlbXMucHVzaCh7IHN0YXJ0OiBbXSwga2V5OiB0b2tlbiwgc2VwOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQudmFsdWUgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdCwgeyBrZXk6IHRva2VuLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRvcC50eXBlID09PSAnZG9jdW1lbnQnIHx8XG4gICAgICAgICAgICAgICAgdG9wLnR5cGUgPT09ICdibG9jay1tYXAnIHx8XG4gICAgICAgICAgICAgICAgdG9wLnR5cGUgPT09ICdibG9jay1zZXEnKSAmJlxuICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSAnYmxvY2stbWFwJyB8fCB0b2tlbi50eXBlID09PSAnYmxvY2stc2VxJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gdG9rZW4uaXRlbXNbdG9rZW4uaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgJiZcbiAgICAgICAgICAgICAgICAgICAgIWxhc3Quc2VwICYmXG4gICAgICAgICAgICAgICAgICAgICFsYXN0LnZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgIGxhc3Quc3RhcnQubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmaW5kTm9uRW1wdHlJbmRleChsYXN0LnN0YXJ0KSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgKHRva2VuLmluZGVudCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdC5zdGFydC5ldmVyeShzdCA9PiBzdC50eXBlICE9PSAnY29tbWVudCcgfHwgc3QuaW5kZW50IDwgdG9rZW4uaW5kZW50KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcC50eXBlID09PSAnZG9jdW1lbnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLmVuZCA9IGxhc3Quc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IGxhc3Quc3RhcnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuLml0ZW1zLnNwbGljZSgtMSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgICpzdHJlYW0oKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdkaXJlY3RpdmUtbGluZSc6XG4gICAgICAgICAgICAgICAgeWllbGQgeyB0eXBlOiAnZGlyZWN0aXZlJywgb2Zmc2V0OiB0aGlzLm9mZnNldCwgc291cmNlOiB0aGlzLnNvdXJjZSB9O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ2J5dGUtb3JkZXItbWFyayc6XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuc291cmNlVG9rZW47XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnZG9jLW1vZGUnOlxuICAgICAgICAgICAgY2FzZSAnZG9jLXN0YXJ0Jzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvYyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RvY3VtZW50JyxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnZG9jLXN0YXJ0JylcbiAgICAgICAgICAgICAgICAgICAgZG9jLnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGRvYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgbWVzc2FnZTogYFVuZXhwZWN0ZWQgJHt0aGlzLnR5cGV9IHRva2VuIGluIFlBTUwgc3RyZWFtYCxcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgKmRvY3VtZW50KGRvYykge1xuICAgICAgICBpZiAoZG9jLnZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmxpbmVFbmQoZG9jKTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RvYy1zdGFydCc6IHtcbiAgICAgICAgICAgICAgICBpZiAoZmluZE5vbkVtcHR5SW5kZXgoZG9jLnN0YXJ0KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkb2Muc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdhbmNob3InOlxuICAgICAgICAgICAgY2FzZSAndGFnJzpcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgZG9jLnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ2ID0gdGhpcy5zdGFydEJsb2NrVmFsdWUoZG9jKTtcbiAgICAgICAgaWYgKGJ2KVxuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ2KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBVbmV4cGVjdGVkICR7dGhpcy50eXBlfSB0b2tlbiBpbiBZQU1MIGRvY3VtZW50YCxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgICpzY2FsYXIoc2NhbGFyKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdtYXAtdmFsdWUtaW5kJykge1xuICAgICAgICAgICAgY29uc3QgcHJldiA9IGdldFByZXZQcm9wcyh0aGlzLnBlZWsoMikpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBnZXRGaXJzdEtleVN0YXJ0UHJvcHMocHJldik7XG4gICAgICAgICAgICBsZXQgc2VwO1xuICAgICAgICAgICAgaWYgKHNjYWxhci5lbmQpIHtcbiAgICAgICAgICAgICAgICBzZXAgPSBzY2FsYXIuZW5kO1xuICAgICAgICAgICAgICAgIHNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2FsYXIuZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlcCA9IFt0aGlzLnNvdXJjZVRva2VuXTtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHNjYWxhci5vZmZzZXQsXG4gICAgICAgICAgICAgICAgaW5kZW50OiBzY2FsYXIuaW5kZW50LFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydCwga2V5OiBzY2FsYXIsIHNlcCB9XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSA9IG1hcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB5aWVsZCogdGhpcy5saW5lRW5kKHNjYWxhcik7XG4gICAgfVxuICAgICpibG9ja1NjYWxhcihzY2FsYXIpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgc2NhbGFyLnByb3BzLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgICAgICBzY2FsYXIuc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgICAgICAgICAgICAgLy8gYmxvY2stc2NhbGFyIHNvdXJjZSBpbmNsdWRlcyB0cmFpbGluZyBuZXdsaW5lXG4gICAgICAgICAgICAgICAgdGhpcy5hdE5ld0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbk5ld0xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5sID0gdGhpcy5zb3VyY2UuaW5kZXhPZignXFxuJykgKyAxO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobmwgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25OZXdMaW5lKHRoaXMub2Zmc2V0ICsgbmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmwgPSB0aGlzLnNvdXJjZS5pbmRleE9mKCdcXG4nLCBubCkgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgICpibG9ja01hcChtYXApIHtcbiAgICAgICAgY29uc3QgaXQgPSBtYXAuaXRlbXNbbWFwLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAvLyBpdC5zZXAgaXMgdHJ1ZS1pc2ggaWYgcGFpciBhbHJlYWR5IGhhcyBrZXkgb3IgOiBzZXBhcmF0b3JcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGl0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9ICdlbmQnIGluIGl0LnZhbHVlID8gaXQudmFsdWUuZW5kIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gQXJyYXkuaXNBcnJheShlbmQpID8gZW5kW2VuZC5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3Q/LnR5cGUgPT09ICdjb21tZW50JylcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZD8ucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApIHtcbiAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApIHtcbiAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdEluZGVudGVkQ29tbWVudChpdC5zdGFydCwgbWFwLmluZGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBtYXAuaXRlbXNbbWFwLml0ZW1zLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gcHJldj8udmFsdWU/LmVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbmQsIGl0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmRlbnQgPj0gbWFwLmluZGVudCkge1xuICAgICAgICAgICAgY29uc3QgYXROZXh0SXRlbSA9ICF0aGlzLm9uS2V5TGluZSAmJiB0aGlzLmluZGVudCA9PT0gbWFwLmluZGVudCAmJiBpdC5zZXA7XG4gICAgICAgICAgICAvLyBGb3IgZW1wdHkgbm9kZXMsIGFzc2lnbiBuZXdsaW5lLXNlcGFyYXRlZCBub3QgaW5kZW50ZWQgZW1wdHkgdG9rZW5zIHRvIGZvbGxvd2luZyBub2RlXG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBbXTtcbiAgICAgICAgICAgIGlmIChhdE5leHRJdGVtICYmIGl0LnNlcCAmJiAhaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBubCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXQuc2VwLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0ID0gaXQuc2VwW2ldO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5sLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3QuaW5kZW50ID4gbWFwLmluZGVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmwubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmwubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmwubGVuZ3RoID49IDIpXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaXQuc2VwLnNwbGljZShubFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FuY2hvcic6XG4gICAgICAgICAgICAgICAgY2FzZSAndGFnJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0TmV4dEl0ZW0gfHwgaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaCh7IHN0YXJ0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnNlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlICdleHBsaWNpdC1rZXktaW5kJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdC5zZXAgJiYgIWluY2x1ZGVzVG9rZW4oaXQuc3RhcnQsICdleHBsaWNpdC1rZXktaW5kJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXROZXh0SXRlbSB8fCBpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHsgc3RhcnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnbWFwLXZhbHVlLWluZCc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlc1Rva2VuKGl0LnN0YXJ0LCAnZXhwbGljaXQta2V5LWluZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWl0LnNlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlc1Rva2VuKGl0LnN0YXJ0LCAnbmV3bGluZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXQsIHsga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Rmlyc3RLZXlTdGFydFByb3BzKGl0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQsIGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaCh7IHN0YXJ0OiBbXSwga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluY2x1ZGVzVG9rZW4oaXQuc2VwLCAnbWFwLXZhbHVlLWluZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLW1hcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydCwga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNGbG93VG9rZW4oaXQua2V5KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpbmNsdWRlc1Rva2VuKGl0LnNlcCwgJ25ld2xpbmUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Rmlyc3RLZXlTdGFydFByb3BzKGl0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBpdC5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VwID0gaXQuc2VwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdHlwZSBndWFyZCBpcyB3cm9uZyBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGl0LmtleSwgZGVsZXRlIGl0LnNlcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0LCBrZXksIHNlcCB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBhY3R1YWxseSBhdCBuZXh0IGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdC5zZXAgPSBpdC5zZXAuY29uY2F0KHN0YXJ0LCB0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0LnNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpdC5zZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0LCB7IGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC52YWx1ZSB8fCBhdE5leHRJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydCwga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluY2x1ZGVzVG9rZW4oaXQuc2VwLCAnbWFwLXZhbHVlLWluZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLW1hcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydDogW10sIGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0LnNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnMgPSB0aGlzLmZsb3dTY2FsYXIodGhpcy50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0TmV4dEl0ZW0gfHwgaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHsgc3RhcnQsIGtleTogZnMsIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goZnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdCwgeyBrZXk6IGZzLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBidiA9IHRoaXMuc3RhcnRCbG9ja1ZhbHVlKG1hcCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChidikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0TmV4dEl0ZW0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidi50eXBlICE9PSAnYmxvY2stc2VxJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGVzVG9rZW4oaXQuc3RhcnQsICdleHBsaWNpdC1rZXktaW5kJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaCh7IHN0YXJ0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgIH1cbiAgICAqYmxvY2tTZXF1ZW5jZShzZXEpIHtcbiAgICAgICAgY29uc3QgaXQgPSBzZXEuaXRlbXNbc2VxLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgaWYgKGl0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9ICdlbmQnIGluIGl0LnZhbHVlID8gaXQudmFsdWUuZW5kIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gQXJyYXkuaXNBcnJheShlbmQpID8gZW5kW2VuZC5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3Q/LnR5cGUgPT09ICdjb21tZW50JylcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZD8ucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICAgICAgaWYgKGl0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBzZXEuaXRlbXMucHVzaCh7IHN0YXJ0OiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0SW5kZW50ZWRDb21tZW50KGl0LnN0YXJ0LCBzZXEuaW5kZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IHNlcS5pdGVtc1tzZXEuaXRlbXMubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBwcmV2Py52YWx1ZT8uZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGVuZCwgaXQuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcS5pdGVtcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnYW5jaG9yJzpcbiAgICAgICAgICAgIGNhc2UgJ3RhZyc6XG4gICAgICAgICAgICAgICAgaWYgKGl0LnZhbHVlIHx8IHRoaXMuaW5kZW50IDw9IHNlcS5pbmRlbnQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnc2VxLWl0ZW0taW5kJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRlbnQgIT09IHNlcS5pbmRlbnQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSB8fCBpbmNsdWRlc1Rva2VuKGl0LnN0YXJ0LCAnc2VxLWl0ZW0taW5kJykpXG4gICAgICAgICAgICAgICAgICAgIHNlcS5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluZGVudCA+IHNlcS5pbmRlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ2ID0gdGhpcy5zdGFydEJsb2NrVmFsdWUoc2VxKTtcbiAgICAgICAgICAgIGlmIChidikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgfVxuICAgICpmbG93Q29sbGVjdGlvbihmYykge1xuICAgICAgICBjb25zdCBpdCA9IGZjLml0ZW1zW2ZjLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnZmxvdy1lcnJvci1lbmQnKSB7XG4gICAgICAgICAgICBsZXQgdG9wO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRvcCA9IHRoaXMucGVlaygxKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRvcCAmJiB0b3AudHlwZSA9PT0gJ2Zsb3ctY29sbGVjdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZjLmVuZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tbWEnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2V4cGxpY2l0LWtleS1pbmQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0IHx8IGl0LnNlcClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnbWFwLXZhbHVlLWluZCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXQgfHwgaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBmYy5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdLCBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdCwgeyBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2FuY2hvcic6XG4gICAgICAgICAgICAgICAgY2FzZSAndGFnJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdCB8fCBpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnMgPSB0aGlzLmZsb3dTY2FsYXIodGhpcy50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdCB8fCBpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjLml0ZW1zLnB1c2goeyBzdGFydDogW10sIGtleTogZnMsIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnNlcClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChmcyk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXQsIHsga2V5OiBmcywgc2VwOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdmbG93LW1hcC1lbmQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Zsb3ctc2VxLWVuZCc6XG4gICAgICAgICAgICAgICAgICAgIGZjLmVuZC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBidiA9IHRoaXMuc3RhcnRCbG9ja1ZhbHVlKGZjKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlIHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgICAgICBpZiAoYnYpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ2KTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGVlaygyKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gJ2Jsb2NrLW1hcCcgJiZcbiAgICAgICAgICAgICAgICAoKHRoaXMudHlwZSA9PT0gJ21hcC12YWx1ZS1pbmQnICYmIHBhcmVudC5pbmRlbnQgPT09IGZjLmluZGVudCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMudHlwZSA9PT0gJ25ld2xpbmUnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhcGFyZW50Lml0ZW1zW3BhcmVudC5pdGVtcy5sZW5ndGggLSAxXS5zZXApKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ21hcC12YWx1ZS1pbmQnICYmXG4gICAgICAgICAgICAgICAgcGFyZW50LnR5cGUgIT09ICdmbG93LWNvbGxlY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IGdldFByZXZQcm9wcyhwYXJlbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Rmlyc3RLZXlTdGFydFByb3BzKHByZXYpO1xuICAgICAgICAgICAgICAgIGZpeEZsb3dTZXFJdGVtcyhmYyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VwID0gZmMuZW5kLnNwbGljZSgxLCBmYy5lbmQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBzZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXAgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGZjLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50OiBmYy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydCwga2V5OiBmYywgc2VwIH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdID0gbWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMubGluZUVuZChmYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmxvd1NjYWxhcih0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLm9uTmV3TGluZSkge1xuICAgICAgICAgICAgbGV0IG5sID0gdGhpcy5zb3VyY2UuaW5kZXhPZignXFxuJykgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKG5sICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk5ld0xpbmUodGhpcy5vZmZzZXQgKyBubCk7XG4gICAgICAgICAgICAgICAgbmwgPSB0aGlzLnNvdXJjZS5pbmRleE9mKCdcXG4nLCBubCkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXJ0QmxvY2tWYWx1ZShwYXJlbnQpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1NjYWxhcih0aGlzLnR5cGUpO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stc2NhbGFyLWhlYWRlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLXNjYWxhcicsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiBbdGhpcy5zb3VyY2VUb2tlbl0sXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJydcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnZmxvdy1tYXAtc3RhcnQnOlxuICAgICAgICAgICAgY2FzZSAnZmxvdy1zZXEtc3RhcnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmbG93LWNvbGxlY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5zb3VyY2VUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ3NlcS1pdGVtLWluZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLXNlcScsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2V4cGxpY2l0LWtleS1pbmQnOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBnZXRQcmV2UHJvcHMocGFyZW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGdldEZpcnN0S2V5U3RhcnRQcm9wcyhwcmV2KTtcbiAgICAgICAgICAgICAgICBzdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQgfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbWFwLXZhbHVlLWluZCc6IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IGdldFByZXZQcm9wcyhwYXJlbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Rmlyc3RLZXlTdGFydFByb3BzKHByZXYpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQsIGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhdEluZGVudGVkQ29tbWVudChzdGFydCwgaW5kZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICdjb21tZW50JylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaW5kZW50IDw9IGluZGVudClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0LmV2ZXJ5KHN0ID0+IHN0LnR5cGUgPT09ICduZXdsaW5lJyB8fCBzdC50eXBlID09PSAnc3BhY2UnKTtcbiAgICB9XG4gICAgKmRvY3VtZW50RW5kKGRvY0VuZCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAnZG9jLW1vZGUnKSB7XG4gICAgICAgICAgICBpZiAoZG9jRW5kLmVuZClcbiAgICAgICAgICAgICAgICBkb2NFbmQuZW5kLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZG9jRW5kLmVuZCA9IFt0aGlzLnNvdXJjZVRva2VuXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICduZXdsaW5lJylcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqbGluZUVuZCh0b2tlbikge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnY29tbWEnOlxuICAgICAgICAgICAgY2FzZSAnZG9jLXN0YXJ0JzpcbiAgICAgICAgICAgIGNhc2UgJ2RvYy1lbmQnOlxuICAgICAgICAgICAgY2FzZSAnZmxvdy1zZXEtZW5kJzpcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3ctbWFwLWVuZCc6XG4gICAgICAgICAgICBjYXNlICdtYXAtdmFsdWUtaW5kJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBhbGwgb3RoZXIgdmFsdWVzIGFyZSBlcnJvcnNcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4uZW5kKVxuICAgICAgICAgICAgICAgICAgICB0b2tlbi5lbmQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRva2VuLmVuZCA9IFt0aGlzLnNvdXJjZVRva2VuXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnbmV3bGluZScpXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBQYXJzZXIgfTtcbiIsICJpbXBvcnQgeyBDb21wb3NlciB9IGZyb20gJy4vY29tcG9zZS9jb21wb3Nlci5qcyc7XG5pbXBvcnQgeyBEb2N1bWVudCB9IGZyb20gJy4vZG9jL0RvY3VtZW50LmpzJztcbmltcG9ydCB7IHByZXR0aWZ5RXJyb3IsIFlBTUxQYXJzZUVycm9yIH0gZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4vbG9nLmpzJztcbmltcG9ydCB7IExpbmVDb3VudGVyIH0gZnJvbSAnLi9wYXJzZS9saW5lLWNvdW50ZXIuanMnO1xuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSAnLi9wYXJzZS9wYXJzZXIuanMnO1xuXG5mdW5jdGlvbiBwYXJzZU9wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IHByZXR0eUVycm9ycyA9IG9wdGlvbnMucHJldHR5RXJyb3JzICE9PSBmYWxzZTtcbiAgICBjb25zdCBsaW5lQ291bnRlciA9IG9wdGlvbnMubGluZUNvdW50ZXIgfHwgKHByZXR0eUVycm9ycyAmJiBuZXcgTGluZUNvdW50ZXIoKSkgfHwgbnVsbDtcbiAgICByZXR1cm4geyBsaW5lQ291bnRlciwgcHJldHR5RXJyb3JzIH07XG59XG4vKipcbiAqIFBhcnNlIHRoZSBpbnB1dCBhcyBhIHN0cmVhbSBvZiBZQU1MIGRvY3VtZW50cy5cbiAqXG4gKiBEb2N1bWVudHMgc2hvdWxkIGJlIHNlcGFyYXRlZCBmcm9tIGVhY2ggb3RoZXIgYnkgYC4uLmAgb3IgYC0tLWAgbWFya2VyIGxpbmVzLlxuICpcbiAqIEByZXR1cm5zIElmIGFuIGVtcHR5IGBkb2NzYCBhcnJheSBpcyByZXR1cm5lZCwgaXQgd2lsbCBiZSBvZiB0eXBlXG4gKiAgIEVtcHR5U3RyZWFtIGFuZCBjb250YWluIGFkZGl0aW9uYWwgc3RyZWFtIGluZm9ybWF0aW9uLiBJblxuICogICBUeXBlU2NyaXB0LCB5b3Ugc2hvdWxkIHVzZSBgJ2VtcHR5JyBpbiBkb2NzYCBhcyBhIHR5cGUgZ3VhcmQgZm9yIGl0LlxuICovXG5mdW5jdGlvbiBwYXJzZUFsbERvY3VtZW50cyhzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgbGluZUNvdW50ZXIsIHByZXR0eUVycm9ycyB9ID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIobGluZUNvdW50ZXI/LmFkZE5ld0xpbmUpO1xuICAgIGNvbnN0IGNvbXBvc2VyID0gbmV3IENvbXBvc2VyKG9wdGlvbnMpO1xuICAgIGNvbnN0IGRvY3MgPSBBcnJheS5mcm9tKGNvbXBvc2VyLmNvbXBvc2UocGFyc2VyLnBhcnNlKHNvdXJjZSkpKTtcbiAgICBpZiAocHJldHR5RXJyb3JzICYmIGxpbmVDb3VudGVyKVxuICAgICAgICBmb3IgKGNvbnN0IGRvYyBvZiBkb2NzKSB7XG4gICAgICAgICAgICBkb2MuZXJyb3JzLmZvckVhY2gocHJldHRpZnlFcnJvcihzb3VyY2UsIGxpbmVDb3VudGVyKSk7XG4gICAgICAgICAgICBkb2Mud2FybmluZ3MuZm9yRWFjaChwcmV0dGlmeUVycm9yKHNvdXJjZSwgbGluZUNvdW50ZXIpKTtcbiAgICAgICAgfVxuICAgIGlmIChkb2NzLmxlbmd0aCA+IDApXG4gICAgICAgIHJldHVybiBkb2NzO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKFtdLCB7IGVtcHR5OiB0cnVlIH0sIGNvbXBvc2VyLnN0cmVhbUluZm8oKSk7XG59XG4vKiogUGFyc2UgYW4gaW5wdXQgc3RyaW5nIGludG8gYSBzaW5nbGUgWUFNTC5Eb2N1bWVudCAqL1xuZnVuY3Rpb24gcGFyc2VEb2N1bWVudChzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgbGluZUNvdW50ZXIsIHByZXR0eUVycm9ycyB9ID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIobGluZUNvdW50ZXI/LmFkZE5ld0xpbmUpO1xuICAgIGNvbnN0IGNvbXBvc2VyID0gbmV3IENvbXBvc2VyKG9wdGlvbnMpO1xuICAgIC8vIGBkb2NgIGlzIGFsd2F5cyBzZXQgYnkgY29tcG9zZS5lbmQodHJ1ZSkgYXQgdGhlIHZlcnkgbGF0ZXN0XG4gICAgbGV0IGRvYyA9IG51bGw7XG4gICAgZm9yIChjb25zdCBfZG9jIG9mIGNvbXBvc2VyLmNvbXBvc2UocGFyc2VyLnBhcnNlKHNvdXJjZSksIHRydWUsIHNvdXJjZS5sZW5ndGgpKSB7XG4gICAgICAgIGlmICghZG9jKVxuICAgICAgICAgICAgZG9jID0gX2RvYztcbiAgICAgICAgZWxzZSBpZiAoZG9jLm9wdGlvbnMubG9nTGV2ZWwgIT09ICdzaWxlbnQnKSB7XG4gICAgICAgICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFlBTUxQYXJzZUVycm9yKF9kb2MucmFuZ2Uuc2xpY2UoMCwgMiksICdNVUxUSVBMRV9ET0NTJywgJ1NvdXJjZSBjb250YWlucyBtdWx0aXBsZSBkb2N1bWVudHM7IHBsZWFzZSB1c2UgWUFNTC5wYXJzZUFsbERvY3VtZW50cygpJykpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByZXR0eUVycm9ycyAmJiBsaW5lQ291bnRlcikge1xuICAgICAgICBkb2MuZXJyb3JzLmZvckVhY2gocHJldHRpZnlFcnJvcihzb3VyY2UsIGxpbmVDb3VudGVyKSk7XG4gICAgICAgIGRvYy53YXJuaW5ncy5mb3JFYWNoKHByZXR0aWZ5RXJyb3Ioc291cmNlLCBsaW5lQ291bnRlcikpO1xuICAgIH1cbiAgICByZXR1cm4gZG9jO1xufVxuZnVuY3Rpb24gcGFyc2Uoc3JjLCByZXZpdmVyLCBvcHRpb25zKSB7XG4gICAgbGV0IF9yZXZpdmVyID0gdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBfcmV2aXZlciA9IHJldml2ZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiByZXZpdmVyICYmIHR5cGVvZiByZXZpdmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRpb25zID0gcmV2aXZlcjtcbiAgICB9XG4gICAgY29uc3QgZG9jID0gcGFyc2VEb2N1bWVudChzcmMsIG9wdGlvbnMpO1xuICAgIGlmICghZG9jKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBkb2Mud2FybmluZ3MuZm9yRWFjaCh3YXJuaW5nID0+IHdhcm4oZG9jLm9wdGlvbnMubG9nTGV2ZWwsIHdhcm5pbmcpKTtcbiAgICBpZiAoZG9jLmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChkb2Mub3B0aW9ucy5sb2dMZXZlbCAhPT0gJ3NpbGVudCcpXG4gICAgICAgICAgICB0aHJvdyBkb2MuZXJyb3JzWzBdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkb2MuZXJyb3JzID0gW107XG4gICAgfVxuICAgIHJldHVybiBkb2MudG9KUyhPYmplY3QuYXNzaWduKHsgcmV2aXZlcjogX3Jldml2ZXIgfSwgb3B0aW9ucykpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgb3B0aW9ucykge1xuICAgIGxldCBfcmVwbGFjZXIgPSBudWxsO1xuICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicgfHwgQXJyYXkuaXNBcnJheShyZXBsYWNlcikpIHtcbiAgICAgICAgX3JlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiByZXBsYWNlcikge1xuICAgICAgICBvcHRpb25zID0gcmVwbGFjZXI7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnN0IGluZGVudCA9IE1hdGgucm91bmQob3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMgPSBpbmRlbnQgPCAxID8gdW5kZWZpbmVkIDogaW5kZW50ID4gOCA/IHsgaW5kZW50OiA4IH0gOiB7IGluZGVudCB9O1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB7IGtlZXBVbmRlZmluZWQgfSA9IG9wdGlvbnMgPz8gcmVwbGFjZXIgPz8ge307XG4gICAgICAgIGlmICgha2VlcFVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRG9jdW1lbnQodmFsdWUsIF9yZXBsYWNlciwgb3B0aW9ucykudG9TdHJpbmcob3B0aW9ucyk7XG59XG5cbmV4cG9ydCB7IHBhcnNlLCBwYXJzZUFsbERvY3VtZW50cywgcGFyc2VEb2N1bWVudCwgc3RyaW5naWZ5IH07XG4iLCAiaW1wb3J0IHRzbGliIGZyb20gJy4uL3RzbGliLmpzJztcclxuY29uc3Qge1xyXG4gICAgX19leHRlbmRzLFxyXG4gICAgX19hc3NpZ24sXHJcbiAgICBfX3Jlc3QsXHJcbiAgICBfX2RlY29yYXRlLFxyXG4gICAgX19wYXJhbSxcclxuICAgIF9fbWV0YWRhdGEsXHJcbiAgICBfX2F3YWl0ZXIsXHJcbiAgICBfX2dlbmVyYXRvcixcclxuICAgIF9fZXhwb3J0U3RhcixcclxuICAgIF9fY3JlYXRlQmluZGluZyxcclxuICAgIF9fdmFsdWVzLFxyXG4gICAgX19yZWFkLFxyXG4gICAgX19zcHJlYWQsXHJcbiAgICBfX3NwcmVhZEFycmF5cyxcclxuICAgIF9fc3ByZWFkQXJyYXksXHJcbiAgICBfX2F3YWl0LFxyXG4gICAgX19hc3luY0dlbmVyYXRvcixcclxuICAgIF9fYXN5bmNEZWxlZ2F0b3IsXHJcbiAgICBfX2FzeW5jVmFsdWVzLFxyXG4gICAgX19tYWtlVGVtcGxhdGVPYmplY3QsXHJcbiAgICBfX2ltcG9ydFN0YXIsXHJcbiAgICBfX2ltcG9ydERlZmF1bHQsXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0LFxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCxcclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRJbixcclxufSA9IHRzbGliO1xyXG5leHBvcnQge1xyXG4gICAgX19leHRlbmRzLFxyXG4gICAgX19hc3NpZ24sXHJcbiAgICBfX3Jlc3QsXHJcbiAgICBfX2RlY29yYXRlLFxyXG4gICAgX19wYXJhbSxcclxuICAgIF9fbWV0YWRhdGEsXHJcbiAgICBfX2F3YWl0ZXIsXHJcbiAgICBfX2dlbmVyYXRvcixcclxuICAgIF9fZXhwb3J0U3RhcixcclxuICAgIF9fY3JlYXRlQmluZGluZyxcclxuICAgIF9fdmFsdWVzLFxyXG4gICAgX19yZWFkLFxyXG4gICAgX19zcHJlYWQsXHJcbiAgICBfX3NwcmVhZEFycmF5cyxcclxuICAgIF9fc3ByZWFkQXJyYXksXHJcbiAgICBfX2F3YWl0LFxyXG4gICAgX19hc3luY0dlbmVyYXRvcixcclxuICAgIF9fYXN5bmNEZWxlZ2F0b3IsXHJcbiAgICBfX2FzeW5jVmFsdWVzLFxyXG4gICAgX19tYWtlVGVtcGxhdGVPYmplY3QsXHJcbiAgICBfX2ltcG9ydFN0YXIsXHJcbiAgICBfX2ltcG9ydERlZmF1bHQsXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0LFxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCxcclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRJbixcclxufTtcclxuIiwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQSxZQUFPLFVBQVU7QUFFakIscUJBQWtCLE1BQU07QUFDcEIsVUFBSSxDQUFFLGlCQUFnQjtBQUFVLGVBQU8sSUFBSSxRQUFRLElBQUk7QUFDdkQsV0FBSyxVQUFVLFFBQVEsQ0FBQztBQUN4QixXQUFLLFNBQVMsS0FBSyxRQUFRLE9BQU8sU0FBVSxNQUFNLEtBQUs7QUFDbkQsZUFBTyxPQUFPLElBQUk7QUFBQSxNQUN0QixHQUFHLENBQUM7QUFBQSxJQUNSO0FBRUEsWUFBUSxVQUFVLE9BQU8sV0FBWTtBQUNqQyxlQUFTLEtBQUksR0FBRyxLQUFJLFVBQVUsUUFBUSxNQUFLO0FBQ3ZDLFlBQUksQ0FBQyxPQUFPLFNBQVMsVUFBVSxHQUFFLEdBQUc7QUFDaEMsZ0JBQU0sSUFBSSxVQUFVLDRCQUE0QjtBQUFBLFFBQ3BEO0FBQUEsTUFDSjtBQUVBLGVBQVMsS0FBSSxHQUFHLEtBQUksVUFBVSxRQUFRLE1BQUs7QUFDdkMsWUFBSSxNQUFNLFVBQVU7QUFDcEIsYUFBSyxRQUFRLEtBQUssR0FBRztBQUNyQixhQUFLLFVBQVUsSUFBSTtBQUFBLE1BQ3ZCO0FBQ0EsYUFBTyxLQUFLO0FBQUEsSUFDaEI7QUFFQSxZQUFRLFVBQVUsVUFBVSxXQUFZO0FBQ3BDLGVBQVMsS0FBSSxHQUFHLEtBQUksVUFBVSxRQUFRLE1BQUs7QUFDdkMs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RSxHQUFFLE1BQUksR0FBRSxHQUFFLE1BQUksR0FBRSxHQUFFLE1BQUksR0FBRSxHQUFFLE1BQUksR0FBRSxFQUFDO0FBQUEsY0FBQztBQUFBLFlBQUM7QUFBQyxtQkFBTyxJQUFJLEtBQUssRUFBQztBQUFBLFVBQUMsRUFBRSxFQUFDLEdBQUUsS0FBSyxLQUFHLEdBQUUsS0FBRyxDQUFDLEdBQUUsS0FBSyxLQUFLO0FBQUEsUUFBQyxHQUFFLEdBQUUsT0FBSyxXQUFVO0FBQUMsY0FBSSxLQUFFLEtBQUs7QUFBRyxlQUFLLEtBQUcsR0FBRSxZQUFZLEdBQUUsS0FBSyxLQUFHLEdBQUUsU0FBUyxHQUFFLEtBQUssS0FBRyxHQUFFLFFBQVEsR0FBRSxLQUFLLEtBQUcsR0FBRSxPQUFPLEdBQUUsS0FBSyxLQUFHLEdBQUUsU0FBUyxHQUFFLEtBQUssS0FBRyxHQUFFLFdBQVcsR0FBRSxLQUFLLEtBQUcsR0FBRSxXQUFXLEdBQUUsS0FBSyxNQUFJLEdBQUUsZ0JBQWdCO0FBQUEsUUFBQyxHQUFFLEdBQUUsU0FBTyxXQUFVO0FBQUMsaUJBQU87QUFBQSxRQUFDLEdBQUUsR0FBRSxVQUFRLFdBQVU7QUFBQyxpQkFBTSxDQUFFLE1BQUssR0FBRyxTQUFTLE1BQUk7QUFBQSxRQUFFLEdBQUUsR0FBRSxTQUFPLFNBQVMsSUFBRSxJQUFFO0FBQUMsY0FBSSxLQUFFLEdBQUUsRUFBQztBQUFFLGlCQUFPLEtBQUssUUFBUSxFQUFDLEtBQUcsTUFBRyxNQUFHLEtBQUssTUFBTSxFQUFDO0FBQUEsUUFBQyxHQUFFLEdBQUUsVUFBUSxTQUFTLElBQUUsSUFBRTtBQUFDLGlCQUFPLEdBQUUsRUFBQyxJQUFFLEtBQUssUUFBUSxFQUFDO0FBQUEsUUFBQyxHQUFFLEdBQUUsV0FBUyxTQUFTLElBQUUsSUFBRTtBQUFDLGlCQUFPLEtBQUssTUFBTSxFQUFDLElBQUUsR0FBRSxFQUFDO0FBQUEsUUFBQyxHQUFFLEdBQUUsS0FBRyxTQUFTLElBQUUsSUFBRSxJQUFFO0FBQUMsaUJBQU8sRUFBRSxFQUFFLEVBQUMsSUFBRSxLQUFLLE1BQUcsS0FBSyxJQUFJLElBQUUsRUFBQztBQUFBLFFBQUMsR0FBRSxHQUFFLE9BQUssV0FBVTtBQUFDLGlCQUFPLEtBQUssTUFBTSxLQUFLLFFBQVEsSUFBRSxHQUFHO0FBQUEsUUFBQyxHQUFFLEdBQUUsVUFBUSxXQUFVO0FBQUMsaUJBQU8sS0FBSyxHQUFHLFFBQVE7QUFBQSxRQUFDLEdBQUUsR0FBRSxVQUFRLFNBQVMsSUFBRSxJQUFFO0FBQUMsY0FBSSxLQUFFLE1BQUssS0FBRSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUMsS0FBRyxJQUFFLEtBQUUsRUFBRSxFQUFFLEVBQUMsR0FBRSxLQUFFLFNBQVMsSUFBRSxJQUFFO0FBQUMsZ0JBQUksS0FBRSxFQUFFLEVBQUUsR0FBRSxLQUFHLEtBQUssSUFBSSxHQUFFLElBQUcsSUFBRSxFQUFDLElBQUUsSUFBSSxLQUFLLEdBQUUsSUFBRyxJQUFFLEVBQUMsR0FBRSxFQUFDO0FBQUUsbUJBQU8sS0FBRSxLQUFFLEdBQUUsTUFBTSxFQUFDO0FBQUEsVUFBQyxHQUFFLEtBQUUsU0FBUyxJQUFFLElBQUU7QUFBQyxtQkFBTyxFQUFFLEVBQUUsR0FBRSxPQUFPLEVBQUUsSUFBRyxNQUFNLEdBQUUsT0FBTyxHQUFHLEdBQUcsTUFBRSxDQUFDLEdBQUUsR0FBRSxHQUFFLENBQUMsSUFBRSxDQUFDLElBQUcsSUFBRyxJQUFHLEdBQUcsR0FBRyxNQUFNLEVBQUMsQ0FBQyxHQUFFLEVBQUM7QUFBQSxVQUFDLEdBQUUsS0FBRSxLQUFLLElBQUcsS0FBRSxLQUFLLElBQUcsS0FBRSxLQUFLLElBQUcsS0FBRSxRQUFPLE1BQUssS0FBRyxRQUFNO0FBQUksa0JBQU87QUFBQSxpQkFBUTtBQUFFLHFCQUFPLEtBQUUsR0FBRSxHQUFFLENBQUMsSUFBRSxHQUFFLElBQUcsRUFBRTtBQUFBLGlCQUFPO0FBQUUscUJBQU8sS0FBRSxHQUFFLEdBQUUsRUFBQyxJQUFFLEdBQUUsR0FBRSxLQUFFLENBQUM7QUFBQSxpQkFBTztBQUFFLGtCQUFJLEtBQUUsS0FBSyxRQUFRLEVB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SSxHQUFFLE9BQU8sRUFBQyxHQUFFLElBQUcsRUFBRSxFQUFFLElBQUUsR0FBRSxHQUFHLEdBQUUsR0FBRSxHQUFFLENBQUMsR0FBRSxJQUFHLEdBQUUsQ0FBQyxHQUFFLEdBQUUsR0FBRSxJQUFFLElBQUUsSUFBRSxHQUFFLEdBQUUsR0FBRSxJQUFFLElBQUUsS0FBRSxHQUFFLEdBQUUsT0FBTyxFQUFDLEdBQUUsSUFBRyxFQUFFLEVBQUUsSUFBRSxHQUFFLEdBQUcsR0FBRSxHQUFFLE9BQU8sS0FBSyxFQUFFLEdBQUUsSUFBRyxFQUFFLEVBQUUsS0FBSyxJQUFHLEdBQUUsR0FBRyxHQUFFLEtBQUksRUFBRSxFQUFFLEtBQUssS0FBSSxHQUFFLEdBQUcsR0FBRSxHQUFFLEdBQUM7QUFBRSxpQkFBTyxHQUFFLFFBQVEsSUFBRyxTQUFTLElBQUUsSUFBRTtBQUFDLG1CQUFPLE1BQUcsR0FBRSxPQUFJLEdBQUUsUUFBUSxLQUFJLEVBQUU7QUFBQSxVQUFDLENBQUU7QUFBQSxRQUFDLEdBQUUsR0FBRSxZQUFVLFdBQVU7QUFBQyxpQkFBTyxLQUFHLENBQUMsS0FBSyxNQUFNLEtBQUssR0FBRyxrQkFBa0IsSUFBRSxFQUFFO0FBQUEsUUFBQyxHQUFFLEdBQUUsT0FBSyxTQUFTLElBQUUsSUFBRSxJQUFFO0FBQUMsY0FBSSxJQUFFLEtBQUUsRUFBRSxFQUFFLEVBQUMsR0FBRSxLQUFFLEdBQUUsRUFBQyxHQUFFLEtBQUcsSUFBRSxVQUFVLElBQUUsS0FBSyxVQUFVLEtBQUcsSUFBRSxLQUFFLE9BQUssSUFBRSxLQUFFLEVBQUUsRUFBRSxNQUFLLEVBQUM7QUFBRSxpQkFBTyxLQUFHLE1BQUUsQ0FBQyxHQUFFLEdBQUUsTUFBRyxLQUFFLElBQUcsR0FBRSxNQUFHLElBQUUsR0FBRSxNQUFHLEtBQUUsR0FBRSxHQUFFLE1BQUksTUFBRSxNQUFHLFFBQU8sR0FBRSxNQUFJLE1BQUUsTUFBRyxPQUFNLEdBQUUsTUFBRyxLQUFFLElBQUUsR0FBRSxNQUFHLEtBQUUsSUFBRSxHQUFFLE1BQUcsS0FBRSxJQUFFLElB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QUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsT0FBTztNQUNQLE9BQU87TUFDUCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLE1BQU07TUFDTixPQUFPO01BQ1AsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsSUFBSTtNQUNKLE1BQU07TUFDTixLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLE9BQU87TUFDUCxNQUFNO01BQ04sTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE9BQU87TUFDUCxNQUFNO01BQ04sS0FBSztNQUNMLE1BQU07TUFDTixNQUFNO01BQ04sTUFBTTtNQUNOLE1BQU07TUFDTixPQUFPO01BQ1AsTUFBTTtNQUNOLE1BQU07TUFDTixNQUFNO01BQ04sS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxPQUFPO01BQ1AsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixNQUFNO01BQ04sT0FBTztNQUNQLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLE9BQU87TUFDUCxNQUFNO01BQ04sS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixNQUFNO01BQ04sTUFBTTtNQUNOLEtBQUs7TUFDTCxJQUFJO01BQ0osS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsT0FBTztNQUNQLE1BQU07TUFDTixLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxNQUFNO01BQ04sTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLElBQUk7TUFDSixPQUFPO01BQ1AsTUFBTTtNQUNOLE1BQU07TUFDTixPQUFPO01BQ1AsTUFBTTs7QUFHViw4QkFBaUMsZUFBK0I7O0FBQzVELFVBQUksa0JBQWtCLFFBQVEsa0JBQWtCLFFBQVc7QUFDdkQsZUFBTzs7QUFHWCxVQUFJLE9BQU8sa0JBQWtCLFVBQVU7QUFDbkMsZUFBTzs7QUFHWCxhQUFPLE1BQUEsUUFBQSxrQkFBa0Isb0JBQWMsUUFBQSxPQUFBLFNBQUEsS0FBSTtJQUMvQztBQVZBLFlBQUEsbUJBQUE7Ozs7Ozs7Ozs7Ozs7QUNoTUEsUUFBQSxrQkFBQSxpQkFBQSx1QkFBQTtBQUNBLFFBQUEsVUFBQSxpQkFBQSxtQkFBQTtBQUNBLFFBQUEsVUFBQTtBQUNBLFFBQUEsYUFBQTtBQUNBLFlBQUEsUUFBTSxPQUFPLGdCQUFBLE9BQWE7QUFFMUIsUUFBYSx3QkFBYixNQUFrQztNQUk5QixZQUFZLE9BQStCOztBQUN2QyxnQkFBUSxVQUFLLFFBQUwsVUFBSyxTQUFMLFFBQVMsSUFBSSxLQUFJO0FBQ3pCLFlBQUksaUJBQWlCLE1BQU07QUFDdkIsZUFBSyxVQUFVO2VBQ1o7QUFDSCxlQUFLLFVBQVUsTUFBQSxNQUFNLGFBQU8sUUFBQSxPQUFBLFNBQUEsS0FBSSxJQUFJLEtBQUk7QUFDeEMsZUFBSyxpQkFBaUIsV0FBQSxpQkFBaUIsTUFBTSxRQUFROztNQUU3RDtNQU1BLDhCQUEyQjtBQUN2QixlQUFPLElBQUksS0FBSyxLQUFLLFFBQVEsUUFBTyxJQUFLLEtBQUssa0NBQWtDLEtBQUssT0FBTyxJQUFJLEdBQUs7TUFDekc7TUFPQSxrQ0FBa0MsTUFBYSx3QkFBK0I7O0FBQzFFLFlBQUksQ0FBQyxRQUFRLEtBQUssUUFBTyxJQUFLLEdBQUc7QUFHN0IsaUJBQU8sSUFBSSxLQUFJOztBQUduQixjQUFNLHdCQUF3QixDQUFDLEtBQUssa0JBQWlCO0FBQ3JELGNBQU0sdUJBQXVCLE1BQUEsMkJBQXNCLFFBQXRCLDJCQUFzQixTQUF0Qix5QkFBMEIsS0FBSyxvQkFBYyxRQUFBLE9BQUEsU0FBQSxLQUFJO0FBQzlFLGVBQU8sd0JBQXdCO01BQ25DOztBQXJDSixZQUFBLHdCQUFBO0FBd0NBLFFBQWEsb0JBQWIsTUFBOEI7TUFLMUIsWUFBWSxXQUFrQyxpQkFBK0M7QUFDekYsYUFBSyxZQUFZO0FBQ2pCLGFBQUssY0FBYyxDQUFBO0FBQ25CLGFBQUssZ0JBQWdCLENBQUE7QUFDckIsWUFBSSxpQkFBaUI7QUFDakIscUJBQVcsT0FBTyxpQkFBaUI7QUFDL0IsaUJBQUssWUFBWSxPQUFvQixnQkFBZ0I7OztBQUk3RCxjQUFNLFdBQVcsUUFBQSxRQUFNLFVBQVUsT0FBTztBQUN4QyxhQUFLLE1BQU0sT0FBTyxTQUFTLEtBQUksQ0FBRTtBQUNqQyxhQUFLLE1BQU0sU0FBUyxTQUFTLE1BQUssSUFBSyxDQUFDO0FBQ3hDLGFBQUssTUFBTSxRQUFRLFNBQVMsS0FBSSxDQUFFO0FBQ2xDLGFBQUssTUFBTSxRQUFRLEVBQUU7QUFDckIsYUFBSyxNQUFNLFVBQVUsQ0FBQztBQUN0QixhQUFLLE1BQU0sVUFBVSxDQUFDO0FBQ3RCLGFBQUssTUFBTSxlQUFlLENBQUM7TUFDL0I7TUFFQSxJQUFJLFdBQW9CO0FBQ3BCLFlBQUksYUFBYSxLQUFLLGFBQWE7QUFDL0IsaUJBQU8sS0FBSyxZQUFZOztBQUc1QixZQUFJLGFBQWEsS0FBSyxlQUFlO0FBQ2pDLGlCQUFPLEtBQUssY0FBYzs7QUFHOUIsZUFBTztNQUNYO01BRUEsVUFBVSxXQUFvQjtBQUMxQixlQUFPLGFBQWEsS0FBSztNQUM3QjtNQUVBLHVCQUFvQjtBQUNoQixlQUFPLE9BQU8sS0FBSyxLQUFLLFdBQVc7TUFDdkM7TUFFQSxNQUFNLFdBQXNCLE9BQWE7QUFDckMsWUFBSSxhQUFhLEtBQUssYUFBYTtBQUMvQixpQkFBTzs7QUFFWCxhQUFLLGNBQWMsYUFBYTtBQUNoQyxlQUFPO01BQ1g7TUFFQSxPQUFPLFdBQXNCLE9BQWE7QUFDdEMsYUFBSyxZQUFZLGFBQWE7QUFDOUIsZUFBTyxLQUFLLGNBQWM7QUFDMUIsZUFBTztNQUNYO01BRUEsT0FBTyxXQUFvQjtBQUN2QixlQUFPLEtBQUssWUFBWTtBQUN4QixlQUFPLEtBQUssY0FBYztNQUM5QjtNQUVBLFFBQUs7QUFDRCxjQUFNLFlBQVksSUFBSSxrQkFBa0IsS0FBSyxTQUFTO0FBQ3RELGtCQUFVLGNBQWMsQ0FBQTtBQUN4QixrQkFBVSxnQkFBZ0IsQ0FBQTtBQUUxQixtQkFBVyxPQUFPLEtBQUssYUFBYTtBQUNoQyxvQkFBVSxZQUFZLE9BQW9CLEtBQUssWUFBWTs7QUFHL0QsbUJBQVcsT0FBTyxLQUFLLGVBQWU7QUFDbEMsb0JBQVUsY0FBYyxPQUFvQixLQUFLLGNBQWM7O0FBR25FLGVBQU87TUFDWDtNQUVBLGFBQVU7QUFDTixlQUFPLENBQUMsS0FBSyxVQUFVLE1BQU0sS0FBSyxDQUFDLEtBQUssVUFBVSxRQUFRLEtBQUssQ0FBQyxLQUFLLFVBQVUsUUFBUTtNQUMzRjtNQUVBLGFBQVU7QUFDTixlQUFPLENBQUMsS0FBSyxVQUFVLFNBQVMsS0FBSyxDQUFDLEtBQUssVUFBVSxLQUFLLEtBQUssQ0FBQyxLQUFLLFVBQVUsT0FBTztNQUMxRjtNQUVBLHlCQUFzQjtBQUNsQixlQUFPLEtBQUssVUFBVSxTQUFTLEtBQUssQ0FBQyxLQUFLLFVBQVUsS0FBSyxLQUFLLENBQUMsS0FBSyxVQUFVLE9BQU87TUFDekY7TUFFQSwwQkFBdUI7QUFDbkIsZUFBTyxLQUFLLFVBQVUsS0FBSyxLQUFLLEtBQUssVUFBVSxPQUFPLEtBQUssQ0FBQyxLQUFLLFVBQVUsTUFBTTtNQUNyRjtNQUVBLGNBQVc7QUFDUCxjQUFNLE9BQU8sS0FBSyw4QkFBNkI7QUFFL0MsWUFBSSxLQUFLLFlBQVcsTUFBTyxLQUFLLElBQUksTUFBTTtBQUFHLGlCQUFPO0FBQ3BELFlBQUksS0FBSyxTQUFRLE1BQU8sS0FBSyxJQUFJLE9BQU8sSUFBSTtBQUFHLGlCQUFPO0FBQ3RELFlBQUksS0FBSyxRQUFPLE1BQU8sS0FBSyxJQUFJLEtBQUs7QUFBRyxpQkFBTztBQUMvQyxZQUFJLEtBQUssSUFBSSxNQUFNLEtBQUssUUFBUSxLQUFLLFNBQVEsS0FBTSxLQUFLLElBQUksTUFBTTtBQUFHLGlCQUFPO0FBQzVFLFlBQUksS0FBSyxJQUFJLFFBQVEsS0FBSyxRQUFRLEtBQUssV0FBVSxLQUFNLEtBQUssSUFBSSxRQUFRO0FBQUcsaUJBQU87QUFFbEYsZUFBTztNQUNYO01BRUEsV0FBUTtBQUNKLGVBQU8sb0NBQW9DLEtBQUssVUFBVSxLQUFLLFdBQVcscUJBQXFCLEtBQUssVUFDaEcsS0FBSyxhQUFhLGtCQUNKLEtBQUssVUFBVSxLQUFLLFNBQVM7TUFDbkQ7TUFFQSxRQUFLO0FBQ0QsZUFBTyxRQUFBLFFBQU0sS0FBSyxLQUFJLENBQUU7TUFDNUI7TUFFQSxPQUFJO0FBQ0EsY0FBTSxPQUFPLEtBQUssOEJBQTZCO0FBQy9DLGNBQU0scUJBQXFCLEtBQUssVUFBVSxrQ0FBa0MsTUFBTSxLQUFLLElBQUksZ0JBQWdCLENBQUM7QUFDNUcsZUFBTyxJQUFJLEtBQUssS0FBSyxRQUFPLElBQUsscUJBQXFCLEdBQUs7TUFDL0Q7TUFFUSxnQ0FBNkI7QUFDakMsY0FBTSxPQUFPLElBQUksS0FDYixLQUFLLElBQUksTUFBTSxHQUNmLEtBQUssSUFBSSxPQUFPLElBQUksR0FDcEIsS0FBSyxJQUFJLEtBQUssR0FDZCxLQUFLLElBQUksTUFBTSxHQUNmLEtBQUssSUFBSSxRQUFRLEdBQ2pCLEtBQUssSUFBSSxRQUFRLEdBQ2pCLEtBQUssSUFBSSxhQUFhLENBQUM7QUFHM0IsYUFBSyxZQUFZLEtBQUssSUFBSSxNQUFNLENBQUM7QUFDakMsZUFBTztNQUNYO01BRUEsT0FBTyw0QkFDSCxXQUNBLFdBQXdDO0FBRXhDLFlBQUksT0FBTyxRQUFBLFFBQU0sVUFBVSxPQUFPO0FBQ2xDLG1CQUFXLE9BQU8sV0FBVztBQUN6QixpQkFBTyxLQUFLLElBQUksVUFBVSxNQUFtQixHQUFnQjs7QUFHakUsY0FBTSxhQUFhLElBQUksa0JBQWtCLFNBQVM7QUFDbEQsWUFBSSxVQUFVLFdBQVcsVUFBVSxhQUFhLFVBQVUsV0FBVztBQUNqRSxrQkFBQSxrQkFBa0IsWUFBWSxJQUFJO0FBQ2xDLGtCQUFBLGtCQUFrQixZQUFZLElBQUk7QUFDbEMsY0FBSSxVQUFVLG1CQUFtQixNQUFNO0FBQ25DLHVCQUFXLE9BQU8sa0JBQWtCLENBQUMsVUFBVSxRQUFRLGtCQUFpQixDQUFFOztlQUUzRTtBQUNILGtCQUFBLGlCQUFpQixZQUFZLElBQUk7QUFDakMsY0FBSSxVQUFVLG1CQUFtQixNQUFNO0FBQ25DLHVCQUFXLE1BQU0sa0JBQWtCLENBQUMsVUFBVSxRQUFRLGtCQUFpQixDQUFFOztBQUc3RSxjQUFJLFVBQVUsTUFBTTtBQUNoQix1QkFBVyxPQUFPLE9BQU8sS0FBSyxLQUFJLENBQUU7QUFDcEMsdUJBQVcsT0FBTyxTQUFTLEtBQUssTUFBSyxJQUFLLENBQUM7QUFDM0MsdUJBQVcsT0FBTyxRQUFRLEtBQUssS0FBSSxDQUFFO2lCQUNsQztBQUNILGdCQUFJLFVBQVUsU0FBUztBQUNuQix5QkFBVyxNQUFNLFdBQVcsS0FBSyxJQUFHLENBQUU7O0FBRzFDLHVCQUFXLE1BQU0sT0FBTyxLQUFLLEtBQUksQ0FBRTtBQUNuQyxnQkFBSSxVQUFVLFVBQVU7QUFDcEIseUJBQVcsT0FBTyxTQUFTLEtBQUssTUFBSyxJQUFLLENBQUM7QUFDM0MseUJBQVcsT0FBTyxRQUFRLEtBQUssS0FBSSxDQUFFO21CQUNsQztBQUNILHlCQUFXLE1BQU0sU0FBUyxLQUFLLE1BQUssSUFBSyxDQUFDO0FBQzFDLGtCQUFJLFVBQVUsU0FBUztBQUNuQiwyQkFBVyxPQUFPLFFBQVEsS0FBSyxLQUFJLENBQUU7cUJBQ2xDO0FBQ0gsMkJBQVcsTUFBTSxRQUFRLEtBQUssS0FBSSxDQUFFOzs7OztBQU1wRCxlQUFPO01BQ1g7O0FBMUxKLFlBQUEsb0JBQUE7QUE2TEEsUUFBYSxnQkFBYixNQUEwQjtNQVV0QixZQUNJLFdBQ0EsT0FDQSxNQUNBLE9BQ0EsS0FBdUI7QUFFdkIsYUFBSyxZQUFZO0FBQ2pCLGFBQUssVUFBVSxVQUFVO0FBQ3pCLGFBQUssUUFBUTtBQUNiLGFBQUssT0FBTztBQUNaLGFBQUssUUFBUSxTQUFTLElBQUksa0JBQWtCLFNBQVM7QUFDckQsYUFBSyxNQUFNO01BQ2Y7TUFFQSxRQUFLO0FBQ0QsY0FBTSxTQUFTLElBQUksY0FBYyxLQUFLLFdBQVcsS0FBSyxPQUFPLEtBQUssSUFBSTtBQUN0RSxlQUFPLFFBQVEsS0FBSyxRQUFRLEtBQUssTUFBTSxNQUFLLElBQUs7QUFDakQsZUFBTyxNQUFNLEtBQUssTUFBTSxLQUFLLElBQUksTUFBSyxJQUFLO0FBQzNDLGVBQU87TUFDWDtNQUVBLE9BQUk7QUFDQSxlQUFPLEtBQUssTUFBTSxLQUFJO01BQzFCO01BRUEsV0FBUTtBQUNKLGVBQU8sMEJBQTBCLEtBQUssaUJBQWlCLEtBQUs7TUFDaEU7O0FBdENKLFlBQUEsZ0JBQUE7Ozs7Ozs7Ozs7QUN0T0EsUUFBc0IseUNBQXRCLE1BQTREO01BQTVELGNBQUE7QUFPWSxhQUFBLHFCQUE4QjtBQUM5QixhQUFBLGdCQUF5QjtNQTJCckM7TUF6Qkksc0JBQW1CO0FBQ2YsZUFBTztNQUNYO01BRUEsUUFBUSxVQUF1QjtBQUMzQixjQUFNLGVBQWUsS0FBSyxhQUFhLFFBQU87QUFDOUMsWUFBSSxnQkFBZ0IsS0FBSyxvQkFBb0I7QUFDekMsaUJBQU8sS0FBSzs7QUFHaEIsYUFBSyxnQkFBZ0IsSUFBSSxPQUFPLEdBQUcsS0FBSyxvQkFBbUIsSUFBSyxhQUFhLFVBQVUsYUFBYSxLQUFLO0FBQ3pHLGFBQUsscUJBQXFCO0FBQzFCLGVBQU8sS0FBSztNQUNoQjtNQUVBLFFBQVEsVUFBeUIsT0FBdUI7O0FBQ3BELGNBQU0sU0FBUyxNQUFBLE1BQU0sUUFBRSxRQUFBLE9BQUEsU0FBQSxLQUFJO0FBQzNCLGNBQU0sUUFBUSxNQUFNLFFBQVEsT0FBTztBQUNuQyxjQUFNLEtBQUssTUFBTSxHQUFHLFVBQVUsT0FBTyxNQUFNO0FBQzNDLGlCQUFTLEtBQUksR0FBRyxLQUFJLE1BQU0sUUFBUSxNQUFLO0FBQ25DLGdCQUFNLEtBQUksS0FBSyxNQUFNOztBQUd6QixlQUFPLEtBQUssYUFBYSxVQUFTLEtBQUs7TUFDM0M7O0FBbENKLFlBQUEseUNBQUE7Ozs7Ozs7OztBQ1BBLFFBQUEsY0FBQTtBQUVBLFFBQUEsWUFBQTtBQUNBLFFBQUEsbUNBQUE7QUFFQSxRQUFNLHNCQUFzQixJQUFJLE9BQzVCLHVGQUNzRSxZQUFBLGdDQUN0RSxHQUFHO0FBR1AsUUFBTSx5QkFBeUIsSUFBSSxPQUMvQixrRUFBa0UsWUFBQSxnQ0FDbEUsR0FBRztBQUdQLFFBQXFCLCtCQUFyQixjQUEwRCxpQ0FBQSx1Q0FBc0M7TUFDNUYsYUFBYSxVQUF1QjtBQUNoQyxlQUFPLFNBQVEsT0FBTyxjQUFjLHlCQUF5QjtNQUNqRTtNQUVBLGFBQWEsVUFBeUIsT0FBdUI7QUFDekQsY0FBTSxZQUFZLFlBQUEsZUFBZSxNQUFNLEVBQUU7QUFDekMsZUFBTyxVQUFBLGtCQUFrQiw0QkFBNEIsU0FBUSxXQUFXLFNBQVM7TUFDckY7O0FBUkosWUFBQSxVQUFBOzs7Ozs7Ozs7QUNkQSxRQUFBLFVBQUE7QUFDQSxRQUFBLGNBQUE7QUFDQSxRQUFBLGNBQUE7QUFDQSxRQUFBLGNBQUE7QUFDQSxRQUFBLFlBQUE7QUFDQSxRQUFBLG1DQUFBO0FBR0EsUUFBTSxVQUFVLElBQUksT0FDaEIsbUJBQ1EsWUFBQSxxRkFHSSxZQUFBLDREQUdKLFVBQUEsZ0JBQWdCLFlBQUEsZ0JBQWdCLDJCQUc1QixZQUFBLHlDQUdaLEdBQUc7QUFHUCxRQUFNLGFBQWE7QUFDbkIsUUFBTSxnQkFBZ0I7QUFDdEIsUUFBTSxtQkFBbUI7QUFDekIsUUFBTSxhQUFhO0FBRW5CLFFBQXFCLGdDQUFyQixjQUEyRCxpQ0FBQSx1Q0FBc0M7TUFDN0YsZUFBWTtBQUNSLGVBQU87TUFDWDtNQUVBLGFBQWEsVUFBeUIsT0FBdUI7QUFDekQsY0FBTSxTQUFTLFNBQVEsb0JBQW9CLE1BQU0sT0FBTyxNQUFNLEVBQUU7QUFFaEUsY0FBTSxRQUFRLFlBQUEsaUJBQWlCLE1BQU0sa0JBQWtCLFlBQVc7QUFDbEUsY0FBTSxNQUFNLFlBQUEsMEJBQTBCLE1BQU0sV0FBVztBQUN2RCxZQUFJLE1BQU0sSUFBSTtBQUVWLGdCQUFNLFFBQVEsTUFBTSxRQUFRLE1BQU0sWUFBWTtBQUM5QyxpQkFBTzs7QUFHWCxlQUFPLE1BQU0sT0FBTyxTQUFTLEtBQUs7QUFDbEMsZUFBTyxNQUFNLE9BQU8sT0FBTyxHQUFHO0FBRTlCLFlBQUksTUFBTSxhQUFhO0FBQ25CLGdCQUFNLGFBQWEsWUFBQSxVQUFVLE1BQU0sV0FBVztBQUM5QyxpQkFBTyxNQUFNLE9BQU8sUUFBUSxVQUFVO2VBQ25DO0FBQ0gsZ0JBQU0sT0FBTyxRQUFBLHFCQUFxQixTQUFRLFNBQVMsS0FBSyxLQUFLO0FBQzdELGlCQUFPLE1BQU0sTUFBTSxRQUFRLElBQUk7O0FBR25DLFlBQUksTUFBTSxnQkFBZ0I7QUFDdEIsZ0JBQU0sVUFBVSxZQUFBLDBCQUEwQixNQUFNLGNBQWM7QUFFOUQsaUJBQU8sTUFBTSxPQUFPLE1BQU0sTUFBSztBQUMvQixpQkFBTyxJQUFJLE9BQU8sT0FBTyxPQUFPOztBQUdwQyxlQUFPO01BQ1g7O0FBbkNKLFlBQUEsVUFBQTs7Ozs7Ozs7O0FDL0JBLFFBQUEsVUFBQTtBQUNBLFFBQUEsY0FBQTtBQUNBLFFBQUEsY0FBQTtBQUNBLFFBQUEsY0FBQTtBQUNBLFFBQUEsWUFBQTtBQUNBLFFBQUEsbUNBQUE7QUFFQSxRQUFNLFVBQVUsSUFBSSxPQUNoQixJQUFJLFVBQUEsZ0JBQWdCLFlBQUEsZ0JBQWdCLHdCQUU1QixZQUFBLGlFQUdBLFlBQUEsc0RBSUEsWUFBQSxzQ0FHUixHQUFHO0FBR1AsUUFBTSxtQkFBbUI7QUFDekIsUUFBTSxhQUFhO0FBQ25CLFFBQU0sZ0JBQWdCO0FBQ3RCLFFBQU0sYUFBYTtBQVluQixRQUFxQixnQ0FBckIsY0FBMkQsaUNBQUEsdUNBQXNDO01BQzdGLGVBQVk7QUFDUixlQUFPO01BQ1g7TUFFQSxhQUFhLFVBQXlCLE9BQXVCO0FBQ3pELGNBQU0sUUFBUSxZQUFBLGlCQUFpQixNQUFNLGtCQUFrQixZQUFXO0FBQ2xFLGNBQU0sTUFBTSxZQUFBLDBCQUEwQixNQUFNLFdBQVc7QUFDdkQsWUFBSSxNQUFNLElBQUk7QUFDVixpQkFBTzs7QUFHWCxjQUFNLGFBQWEsU0FBUSx3QkFBd0I7VUFDL0M7VUFDQTtTQUNIO0FBRUQsWUFBSSxNQUFNLGFBQWE7QUFDbkIsZ0JBQU0sT0FBTyxZQUFBLFVBQVUsTUFBTSxXQUFXO0FBQ3hDLHFCQUFXLE9BQU8sUUFBUSxJQUFJO2VBQzNCO0FBQ0gsZ0JBQU0sT0FBTyxRQUFBLHFCQUFxQixTQUFRLFNBQVMsS0FBSyxLQUFLO0FBQzdELHFCQUFXLE1BQU0sUUFBUSxJQUFJOztBQUdqQyxZQUFJLENBQUMsTUFBTSxnQkFBZ0I7QUFDdkIsaUJBQU87O0FBSVgsY0FBTSxVQUFVLFlBQUEsMEJBQTBCLE1BQU0sY0FBYztBQUM5RCxjQUFNLFNBQVMsU0FBUSxvQkFBb0IsTUFBTSxPQUFPLE1BQU0sRUFBRTtBQUNoRSxlQUFPLFFBQVE7QUFDZixlQUFPLE1BQU0sV0FBVyxNQUFLO0FBQzdCLGVBQU8sSUFBSSxPQUFPLE9BQU8sT0FBTztBQUVoQyxlQUFPO01BQ1g7O0FBckNKLFlBQUEsVUFBQTs7Ozs7Ozs7O0FDdkNBLFFBQUEsY0FBQTtBQUVBLFFBQUEsVUFBQTtBQUNBLFFBQUEsWUFBQTtBQUNBLFFBQUEsY0FBQTtBQUNBLFFBQUEsbUNBQUE7QUFFQSxRQUFNLFVBQVUsSUFBSSxPQUNoQixpQkFDUSxVQUFBLGdCQUFnQixZQUFBLGdCQUFnQixzQkFHdkIsWUFBQSxvREFHakIsR0FBRztBQUdQLFFBQU0sZUFBZTtBQUNyQixRQUFNLG1CQUFtQjtBQUN6QixRQUFNLGFBQWE7QUFTbkIsUUFBcUIsb0JBQXJCLGNBQStDLGlDQUFBLHVDQUFzQztNQUNqRixlQUFZO0FBQ1IsZUFBTztNQUNYO01BRUEsYUFBYSxVQUF5QixPQUF1QjtBQUN6RCxjQUFNLFlBQVksTUFBTSxrQkFBa0IsWUFBVztBQUdyRCxZQUFJLE1BQU0sR0FBRyxVQUFVLEtBQUssQ0FBQyxZQUFBLDJCQUEyQixZQUFZO0FBQ2hFLGlCQUFPOztBQUdYLGNBQU0sU0FBUyxTQUFRLG9CQUNuQixNQUFNLFFBQVMsT0FBTSxpQkFBaUIsSUFBSSxRQUMxQyxNQUFNLFFBQVEsTUFBTSxHQUFHLE1BQU07QUFFakMsZUFBTyxNQUFNLE1BQU0sT0FBTyxDQUFDO0FBRTNCLGNBQU0sUUFBUSxZQUFBLGlCQUFpQjtBQUMvQixlQUFPLE1BQU0sT0FBTyxTQUFTLEtBQUs7QUFFbEMsWUFBSSxNQUFNLGFBQWE7QUFDbkIsZ0JBQU0sT0FBTyxZQUFBLFVBQVUsTUFBTSxXQUFXO0FBQ3hDLGlCQUFPLE1BQU0sT0FBTyxRQUFRLElBQUk7ZUFDN0I7QUFDSCxnQkFBTSxPQUFPLFFBQUEscUJBQXFCLFNBQVEsU0FBUyxHQUFHLEtBQUs7QUFDM0QsaUJBQU8sTUFBTSxNQUFNLFFBQVEsSUFBSTs7QUFHbkMsZUFBTztNQUNYOztBQS9CSixZQUFBLFVBQUE7Ozs7Ozs7OztBQzVCQSxRQUFBLGNBQUE7QUFDQSxRQUFBLFlBQUE7QUFDQSxRQUFBLG1DQUFBO0FBU0EsUUFBTSxVQUFVLElBQUksT0FDaEIsNEJBQ1csVUFBQSxnQkFBZ0IsWUFBQSxnQkFBZ0Isb0RBRzNDLEdBQUc7QUFHUCxRQUFNLG9CQUFvQjtBQUMxQixRQUFNLG1CQUFtQjtBQUN6QixRQUFNLHFCQUFxQjtBQUMzQixRQUFNLG9CQUFvQjtBQUUxQixRQUFxQiw2QkFBckIsY0FBd0QsaUNBQUEsdUNBQXNDO01BQzFGLGVBQVk7QUFDUixlQUFPO01BQ1g7TUFFQSxhQUFhLFVBQXlCLE9BQXVCO0FBQ3pELGNBQU0sUUFBUSxNQUFNLHNCQUNkLFNBQVMsTUFBTSxtQkFBbUIsSUFDbEMsWUFBQSxpQkFBaUIsTUFBTSxrQkFBa0IsWUFBVztBQUUxRCxZQUFJLFFBQVEsS0FBSyxRQUFRLElBQUk7QUFDekIsaUJBQU87O0FBR1gsY0FBTSxPQUFPLFNBQVMsTUFBTSxrQkFBa0I7QUFDOUMsY0FBTSxNQUFNLFNBQVMsTUFBTSxrQkFBa0I7QUFFN0MsZUFBTztVQUNIO1VBQ0E7VUFDQTs7TUFFUjs7QUF0QkosWUFBQSxVQUFBOzs7Ozs7Ozs7QUN2QkEsUUFBQSxtQ0FBQTtBQUVBLFFBQU0sVUFBVSxJQUFJLE9BQU8sb0NBQXlDLEdBQUc7QUFFdkUsUUFBTSxjQUFjO0FBQ3BCLFFBQU0sYUFBYTtBQU9uQixRQUFxQiwyQkFBckIsY0FBc0QsaUNBQUEsdUNBQXNDO01BQ3hGLGVBQVk7QUFDUixlQUFPO01BQ1g7TUFFQSxhQUFhLFVBQXlCLE9BQXVCO0FBQ3pELGNBQU0sT0FBTyxTQUFTLE1BQU0sV0FBVztBQUN2QyxjQUFNLFFBQVEsU0FBUyxNQUFNLFlBQVk7QUFFekMsZUFBTyxTQUFRLHdCQUF1QixFQUFHLE1BQU0sT0FBTyxDQUFDLEVBQUUsT0FBTyxTQUFTLEtBQUssRUFBRSxPQUFPLFFBQVEsSUFBSTtNQUN2Rzs7QUFWSixZQUFBLFVBQUE7Ozs7Ozs7Ozs7QUNaQSxRQUFBLFVBQUE7QUFHQSxnQ0FBNEIsY0FBc0IsZUFBdUIsZUFBdUIsT0FBYTtBQUN6RyxhQUFPLElBQUksT0FDSCxHQUFHLGVBQ0Esd0lBWUEsaUJBQ1AsS0FBSztJQUViO0FBR0EsaUNBQTZCLGdCQUF3QixpQkFBdUI7QUFDeEUsYUFBTyxJQUFJLE9BQ1AsS0FBSyx3SkFXRSxtQkFDUCxHQUFHO0lBRVg7QUFFQSxRQUFNLGFBQWE7QUFDbkIsUUFBTSxlQUFlO0FBQ3JCLFFBQU0sZUFBZTtBQUNyQixRQUFNLHFCQUFxQjtBQUMzQixRQUFNLG1CQUFtQjtBQUV6QixRQUFzQiwrQkFBdEIsTUFBa0Q7TUFLOUMsWUFBWSxhQUFhLE9BQUs7QUFpVnRCLGFBQUEsc0JBQXNCO0FBQ3RCLGFBQUEsc0JBQXNCO0FBQ3RCLGFBQUEsMkJBQTJCO0FBcUIzQixhQUFBLHVCQUF1QjtBQUN2QixhQUFBLHdCQUF3QjtBQUN4QixhQUFBLDRCQUE0QjtBQXpXaEMsYUFBSyxhQUFhO01BQ3RCO01BRUEsZUFBWTtBQUNSLGVBQU87TUFDWDtNQUVBLDZCQUEwQjtBQUN0QixlQUFPO01BQ1g7TUFFQSxnQkFBYTtBQUNULGVBQU87TUFDWDtNQUVBLGtCQUFlO0FBQ1gsZUFBTztNQUNYO01BRUEsUUFBUSxVQUF1QjtBQUMzQixlQUFPLEtBQUssa0NBQWlDO01BQ2pEO01BRUEsUUFBUSxVQUF5QixPQUF1QjtBQUNwRCxjQUFNLGtCQUFrQixLQUFLLDZCQUE2QixVQUFTLEtBQUs7QUFDeEUsWUFBSSxDQUFDLGlCQUFpQjtBQUNsQixnQkFBTSxTQUFTLE1BQU0sR0FBRztBQUN4QixpQkFBTzs7QUFHWCxjQUFNLFFBQVEsTUFBTSxRQUFRLE1BQU0sR0FBRztBQUNyQyxjQUFNLE9BQU8sTUFBTSxHQUFHLFVBQVUsTUFBTSxHQUFHLE1BQU07QUFDL0MsY0FBTSxTQUFTLFNBQVEsb0JBQW9CLE9BQU8sTUFBTSxlQUFlO0FBQ3ZFLGNBQU0sU0FBUyxNQUFNLEdBQUc7QUFFeEIsY0FBTSxnQkFBZ0IsU0FBUSxLQUFLLFVBQVUsTUFBTSxLQUFLO0FBQ3hELGNBQU0sbUJBQW1CLEtBQUssb0NBQW1DO0FBQ2pFLGNBQU0saUJBQWlCLGlCQUFpQixLQUFLLGFBQWE7QUFHMUQsWUFBSSxLQUFLLE1BQU0sVUFBVSxLQUFLLGtCQUFrQixlQUFlLEdBQUcsTUFBTSx1QkFBdUIsR0FBRztBQUM5RixpQkFBTzs7QUFHWCxZQUNJLENBQUMsa0JBRUQsZUFBZSxHQUFHLE1BQU0sdUJBQXVCLEdBQ2pEO0FBQ0UsaUJBQU8sS0FBSyxzQ0FBc0MsTUFBTTs7QUFHNUQsZUFBTyxNQUFNLEtBQUssK0JBQStCLFVBQVMsZ0JBQWdCLE1BQU07QUFDaEYsWUFBSSxPQUFPLEtBQUs7QUFDWixpQkFBTyxRQUFRLGVBQWU7O0FBR2xDLGVBQU8sS0FBSyxtQ0FBbUMsTUFBTTtNQUN6RDtNQUVBLDZCQUNJLFVBQ0EsT0FDQSxTQUFTLE9BQUs7QUFFZCxjQUFNLGFBQWEsU0FBUSx3QkFBdUI7QUFDbEQsWUFBSSxTQUFTO0FBQ2IsWUFBSSxXQUFXO0FBR2YsWUFBSSxPQUFPLFNBQVMsTUFBTSxXQUFXO0FBQ3JDLFlBQUksT0FBTyxLQUFLO0FBQ1osY0FBSSxLQUFLLGNBQWMsTUFBTSxpQkFBaUIsTUFBTTtBQUNoRCxtQkFBTzs7QUFHWCxtQkFBUyxPQUFPO0FBQ2hCLGlCQUFPLEtBQUssTUFBTSxPQUFPLEdBQUc7O0FBR2hDLFlBQUksT0FBTyxJQUFJO0FBQ1gsaUJBQU87O0FBSVgsWUFBSSxNQUFNLGlCQUFpQixNQUFNO0FBQzdCLGNBQUksTUFBTSxjQUFjLFVBQVUsS0FBSyxDQUFDLE1BQU0sbUJBQW1CO0FBRTdELG1CQUFPOztBQUdYLG1CQUFTLFNBQVMsTUFBTSxhQUFhOztBQUd6QyxZQUFJLFVBQVUsSUFBSTtBQUNkLGlCQUFPOztBQUdYLFlBQUksT0FBTyxJQUFJO0FBQ1gscUJBQVcsUUFBQSxTQUFTOztBQUl4QixZQUFJLE1BQU0scUJBQXFCLE1BQU07QUFDakMsY0FBSSxPQUFPO0FBQUksbUJBQU87QUFDdEIsZ0JBQU0sT0FBTyxNQUFNLGtCQUFrQixHQUFHLFlBQVc7QUFDbkQsY0FBSSxRQUFRLEtBQUs7QUFDYix1QkFBVyxRQUFBLFNBQVM7QUFDcEIsZ0JBQUksUUFBUSxJQUFJO0FBQ1oscUJBQU87OztBQUlmLGNBQUksUUFBUSxLQUFLO0FBQ2IsdUJBQVcsUUFBQSxTQUFTO0FBQ3BCLGdCQUFJLFFBQVEsSUFBSTtBQUNaLHNCQUFROzs7O0FBS3BCLG1CQUFXLE9BQU8sUUFBUSxJQUFJO0FBQzlCLG1CQUFXLE9BQU8sVUFBVSxNQUFNO0FBRWxDLFlBQUksYUFBYSxNQUFNO0FBQ25CLHFCQUFXLE9BQU8sWUFBWSxRQUFRO2VBQ25DO0FBQ0gsY0FBSSxPQUFPLElBQUk7QUFDWCx1QkFBVyxNQUFNLFlBQVksUUFBQSxTQUFTLEVBQUU7aUJBQ3JDO0FBQ0gsdUJBQVcsTUFBTSxZQUFZLFFBQUEsU0FBUyxFQUFFOzs7QUFLaEQsWUFBSSxNQUFNLHVCQUF1QixNQUFNO0FBQ25DLGdCQUFNLGNBQWMsU0FBUyxNQUFNLG9CQUFvQixVQUFVLEdBQUcsQ0FBQyxDQUFDO0FBQ3RFLGNBQUksZUFBZTtBQUFNLG1CQUFPO0FBRWhDLHFCQUFXLE9BQU8sZUFBZSxXQUFXOztBQUloRCxZQUFJLE1BQU0saUJBQWlCLE1BQU07QUFDN0IsZ0JBQU0sU0FBUyxTQUFTLE1BQU0sYUFBYTtBQUMzQyxjQUFJLFVBQVU7QUFBSSxtQkFBTztBQUV6QixxQkFBVyxPQUFPLFVBQVUsTUFBTTs7QUFHdEMsZUFBTztNQUNYO01BRUEsK0JBQ0ksVUFDQSxPQUNBLFFBQXFCO0FBRXJCLGNBQU0sYUFBYSxTQUFRLHdCQUF1QjtBQUdsRCxZQUFJLE1BQU0sdUJBQXVCLE1BQU07QUFDbkMsZ0JBQU0sY0FBYyxTQUFTLE1BQU0sb0JBQW9CLFVBQVUsR0FBRyxDQUFDLENBQUM7QUFDdEUsY0FBSSxlQUFlO0FBQU0sbUJBQU87QUFFaEMscUJBQVcsT0FBTyxlQUFlLFdBQVc7O0FBSWhELFlBQUksTUFBTSxpQkFBaUIsTUFBTTtBQUM3QixnQkFBTSxTQUFTLFNBQVMsTUFBTSxhQUFhO0FBQzNDLGNBQUksVUFBVTtBQUFJLG1CQUFPO0FBRXpCLHFCQUFXLE9BQU8sVUFBVSxNQUFNOztBQUd0QyxZQUFJLE9BQU8sU0FBUyxNQUFNLFdBQVc7QUFDckMsWUFBSSxTQUFTO0FBQ2IsWUFBSSxXQUFXO0FBR2YsWUFBSSxNQUFNLGlCQUFpQixNQUFNO0FBQzdCLG1CQUFTLFNBQVMsTUFBTSxhQUFhO21CQUM5QixPQUFPLEtBQUs7QUFDbkIsbUJBQVMsT0FBTztBQUNoQixpQkFBTyxLQUFLLE1BQU0sT0FBTyxHQUFHOztBQUdoQyxZQUFJLFVBQVUsTUFBTSxPQUFPLElBQUk7QUFDM0IsaUJBQU87O0FBR1gsWUFBSSxRQUFRLElBQUk7QUFDWixxQkFBVyxRQUFBLFNBQVM7O0FBSXhCLFlBQUksTUFBTSxxQkFBcUIsTUFBTTtBQUNqQyxjQUFJLE9BQU8sSUFBSTtBQUNYLG1CQUFPOztBQUdYLGdCQUFNLE9BQU8sTUFBTSxrQkFBa0IsR0FBRyxZQUFXO0FBQ25ELGNBQUksUUFBUSxLQUFLO0FBQ2IsdUJBQVcsUUFBQSxTQUFTO0FBQ3BCLGdCQUFJLFFBQVEsSUFBSTtBQUNaLHFCQUFPO0FBQ1Asa0JBQUksQ0FBQyxXQUFXLFVBQVUsS0FBSyxHQUFHO0FBQzlCLDJCQUFXLE1BQU0sT0FBTyxXQUFXLElBQUksS0FBSyxJQUFJLENBQUM7Ozs7QUFLN0QsY0FBSSxRQUFRLEtBQUs7QUFDYix1QkFBVyxRQUFBLFNBQVM7QUFDcEIsZ0JBQUksUUFBUTtBQUFJLHNCQUFROztBQUc1QixjQUFJLENBQUMsT0FBTyxNQUFNLFVBQVUsVUFBVSxHQUFHO0FBQ3JDLGdCQUFJLFlBQVksUUFBQSxTQUFTLElBQUk7QUFDekIscUJBQU8sTUFBTSxNQUFNLFlBQVksUUFBQSxTQUFTLEVBQUU7QUFFMUMsa0JBQUksT0FBTyxNQUFNLElBQUksTUFBTSxLQUFLLElBQUk7QUFDaEMsdUJBQU8sTUFBTSxPQUFPLFFBQVEsQ0FBQzs7bUJBRTlCO0FBQ0gscUJBQU8sTUFBTSxNQUFNLFlBQVksUUFBQSxTQUFTLEVBQUU7QUFFMUMsa0JBQUksT0FBTyxNQUFNLElBQUksTUFBTSxLQUFLLElBQUk7QUFDaEMsdUJBQU8sTUFBTSxPQUFPLFFBQVEsT0FBTyxNQUFNLElBQUksTUFBTSxJQUFJLEVBQUU7Ozs7O0FBTXpFLG1CQUFXLE9BQU8sUUFBUSxJQUFJO0FBQzlCLG1CQUFXLE9BQU8sVUFBVSxNQUFNO0FBRWxDLFlBQUksWUFBWSxHQUFHO0FBQ2YscUJBQVcsT0FBTyxZQUFZLFFBQVE7ZUFDbkM7QUFDSCxnQkFBTSxZQUFZLE9BQU8sTUFBTSxVQUFVLFVBQVUsS0FBSyxPQUFPLE1BQU0sSUFBSSxNQUFNLElBQUk7QUFDbkYsY0FBSSxXQUFXO0FBQ1gsZ0JBQUksT0FBTyxNQUFNLElBQUksTUFBTSxJQUFJLEtBQUssTUFBTTtBQUV0Qyx5QkFBVyxNQUFNLFlBQVksUUFBQSxTQUFTLEVBQUU7dUJBQ2pDLFFBQVEsSUFBSTtBQUNuQix5QkFBVyxPQUFPLFFBQVEsT0FBTyxFQUFFO0FBQ25DLHlCQUFXLE9BQU8sWUFBWSxRQUFBLFNBQVMsRUFBRTs7cUJBRXRDLE9BQU8sSUFBSTtBQUNsQix1QkFBVyxNQUFNLFlBQVksUUFBQSxTQUFTLEVBQUU7cUJBQ2pDLFFBQVEsSUFBSTtBQUNuQix1QkFBVyxNQUFNLFlBQVksUUFBQSxTQUFTLEVBQUU7OztBQUloRCxZQUFJLFdBQVcsS0FBSSxFQUFHLFFBQU8sSUFBSyxPQUFPLE1BQU0sS0FBSSxFQUFHLFFBQU8sR0FBSTtBQUM3RCxxQkFBVyxNQUFNLE9BQU8sV0FBVyxJQUFJLEtBQUssSUFBSSxDQUFDOztBQUdyRCxlQUFPO01BQ1g7TUFFUSxzQ0FBc0MsUUFBTTtBQUVoRCxZQUFJLE9BQU8sS0FBSyxNQUFNLE1BQU0sR0FBRztBQUMzQixpQkFBTzs7QUFJWCxZQUFJLE9BQU8sS0FBSyxNQUFNLFdBQVcsR0FBRztBQUNoQyxpQkFBTzs7QUFJWCxZQUFJLE9BQU8sS0FBSyxNQUFNLFdBQVcsR0FBRztBQUNoQyxpQkFBTzs7QUFJWCxjQUFNLG9CQUFvQixPQUFPLEtBQUssTUFBTSxvQkFBb0I7QUFDaEUsWUFBSSxtQkFBbUI7QUFDbkIsZ0JBQU0sZ0JBQXdCLGtCQUFrQjtBQUdoRCxjQUFJLEtBQUssWUFBWTtBQUNqQixtQkFBTzs7QUFJWCxjQUFJLGNBQWMsU0FBUyxHQUFHLEtBQUssQ0FBQyxjQUFjLE1BQU0sZUFBZSxHQUFHO0FBQ3RFLG1CQUFPOztBQUlYLGdCQUFNLGtCQUFrQixTQUFTLGFBQWE7QUFDOUMsY0FBSSxrQkFBa0IsSUFBSTtBQUN0QixtQkFBTzs7O0FBSWYsZUFBTztNQUNYO01BRVEsbUNBQW1DLFFBQU07QUFDN0MsWUFBSSxPQUFPLEtBQUssTUFBTSxXQUFXLEdBQUc7QUFDaEMsaUJBQU87O0FBSVgsY0FBTSxvQkFBb0IsT0FBTyxLQUFLLE1BQU0scUNBQXFDO0FBQ2pGLFlBQUksbUJBQW1CO0FBRW5CLGNBQUksS0FBSyxZQUFZO0FBQ2pCLG1CQUFPOztBQUdYLGdCQUFNLGtCQUEwQixrQkFBa0I7QUFDbEQsZ0JBQU0sZ0JBQXdCLGtCQUFrQjtBQUVoRCxjQUFJLGNBQWMsU0FBUyxHQUFHLEtBQUssQ0FBQyxjQUFjLE1BQU0sZUFBZSxHQUFHO0FBQ3RFLG1CQUFPOztBQUlYLGdCQUFNLGtCQUFrQixTQUFTLGFBQWE7QUFDOUMsZ0JBQU0sb0JBQW9CLFNBQVMsZUFBZTtBQUNsRCxjQUFJLGtCQUFrQixNQUFNLG9CQUFvQixJQUFJO0FBQ2hELG1CQUFPOzs7QUFJZixlQUFPO01BQ1g7TUFNQSxvQ0FBaUM7QUFDN0IsY0FBTSxnQkFBZ0IsS0FBSyxjQUFhO0FBQ3hDLGNBQU0sZ0JBQWdCLEtBQUssY0FBYTtBQUV4QyxZQUFJLEtBQUssd0JBQXdCLGlCQUFpQixLQUFLLHdCQUF3QixlQUFlO0FBQzFGLGlCQUFPLEtBQUs7O0FBR2hCLGFBQUssMkJBQTJCLG1CQUM1QixLQUFLLDJCQUEwQixHQUMvQixlQUNBLGVBQ0EsS0FBSyxhQUFZLENBQUU7QUFFdkIsYUFBSyxzQkFBc0I7QUFDM0IsYUFBSyxzQkFBc0I7QUFDM0IsZUFBTyxLQUFLO01BQ2hCO01BTUEsc0NBQW1DO0FBQy9CLGNBQU0saUJBQWlCLEtBQUssZUFBYztBQUMxQyxjQUFNLGtCQUFrQixLQUFLLGdCQUFlO0FBRTVDLFlBQUksS0FBSyx5QkFBeUIsa0JBQWtCLEtBQUssMEJBQTBCLGlCQUFpQjtBQUNoRyxpQkFBTyxLQUFLOztBQUdoQixhQUFLLDRCQUE0QixvQkFBb0IsZ0JBQWdCLGVBQWU7QUFDcEYsYUFBSyx1QkFBdUI7QUFDNUIsYUFBSyx3QkFBd0I7QUFDN0IsZUFBTyxLQUFLO01BQ2hCOztBQTdYSixZQUFBLCtCQUFBOzs7Ozs7Ozs7QUNoREEsUUFBQSxVQUFBO0FBQ0EsUUFBQSxpQ0FBQTtBQUVBLFFBQXFCLHlCQUFyQixjQUFvRCwrQkFBQSw2QkFBNEI7TUFDNUUsWUFBWSxZQUFVO0FBQ2xCLGNBQU0sVUFBVTtNQUNwQjtNQUVBLGlCQUFjO0FBQ1YsZUFBTztNQUNYO01BRUEsZ0JBQWE7QUFDVCxlQUFPO01BQ1g7TUFFQSxnQkFBYTtBQUNULGVBQU87TUFDWDtNQUVBLDZCQUE2QixVQUF5QixPQUF1QjtBQUN6RSxjQUFNLGFBQWEsTUFBTSw2QkFBNkIsVUFBUyxLQUFLO0FBQ3BFLFlBQUksWUFBWTtBQUNaLGNBQUksTUFBTSxHQUFHLFNBQVMsT0FBTyxHQUFHO0FBQzVCLGtCQUFNLE9BQU8sV0FBVyxJQUFJLE1BQU07QUFDbEMsZ0JBQUksUUFBUSxLQUFLLE9BQU8sSUFBSTtBQUN4Qix5QkFBVyxPQUFPLFFBQVEsV0FBVyxJQUFJLE1BQU0sSUFBSSxFQUFFO0FBQ3JELHlCQUFXLE9BQU8sWUFBWSxRQUFBLFNBQVMsRUFBRTt1QkFDbEMsT0FBTyxHQUFHO0FBQ2pCLHlCQUFXLE9BQU8sWUFBWSxRQUFBLFNBQVMsRUFBRTs7O0FBSWpELGNBQUksTUFBTSxHQUFHLFNBQVMsV0FBVyxHQUFHO0FBQ2hDLHVCQUFXLE9BQU8sWUFBWSxRQUFBLFNBQVMsRUFBRTtBQUN6QyxrQkFBTSxPQUFPLFdBQVcsSUFBSSxNQUFNO0FBQ2xDLGdCQUFJLFFBQVEsS0FBSyxRQUFRLEdBQUc7QUFDeEIseUJBQVcsT0FBTyxRQUFRLFdBQVcsSUFBSSxNQUFNLElBQUksRUFBRTs7O0FBSTdELGNBQUksTUFBTSxHQUFHLFNBQVMsU0FBUyxHQUFHO0FBQzlCLHVCQUFXLE9BQU8sWUFBWSxRQUFBLFNBQVMsRUFBRTtBQUN6QyxrQkFBTSxPQUFPLFdBQVcsSUFBSSxNQUFNO0FBQ2xDLGdCQUFJLE9BQU8sSUFBSTtBQUNYLHlCQUFXLE9BQU8sUUFBUSxXQUFXLElBQUksTUFBTSxDQUFDOzs7O0FBSzVELGVBQU87TUFDWDs7QUFoREosWUFBQSxVQUFBOzs7Ozs7Ozs7O0FDQUEsOEJBQWlDLFdBQW9CO0FBQ2pELFlBQU0sV0FBVyxDQUFBO0FBQ2pCLGlCQUFXLE9BQU8sV0FBVztBQUV6QixpQkFBUyxPQUFPLENBQUMsVUFBVTs7QUFHL0IsYUFBTztJQUNYO0FBUkEsWUFBQSxtQkFBQTtBQVVBLGlDQUFvQyxZQUErQixXQUFvQjtBQUNuRixZQUFNLFNBQVMsV0FBVyxNQUFLO0FBRS9CLFVBQUksT0FBTyxXQUFXLE1BQUs7QUFDM0IsaUJBQVcsT0FBTyxXQUFXO0FBRXpCLGVBQU8sS0FBSyxJQUFJLFVBQVUsTUFBTSxHQUFnQjs7QUFHcEQsVUFBSSxTQUFTLGFBQWEsT0FBTyxhQUFhLFVBQVUsYUFBYSxXQUFXLGFBQWEsVUFBVSxXQUFXO0FBQzlHLGVBQU8sTUFBTSxPQUFPLEtBQUssS0FBSSxDQUFFO0FBQy9CLGVBQU8sTUFBTSxTQUFTLEtBQUssTUFBSyxJQUFLLENBQUM7QUFDdEMsZUFBTyxNQUFNLFFBQVEsS0FBSyxLQUFJLENBQUU7O0FBR3BDLFVBQUksWUFBWSxhQUFhLFlBQVksYUFBYSxVQUFVLFdBQVc7QUFDdkUsZUFBTyxNQUFNLFVBQVUsS0FBSyxPQUFNLENBQUU7QUFDcEMsZUFBTyxNQUFNLFVBQVUsS0FBSyxPQUFNLENBQUU7QUFDcEMsZUFBTyxNQUFNLFFBQVEsS0FBSyxLQUFJLENBQUU7O0FBR3BDLGFBQU87SUFDWDtBQXRCQSxZQUFBLHNCQUFBOzs7Ozs7Ozs7QUNkQSxRQUFBLGNBQUE7QUFDQSxRQUFBLFlBQUE7QUFDQSxRQUFBLG1DQUFBO0FBQ0EsUUFBQSxjQUFBO0FBRUEsUUFBTSxVQUFVLElBQUksT0FBTyxJQUFJLFlBQUEsa0VBQWtFLEdBQUc7QUFDcEcsUUFBTSxpQkFBaUIsSUFBSSxPQUFPLElBQUksWUFBQSwrQ0FBK0MsR0FBRztBQUV4RixRQUFxQiw0QkFBckIsY0FBdUQsaUNBQUEsdUNBQXNDO01BQ3pGLFlBQW9CLFlBQW1CO0FBQ25DLGNBQUs7QUFEVyxhQUFBLGFBQUE7TUFFcEI7TUFFQSxlQUFZO0FBQ1IsZUFBTyxLQUFLLGFBQWEsaUJBQWlCO01BQzlDO01BRUEsYUFBYSxVQUF5QixPQUF1QjtBQUN6RCxjQUFNLFlBQVksWUFBQSxlQUFlLE1BQU0sRUFBRTtBQUN6QyxjQUFNLGtCQUFrQixZQUFBLGlCQUFpQixTQUFTO0FBRWxELGVBQU8sVUFBQSxrQkFBa0IsNEJBQTRCLFNBQVEsV0FBVyxlQUFlO01BQzNGOztBQWRKLFlBQUEsVUFBQTs7Ozs7Ozs7O0FDUkEsUUFBQSxjQUFBO0FBQ0EsUUFBQSxZQUFBO0FBQ0EsUUFBQSxtQ0FBQTtBQUVBLFFBQU0sVUFBVSxJQUFJLE9BQ2hCLElBQUksWUFBQSwyRkFDSixHQUFHO0FBR1AsUUFBTSxpQkFBaUIsSUFBSSxPQUFPLE1BQVcsWUFBQSxxQkFBcUIsa0NBQTRDLEdBQUc7QUFDakgsUUFBTSxzQkFBc0I7QUFFNUIsUUFBcUIsOEJBQXJCLGNBQXlELGlDQUFBLHVDQUFzQztNQUMzRixZQUFvQixZQUFtQjtBQUNuQyxjQUFLO0FBRFcsYUFBQSxhQUFBO01BRXBCO01BRUEsZUFBWTtBQUNSLGVBQU8sS0FBSyxhQUFhLGlCQUFpQjtNQUM5QztNQUVBLGFBQWEsVUFBeUIsT0FBdUI7QUFDekQsY0FBTSxZQUFZLFlBQUEsZUFBZSxNQUFNLG9CQUFvQjtBQUMzRCxlQUFPLFVBQUEsa0JBQWtCLDRCQUE0QixTQUFRLFdBQVcsU0FBUztNQUNyRjs7QUFaSixZQUFBLFVBQUE7Ozs7Ozs7Ozs7QUNQQSxRQUFzQixTQUF0QixNQUE0QjtNQUd4QixPQUFPLFVBQXlCLFNBQXdCO0FBQ3BELGVBQU8sUUFBUSxPQUFPLENBQUMsT0FBTSxLQUFLLFFBQVEsVUFBUyxFQUFDLENBQUM7TUFDekQ7O0FBTEosWUFBQSxTQUFBO0FBV0EsUUFBc0IsaUJBQXRCLE1BQW9DO01BZWhDLE9BQU8sVUFBeUIsU0FBd0I7QUFDcEQsWUFBSSxRQUFRLFNBQVMsR0FBRztBQUNwQixpQkFBTzs7QUFHWCxjQUFNLGdCQUFpQyxDQUFBO0FBQ3ZDLFlBQUksWUFBWSxRQUFRO0FBQ3hCLFlBQUksYUFBYTtBQUVqQixpQkFBUyxLQUFJLEdBQUcsS0FBSSxRQUFRLFFBQVEsTUFBSztBQUNyQyx1QkFBYSxRQUFRO0FBRXJCLGdCQUFNLGNBQWMsU0FBUSxLQUFLLFVBQVUsVUFBVSxRQUFRLFVBQVUsS0FBSyxRQUFRLFdBQVcsS0FBSztBQUNwRyxjQUFJLENBQUMsS0FBSyxtQkFBbUIsYUFBYSxXQUFXLFlBQVksUUFBTyxHQUFHO0FBQ3ZFLDBCQUFjLEtBQUssU0FBUztBQUM1Qix3QkFBWTtpQkFDVDtBQUNILGtCQUFNLE9BQU87QUFDYixrQkFBTSxRQUFRO0FBQ2Qsa0JBQU0sZUFBZSxLQUFLLGFBQWEsYUFBYSxNQUFNLE9BQU8sUUFBTztBQUN4RSxxQkFBUSxNQUFNLE1BQUs7QUFDZixzQkFBUSxJQUFJLEdBQUcsS0FBSyxZQUFZLGVBQWUsWUFBWSxjQUFjLGNBQWM7WUFDM0YsQ0FBQztBQUVELHdCQUFZOzs7QUFJcEIsWUFBSSxhQUFhLE1BQU07QUFDbkIsd0JBQWMsS0FBSyxTQUFTOztBQUdoQyxlQUFPO01BQ1g7O0FBaERKLFlBQUEsaUJBQUE7Ozs7Ozs7OztBQ1pBLFFBQUEscUJBQUE7QUFFQSxRQUE4QixnQ0FBOUIsY0FBb0UsbUJBQUEsZUFBYztNQUc5RSxtQkFBbUIsYUFBYSxlQUFlLFlBQVU7QUFDckQsZUFBTyxDQUFDLGNBQWMsT0FBTyxDQUFDLFdBQVcsT0FBTyxZQUFZLE1BQU0sS0FBSyxlQUFjLENBQUUsS0FBSztNQUNoRztNQUVBLGFBQWEsYUFBYSxZQUFZLFVBQVE7QUFDMUMsWUFBSSxDQUFDLFdBQVcsTUFBTSx1QkFBc0IsS0FBTSxDQUFDLFNBQVMsTUFBTSx1QkFBc0IsR0FBSTtBQUN4RixtQkFBUyxNQUFNLHFCQUFvQixFQUFHLFFBQVEsQ0FBQyxRQUFPO0FBQ2xELGdCQUFJLENBQUMsV0FBVyxNQUFNLFVBQVUsR0FBRyxHQUFHO0FBQ2xDLHlCQUFXLE1BQU0sT0FBTyxLQUFLLFNBQVMsTUFBTSxJQUFJLEdBQUcsQ0FBQzs7VUFFNUQsQ0FBQztBQUVELHFCQUFXLE1BQU0scUJBQW9CLEVBQUcsUUFBUSxDQUFDLFFBQU87QUFDcEQsZ0JBQUksQ0FBQyxTQUFTLE1BQU0sVUFBVSxHQUFHLEdBQUc7QUFDaEMsdUJBQVMsTUFBTSxPQUFPLEtBQUssV0FBVyxNQUFNLElBQUksR0FBRyxDQUFDOztVQUU1RCxDQUFDOztBQUdMLFlBQUksV0FBVyxNQUFNLEtBQUksRUFBRyxRQUFPLElBQUssU0FBUyxNQUFNLEtBQUksRUFBRyxRQUFPLEdBQUk7QUFDckUsY0FBSSxhQUFhLFdBQVcsTUFBTSxNQUFLO0FBQ3ZDLGNBQUksV0FBVyxTQUFTLE1BQU0sTUFBSztBQUVuQyxjQUFJLFdBQVcsTUFBTSx1QkFBc0IsS0FBTSxXQUFXLElBQUksSUFBSSxNQUFNLEVBQUUsU0FBUyxRQUFRLEdBQUc7QUFDNUYseUJBQWEsV0FBVyxJQUFJLElBQUksTUFBTTtBQUN0Qyx1QkFBVyxNQUFNLE1BQU0sT0FBTyxXQUFXLEtBQUksQ0FBRTtBQUMvQyx1QkFBVyxNQUFNLE1BQU0sU0FBUyxXQUFXLE1BQUssSUFBSyxDQUFDO0FBQ3RELHVCQUFXLE1BQU0sTUFBTSxRQUFRLFdBQVcsS0FBSSxDQUFFO3FCQUN6QyxTQUFTLE1BQU0sdUJBQXNCLEtBQU0sU0FBUyxJQUFJLEdBQUcsTUFBTSxFQUFFLFFBQVEsVUFBVSxHQUFHO0FBQy9GLHVCQUFXLFNBQVMsSUFBSSxHQUFHLE1BQU07QUFDakMscUJBQVMsTUFBTSxNQUFNLE9BQU8sU0FBUyxLQUFJLENBQUU7QUFDM0MscUJBQVMsTUFBTSxNQUFNLFNBQVMsU0FBUyxNQUFLLElBQUssQ0FBQztBQUNsRCxxQkFBUyxNQUFNLE1BQU0sUUFBUSxTQUFTLEtBQUksQ0FBRTtpQkFDekM7QUFDSCxhQUFDLFVBQVUsVUFBVSxJQUFJLENBQUMsWUFBWSxRQUFROzs7QUFJdEQsY0FBTSxTQUFTLFdBQVcsTUFBSztBQUMvQixlQUFPLFFBQVEsV0FBVztBQUMxQixlQUFPLE1BQU0sU0FBUztBQUN0QixlQUFPLFFBQVEsS0FBSyxJQUFJLFdBQVcsT0FBTyxTQUFTLEtBQUs7QUFDeEQsWUFBSSxXQUFXLFFBQVEsU0FBUyxPQUFPO0FBQ25DLGlCQUFPLE9BQU8sV0FBVyxPQUFPLGNBQWMsU0FBUztlQUNwRDtBQUNILGlCQUFPLE9BQU8sU0FBUyxPQUFPLGNBQWMsV0FBVzs7QUFHM0QsZUFBTztNQUNYOztBQXBESixZQUFBLFVBQUE7Ozs7Ozs7Ozs7OztBQ0hBLFFBQUEsa0NBQUEsaUJBQUEsdUNBQUE7QUFRQSxRQUFxQiwwQkFBckIsY0FBcUQsZ0NBQUEsUUFBNkI7TUFDOUUsaUJBQWM7QUFDVixlQUFPO01BQ1g7O0FBSEosWUFBQSxVQUFBOzs7Ozs7Ozs7O0FDWEEsUUFBQSxVQUFBO0FBRUEsaUNBQW9DLFlBQTJCLFlBQXlCO0FBQ3BGLFlBQU0sU0FBUyxXQUFXLE1BQUs7QUFDL0IsWUFBTSxZQUFZLFdBQVc7QUFDN0IsWUFBTSxZQUFZLFdBQVc7QUFFN0IsYUFBTyxRQUFRLHVCQUF1QixXQUFXLFNBQVM7QUFDMUQsVUFBSSxXQUFXLE9BQU8sUUFBUSxXQUFXLE9BQU8sTUFBTTtBQUNsRCxjQUFNLFVBQVUsV0FBVyxPQUFPLE9BQU8sV0FBVyxRQUFRLFdBQVc7QUFDdkUsY0FBTSxVQUFVLFdBQVcsT0FBTyxPQUFPLFdBQVcsUUFBUSxXQUFXO0FBQ3ZFLGNBQU0sY0FBYyx1QkFBdUIsU0FBUyxPQUFPO0FBRTNELFlBQUksV0FBVyxPQUFPLFFBQVEsWUFBWSxLQUFJLEVBQUcsUUFBTyxJQUFLLE9BQU8sTUFBTSxLQUFJLEVBQUcsUUFBTyxHQUFJO0FBRXhGLGNBQUksWUFBWSxVQUFVLEtBQUssR0FBRztBQUM5Qix3QkFBWSxPQUFPLE9BQU8sWUFBWSxJQUFJLEtBQUssSUFBSSxDQUFDO2lCQUNqRDtBQUNILHdCQUFZLE1BQU0sT0FBTyxZQUFZLElBQUksS0FBSyxJQUFJLENBQUM7OztBQUkzRCxlQUFPLE1BQU07O0FBR2pCLGFBQU87SUFDWDtBQXhCQSxZQUFBLHNCQUFBO0FBMEJBLG9DQUNJLGVBQ0EsZUFBZ0M7QUFFaEMsWUFBTSxvQkFBb0IsY0FBYyxNQUFLO0FBRTdDLFVBQUksY0FBYyxVQUFVLE1BQU0sR0FBRztBQUNqQywwQkFBa0IsT0FBTyxRQUFRLGNBQWMsSUFBSSxNQUFNLENBQUM7QUFDMUQsMEJBQWtCLE9BQU8sVUFBVSxjQUFjLElBQUksUUFBUSxDQUFDO0FBRTlELFlBQUksY0FBYyxVQUFVLFFBQVEsR0FBRztBQUNuQyw0QkFBa0IsT0FBTyxVQUFVLGNBQWMsSUFBSSxRQUFRLENBQUM7QUFFOUQsY0FBSSxjQUFjLFVBQVUsYUFBYSxHQUFHO0FBQ3hDLDhCQUFrQixPQUFPLGVBQWUsY0FBYyxJQUFJLGFBQWEsQ0FBQztpQkFDckU7QUFDSCw4QkFBa0IsTUFBTSxlQUFlLGNBQWMsSUFBSSxhQUFhLENBQUM7O2VBRXhFO0FBQ0gsNEJBQWtCLE1BQU0sVUFBVSxjQUFjLElBQUksUUFBUSxDQUFDO0FBQzdELDRCQUFrQixNQUFNLGVBQWUsY0FBYyxJQUFJLGFBQWEsQ0FBQzs7YUFFeEU7QUFDSCwwQkFBa0IsTUFBTSxRQUFRLGNBQWMsSUFBSSxNQUFNLENBQUM7QUFDekQsMEJBQWtCLE1BQU0sVUFBVSxjQUFjLElBQUksUUFBUSxDQUFDO0FBQzdELDBCQUFrQixNQUFNLFVBQVUsY0FBYyxJQUFJLFFBQVEsQ0FBQztBQUM3RCwwQkFBa0IsTUFBTSxlQUFlLGNBQWMsSUFBSSxhQUFhLENBQUM7O0FBRzNFLFVBQUksY0FBYyxVQUFVLGdCQUFnQixHQUFHO0FBQzNDLDBCQUFrQixPQUFPLGtCQUFrQixjQUFjLElBQUksZ0JBQWdCLENBQUM7O0FBR2xGLFVBQUksY0FBYyxVQUFVLFVBQVUsR0FBRztBQUNyQywwQkFBa0IsT0FBTyxZQUFZLGNBQWMsSUFBSSxVQUFVLENBQUM7aUJBQzNELGNBQWMsSUFBSSxVQUFVLEtBQUssUUFBUSxrQkFBa0IsSUFBSSxVQUFVLEtBQUssTUFBTTtBQUMzRiwwQkFBa0IsTUFBTSxZQUFZLGNBQWMsSUFBSSxVQUFVLENBQUM7O0FBR3JFLFVBQUksa0JBQWtCLElBQUksVUFBVSxLQUFLLFFBQUEsU0FBUyxNQUFNLGtCQUFrQixJQUFJLE1BQU0sSUFBSSxJQUFJO0FBQ3hGLFlBQUksY0FBYyxVQUFVLE1BQU0sR0FBRztBQUNqQyw0QkFBa0IsT0FBTyxRQUFRLGtCQUFrQixJQUFJLE1BQU0sSUFBSSxFQUFFO2VBQ2hFO0FBQ0gsNEJBQWtCLE1BQU0sUUFBUSxrQkFBa0IsSUFBSSxNQUFNLElBQUksRUFBRTs7O0FBSTFFLGFBQU87SUFDWDtBQWhEQSxZQUFBLHlCQUFBOzs7Ozs7Ozs7QUN6QkEsUUFBQSxxQkFBQTtBQUVBLFFBQUEsdUJBQUE7QUFFQSxRQUE4Qix5QkFBOUIsY0FBNkQsbUJBQUEsZUFBYztNQUd2RSxtQkFBbUIsYUFBcUIsZUFBOEIsWUFBeUI7QUFDM0YsZUFDTSxlQUFjLE1BQU0sV0FBVSxLQUFNLFdBQVcsTUFBTSxXQUFVLEtBQzVELFdBQVcsTUFBTSxXQUFVLEtBQU0sY0FBYyxNQUFNLFdBQVUsTUFDcEUsWUFBWSxNQUFNLEtBQUssZUFBYyxDQUFFLEtBQUs7TUFFcEQ7TUFFQSxhQUFhLGFBQXFCLGVBQThCLFlBQXlCO0FBQ3JGLGNBQU0sU0FBUyxjQUFjLE1BQU0sV0FBVSxJQUN2QyxxQkFBQSxvQkFBb0IsZUFBZSxVQUFVLElBQzdDLHFCQUFBLG9CQUFvQixZQUFZLGFBQWE7QUFFbkQsZUFBTyxRQUFRLGNBQWM7QUFDN0IsZUFBTyxPQUFPLGNBQWMsT0FBTyxjQUFjLFdBQVc7QUFDNUQsZUFBTztNQUNYOztBQW5CSixZQUFBLFVBQUE7Ozs7Ozs7Ozs7OztBQ1JBLFFBQUEsaUNBQUEsaUJBQUEsc0NBQUE7QUFRQSxRQUFxQix5QkFBckIsY0FBb0QsK0JBQUEsUUFBNEI7TUFDNUUsaUJBQWM7QUFDVixlQUFPLElBQUksT0FBTywwQ0FBMEM7TUFDaEU7O0FBSEosWUFBQSxVQUFBOzs7Ozs7Ozs7QUNKQSxRQUFNLHdCQUF3QixJQUFJLE9BQU8sNENBQTRDLEdBQUc7QUFDeEYsUUFBTSw0QkFBNEI7TUFDOUIsTUFBTTtNQUNOLE1BQU07TUFDTixLQUFLO01BQ0wsTUFBTTtNQUNOLE1BQU07TUFDTixLQUFLO01BQ0wsTUFBTTtNQUNOLE1BQU07TUFDTixNQUFNO01BQ04sTUFBTTtNQUNOLEtBQUs7TUFDTCxPQUFPO01BQ1AsTUFBTTtNQUNOLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixNQUFNO01BQ04sT0FBTztNQUNQLE1BQU07TUFDTixNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLE9BQU87TUFDUCxPQUFPO01BQ1AsS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixNQUFNO01BQ04sT0FBTztNQUNQLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLElBQUk7TUFDSixNQUFNO01BQ04sS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixPQUFPO01BQ1AsTUFBTTtNQUNOLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxPQUFPO01BQ1AsTUFBTTtNQUNOLEtBQUs7TUFDTCxNQUFNO01BQ04sTUFBTTtNQUNOLE1BQU07TUFDTixNQUFNO01BQ04sT0FBTztNQUNQLE1BQU07TUFDTixNQUFNO01BQ04sTUFBTTtNQUNOLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsT0FBTztNQUNQLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sTUFBTTtNQUNOLE9BQU87TUFDUCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxPQUFPO01BQ1AsTUFBTTtNQUNOLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sTUFBTTtNQUNOLE1BQU07TUFDTixLQUFLO01BQ0wsSUFBSTtNQUNKLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFD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
